import * as tslib_1 from "tslib";
import { Injectable, Optional } from '@angular/core';
import { TranslateService } from '@ngx-translate/core';
import { Constants } from '../constants';
import { ExtensionName } from '../models/index';
import { SharedService } from '../services/shared.service';
import { getTranslationPrefix } from '../services/utilities';
var ExtensionUtility = /** @class */ (function () {
    function ExtensionUtility(sharedService, translate) {
        this.sharedService = sharedService;
        this.translate = translate;
    }
    /**
     * Load SlickGrid Extension (Control/Plugin) dynamically (on demand)
     * This will basically only load the extension when user enables the feature
     * @param extensionName
     */
    ExtensionUtility.prototype.loadExtensionDynamically = function (extensionName) {
        try {
            switch (extensionName) {
                case ExtensionName.autoTooltip:
                    require('slickgrid/plugins/slick.autotooltips');
                    break;
                case ExtensionName.cellExternalCopyManager:
                    require('slickgrid/plugins/slick.cellexternalcopymanager');
                    break;
                case ExtensionName.checkboxSelector:
                    require('slickgrid/plugins/slick.checkboxselectcolumn');
                    break;
                case ExtensionName.cellMenu:
                    require('slickgrid/plugins/slick.cellmenu');
                    break;
                case ExtensionName.columnPicker:
                    require('slickgrid/controls/slick.columnpicker');
                    break;
                case ExtensionName.contextMenu:
                    require('slickgrid/plugins/slick.contextmenu');
                    break;
                case ExtensionName.draggableGrouping:
                    require('slickgrid/plugins/slick.draggablegrouping');
                    break;
                case ExtensionName.gridMenu:
                    require('slickgrid/controls/slick.gridmenu');
                    break;
                case ExtensionName.groupItemMetaProvider:
                    require('slickgrid/slick.groupitemmetadataprovider');
                    break;
                case ExtensionName.headerButton:
                    require('slickgrid/plugins/slick.headerbuttons');
                    break;
                case ExtensionName.headerMenu:
                    require('slickgrid/plugins/slick.headermenu');
                    break;
                case ExtensionName.rowSelection:
                    require('slickgrid/plugins/slick.rowselectionmodel');
                    break;
                case ExtensionName.rowDetailView:
                    require('slickgrid/plugins/slick.rowdetailview');
                    break;
                case ExtensionName.rowMoveManager:
                    require('slickgrid/plugins/slick.rowmovemanager');
                    break;
            }
        }
        catch (e) {
            // do nothing, we fall here when using Angular and RequireJS
        }
    };
    /**
     * From a Grid Menu object property name, we will return the correct title output string following this order
     * 1- if user provided a title, use it as the output title
     * 2- else if user provided a title key, use it to translate the output title
     * 3- else if nothing is provided use text defined as constants
     */
    ExtensionUtility.prototype.getPickerTitleOutputString = function (propName, pickerName) {
        if (this.sharedService.gridOptions && this.sharedService.gridOptions.enableTranslate && (!this.translate || !this.translate.instant)) {
            throw new Error('[Angular-Slickgrid] requires "ngx-translate" to be installed and configured when the grid option "enableTranslate" is enabled.');
        }
        var output = '';
        var picker = this.sharedService.gridOptions && this.sharedService.gridOptions[pickerName] || {};
        var enableTranslate = this.sharedService.gridOptions && this.sharedService.gridOptions.enableTranslate || false;
        // get locales provided by user in forRoot or else use default English locales via the Constants
        var locales = this.sharedService && this.sharedService.gridOptions && this.sharedService.gridOptions.locales || Constants.locales;
        var title = picker && picker[propName];
        var titleKey = picker && picker[propName + "Key"];
        var gridOptions = this.sharedService.gridOptions;
        var translationPrefix = getTranslationPrefix(gridOptions);
        if (titleKey && this.translate && this.translate.currentLang && this.translate.instant) {
            output = this.translate.instant(titleKey || ' ');
        }
        else {
            switch (propName) {
                case 'customTitle':
                    output = title || enableTranslate && this.translate && this.translate.currentLang && this.translate.instant && this.translate.instant(translationPrefix + "COMMANDS" || ' ') || locales && locales.TEXT_COMMANDS;
                    break;
                case 'columnTitle':
                    output = title || enableTranslate && this.translate && this.translate.currentLang && this.translate.instant && this.translate.instant(translationPrefix + "COLUMNS" || ' ') || locales && locales.TEXT_COLUMNS;
                    break;
                case 'forceFitTitle':
                    output = title || enableTranslate && this.translate && this.translate.currentLang && this.translate.instant && this.translate.instant(translationPrefix + "FORCE_FIT_COLUMNS" || ' ') || locales && locales.TEXT_FORCE_FIT_COLUMNS;
                    break;
                case 'syncResizeTitle':
                    output = title || enableTranslate && this.translate && this.translate.currentLang && this.translate.instant && this.translate.instant(translationPrefix + "SYNCHRONOUS_RESIZE" || ' ') || locales && locales.TEXT_SYNCHRONOUS_RESIZE;
                    break;
                default:
                    output = title;
                    break;
            }
        }
        return output;
    };
    /**
     * Loop through object provided and set to null any property found starting with "onX"
     * @param {Object}: obj
     */
    ExtensionUtility.prototype.nullifyFunctionNameStartingWithOn = function (obj) {
        var e_1, _a;
        if (obj) {
            try {
                for (var _b = tslib_1.__values(Object.keys(obj)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var prop = _c.value;
                    if (prop.startsWith('on')) {
                        obj[prop] = null;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
    };
    /**
     * When using ColumnPicker/GridMenu to show/hide a column, we potentially need to readjust the grid option "frozenColumn" index.
     * That is because SlickGrid freezes by column index and it has no knowledge of the columns themselves and won't change the index, we need to do that ourselves whenever necessary.
     * Note: we call this method right after the visibleColumns array got updated, it won't work properly if we call it before the setting the visibleColumns.
     * @param {String} pickerColumnId - what is the column id triggered by the picker
     * @param {Number} frozenColumnIndex - current frozenColumn index
     * @param {Boolean} showingColumn - is the column being shown or hidden?
     * @param {Array<Object>} allColumns - all columns (including hidden ones)
     * @param {Array<Object>} visibleColumns - only visible columns (excluding hidden ones)
     */
    ExtensionUtility.prototype.readjustFrozenColumnIndexWhenNeeded = function (pickerColumnId, frozenColumnIndex, showingColumn, allColumns, visibleColumns) {
        var _this = this;
        if (frozenColumnIndex >= 0 && pickerColumnId) {
            // calculate a possible frozenColumn index variance
            var frozenColIndexVariance = 0;
            if (showingColumn) {
                var definedFrozenColumnIndex = visibleColumns.findIndex(function (col) { return col.id === _this.sharedService.frozenVisibleColumnId; });
                var columnIndex = visibleColumns.findIndex(function (col) { return col.id === pickerColumnId; });
                frozenColIndexVariance = (columnIndex >= 0 && (frozenColumnIndex >= columnIndex || definedFrozenColumnIndex === columnIndex)) ? 1 : 0;
            }
            else {
                var columnIndex = allColumns.findIndex(function (col) { return col.id === pickerColumnId; });
                frozenColIndexVariance = (columnIndex >= 0 && frozenColumnIndex >= columnIndex) ? -1 : 0;
            }
            // if we have a variance different than 0 then apply it
            var newFrozenColIndex = frozenColumnIndex + frozenColIndexVariance;
            if (frozenColIndexVariance !== 0) {
                this.sharedService.grid.setOptions({ frozenColumn: newFrozenColIndex });
            }
            // to freeze columns, we need to take only the visible columns and we also need to use setColumns() when some of them are hidden
            // to make sure that we only use the visible columns, not doing this would show back some of the hidden columns
            if (Array.isArray(visibleColumns) && Array.isArray(allColumns) && visibleColumns.length !== allColumns.length) {
                this.sharedService.grid.setColumns(visibleColumns);
            }
        }
    };
    /**
     * Sort items (by pointers) in an array by a property name
     * @params items array
     * @param property name to sort with
     */
    ExtensionUtility.prototype.sortItems = function (items, propertyName) {
        // sort the custom items by their position in the list
        if (Array.isArray(items)) {
            items.sort(function (itemA, itemB) {
                if (itemA && itemB && itemA.hasOwnProperty(propertyName) && itemB.hasOwnProperty(propertyName)) {
                    return itemA[propertyName] - itemB[propertyName];
                }
                return 0;
            });
        }
    };
    /** Translate the an array of items from an input key and assign to the output key */
    ExtensionUtility.prototype.translateItems = function (items, inputKey, outputKey) {
        var e_2, _a;
        if (Array.isArray(items)) {
            try {
                for (var items_1 = tslib_1.__values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
                    var item = items_1_1.value;
                    if (item[inputKey]) {
                        item[outputKey] = this.translate && this.translate && this.translate.currentLang && this.translate.instant && this.translate.instant(item[inputKey]);
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    };
    /**
     * When "enabledTranslate" is set to True, we will try to translate if the Translate Service exist or use the Locales when not
     * @param translationKey
     * @param localeKey
     */
    ExtensionUtility.prototype.translateWhenEnabledAndServiceExist = function (translationKey, localeKey) {
        var text = '';
        var gridOptions = this.sharedService && this.sharedService.gridOptions;
        // get locales provided by user in main file or else use default English locales via the Constants
        var locales = gridOptions && gridOptions.locales || Constants.locales;
        if (gridOptions.enableTranslate && this.translate && this.translate.currentLang && this.translate.instant) {
            text = this.translate.instant(translationKey || ' ');
        }
        else if (locales && locales.hasOwnProperty(localeKey)) {
            text = locales[localeKey];
        }
        else {
            text = localeKey;
        }
        return text;
    };
    ExtensionUtility.ctorParameters = function () { return [
        { type: SharedService },
        { type: TranslateService, decorators: [{ type: Optional }] }
    ]; };
    ExtensionUtility = tslib_1.__decorate([
        Injectable(),
        tslib_1.__param(1, Optional())
    ], ExtensionUtility);
    return ExtensionUtility;
}());
export { ExtensionUtility };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXh0ZW5zaW9uVXRpbGl0eS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2FuZ3VsYXItc2xpY2tncmlkLyIsInNvdXJjZXMiOlsiYXBwL21vZHVsZXMvYW5ndWxhci1zbGlja2dyaWQvZXh0ZW5zaW9ucy9leHRlbnNpb25VdGlsaXR5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNyRCxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUV2RCxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sY0FBYyxDQUFDO0FBQ3pDLE9BQU8sRUFBVSxhQUFhLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUN4RCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFDM0QsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFLN0Q7SUFDRSwwQkFBb0IsYUFBNEIsRUFBc0IsU0FBMkI7UUFBN0Usa0JBQWEsR0FBYixhQUFhLENBQWU7UUFBc0IsY0FBUyxHQUFULFNBQVMsQ0FBa0I7SUFBSSxDQUFDO0lBRXRHOzs7O09BSUc7SUFDSCxtREFBd0IsR0FBeEIsVUFBeUIsYUFBNEI7UUFDbkQsSUFBSTtZQUNGLFFBQVEsYUFBYSxFQUFFO2dCQUNyQixLQUFLLGFBQWEsQ0FBQyxXQUFXO29CQUM1QixPQUFPLENBQUMsc0NBQXNDLENBQUMsQ0FBQztvQkFDaEQsTUFBTTtnQkFDUixLQUFLLGFBQWEsQ0FBQyx1QkFBdUI7b0JBQ3hDLE9BQU8sQ0FBQyxpREFBaUQsQ0FBQyxDQUFDO29CQUMzRCxNQUFNO2dCQUNSLEtBQUssYUFBYSxDQUFDLGdCQUFnQjtvQkFDakMsT0FBTyxDQUFDLDhDQUE4QyxDQUFDLENBQUM7b0JBQ3hELE1BQU07Z0JBQ1IsS0FBSyxhQUFhLENBQUMsUUFBUTtvQkFDekIsT0FBTyxDQUFDLGtDQUFrQyxDQUFDLENB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QyxhQUFhLENBQUMsV0FBVyxDQUFDO1FBRXpFLGtHQUFrRztRQUNsRyxJQUFNLE9BQU8sR0FBRyxXQUFXLElBQUksV0FBVyxDQUFDLE9BQU8sSUFBSSxTQUFTLENBQUMsT0FBTyxDQUFDO1FBRXhFLElBQUksV0FBVyxDQUFDLGVBQWUsSUFBSSxJQUFJLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxFQUFFO1lBQ3pHLElBQUksR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxjQUFjLElBQUksR0FBRyxDQUFDLENBQUM7U0FDdEQ7YUFBTSxJQUFJLE9BQU8sSUFBSSxPQUFPLENBQUMsY0FBYyxDQUFDLFNBQVMsQ0FBQyxFQUFFO1lBQ3ZELElBQUksR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7U0FDM0I7YUFBTTtZQUNMLElBQUksR0FBRyxTQUFTLENBQUM7U0FDbEI7UUFDRCxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7O2dCQTNNa0MsYUFBYTtnQkFBaUMsZ0JBQWdCLHVCQUE5QyxRQUFROztJQURoRCxnQkFBZ0I7UUFENUIsVUFBVSxFQUFFO1FBRXdDLG1CQUFBLFFBQVEsRUFBRSxDQUFBO09BRGxELGdCQUFnQixDQTZNNUI7SUFBRCx1QkFBQztDQUFBLEFBN01ELElBNk1DO1NBN01ZLGdCQUFnQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFRyYW5zbGF0ZVNlcnZpY2UgfSBmcm9tICdAbmd4LXRyYW5zbGF0ZS9jb3JlJztcclxuXHJcbmltcG9ydCB7IENvbnN0YW50cyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XHJcbmltcG9ydCB7IENvbHVtbiwgRXh0ZW5zaW9uTmFtZSB9IGZyb20gJy4uL21vZGVscy9pbmRleCc7XHJcbmltcG9ydCB7IFNoYXJlZFNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9zaGFyZWQuc2VydmljZSc7XHJcbmltcG9ydCB7IGdldFRyYW5zbGF0aW9uUHJlZml4IH0gZnJvbSAnLi4vc2VydmljZXMvdXRpbGl0aWVzJztcclxuXHJcbmRlY2xhcmUgZnVuY3Rpb24gcmVxdWlyZShuYW1lOiBzdHJpbmcpO1xyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgRXh0ZW5zaW9uVXRpbGl0eSB7XHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBzaGFyZWRTZXJ2aWNlOiBTaGFyZWRTZXJ2aWNlLCBAT3B0aW9uYWwoKSBwcml2YXRlIHRyYW5zbGF0ZTogVHJhbnNsYXRlU2VydmljZSkgeyB9XHJcblxyXG4gIC8qKlxyXG4gICAqIExvYWQgU2xpY2tHcmlkIEV4dGVuc2lvbiAoQ29udHJvbC9QbHVnaW4pIGR5bmFtaWNhbGx5IChvbiBkZW1hbmQpXHJcbiAgICogVGhpcyB3aWxsIGJhc2ljYWxseSBvbmx5IGxvYWQgdGhlIGV4dGVuc2lvbiB3aGVuIHVzZXIgZW5hYmxlcyB0aGUgZmVhdHVyZVxyXG4gICAqIEBwYXJhbSBleHRlbnNpb25OYW1lXHJcbiAgICovXHJcbiAgbG9hZEV4dGVuc2lvbkR5bmFtaWNhbGx5KGV4dGVuc2lvbk5hbWU6IEV4dGVuc2lvbk5hbWUpOiBhbnkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgc3dpdGNoIChleHRlbnNpb25OYW1lKSB7XHJcbiAgICAgICAgY2FzZSBFeHRlbnNpb25OYW1lLmF1dG9Ub29sdGlwOlxyXG4gICAgICAgICAgcmVxdWlyZSgnc2xpY2tncmlkL3BsdWdpbnMvc2xpY2suYXV0b3Rvb2x0aXBzJyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEV4dGVuc2lvbk5hbWUuY2VsbEV4dGVybmFsQ29weU1hbmFnZXI6XHJcbiAgICAgICAgICByZXF1aXJlKCdzbGlja2dyaWQvcGx1Z2lucy9zbGljay5jZWxsZXh0ZXJuYWxjb3B5bWFuYWdlcicpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBFeHRlbnNpb25OYW1lLmNoZWNrYm94U2VsZWN0b3I6XHJcbiAgICAgICAgICByZXF1aXJlKCdzbGlja2dyaWQvcGx1Z2lucy9zbGljay5jaGVja2JveHNlbGVjdGNvbHVtbicpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBFeHRlbnNpb25OYW1lLmNlbGxNZW51OlxyXG4gICAgICAgICAgcmVxdWlyZSgnc2xpY2tncmlkL3BsdWdpbnMvc2xpY2suY2VsbG1lbnUnKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgRXh0ZW5zaW9uTmFtZS5jb2x1bW5QaWNrZXI6XHJcbiAgICAgICAgICByZXF1aXJlKCdzbGlja2dyaWQvY29udHJvbHMvc2xpY2suY29sdW1ucGlja2VyJyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEV4dGVuc2lvbk5hbWUuY29udGV4dE1lbnU6XHJcbiAgICAgICAgICByZXF1aXJlKCdzbGlja2dyaWQvcGx1Z2lucy9zbGljay5jb250ZXh0bWVudScpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBFeHRlbnNpb25OYW1lLmRyYWdnYWJsZUdyb3VwaW5nOlxyXG4gICAgICAgICAgcmVxdWlyZSgnc2xpY2tncmlkL3BsdWdpbnMvc2xpY2suZHJhZ2dhYmxlZ3JvdXBpbmcnKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgRXh0ZW5zaW9uTmFtZS5ncmlkTWVudTpcclxuICAgICAgICAgIHJlcXVpcmUoJ3NsaWNrZ3JpZC9jb250cm9scy9zbGljay5ncmlkbWVudScpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBFeHRlbnNpb25OYW1lLmdyb3VwSXRlbU1ldGFQcm92aWRlcjpcclxuICAgICAgICAgIHJlcXVpcmUoJ3NsaWNrZ3JpZC9zbGljay5ncm91cGl0ZW1tZXRhZGF0YXByb3ZpZGVyJyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEV4dGVuc2lvbk5hbWUuaGVhZGVyQnV0dG9uOlxyXG4gICAgICAgICAgcmVxdWlyZSgnc2xpY2tncmlkL3BsdWdpbnMvc2xpY2suaGVhZGVyYnV0dG9ucycpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBFeHRlbnNpb25OYW1lLmhlYWRlck1lbnU6XHJcbiAgICAgICAgICByZXF1aXJlKCdzbGlja2dyaWQvcGx1Z2lucy9zbGljay5oZWFkZXJtZW51Jyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEV4dGVuc2lvbk5hbWUucm93U2VsZWN0aW9uOlxyXG4gICAgICAgICAgcmVxdWlyZSgnc2xpY2tncmlkL3BsdWdpbnMvc2xpY2sucm93c2VsZWN0aW9ubW9kZWwnKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgRXh0ZW5zaW9uTmFtZS5yb3dEZXRhaWxWaWV3OlxyXG4gICAgICAgICAgcmVxdWlyZSgnc2xpY2tncmlkL3BsdWdpbnMvc2xpY2sucm93ZGV0YWlsdmlldycpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBFeHRlbnNpb25OYW1lLnJvd01vdmVNYW5hZ2VyOlxyXG4gICAgICAgICAgcmVxdWlyZSgnc2xpY2tncmlkL3BsdWdpbnMvc2xpY2sucm93bW92ZW1hbmFnZXInKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIC8vIGRvIG5vdGhpbmcsIHdlIGZhbGwgaGVyZSB3aGVuIHVzaW5nIEFuZ3VsYXIgYW5kIFJlcXVpcmVKU1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRnJvbSBhIEdyaWQgTWVudSBvYmplY3QgcHJvcGVydHkgbmFtZSwgd2Ugd2lsbCByZXR1cm4gdGhlIGNvcnJlY3QgdGl0bGUgb3V0cHV0IHN0cmluZyBmb2xsb3dpbmcgdGhpcyBvcmRlclxyXG4gICAqIDEtIGlmIHVzZXIgcHJvdmlkZWQgYSB0aXRsZSwgdXNlIGl0IGFzIHRoZSBvdXRwdXQgdGl0bGVcclxuICAgKiAyLSBlbHNlIGlmIHVzZXIgcHJvdmlkZWQgYSB0aXRsZSBrZXksIHVzZSBpdCB0byB0cmFuc2xhdGUgdGhlIG91dHB1dCB0aXRsZVxyXG4gICAqIDMtIGVsc2UgaWYgbm90aGluZyBpcyBwcm92aWRlZCB1c2UgdGV4dCBkZWZpbmVkIGFzIGNvbnN0YW50c1xyXG4gICAqL1xyXG4gIGdldFBpY2tlclRpdGxlT3V0cHV0U3RyaW5nKHByb3BOYW1lOiBzdHJpbmcsIHBpY2tlck5hbWU6ICdncmlkTWVudScgfCAnY29sdW1uUGlja2VyJykge1xyXG4gICAgaWYgKHRoaXMuc2hhcmVkU2VydmljZS5ncmlkT3B0aW9ucyAmJiB0aGlzLnNoYXJlZFNlcnZpY2UuZ3JpZE9wdGlvbnMuZW5hYmxlVHJhbnNsYXRlICYmICghdGhpcy50cmFuc2xhdGUgfHwgIXRoaXMudHJhbnNsYXRlLmluc3RhbnQpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignW0FuZ3VsYXItU2xpY2tncmlkXSByZXF1aXJlcyBcIm5neC10cmFuc2xhdGVcIiB0byBiZSBpbnN0YWxsZWQgYW5kIGNvbmZpZ3VyZWQgd2hlbiB0aGUgZ3JpZCBvcHRpb24gXCJlbmFibGVUcmFuc2xhdGVcIiBpcyBlbmFibGVkLicpO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBvdXRwdXQgPSAnJztcclxuICAgIGNvbnN0IHBpY2tlciA9IHRoaXMuc2hhcmVkU2VydmljZS5ncmlkT3B0aW9ucyAmJiB0aGlzLnNoYXJlZFNlcnZpY2UuZ3JpZE9wdGlvbnNbcGlja2VyTmFtZV0gfHwge307XHJcbiAgICBjb25zdCBlbmFibGVUcmFuc2xhdGUgPSB0aGlzLnNoYXJlZFNlcnZpY2UuZ3JpZE9wdGlvbnMgJiYgdGhpcy5zaGFyZWRTZXJ2aWNlLmdyaWRPcHRpb25zLmVuYWJsZVRyYW5zbGF0ZSB8fCBmYWxzZTtcclxuXHJcbiAgICAvLyBnZXQgbG9jYWxlcyBwcm92aWRlZCBieSB1c2VyIGluIGZvclJvb3Qgb3IgZWxzZSB1c2UgZGVmYXVsdCBFbmdsaXNoIGxvY2FsZXMgdmlhIHRoZSBDb25zdGFudHNcclxuICAgIGNvbnN0IGxvY2FsZXMgPSB0aGlzLnNoYXJlZFNlcnZpY2UgJiYgdGhpcy5zaGFyZWRTZXJ2aWNlLmdyaWRPcHRpb25zICYmIHRoaXMuc2hhcmVkU2VydmljZS5ncmlkT3B0aW9ucy5sb2NhbGVzIHx8IENvbnN0YW50cy5sb2NhbGVzO1xyXG5cclxuICAgIGNvbnN0IHRpdGxlID0gcGlja2VyICYmIHBpY2tlcltwcm9wTmFtZV07XHJcbiAgICBjb25zdCB0aXRsZUtleSA9IHBpY2tlciAmJiBwaWNrZXJbYCR7cHJvcE5hbWV9S2V5YF07XHJcbiAgICBjb25zdCBncmlkT3B0aW9ucyA9IHRoaXMuc2hhcmVkU2VydmljZS5ncmlkT3B0aW9ucztcclxuICAgIGNvbnN0IHRyYW5zbGF0aW9uUHJlZml4ID0gZ2V0VHJhbnNsYXRpb25QcmVmaXgoZ3JpZE9wdGlvbnMpO1xyXG5cclxuICAgIGlmICh0aXRsZUtleSAmJiB0aGlzLnRyYW5zbGF0ZSAmJiB0aGlzLnRyYW5zbGF0ZS5jdXJyZW50TGFuZyAmJiB0aGlzLnRyYW5zbGF0ZS5pbnN0YW50KSB7XHJcbiAgICAgIG91dHB1dCA9IHRoaXMudHJhbnNsYXRlLmluc3RhbnQodGl0bGVLZXkgfHwgJyAnKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN3aXRjaCAocHJvcE5hbWUpIHtcclxuICAgICAgICBjYXNlICdjdXN0b21UaXRsZSc6XHJcbiAgICAgICAgICBvdXRwdXQgPSB0aXRsZSB8fCBlbmFibGVUcmFuc2xhdGUgJiYgdGhpcy50cmFuc2xhdGUgJiYgdGhpcy50cmFuc2xhdGUuY3VycmVudExhbmcgJiYgdGhpcy50cmFuc2xhdGUuaW5zdGFudCAmJiB0aGlzLnRyYW5zbGF0ZS5pbnN0YW50KGAke3RyYW5zbGF0aW9uUHJlZml4fUNPTU1BTkRTYCB8fCAnICcpIHx8IGxvY2FsZXMgJiYgbG9jYWxlcy5URVhUX0NPTU1BTkRTO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnY29sdW1uVGl0bGUnOlxyXG4gICAgICAgICAgb3V0cHV0ID0gdGl0bGUgfHwgZW5hYmxlVHJhbnNsYXRlICYmIHRoaXMudHJhbnNsYXRlICYmIHRoaXMudHJhbnNsYXRlLmN1cnJlbnRMYW5nICYmIHRoaXMudHJhbnNsYXRlLmluc3RhbnQgJiYgdGhpcy50cmFuc2xhdGUuaW5zdGFudChgJHt0cmFuc2xhdGlvblByZWZpeH1DT0xVTU5TYCB8fCAnICcpIHx8IGxvY2FsZXMgJiYgbG9jYWxlcy5URVhUX0NPTFVNTlM7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdmb3JjZUZpdFRpdGxlJzpcclxuICAgICAgICAgIG91dHB1dCA9IHRpdGxlIHx8IGVuYWJsZVRyYW5zbGF0ZSAmJiB0aGlzLnRyYW5zbGF0ZSAmJiB0aGlzLnRyYW5zbGF0ZS5jdXJyZW50TGFuZyAmJiB0aGlzLnRyYW5zbGF0ZS5pbnN0YW50ICYmIHRoaXMudHJhbnNsYXRlLmluc3RhbnQoYCR7dHJhbnNsYXRpb25QcmVmaXh9Rk9SQ0VfRklUX0NPTFVNTlNgIHx8ICcgJykgfHwgbG9jYWxlcyAmJiBsb2NhbGVzLlRFWFRfRk9SQ0VfRklUX0NPTFVNTlM7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdzeW5jUmVzaXplVGl0bGUnOlxyXG4gICAgICAgICAgb3V0cHV0ID0gdGl0bGUgfHwgZW5hYmxlVHJhbnNsYXRlICYmIHRoaXMudHJhbnNsYXRlICYmIHRoaXMudHJhbnNsYXRlLmN1cnJlbnRMYW5nICYmIHRoaXMudHJhbnNsYXRlLmluc3RhbnQgJiYgdGhpcy50cmFuc2xhdGUuaW5zdGFudChgJHt0cmFuc2xhdGlvblByZWZpeH1TWU5DSFJPTk9VU19SRVNJWkVgIHx8ICcgJykgfHwgbG9jYWxlcyAmJiBsb2NhbGVzLlRFWFRfU1lOQ0hST05PVVNfUkVTSVpFO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIG91dHB1dCA9IHRpdGxlO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMb29wIHRocm91Z2ggb2JqZWN0IHByb3ZpZGVkIGFuZCBzZXQgdG8gbnVsbCBhbnkgcHJvcGVydHkgZm91bmQgc3RhcnRpbmcgd2l0aCBcIm9uWFwiXHJcbiAgICogQHBhcmFtIHtPYmplY3R9OiBvYmpcclxuICAgKi9cclxuICBudWxsaWZ5RnVuY3Rpb25OYW1lU3RhcnRpbmdXaXRoT24ob2JqPzogYW55KSB7XHJcbiAgICBpZiAob2JqKSB7XHJcbiAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBPYmplY3Qua2V5cyhvYmopKSB7XHJcbiAgICAgICAgaWYgKHByb3Auc3RhcnRzV2l0aCgnb24nKSkge1xyXG4gICAgICAgICAgb2JqW3Byb3BdID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFdoZW4gdXNpbmcgQ29sdW1uUGlja2VyL0dyaWRNZW51IHRvIHNob3cvaGlkZSBhIGNvbHVtbiwgd2UgcG90ZW50aWFsbHkgbmVlZCB0byByZWFkanVzdCB0aGUgZ3JpZCBvcHRpb24gXCJmcm96ZW5Db2x1bW5cIiBpbmRleC5cclxuICAgKiBUaGF0IGlzIGJlY2F1c2UgU2xpY2tHcmlkIGZyZWV6ZXMgYnkgY29sdW1uIGluZGV4IGFuZCBpdCBoYXMgbm8ga25vd2xlZGdlIG9mIHRoZSBjb2x1bW5zIHRoZW1zZWx2ZXMgYW5kIHdvbid0IGNoYW5nZSB0aGUgaW5kZXgsIHdlIG5lZWQgdG8gZG8gdGhhdCBvdXJzZWx2ZXMgd2hlbmV2ZXIgbmVjZXNzYXJ5LlxyXG4gICAqIE5vdGU6IHdlIGNhbGwgdGhpcyBtZXRob2QgcmlnaHQgYWZ0ZXIgdGhlIHZpc2libGVDb2x1bW5zIGFycmF5IGdvdCB1cGRhdGVkLCBpdCB3b24ndCB3b3JrIHByb3Blcmx5IGlmIHdlIGNhbGwgaXQgYmVmb3JlIHRoZSBzZXR0aW5nIHRoZSB2aXNpYmxlQ29sdW1ucy5cclxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGlja2VyQ29sdW1uSWQgLSB3aGF0IGlzIHRoZSBjb2x1bW4gaWQgdHJpZ2dlcmVkIGJ5IHRoZSBwaWNrZXJcclxuICAgKiBAcGFyYW0ge051bWJlcn0gZnJvemVuQ29sdW1uSW5kZXggLSBjdXJyZW50IGZyb3plbkNvbHVtbiBpbmRleFxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2hvd2luZ0NvbHVtbiAtIGlzIHRoZSBjb2x1bW4gYmVpbmcgc2hvd24gb3IgaGlkZGVuP1xyXG4gICAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gYWxsQ29sdW1ucyAtIGFsbCBjb2x1bW5zIChpbmNsdWRpbmcgaGlkZGVuIG9uZXMpXHJcbiAgICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSB2aXNpYmxlQ29sdW1ucyAtIG9ubHkgdmlzaWJsZSBjb2x1bW5zIChleGNsdWRpbmcgaGlkZGVuIG9uZXMpXHJcbiAgICovXHJcbiAgcmVhZGp1c3RGcm96ZW5Db2x1bW5JbmRleFdoZW5OZWVkZWQocGlja2VyQ29sdW1uSWQ6IHN0cmluZyB8IG51bWJlciwgZnJvemVuQ29sdW1uSW5kZXg6IG51bWJlciwgc2hvd2luZ0NvbHVtbjogYm9vbGVhbiwgYWxsQ29sdW1uczogQ29sdW1uW10sIHZpc2libGVDb2x1bW5zOiBDb2x1bW5bXSkge1xyXG4gICAgaWYgKGZyb3plbkNvbHVtbkluZGV4ID49IDAgJiYgcGlja2VyQ29sdW1uSWQpIHtcclxuICAgICAgLy8gY2FsY3VsYXRlIGEgcG9zc2libGUgZnJvemVuQ29sdW1uIGluZGV4IHZhcmlhbmNlXHJcbiAgICAgIGxldCBmcm96ZW5Db2xJbmRleFZhcmlhbmNlID0gMDtcclxuICAgICAgaWYgKHNob3dpbmdDb2x1bW4pIHtcclxuICAgICAgICBjb25zdCBkZWZpbmVkRnJvemVuQ29sdW1uSW5kZXggPSB2aXNpYmxlQ29sdW1ucy5maW5kSW5kZXgoY29sID0+IGNvbC5pZCA9PT0gdGhpcy5zaGFyZWRTZXJ2aWNlLmZyb3plblZpc2libGVDb2x1bW5JZCk7XHJcbiAgICAgICAgY29uc3QgY29sdW1uSW5kZXggPSB2aXNpYmxlQ29sdW1ucy5maW5kSW5kZXgoY29sID0+IGNvbC5pZCA9PT0gcGlja2VyQ29sdW1uSWQpO1xyXG4gICAgICAgIGZyb3plbkNvbEluZGV4VmFyaWFuY2UgPSAoY29sdW1uSW5kZXggPj0gMCAmJiAoZnJvemVuQ29sdW1uSW5kZXggPj0gY29sdW1uSW5kZXggfHwgZGVmaW5lZEZyb3plbkNvbHVtbkluZGV4ID09PSBjb2x1bW5JbmRleCkpID8gMSA6IDA7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3QgY29sdW1uSW5kZXggPSBhbGxDb2x1bW5zLmZpbmRJbmRleChjb2wgPT4gY29sLmlkID09PSBwaWNrZXJDb2x1bW5JZCk7XHJcbiAgICAgICAgZnJvemVuQ29sSW5kZXhWYXJpYW5jZSA9IChjb2x1bW5JbmRleCA+PSAwICYmIGZyb3plbkNvbHVtbkluZGV4ID49IGNvbHVtbkluZGV4KSA/IC0xIDogMDtcclxuICAgICAgfVxyXG4gICAgICAvLyBpZiB3ZSBoYXZlIGEgdmFyaWFuY2UgZGlmZmVyZW50IHRoYW4gMCB0aGVuIGFwcGx5IGl0XHJcbiAgICAgIGNvbnN0IG5ld0Zyb3plbkNvbEluZGV4ID0gZnJvemVuQ29sdW1uSW5kZXggKyBmcm96ZW5Db2xJbmRleFZhcmlhbmNlO1xyXG4gICAgICBpZiAoZnJvemVuQ29sSW5kZXhWYXJpYW5jZSAhPT0gMCkge1xyXG4gICAgICAgIHRoaXMuc2hhcmVkU2VydmljZS5ncmlkLnNldE9wdGlvbnMoeyBmcm96ZW5Db2x1bW46IG5ld0Zyb3plbkNvbEluZGV4IH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB0byBmcmVlemUgY29sdW1ucywgd2UgbmVlZCB0byB0YWtlIG9ubHkgdGhlIHZpc2libGUgY29sdW1ucyBhbmQgd2UgYWxzbyBuZWVkIHRvIHVzZSBzZXRDb2x1bW5zKCkgd2hlbiBzb21lIG9mIHRoZW0gYXJlIGhpZGRlblxyXG4gICAgICAvLyB0byBtYWtlIHN1cmUgdGhhdCB3ZSBvbmx5IHVzZSB0aGUgdmlzaWJsZSBjb2x1bW5zLCBub3QgZG9pbmcgdGhpcyB3b3VsZCBzaG93IGJhY2sgc29tZSBvZiB0aGUgaGlkZGVuIGNvbHVtbnNcclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmlzaWJsZUNvbHVtbnMpICYmIEFycmF5LmlzQXJyYXkoYWxsQ29sdW1ucykgJiYgdmlzaWJsZUNvbHVtbnMubGVuZ3RoICE9PSBhbGxDb2x1bW5zLmxlbmd0aCkge1xyXG4gICAgICAgIHRoaXMuc2hhcmVkU2VydmljZS5ncmlkLnNldENvbHVtbnModmlzaWJsZUNvbHVtbnMpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTb3J0IGl0ZW1zIChieSBwb2ludGVycykgaW4gYW4gYXJyYXkgYnkgYSBwcm9wZXJ0eSBuYW1lXHJcbiAgICogQHBhcmFtcyBpdGVtcyBhcnJheVxyXG4gICAqIEBwYXJhbSBwcm9wZXJ0eSBuYW1lIHRvIHNvcnQgd2l0aFxyXG4gICAqL1xyXG4gIHNvcnRJdGVtczxUID0gYW55PihpdGVtczogVFtdLCBwcm9wZXJ0eU5hbWU6IHN0cmluZykge1xyXG4gICAgLy8gc29ydCB0aGUgY3VzdG9tIGl0ZW1zIGJ5IHRoZWlyIHBvc2l0aW9uIGluIHRoZSBsaXN0XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtcykpIHtcclxuICAgICAgaXRlbXMuc29ydCgoaXRlbUE6IFQsIGl0ZW1COiBUKSA9PiB7XHJcbiAgICAgICAgaWYgKGl0ZW1BICYmIGl0ZW1CICYmIGl0ZW1BLmhhc093blByb3BlcnR5KHByb3BlcnR5TmFtZSkgJiYgaXRlbUIuaGFzT3duUHJvcGVydHkocHJvcGVydHlOYW1lKSkge1xyXG4gICAgICAgICAgcmV0dXJuIGl0ZW1BW3Byb3BlcnR5TmFtZV0gLSBpdGVtQltwcm9wZXJ0eU5hbWVdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogVHJhbnNsYXRlIHRoZSBhbiBhcnJheSBvZiBpdGVtcyBmcm9tIGFuIGlucHV0IGtleSBhbmQgYXNzaWduIHRvIHRoZSBvdXRwdXQga2V5ICovXHJcbiAgdHJhbnNsYXRlSXRlbXM8VCA9IGFueT4oaXRlbXM6IFRbXSwgaW5wdXRLZXk6IHN0cmluZywgb3V0cHV0S2V5OiBzdHJpbmcpIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xyXG4gICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcclxuICAgICAgICBpZiAoaXRlbVtpbnB1dEtleV0pIHtcclxuICAgICAgICAgIGl0ZW1bb3V0cHV0S2V5XSA9IHRoaXMudHJhbnNsYXRlICYmIHRoaXMudHJhbnNsYXRlICYmIHRoaXMudHJhbnNsYXRlLmN1cnJlbnRMYW5nICYmIHRoaXMudHJhbnNsYXRlLmluc3RhbnQgJiYgdGhpcy50cmFuc2xhdGUuaW5zdGFudChpdGVtW2lucHV0S2V5XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBXaGVuIFwiZW5hYmxlZFRyYW5zbGF0ZVwiIGlzIHNldCB0byBUcnVlLCB3ZSB3aWxsIHRyeSB0byB0cmFuc2xhdGUgaWYgdGhlIFRyYW5zbGF0ZSBTZXJ2aWNlIGV4aXN0IG9yIHVzZSB0aGUgTG9jYWxlcyB3aGVuIG5vdFxyXG4gICAqIEBwYXJhbSB0cmFuc2xhdGlvbktleVxyXG4gICAqIEBwYXJhbSBsb2NhbGVLZXlcclxuICAgKi9cclxuICB0cmFuc2xhdGVXaGVuRW5hYmxlZEFuZFNlcnZpY2VFeGlzdCh0cmFuc2xhdGlvbktleTogc3RyaW5nLCBsb2NhbGVLZXk6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICBsZXQgdGV4dCA9ICcnO1xyXG4gICAgY29uc3QgZ3JpZE9wdGlvbnMgPSB0aGlzLnNoYXJlZFNlcnZpY2UgJiYgdGhpcy5zaGFyZWRTZXJ2aWNlLmdyaWRPcHRpb25zO1xyXG5cclxuICAgIC8vIGdldCBsb2NhbGVzIHByb3ZpZGVkIGJ5IHVzZXIgaW4gbWFpbiBmaWxlIG9yIGVsc2UgdXNlIGRlZmF1bHQgRW5nbGlzaCBsb2NhbGVzIHZpYSB0aGUgQ29uc3RhbnRzXHJcbiAgICBjb25zdCBsb2NhbGVzID0gZ3JpZE9wdGlvbnMgJiYgZ3JpZE9wdGlvbnMubG9jYWxlcyB8fCBDb25zdGFudHMubG9jYWxlcztcclxuXHJcbiAgICBpZiAoZ3JpZE9wdGlvbnMuZW5hYmxlVHJhbnNsYXRlICYmIHRoaXMudHJhbnNsYXRlICYmIHRoaXMudHJhbnNsYXRlLmN1cnJlbnRMYW5nICYmIHRoaXMudHJhbnNsYXRlLmluc3RhbnQpIHtcclxuICAgICAgdGV4dCA9IHRoaXMudHJhbnNsYXRlLmluc3RhbnQodHJhbnNsYXRpb25LZXkgfHwgJyAnKTtcclxuICAgIH0gZWxzZSBpZiAobG9jYWxlcyAmJiBsb2NhbGVzLmhhc093blByb3BlcnR5KGxvY2FsZUtleSkpIHtcclxuICAgICAgdGV4dCA9IGxvY2FsZXNbbG9jYWxlS2V5XTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRleHQgPSBsb2NhbGVLZXk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGV4dDtcclxuICB9XHJcbn1cclxuIl19