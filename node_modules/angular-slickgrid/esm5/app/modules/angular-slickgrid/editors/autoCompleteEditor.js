import * as tslib_1 from "tslib";
import * as DOMPurify_ from 'dompurify';
var DOMPurify = DOMPurify_; // patch to fix rollup to work
import { FieldType, KeyCode, } from './../models/index';
import { findOrDefault, getDescendantProperty, setDeepValue, toKebabCase } from '../services/utilities';
import { textValidator } from '../editorValidators/textValidator';
// minimum length of chars to type before starting to start querying
var MIN_LENGTH = 3;
/*
 * An example of a 'detached' editor.
 * KeyDown events are also handled to provide handling for Tab, Shift-Tab, Esc and Ctrl-Enter.
 */
var AutoCompleteEditor = /** @class */ (function () {
    function AutoCompleteEditor(args) {
        this.args = args;
        if (!args) {
            throw new Error('[Angular-SlickGrid] Something is wrong with this grid, an Editor must always have valid arguments.');
        }
        this.grid = args.grid;
        this.init();
    }
    Object.defineProperty(AutoCompleteEditor.prototype, "autoCompleteOptions", {
        /** Getter for the Autocomplete Option */
        get: function () {
            return this._autoCompleteOptions || {};
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoCompleteEditor.prototype, "editorCollection", {
        /** Get the Collection */
        get: function () {
            return this.columnDef && this.columnDef.internalColumnEditor && this.columnDef.internalColumnEditor.collection || [];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoCompleteEditor.prototype, "elementCollection", {
        /** Get the Final Collection used in the AutoCompleted Source (this may vary from the "collection" especially when providing a customStructure) */
        get: function () {
            return this._elementCollection;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoCompleteEditor.prototype, "columnDef", {
        /** Get Column Definition object */
        get: function () {
            return this.args && this.args.column;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoCompleteEditor.prototype, "columnEditor", {
        /** Get Column Editor object */
        get: function () {
            return this.columnDef && this.columnDef.internalColumnEditor || {};
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoCompleteEditor.prototype, "customStructure", {
        /** Getter for the Custom Structure if exist */
        get: function () {
            var customStructure = this.columnEditor && this.columnEditor.customStructure;
            var columnType = this.columnEditor && this.columnEditor.type || this.columnDef && this.columnDef.type;
            if (!customStructure && (columnType === FieldType.object && this.columnDef && this.columnDef.dataKey && this.columnDef.labelKey)) {
                customStructure = {
                    label: this.columnDef.labelKey,
                    value: this.columnDef.dataKey,
                };
            }
            return customStructure;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoCompleteEditor.prototype, "hasAutoCommitEdit", {
        get: function () {
            return this.gridOptions.autoCommitEdit;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoCompleteEditor.prototype, "validator", {
        /** Get the Validator function, can be passed in Editor property or Column Definition */
        get: function () {
            return this.columnEditor.validator || this.columnDef.validator;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoCompleteEditor.prototype, "editorOptions", {
        get: function () {
            return this.columnEditor && this.columnEditor.editorOptions || {};
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoCompleteEditor.prototype, "instance", {
        /** jQuery UI AutoComplete instance */
        get: function () {
            return this._$editorElm.autocomplete('instance');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoCompleteEditor.prototype, "gridOptions", {
        /** Getter for the Grid Options pulled through the Grid Object */
        get: function () {
            return (this.grid && this.grid.getOptions) ? this.grid.getOptions() : {};
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoCompleteEditor.prototype, "editorDomElement", {
        /** Get the Editor DOM Element */
        get: function () {
            return this._$editorElm;
        },
        enumerable: true,
        configurable: true
    });
    AutoCompleteEditor.prototype.init = function () {
        this.labelName = this.customStructure && this.customStructure.label || 'label';
        this.valueName = this.customStructure && this.customStructure.value || 'value';
        this.labelPrefixName = this.customStructure && this.customStructure.labelPrefix || 'labelPrefix';
        this.labelSuffixName = this.customStructure && this.customStructure.labelSuffix || 'labelSuffix';
        // always render the DOM element, even if user passed a "collectionAsync",
        var newCollection = this.columnEditor.collection || [];
        this.renderDomElement(newCollection);
    };
    AutoCompleteEditor.prototype.destroy = function () {
        if (this._$editorElm) {
            this._$editorElm.autocomplete('destroy');
            this._$editorElm.off('keydown.nav').remove();
        }
        this._$editorElm = null;
        this._elementCollection = null;
    };
    AutoCompleteEditor.prototype.focus = function () {
        if (this._$editorElm) {
            this._$editorElm.focus().select();
        }
    };
    AutoCompleteEditor.prototype.getValue = function () {
        return this._$editorElm.val();
    };
    AutoCompleteEditor.prototype.setValue = function (value) {
        this._$editorElm.val(value);
    };
    AutoCompleteEditor.prototype.applyValue = function (item, state) {
        var _this = this;
        var newValue = state;
        var fieldName = this.columnDef && this.columnDef.field;
        // if we have a collection defined, we will try to find the string within the collection and return it
        if (Array.isArray(this.editorCollection) && this.editorCollection.length > 0) {
            newValue = findOrDefault(this.editorCollection, function (collectionItem) {
                if (collectionItem && typeof state === 'object' && collectionItem.hasOwnProperty(_this.labelName)) {
                    return (collectionItem.hasOwnProperty(_this.labelName) && collectionItem[_this.labelName].toString()) === (state.hasOwnProperty(_this.labelName) && state[_this.labelName].toString());
                }
                else if (collectionItem && typeof state === 'string' && collectionItem.hasOwnProperty(_this.labelName)) {
                    return (collectionItem.hasOwnProperty(_this.labelName) && collectionItem[_this.labelName].toString()) === state;
                }
                return collectionItem && collectionItem.toString() === state;
            });
        }
        // is the field a complex object, "address.streetNumber"
        var isComplexObject = fieldName && fieldName.indexOf('.') > 0;
        // validate the value before applying it (if not valid we'll set an empty string)
        var validation = this.validate(newValue);
        newValue = (validation && validation.valid) ? newValue : '';
        // set the new value to the item datacontext
        if (isComplexObject) {
            setDeepValue(item, fieldName, newValue);
        }
        else {
            item[fieldName] = newValue;
        }
    };
    AutoCompleteEditor.prototype.isValueChanged = function () {
        var elmValue = this._$editorElm.val();
        var lastKeyEvent = this._lastInputEvent && this._lastInputEvent.keyCode;
        if (this.columnEditor && this.columnEditor.alwaysSaveOnEnterKey && lastKeyEvent === KeyCode.ENTER) {
            return true;
        }
        return (!(elmValue === '' && (this._defaultTextValue === null || this._defaultTextValue === undefined))) && (elmValue !== this._defaultTextValue);
    };
    AutoCompleteEditor.prototype.loadValue = function (item) {
        var fieldName = this.columnDef && this.columnDef.field;
        if (item && fieldName !== undefined) {
            // is the field a complex object, "address.streetNumber"
            var isComplexObject = fieldName && fieldName.indexOf('.') > 0;
            var data = (isComplexObject) ? getDescendantProperty(item, fieldName) : item[fieldName];
            this._currentValue = data;
            this._defaultTextValue = typeof data === 'string' ? data : (data && data.hasOwnProperty(this.labelName) && data[this.labelName] || '');
            this._$editorElm.val(this._defaultTextValue);
            this._$editorElm.select();
        }
    };
    AutoCompleteEditor.prototype.save = function () {
        var validation = this.validate();
        var isValid = (validation && validation.valid) || false;
        if (this.hasAutoCommitEdit && isValid) {
            // do not use args.commitChanges() as this sets the focus to the next row.
            // also the select list will stay shown when clicking off the grid
            this.grid.getEditorLock().commitCurrentEdit();
        }
        else {
            this.args.commitChanges();
        }
    };
    AutoCompleteEditor.prototype.serializeValue = function () {
        var _a;
        // if you want to add the autocomplete functionality but want the user to be able to input a new option
        if (this.editorOptions.forceUserInput) {
            var minLength = this.editorOptions && this.editorOptions.hasOwnProperty('minLength') ? this.editorOptions.minLength : MIN_LENGTH;
            this._currentValue = this._$editorElm.val().length > minLength ? this._$editorElm.val() : this._currentValue;
        }
        // if user provided a custom structure, we will serialize the value returned from the object with custom structure
        if (this.customStructure && this._currentValue && this._currentValue.hasOwnProperty(this.valueName) && (this.columnDef && this.columnDef.type !== FieldType.object && this.columnEditor && this.columnEditor.type !== FieldType.object)) {
            return this._currentValue[this.valueName];
        }
        else if (this._currentValue && this._currentValue.value !== undefined) {
            // when object has a "value" property and its column is set as an Object type, we'll return an object with optional custom structure
            if (this.columnDef && this.columnDef.type === FieldType.object || ((this.columnEditor && this.columnEditor.type) === FieldType.object)) {
                return _a = {},
                    _a[this.labelName] = this._currentValue.label,
                    _a[this.valueName] = this._currentValue.value,
                    _a;
            }
            return this._currentValue.value;
        }
        // if it falls here it might be that the user provided its own custom item with something else than the regular label/value pair
        // at this point it's only available when user provide a custom template for the autocomplete renderItem callback
        return this._currentValue;
    };
    AutoCompleteEditor.prototype.validate = function (inputValue) {
        var val = (inputValue !== undefined) ? inputValue : this._$editorElm && this._$editorElm.val && this._$editorElm.val();
        return textValidator(val, {
            editorArgs: this.args,
            errorMessage: this.columnEditor.errorMessage,
            minLength: this.columnEditor.minLength,
            maxLength: this.columnEditor.maxLength,
            operatorConditionalType: this.columnEditor.operatorConditionalType,
            required: this.columnEditor.required,
            validator: this.validator,
        });
    };
    //
    // private functions
    // ------------------
    // this function should be PRIVATE but for unit tests purposes we'll make it public until a better solution is found
    // a better solution would be to get the autocomplete DOM element to work with selection but I couldn't find how to do that in Jest
    AutoCompleteEditor.prototype.onSelect = function (_event, ui) {
        if (ui && ui.item) {
            var item = ui && ui.item;
            this._currentValue = item;
            // when the user defines a "renderItem" (or "_renderItem") template, then we assume the user defines his own custom structure of label/value pair
            // otherwise we know that jQueryUI always require a label/value pair, we can pull them directly
            var hasCustomRenderItemCallback = this.columnEditor && this.columnEditor.callbacks && this.columnEditor.callbacks.hasOwnProperty('_renderItem') || (this.columnEditor && this.columnEditor.editorOptions && this.columnEditor.editorOptions.renderItem) || false;
            var itemLabel = typeof item === 'string' ? item : (hasCustomRenderItemCallback ? item[this.labelName] : item.label);
            this.setValue(itemLabel);
            this.save();
        }
        return false;
    };
    AutoCompleteEditor.prototype.renderCustomItem = function (ul, item) {
        var templateString = this._autoCompleteOptions && this._autoCompleteOptions.renderItem && this._autoCompleteOptions.renderItem.templateCallback(item) || '';
        // sanitize any unauthorized html tags like script and others
        // for the remaining allowed tags we'll permit all attributes
        var sanitizedTemplateText = (DOMPurify.sanitize(templateString, {}) || '').toString();
        return $('<li></li>')
            .data('item.autocomplete', item)
            .append(sanitizedTemplateText)
            .appendTo(ul);
    };
    AutoCompleteEditor.prototype.renderCollectionItem = function (ul, item) {
        var isRenderHtmlEnabled = this.columnEditor && this.columnEditor.enableRenderHtml || false;
        var prefixText = item.labelPrefix || '';
        var labelText = item.label || '';
        var suffixText = item.labelSuffix || '';
        var finalText = prefixText + labelText + suffixText;
        // sanitize any unauthorized html tags like script and others
        // for the remaining allowed tags we'll permit all attributes
        var sanitizedText = (DOMPurify.sanitize(finalText, {}) || '').toString();
        var $liDiv = $('<div></div>')[isRenderHtmlEnabled ? 'html' : 'text'](sanitizedText);
        return $('<li></li>')
            .data('item.autocomplete', item)
            .append($liDiv)
            .appendTo(ul);
    };
    AutoCompleteEditor.prototype.renderDomElement = function (collection) {
        var e_1, _a;
        var _this = this;
        if (!Array.isArray(collection)) {
            throw new Error('The "collection" passed to the Autocomplete Editor is not a valid array.');
        }
        var columnId = this.columnDef && this.columnDef.id || '';
        var placeholder = this.columnEditor && this.columnEditor.placeholder || '';
        var title = this.columnEditor && this.columnEditor.title || '';
        this._$editorElm = $("<input type=\"text\" role=\"presentation\" autocomplete=\"off\" class=\"autocomplete editor-text editor-" + columnId + "\" placeholder=\"" + placeholder + "\" title=\"" + title + "\" />")
            .appendTo(this.args.container)
            .on('keydown.nav', function (event) {
            _this._lastInputEvent = event;
            if (event.keyCode === KeyCode.LEFT || event.keyCode === KeyCode.RIGHT) {
                event.stopImmediatePropagation();
            }
        });
        // add a <span> in order to add spinner styling
        $("<span></span>").appendTo(this.args.container);
        // user might pass his own autocomplete options
        var autoCompleteOptions = this.columnEditor.editorOptions;
        // assign the collection to a temp variable before filtering/sorting the collection
        var finalCollection = collection;
        // user might provide his own custom structure
        // jQuery UI autocomplete requires a label/value pair, so we must remap them when user provide different ones
        if (Array.isArray(finalCollection)) {
            finalCollection = finalCollection.map(function (item) {
                return { label: item[_this.labelName], value: item[_this.valueName], labelPrefix: item[_this.labelPrefixName] || '', labelSuffix: item[_this.labelSuffixName] || '' };
            });
        }
        // keep the final source collection used in the AutoComplete as reference
        this._elementCollection = finalCollection;
        // when user passes it's own autocomplete options
        // we still need to provide our own "select" callback implementation
        if (autoCompleteOptions && autoCompleteOptions.source) {
            autoCompleteOptions.select = function (event, ui) { return _this.onSelect(event, ui); };
            this._autoCompleteOptions = tslib_1.__assign({}, autoCompleteOptions);
            // when "renderItem" is defined, we need to add our custom style CSS class
            if (this._autoCompleteOptions.renderItem) {
                this._autoCompleteOptions.classes = {
                    'ui-autocomplete': "autocomplete-custom-" + toKebabCase(this._autoCompleteOptions.renderItem.layout)
                };
            }
            // create the jQueryUI AutoComplete
            this._$editorElm.autocomplete(this._autoCompleteOptions);
            // when "renderItem" is defined, we need to call the user's custom renderItem template callback
            if (this._autoCompleteOptions.renderItem) {
                this._$editorElm.autocomplete('instance')._renderItem = this.renderCustomItem.bind(this);
            }
        }
        else {
            var definedOptions = {
                source: finalCollection,
                minLength: 0,
                select: function (event, ui) { return _this.onSelect(event, ui); },
            };
            this._autoCompleteOptions = tslib_1.__assign({}, definedOptions, this.columnEditor.editorOptions);
            this._$editorElm.autocomplete(this._autoCompleteOptions);
            // we'll use our own renderer so that it works with label prefix/suffix and also with html rendering when enabled
            this._$editorElm.autocomplete('instance')._renderItem = this.renderCollectionItem.bind(this);
        }
        // in case the user wants to save even an empty value,
        // we need to subscribe to the onKeyDown event for that use case and clear the current value
        if (this.columnEditor.alwaysSaveOnEnterKey) {
            this._$editorElm.keydown(function (event) {
                if (event.keyCode === KeyCode.ENTER) {
                    _this._currentValue = null;
                }
            });
        }
        // we could optionally trigger a search when clicking on the AutoComplete
        if (this.editorOptions.openSearchListOnFocus) {
            this._$editorElm.click(function () { return _this._$editorElm.autocomplete('search', _this._$editorElm.val()); });
        }
        // user might override any of the jQueryUI callback methods
        if (this.columnEditor.callbacks) {
            try {
                for (var _b = tslib_1.__values(Object.keys(this.columnEditor.callbacks)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var callback = _c.value;
                    if (typeof this.columnEditor.callbacks[callback] === 'function') {
                        this.instance[callback] = this.columnEditor.callbacks[callback];
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        this._$editorElm.on('focus', function () {
            _this._$editorElm.select();
            // we could optionally trigger a search to open the AutoComplete search list
            if (_this.editorOptions.openSearchListOnFocus) {
                _this._$editorElm.autocomplete('search', _this._$editorElm.val());
            }
        });
        setTimeout(function () { return _this.focus(); }, 50);
    };
    return AutoCompleteEditor;
}());
export { AutoCompleteEditor };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0b0NvbXBsZXRlRWRpdG9yLmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci1zbGlja2dyaWQvIiwic291cmNlcyI6WyJhcHAvbW9kdWxlcy9hbmd1bGFyLXNsaWNrZ3JpZC9lZGl0b3JzL2F1dG9Db21wbGV0ZUVkaXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxLQUFLLFVBQVUsTUFBTSxXQUFXLENBQUM7QUFDeEMsSUFBTSxTQUFTLEdBQUcsVUFBVSxDQUFDLENBQUMsOEJBQThCO0FBRTVELE9BQU8sRUFTTCxTQUFTLEVBRVQsT0FBTyxHQUNSLE1BQU0sbUJBQW1CLENBQUM7QUFDM0IsT0FBTyxFQUFFLGFBQWEsRUFBRSxxQkFBcUIsRUFBRSxZQUFZLEVBQUUsV0FBVyxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDeEcsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLG1DQUFtQyxDQUFDO0FBS2xFLG9FQUFvRTtBQUNwRSxJQUFNLFVBQVUsR0FBRyxDQUFDLENBQUM7QUFFckI7OztHQUdHO0FBQ0g7SUEyQkUsNEJBQW9CLElBQXFCO1FBQXJCLFNBQUksR0FBSixJQUFJLENBQWlCO1FBQ3ZDLElBQUksQ0FBQyxJQUFJLEVBQUU7WUFDVCxNQUFNLElBQUksS0FBSyxDQUFDLG9HQUFvRyxDQUFDLENBQUM7U0FDdkg7UUFDRCxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7UUFDdEIsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO0lBQ2QsQ0FBQztJQUdELHNCQUFJLG1EQUFtQjtRQUR2Qix5Q0FBeUM7YUFDekM7WUFDRSxPQUFPLElBQUksQ0FBQyxvQkFBb0IsSUFBSSxFQUFFLENBQUM7UUFDekMsQ0FBQzs7O09BQUE7SUFHRCxzQkFBSSxnREFBZ0I7UUFEcEIseUJBQXlCO2FBQ3pCO1lBQ0UsT0FBTyxJQUFJLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsb0JBQW9CLElBQUksSUFBSSxD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QUUsQ0FBQyxDQUFDO2FBQ2pFO1FBQ0gsQ0FBQyxDQUFDLENBQUM7UUFFSCxVQUFVLENBQUMsY0FBTSxPQUFBLEtBQUksQ0FBQyxLQUFLLEVBQUUsRUFBWixDQUFZLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUNILHlCQUFDO0FBQUQsQ0FBQyxBQTVZRCxJQTRZQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIERPTVB1cmlmeV8gZnJvbSAnZG9tcHVyaWZ5JztcclxuY29uc3QgRE9NUHVyaWZ5ID0gRE9NUHVyaWZ5XzsgLy8gcGF0Y2ggdG8gZml4IHJvbGx1cCB0byB3b3JrXHJcblxyXG5pbXBvcnQge1xyXG4gIEF1dG9jb21wbGV0ZU9wdGlvbixcclxuICBDb2xsZWN0aW9uQ3VzdG9tU3RydWN0dXJlLFxyXG4gIENvbHVtbixcclxuICBDb2x1bW5FZGl0b3IsXHJcbiAgRWRpdG9yLFxyXG4gIEVkaXRvckFyZ3VtZW50cyxcclxuICBFZGl0b3JWYWxpZGF0b3IsXHJcbiAgRWRpdG9yVmFsaWRhdG9yT3V0cHV0LFxyXG4gIEZpZWxkVHlwZSxcclxuICBHcmlkT3B0aW9uLFxyXG4gIEtleUNvZGUsXHJcbn0gZnJvbSAnLi8uLi9tb2RlbHMvaW5kZXgnO1xyXG5pbXBvcnQgeyBmaW5kT3JEZWZhdWx0LCBnZXREZXNjZW5kYW50UHJvcGVydHksIHNldERlZXBWYWx1ZSwgdG9LZWJhYkNhc2UgfSBmcm9tICcuLi9zZXJ2aWNlcy91dGlsaXRpZXMnO1xyXG5pbXBvcnQgeyB0ZXh0VmFsaWRhdG9yIH0gZnJvbSAnLi4vZWRpdG9yVmFsaWRhdG9ycy90ZXh0VmFsaWRhdG9yJztcclxuXHJcbi8vIHVzaW5nIGV4dGVybmFsIG5vbi10eXBlZCBqcyBsaWJyYXJpZXNcclxuZGVjbGFyZSBjb25zdCAkOiBhbnk7XHJcblxyXG4vLyBtaW5pbXVtIGxlbmd0aCBvZiBjaGFycyB0byB0eXBlIGJlZm9yZSBzdGFydGluZyB0byBzdGFydCBxdWVyeWluZ1xyXG5jb25zdCBNSU5fTEVOR1RIID0gMztcclxuXHJcbi8qXHJcbiAqIEFuIGV4YW1wbGUgb2YgYSAnZGV0YWNoZWQnIGVkaXRvci5cclxuICogS2V5RG93biBldmVudHMgYXJlIGFsc28gaGFuZGxlZCB0byBwcm92aWRlIGhhbmRsaW5nIGZvciBUYWIsIFNoaWZ0LVRhYiwgRXNjIGFuZCBDdHJsLUVudGVyLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEF1dG9Db21wbGV0ZUVkaXRvciBpbXBsZW1lbnRzIEVkaXRvciB7XHJcbiAgcHJpdmF0ZSBfYXV0b0NvbXBsZXRlT3B0aW9uczogQXV0b2NvbXBsZXRlT3B0aW9uO1xyXG4gIHByaXZhdGUgX2N1cnJlbnRWYWx1ZTogYW55O1xyXG4gIHByaXZhdGUgX2RlZmF1bHRUZXh0VmFsdWU6IHN0cmluZztcclxuICBwcml2YXRlIF9lbGVtZW50Q29sbGVjdGlvbjogYW55W10gfCBudWxsO1xyXG4gIHByaXZhdGUgX2xhc3RJbnB1dEV2ZW50OiBKUXVlcnkuRXZlbnQ7XHJcblxyXG4gIC8qKiBUaGUgSlF1ZXJ5IERPTSBlbGVtZW50ICovXHJcbiAgcHJpdmF0ZSBfJGVkaXRvckVsbTogYW55O1xyXG5cclxuICAvKiogU2xpY2tHcmlkIEdyaWQgb2JqZWN0ICovXHJcbiAgZ3JpZDogYW55O1xyXG5cclxuICAvKiogVGhlIHByb3BlcnR5IG5hbWUgZm9yIGxhYmVscyBpbiB0aGUgY29sbGVjdGlvbiAqL1xyXG4gIGxhYmVsTmFtZTogc3RyaW5nO1xyXG5cclxuICAvKiogVGhlIHByb3BlcnR5IG5hbWUgZm9yIGEgcHJlZml4IHRoYXQgY2FuIGJlIGFkZGVkIHRvIHRoZSBsYWJlbHMgaW4gdGhlIGNvbGxlY3Rpb24gKi9cclxuICBsYWJlbFByZWZpeE5hbWU6IHN0cmluZztcclxuXHJcbiAgLyoqIFRoZSBwcm9wZXJ0eSBuYW1lIGZvciBhIHN1ZmZpeCB0aGF0IGNhbiBiZSBhZGRlZCB0byB0aGUgbGFiZWxzIGluIHRoZSBjb2xsZWN0aW9uICovXHJcbiAgbGFiZWxTdWZmaXhOYW1lOiBzdHJpbmc7XHJcblxyXG4gIC8qKiBUaGUgcHJvcGVydHkgbmFtZSBmb3IgdmFsdWVzIGluIHRoZSBjb2xsZWN0aW9uICovXHJcbiAgdmFsdWVOYW1lOiBzdHJpbmc7XHJcblxyXG4gIGZvcmNlVXNlcklucHV0OiBib29sZWFuO1xyXG5cclxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGFyZ3M6IEVkaXRvckFyZ3VtZW50cykge1xyXG4gICAgaWYgKCFhcmdzKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignW0FuZ3VsYXItU2xpY2tHcmlkXSBTb21ldGhpbmcgaXMgd3Jvbmcgd2l0aCB0aGlzIGdyaWQsIGFuIEVkaXRvciBtdXN0IGFsd2F5cyBoYXZlIHZhbGlkIGFyZ3VtZW50cy4nKTtcclxuICAgIH1cclxuICAgIHRoaXMuZ3JpZCA9IGFyZ3MuZ3JpZDtcclxuICAgIHRoaXMuaW5pdCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldHRlciBmb3IgdGhlIEF1dG9jb21wbGV0ZSBPcHRpb24gKi9cclxuICBnZXQgYXV0b0NvbXBsZXRlT3B0aW9ucygpOiBQYXJ0aWFsPEF1dG9jb21wbGV0ZU9wdGlvbj4ge1xyXG4gICAgcmV0dXJuIHRoaXMuX2F1dG9Db21wbGV0ZU9wdGlvbnMgfHwge307XHJcbiAgfVxyXG5cclxuICAvKiogR2V0IHRoZSBDb2xsZWN0aW9uICovXHJcbiAgZ2V0IGVkaXRvckNvbGxlY3Rpb24oKTogYW55W10ge1xyXG4gICAgcmV0dXJuIHRoaXMuY29sdW1uRGVmICYmIHRoaXMuY29sdW1uRGVmLmludGVybmFsQ29sdW1uRWRpdG9yICYmIHRoaXMuY29sdW1uRGVmLmludGVybmFsQ29sdW1uRWRpdG9yLmNvbGxlY3Rpb24gfHwgW107XHJcbiAgfVxyXG5cclxuICAvKiogR2V0IHRoZSBGaW5hbCBDb2xsZWN0aW9uIHVzZWQgaW4gdGhlIEF1dG9Db21wbGV0ZWQgU291cmNlICh0aGlzIG1heSB2YXJ5IGZyb20gdGhlIFwiY29sbGVjdGlvblwiIGVzcGVjaWFsbHkgd2hlbiBwcm92aWRpbmcgYSBjdXN0b21TdHJ1Y3R1cmUpICovXHJcbiAgZ2V0IGVsZW1lbnRDb2xsZWN0aW9uKCk6IGFueVtdIHwgbnVsbCB7XHJcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudENvbGxlY3Rpb247XHJcbiAgfVxyXG5cclxuICAvKiogR2V0IENvbHVtbiBEZWZpbml0aW9uIG9iamVjdCAqL1xyXG4gIGdldCBjb2x1bW5EZWYoKTogQ29sdW1uIHwgdW5kZWZpbmVkIHtcclxuICAgIHJldHVybiB0aGlzLmFyZ3MgJiYgdGhpcy5hcmdzLmNvbHVtbjtcclxuICB9XHJcblxyXG4gIC8qKiBHZXQgQ29sdW1uIEVkaXRvciBvYmplY3QgKi9cclxuICBnZXQgY29sdW1uRWRpdG9yKCk6IENvbHVtbkVkaXRvciB7XHJcbiAgICByZXR1cm4gdGhpcy5jb2x1bW5EZWYgJiYgdGhpcy5jb2x1bW5EZWYuaW50ZXJuYWxDb2x1bW5FZGl0b3IgfHwge307XHJcbiAgfVxyXG5cclxuICAvKiogR2V0dGVyIGZvciB0aGUgQ3VzdG9tIFN0cnVjdHVyZSBpZiBleGlzdCAqL1xyXG4gIGdldCBjdXN0b21TdHJ1Y3R1cmUoKTogQ29sbGVjdGlvbkN1c3RvbVN0cnVjdHVyZSB7XHJcbiAgICBsZXQgY3VzdG9tU3RydWN0dXJlID0gdGhpcy5jb2x1bW5FZGl0b3IgJiYgdGhpcy5jb2x1bW5FZGl0b3IuY3VzdG9tU3RydWN0dXJlO1xyXG4gICAgY29uc3QgY29sdW1uVHlwZSA9IHRoaXMuY29sdW1uRWRpdG9yICYmIHRoaXMuY29sdW1uRWRpdG9yLnR5cGUgfHwgdGhpcy5jb2x1bW5EZWYgJiYgdGhpcy5jb2x1bW5EZWYudHlwZTtcclxuICAgIGlmICghY3VzdG9tU3RydWN0dXJlICYmIChjb2x1bW5UeXBlID09PSBGaWVsZFR5cGUub2JqZWN0ICYmIHRoaXMuY29sdW1uRGVmICYmIHRoaXMuY29sdW1uRGVmLmRhdGFLZXkgJiYgdGhpcy5jb2x1bW5EZWYubGFiZWxLZXkpKSB7XHJcbiAgICAgIGN1c3RvbVN0cnVjdHVyZSA9IHtcclxuICAgICAgICBsYWJlbDogdGhpcy5jb2x1bW5EZWYubGFiZWxLZXksXHJcbiAgICAgICAgdmFsdWU6IHRoaXMuY29sdW1uRGVmLmRhdGFLZXksXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3VzdG9tU3RydWN0dXJlO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGhhc0F1dG9Db21taXRFZGl0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ3JpZE9wdGlvbnMuYXV0b0NvbW1pdEVkaXQ7XHJcbiAgfVxyXG5cclxuICAvKiogR2V0IHRoZSBWYWxpZGF0b3IgZnVuY3Rpb24sIGNhbiBiZSBwYXNzZWQgaW4gRWRpdG9yIHByb3BlcnR5IG9yIENvbHVtbiBEZWZpbml0aW9uICovXHJcbiAgZ2V0IHZhbGlkYXRvcigpOiBFZGl0b3JWYWxpZGF0b3Ige1xyXG4gICAgcmV0dXJuIHRoaXMuY29sdW1uRWRpdG9yLnZhbGlkYXRvciB8fCB0aGlzLmNvbHVtbkRlZi52YWxpZGF0b3I7XHJcbiAgfVxyXG5cclxuICBnZXQgZWRpdG9yT3B0aW9ucygpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbHVtbkVkaXRvciAmJiB0aGlzLmNvbHVtbkVkaXRvci5lZGl0b3JPcHRpb25zIHx8IHt9O1xyXG4gIH1cclxuXHJcbiAgLyoqIGpRdWVyeSBVSSBBdXRvQ29tcGxldGUgaW5zdGFuY2UgKi9cclxuICBnZXQgaW5zdGFuY2UoKTogYW55IHtcclxuICAgIHJldHVybiB0aGlzLl8kZWRpdG9yRWxtLmF1dG9jb21wbGV0ZSgnaW5zdGFuY2UnKTtcclxuICB9XHJcblxyXG4gIC8qKiBHZXR0ZXIgZm9yIHRoZSBHcmlkIE9wdGlvbnMgcHVsbGVkIHRocm91Z2ggdGhlIEdyaWQgT2JqZWN0ICovXHJcbiAgZ2V0IGdyaWRPcHRpb25zKCk6IEdyaWRPcHRpb24ge1xyXG4gICAgcmV0dXJuICh0aGlzLmdyaWQgJiYgdGhpcy5ncmlkLmdldE9wdGlvbnMpID8gdGhpcy5ncmlkLmdldE9wdGlvbnMoKSA6IHt9O1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldCB0aGUgRWRpdG9yIERPTSBFbGVtZW50ICovXHJcbiAgZ2V0IGVkaXRvckRvbUVsZW1lbnQoKTogYW55IHtcclxuICAgIHJldHVybiB0aGlzLl8kZWRpdG9yRWxtO1xyXG4gIH1cclxuXHJcbiAgaW5pdCgpIHtcclxuICAgIHRoaXMubGFiZWxOYW1lID0gdGhpcy5jdXN0b21TdHJ1Y3R1cmUgJiYgdGhpcy5jdXN0b21TdHJ1Y3R1cmUubGFiZWwgfHwgJ2xhYmVsJztcclxuICAgIHRoaXMudmFsdWVOYW1lID0gdGhpcy5jdXN0b21TdHJ1Y3R1cmUgJiYgdGhpcy5jdXN0b21TdHJ1Y3R1cmUudmFsdWUgfHwgJ3ZhbHVlJztcclxuICAgIHRoaXMubGFiZWxQcmVmaXhOYW1lID0gdGhpcy5jdXN0b21TdHJ1Y3R1cmUgJiYgdGhpcy5jdXN0b21TdHJ1Y3R1cmUubGFiZWxQcmVmaXggfHwgJ2xhYmVsUHJlZml4JztcclxuICAgIHRoaXMubGFiZWxTdWZmaXhOYW1lID0gdGhpcy5jdXN0b21TdHJ1Y3R1cmUgJiYgdGhpcy5jdXN0b21TdHJ1Y3R1cmUubGFiZWxTdWZmaXggfHwgJ2xhYmVsU3VmZml4JztcclxuXHJcbiAgICAvLyBhbHdheXMgcmVuZGVyIHRoZSBET00gZWxlbWVudCwgZXZlbiBpZiB1c2VyIHBhc3NlZCBhIFwiY29sbGVjdGlvbkFzeW5jXCIsXHJcbiAgICBjb25zdCBuZXdDb2xsZWN0aW9uID0gdGhpcy5jb2x1bW5FZGl0b3IuY29sbGVjdGlvbiB8fCBbXTtcclxuICAgIHRoaXMucmVuZGVyRG9tRWxlbWVudChuZXdDb2xsZWN0aW9uKTtcclxuICB9XHJcblxyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICBpZiAodGhpcy5fJGVkaXRvckVsbSkge1xyXG4gICAgICB0aGlzLl8kZWRpdG9yRWxtLmF1dG9jb21wbGV0ZSgnZGVzdHJveScpO1xyXG4gICAgICB0aGlzLl8kZWRpdG9yRWxtLm9mZigna2V5ZG93bi5uYXYnKS5yZW1vdmUoKTtcclxuICAgIH1cclxuICAgIHRoaXMuXyRlZGl0b3JFbG0gPSBudWxsO1xyXG4gICAgdGhpcy5fZWxlbWVudENvbGxlY3Rpb24gPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgZm9jdXMoKSB7XHJcbiAgICBpZiAodGhpcy5fJGVkaXRvckVsbSkge1xyXG4gICAgICB0aGlzLl8kZWRpdG9yRWxtLmZvY3VzKCkuc2VsZWN0KCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBnZXRWYWx1ZSgpIHtcclxuICAgIHJldHVybiB0aGlzLl8kZWRpdG9yRWxtLnZhbCgpO1xyXG4gIH1cclxuXHJcbiAgc2V0VmFsdWUodmFsdWU6IHN0cmluZykge1xyXG4gICAgdGhpcy5fJGVkaXRvckVsbS52YWwodmFsdWUpO1xyXG4gIH1cclxuXHJcbiAgYXBwbHlWYWx1ZShpdGVtOiBhbnksIHN0YXRlOiBhbnkpIHtcclxuICAgIGxldCBuZXdWYWx1ZSA9IHN0YXRlO1xyXG4gICAgY29uc3QgZmllbGROYW1lID0gdGhpcy5jb2x1bW5EZWYgJiYgdGhpcy5jb2x1bW5EZWYuZmllbGQ7XHJcblxyXG4gICAgLy8gaWYgd2UgaGF2ZSBhIGNvbGxlY3Rpb24gZGVmaW5lZCwgd2Ugd2lsbCB0cnkgdG8gZmluZCB0aGUgc3RyaW5nIHdpdGhpbiB0aGUgY29sbGVjdGlvbiBhbmQgcmV0dXJuIGl0XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmVkaXRvckNvbGxlY3Rpb24pICYmIHRoaXMuZWRpdG9yQ29sbGVjdGlvbi5sZW5ndGggPiAwKSB7XHJcbiAgICAgIG5ld1ZhbHVlID0gZmluZE9yRGVmYXVsdCh0aGlzLmVkaXRvckNvbGxlY3Rpb24sIChjb2xsZWN0aW9uSXRlbTogYW55KSA9PiB7XHJcbiAgICAgICAgaWYgKGNvbGxlY3Rpb25JdGVtICYmIHR5cGVvZiBzdGF0ZSA9PT0gJ29iamVjdCcgJiYgY29sbGVjdGlvbkl0ZW0uaGFzT3duUHJvcGVydHkodGhpcy5sYWJlbE5hbWUpKSB7XHJcbiAgICAgICAgICByZXR1cm4gKGNvbGxlY3Rpb25JdGVtLmhhc093blByb3BlcnR5KHRoaXMubGFiZWxOYW1lKSAmJiBjb2xsZWN0aW9uSXRlbVt0aGlzLmxhYmVsTmFtZV0udG9TdHJpbmcoKSkgPT09IChzdGF0ZS5oYXNPd25Qcm9wZXJ0eSh0aGlzLmxhYmVsTmFtZSkgJiYgc3RhdGVbdGhpcy5sYWJlbE5hbWVdLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY29sbGVjdGlvbkl0ZW0gJiYgdHlwZW9mIHN0YXRlID09PSAnc3RyaW5nJyAmJiBjb2xsZWN0aW9uSXRlbS5oYXNPd25Qcm9wZXJ0eSh0aGlzLmxhYmVsTmFtZSkpIHtcclxuICAgICAgICAgIHJldHVybiAoY29sbGVjdGlvbkl0ZW0uaGFzT3duUHJvcGVydHkodGhpcy5sYWJlbE5hbWUpICYmIGNvbGxlY3Rpb25JdGVtW3RoaXMubGFiZWxOYW1lXS50b1N0cmluZygpKSA9PT0gc3RhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uSXRlbSAmJiBjb2xsZWN0aW9uSXRlbS50b1N0cmluZygpID09PSBzdGF0ZTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaXMgdGhlIGZpZWxkIGEgY29tcGxleCBvYmplY3QsIFwiYWRkcmVzcy5zdHJlZXROdW1iZXJcIlxyXG4gICAgY29uc3QgaXNDb21wbGV4T2JqZWN0ID0gZmllbGROYW1lICYmIGZpZWxkTmFtZS5pbmRleE9mKCcuJykgPiAwO1xyXG5cclxuICAgIC8vIHZhbGlkYXRlIHRoZSB2YWx1ZSBiZWZvcmUgYXBwbHlpbmcgaXQgKGlmIG5vdCB2YWxpZCB3ZSdsbCBzZXQgYW4gZW1wdHkgc3RyaW5nKVxyXG4gICAgY29uc3QgdmFsaWRhdGlvbiA9IHRoaXMudmFsaWRhdGUobmV3VmFsdWUpO1xyXG4gICAgbmV3VmFsdWUgPSAodmFsaWRhdGlvbiAmJiB2YWxpZGF0aW9uLnZhbGlkKSA/IG5ld1ZhbHVlIDogJyc7XHJcblxyXG4gICAgLy8gc2V0IHRoZSBuZXcgdmFsdWUgdG8gdGhlIGl0ZW0gZGF0YWNvbnRleHRcclxuICAgIGlmIChpc0NvbXBsZXhPYmplY3QpIHtcclxuICAgICAgc2V0RGVlcFZhbHVlKGl0ZW0sIGZpZWxkTmFtZSwgbmV3VmFsdWUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaXRlbVtmaWVsZE5hbWVdID0gbmV3VmFsdWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpc1ZhbHVlQ2hhbmdlZCgpOiBib29sZWFuIHtcclxuICAgIGNvbnN0IGVsbVZhbHVlID0gdGhpcy5fJGVkaXRvckVsbS52YWwoKTtcclxuICAgIGNvbnN0IGxhc3RLZXlFdmVudCA9IHRoaXMuX2xhc3RJbnB1dEV2ZW50ICYmIHRoaXMuX2xhc3RJbnB1dEV2ZW50LmtleUNvZGU7XHJcbiAgICBpZiAodGhpcy5jb2x1bW5FZGl0b3IgJiYgdGhpcy5jb2x1bW5FZGl0b3IuYWx3YXlzU2F2ZU9uRW50ZXJLZXkgJiYgbGFzdEtleUV2ZW50ID09PSBLZXlDb2RlLkVOVEVSKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICghKGVsbVZhbHVlID09PSAnJyAmJiAodGhpcy5fZGVmYXVsdFRleHRWYWx1ZSA9PT0gbnVsbCB8fCB0aGlzLl9kZWZhdWx0VGV4dFZhbHVlID09PSB1bmRlZmluZWQpKSkgJiYgKGVsbVZhbHVlICE9PSB0aGlzLl9kZWZhdWx0VGV4dFZhbHVlKTtcclxuICB9XHJcblxyXG4gIGxvYWRWYWx1ZShpdGVtOiBhbnkpIHtcclxuICAgIGNvbnN0IGZpZWxkTmFtZSA9IHRoaXMuY29sdW1uRGVmICYmIHRoaXMuY29sdW1uRGVmLmZpZWxkO1xyXG5cclxuICAgIGlmIChpdGVtICYmIGZpZWxkTmFtZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIC8vIGlzIHRoZSBmaWVsZCBhIGNvbXBsZXggb2JqZWN0LCBcImFkZHJlc3Muc3RyZWV0TnVtYmVyXCJcclxuICAgICAgY29uc3QgaXNDb21wbGV4T2JqZWN0ID0gZmllbGROYW1lICYmIGZpZWxkTmFtZS5pbmRleE9mKCcuJykgPiAwO1xyXG4gICAgICBjb25zdCBkYXRhID0gKGlzQ29tcGxleE9iamVjdCkgPyBnZXREZXNjZW5kYW50UHJvcGVydHkoaXRlbSwgZmllbGROYW1lKSA6IGl0ZW1bZmllbGROYW1lXTtcclxuXHJcbiAgICAgIHRoaXMuX2N1cnJlbnRWYWx1ZSA9IGRhdGE7XHJcbiAgICAgIHRoaXMuX2RlZmF1bHRUZXh0VmFsdWUgPSB0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgPyBkYXRhIDogKGRhdGEgJiYgZGF0YS5oYXNPd25Qcm9wZXJ0eSh0aGlzLmxhYmVsTmFtZSkgJiYgZGF0YVt0aGlzLmxhYmVsTmFtZV0gfHwgJycpO1xyXG4gICAgICB0aGlzLl8kZWRpdG9yRWxtLnZhbCh0aGlzLl9kZWZhdWx0VGV4dFZhbHVlKTtcclxuICAgICAgdGhpcy5fJGVkaXRvckVsbS5zZWxlY3QoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNhdmUoKSB7XHJcbiAgICBjb25zdCB2YWxpZGF0aW9uID0gdGhpcy52YWxpZGF0ZSgpO1xyXG4gICAgY29uc3QgaXNWYWxpZCA9ICh2YWxpZGF0aW9uICYmIHZhbGlkYXRpb24udmFsaWQpIHx8IGZhbHNlO1xyXG5cclxuICAgIGlmICh0aGlzLmhhc0F1dG9Db21taXRFZGl0ICYmIGlzVmFsaWQpIHtcclxuICAgICAgLy8gZG8gbm90IHVzZSBhcmdzLmNvbW1pdENoYW5nZXMoKSBhcyB0aGlzIHNldHMgdGhlIGZvY3VzIHRvIHRoZSBuZXh0IHJvdy5cclxuICAgICAgLy8gYWxzbyB0aGUgc2VsZWN0IGxpc3Qgd2lsbCBzdGF5IHNob3duIHdoZW4gY2xpY2tpbmcgb2ZmIHRoZSBncmlkXHJcbiAgICAgIHRoaXMuZ3JpZC5nZXRFZGl0b3JMb2NrKCkuY29tbWl0Q3VycmVudEVkaXQoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuYXJncy5jb21taXRDaGFuZ2VzKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzZXJpYWxpemVWYWx1ZSgpOiBhbnkge1xyXG4gICAgLy8gaWYgeW91IHdhbnQgdG8gYWRkIHRoZSBhdXRvY29tcGxldGUgZnVuY3Rpb25hbGl0eSBidXQgd2FudCB0aGUgdXNlciB0byBiZSBhYmxlIHRvIGlucHV0IGEgbmV3IG9wdGlvblxyXG4gICAgaWYgKHRoaXMuZWRpdG9yT3B0aW9ucy5mb3JjZVVzZXJJbnB1dCkge1xyXG4gICAgICBjb25zdCBtaW5MZW5ndGggPSB0aGlzLmVkaXRvck9wdGlvbnMgJiYgdGhpcy5lZGl0b3JPcHRpb25zLmhhc093blByb3BlcnR5KCdtaW5MZW5ndGgnKSA/IHRoaXMuZWRpdG9yT3B0aW9ucy5taW5MZW5ndGggOiBNSU5fTEVOR1RIO1xyXG4gICAgICB0aGlzLl9jdXJyZW50VmFsdWUgPSB0aGlzLl8kZWRpdG9yRWxtLnZhbCgpLmxlbmd0aCA+IG1pbkxlbmd0aCA/IHRoaXMuXyRlZGl0b3JFbG0udmFsKCkgOiB0aGlzLl9jdXJyZW50VmFsdWU7XHJcbiAgICB9XHJcbiAgICAvLyBpZiB1c2VyIHByb3ZpZGVkIGEgY3VzdG9tIHN0cnVjdHVyZSwgd2Ugd2lsbCBzZXJpYWxpemUgdGhlIHZhbHVlIHJldHVybmVkIGZyb20gdGhlIG9iamVjdCB3aXRoIGN1c3RvbSBzdHJ1Y3R1cmVcclxuICAgIGlmICh0aGlzLmN1c3RvbVN0cnVjdHVyZSAmJiB0aGlzLl9jdXJyZW50VmFsdWUgJiYgdGhpcy5fY3VycmVudFZhbHVlLmhhc093blByb3BlcnR5KHRoaXMudmFsdWVOYW1lKSAmJiAodGhpcy5jb2x1bW5EZWYgJiYgdGhpcy5jb2x1bW5EZWYudHlwZSAhPT0gRmllbGRUeXBlLm9iamVjdCAmJiB0aGlzLmNvbHVtbkVkaXRvciAmJiB0aGlzLmNvbHVtbkVkaXRvci50eXBlICE9PSBGaWVsZFR5cGUub2JqZWN0KSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5fY3VycmVudFZhbHVlW3RoaXMudmFsdWVOYW1lXTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5fY3VycmVudFZhbHVlICYmIHRoaXMuX2N1cnJlbnRWYWx1ZS52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIC8vIHdoZW4gb2JqZWN0IGhhcyBhIFwidmFsdWVcIiBwcm9wZXJ0eSBhbmQgaXRzIGNvbHVtbiBpcyBzZXQgYXMgYW4gT2JqZWN0IHR5cGUsIHdlJ2xsIHJldHVybiBhbiBvYmplY3Qgd2l0aCBvcHRpb25hbCBjdXN0b20gc3RydWN0dXJlXHJcbiAgICAgIGlmICh0aGlzLmNvbHVtbkRlZiAmJiB0aGlzLmNvbHVtbkRlZi50eXBlID09PSBGaWVsZFR5cGUub2JqZWN0IHx8ICgodGhpcy5jb2x1bW5FZGl0b3IgJiYgdGhpcy5jb2x1bW5FZGl0b3IudHlwZSkgPT09IEZpZWxkVHlwZS5vYmplY3QpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIFt0aGlzLmxhYmVsTmFtZV06IHRoaXMuX2N1cnJlbnRWYWx1ZS5sYWJlbCxcclxuICAgICAgICAgIFt0aGlzLnZhbHVlTmFtZV06IHRoaXMuX2N1cnJlbnRWYWx1ZS52YWx1ZVxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRWYWx1ZS52YWx1ZTtcclxuICAgIH1cclxuICAgIC8vIGlmIGl0IGZhbGxzIGhlcmUgaXQgbWlnaHQgYmUgdGhhdCB0aGUgdXNlciBwcm92aWRlZCBpdHMgb3duIGN1c3RvbSBpdGVtIHdpdGggc29tZXRoaW5nIGVsc2UgdGhhbiB0aGUgcmVndWxhciBsYWJlbC92YWx1ZSBwYWlyXHJcbiAgICAvLyBhdCB0aGlzIHBvaW50IGl0J3Mgb25seSBhdmFpbGFibGUgd2hlbiB1c2VyIHByb3ZpZGUgYSBjdXN0b20gdGVtcGxhdGUgZm9yIHRoZSBhdXRvY29tcGxldGUgcmVuZGVySXRlbSBjYWxsYmFja1xyXG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRWYWx1ZTtcclxuICB9XHJcblxyXG4gIHZhbGlkYXRlKGlucHV0VmFsdWU/OiBhbnkpOiBFZGl0b3JWYWxpZGF0b3JPdXRwdXQge1xyXG4gICAgY29uc3QgdmFsID0gKGlucHV0VmFsdWUgIT09IHVuZGVmaW5lZCkgPyBpbnB1dFZhbHVlIDogdGhpcy5fJGVkaXRvckVsbSAmJiB0aGlzLl8kZWRpdG9yRWxtLnZhbCAmJiB0aGlzLl8kZWRpdG9yRWxtLnZhbCgpO1xyXG4gICAgcmV0dXJuIHRleHRWYWxpZGF0b3IodmFsLCB7XHJcbiAgICAgIGVkaXRvckFyZ3M6IHRoaXMuYXJncyxcclxuICAgICAgZXJyb3JNZXNzYWdlOiB0aGlzLmNvbHVtbkVkaXRvci5lcnJvck1lc3NhZ2UsXHJcbiAgICAgIG1pbkxlbmd0aDogdGhpcy5jb2x1bW5FZGl0b3IubWluTGVuZ3RoLFxyXG4gICAgICBtYXhMZW5ndGg6IHRoaXMuY29sdW1uRWRpdG9yLm1heExlbmd0aCxcclxuICAgICAgb3BlcmF0b3JDb25kaXRpb25hbFR5cGU6IHRoaXMuY29sdW1uRWRpdG9yLm9wZXJhdG9yQ29uZGl0aW9uYWxUeXBlLFxyXG4gICAgICByZXF1aXJlZDogdGhpcy5jb2x1bW5FZGl0b3IucmVxdWlyZWQsXHJcbiAgICAgIHZhbGlkYXRvcjogdGhpcy52YWxpZGF0b3IsXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vXHJcbiAgLy8gcHJpdmF0ZSBmdW5jdGlvbnNcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgLy8gdGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgUFJJVkFURSBidXQgZm9yIHVuaXQgdGVzdHMgcHVycG9zZXMgd2UnbGwgbWFrZSBpdCBwdWJsaWMgdW50aWwgYSBiZXR0ZXIgc29sdXRpb24gaXMgZm91bmRcclxuICAvLyBhIGJldHRlciBzb2x1dGlvbiB3b3VsZCBiZSB0byBnZXQgdGhlIGF1dG9jb21wbGV0ZSBET00gZWxlbWVudCB0byB3b3JrIHdpdGggc2VsZWN0aW9uIGJ1dCBJIGNvdWxkbid0IGZpbmQgaG93IHRvIGRvIHRoYXQgaW4gSmVzdFxyXG4gIG9uU2VsZWN0KF9ldmVudDogRXZlbnQsIHVpOiB7IGl0ZW06IGFueTsgfSkge1xyXG4gICAgaWYgKHVpICYmIHVpLml0ZW0pIHtcclxuICAgICAgY29uc3QgaXRlbSA9IHVpICYmIHVpLml0ZW07XHJcbiAgICAgIHRoaXMuX2N1cnJlbnRWYWx1ZSA9IGl0ZW07XHJcbiAgICAgIC8vIHdoZW4gdGhlIHVzZXIgZGVmaW5lcyBhIFwicmVuZGVySXRlbVwiIChvciBcIl9yZW5kZXJJdGVtXCIpIHRlbXBsYXRlLCB0aGVuIHdlIGFzc3VtZSB0aGUgdXNlciBkZWZpbmVzIGhpcyBvd24gY3VzdG9tIHN0cnVjdHVyZSBvZiBsYWJlbC92YWx1ZSBwYWlyXHJcbiAgICAgIC8vIG90aGVyd2lzZSB3ZSBrbm93IHRoYXQgalF1ZXJ5VUkgYWx3YXlzIHJlcXVpcmUgYSBsYWJlbC92YWx1ZSBwYWlyLCB3ZSBjYW4gcHVsbCB0aGVtIGRpcmVjdGx5XHJcbiAgICAgIGNvbnN0IGhhc0N1c3RvbVJlbmRlckl0ZW1DYWxsYmFjayA9IHRoaXMuY29sdW1uRWRpdG9yICYmIHRoaXMuY29sdW1uRWRpdG9yLmNhbGxiYWNrcyAmJiB0aGlzLmNvbHVtbkVkaXRvci5jYWxsYmFja3MuaGFzT3duUHJvcGVydHkoJ19yZW5kZXJJdGVtJykgfHwgKHRoaXMuY29sdW1uRWRpdG9yICYmIHRoaXMuY29sdW1uRWRpdG9yLmVkaXRvck9wdGlvbnMgJiYgdGhpcy5jb2x1bW5FZGl0b3IuZWRpdG9yT3B0aW9ucy5yZW5kZXJJdGVtKSB8fCBmYWxzZTtcclxuXHJcbiAgICAgIGNvbnN0IGl0ZW1MYWJlbCA9IHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJyA/IGl0ZW0gOiAoaGFzQ3VzdG9tUmVuZGVySXRlbUNhbGxiYWNrID8gaXRlbVt0aGlzLmxhYmVsTmFtZV0gOiBpdGVtLmxhYmVsKTtcclxuICAgICAgdGhpcy5zZXRWYWx1ZShpdGVtTGFiZWwpO1xyXG4gICAgICB0aGlzLnNhdmUoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgcmVuZGVyQ3VzdG9tSXRlbSh1bDogSFRNTEVsZW1lbnQsIGl0ZW06IGFueSkge1xyXG4gICAgY29uc3QgdGVtcGxhdGVTdHJpbmcgPSB0aGlzLl9hdXRvQ29tcGxldGVPcHRpb25zICYmIHRoaXMuX2F1dG9Db21wbGV0ZU9wdGlvbnMucmVuZGVySXRlbSAmJiB0aGlzLl9hdXRvQ29tcGxldGVPcHRpb25zLnJlbmRlckl0ZW0udGVtcGxhdGVDYWxsYmFjayhpdGVtKSB8fCAnJztcclxuXHJcbiAgICAvLyBzYW5pdGl6ZSBhbnkgdW5hdXRob3JpemVkIGh0bWwgdGFncyBsaWtlIHNjcmlwdCBhbmQgb3RoZXJzXHJcbiAgICAvLyBmb3IgdGhlIHJlbWFpbmluZyBhbGxvd2VkIHRhZ3Mgd2UnbGwgcGVybWl0IGFsbCBhdHRyaWJ1dGVzXHJcbiAgICBjb25zdCBzYW5pdGl6ZWRUZW1wbGF0ZVRleHQgPSAoRE9NUHVyaWZ5LnNhbml0aXplKHRlbXBsYXRlU3RyaW5nLCB7fSkgfHwgJycpLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgcmV0dXJuICQoJzxsaT48L2xpPicpXHJcbiAgICAgIC5kYXRhKCdpdGVtLmF1dG9jb21wbGV0ZScsIGl0ZW0pXHJcbiAgICAgIC5hcHBlbmQoc2FuaXRpemVkVGVtcGxhdGVUZXh0KVxyXG4gICAgICAuYXBwZW5kVG8odWwpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSByZW5kZXJDb2xsZWN0aW9uSXRlbSh1bDogSFRNTEVsZW1lbnQsIGl0ZW06IGFueSkge1xyXG4gICAgY29uc3QgaXNSZW5kZXJIdG1sRW5hYmxlZCA9IHRoaXMuY29sdW1uRWRpdG9yICYmIHRoaXMuY29sdW1uRWRpdG9yLmVuYWJsZVJlbmRlckh0bWwgfHwgZmFsc2U7XHJcbiAgICBjb25zdCBwcmVmaXhUZXh0ID0gaXRlbS5sYWJlbFByZWZpeCB8fCAnJztcclxuICAgIGNvbnN0IGxhYmVsVGV4dCA9IGl0ZW0ubGFiZWwgfHwgJyc7XHJcbiAgICBjb25zdCBzdWZmaXhUZXh0ID0gaXRlbS5sYWJlbFN1ZmZpeCB8fCAnJztcclxuICAgIGNvbnN0IGZpbmFsVGV4dCA9IHByZWZpeFRleHQgKyBsYWJlbFRleHQgKyBzdWZmaXhUZXh0O1xyXG5cclxuICAgIC8vIHNhbml0aXplIGFueSB1bmF1dGhvcml6ZWQgaHRtbCB0YWdzIGxpa2Ugc2NyaXB0IGFuZCBvdGhlcnNcclxuICAgIC8vIGZvciB0aGUgcmVtYWluaW5nIGFsbG93ZWQgdGFncyB3ZSdsbCBwZXJtaXQgYWxsIGF0dHJpYnV0ZXNcclxuICAgIGNvbnN0IHNhbml0aXplZFRleHQgPSAoRE9NUHVyaWZ5LnNhbml0aXplKGZpbmFsVGV4dCwge30pIHx8ICcnKS50b1N0cmluZygpO1xyXG5cclxuICAgIGNvbnN0ICRsaURpdiA9ICQoJzxkaXY+PC9kaXY+JylbaXNSZW5kZXJIdG1sRW5hYmxlZCA/ICdodG1sJyA6ICd0ZXh0J10oc2FuaXRpemVkVGV4dCk7XHJcbiAgICByZXR1cm4gJCgnPGxpPjwvbGk+JylcclxuICAgICAgLmRhdGEoJ2l0ZW0uYXV0b2NvbXBsZXRlJywgaXRlbSlcclxuICAgICAgLmFwcGVuZCgkbGlEaXYpXHJcbiAgICAgIC5hcHBlbmRUbyh1bCk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHJlbmRlckRvbUVsZW1lbnQoY29sbGVjdGlvbjogYW55W10pIHtcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShjb2xsZWN0aW9uKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBcImNvbGxlY3Rpb25cIiBwYXNzZWQgdG8gdGhlIEF1dG9jb21wbGV0ZSBFZGl0b3IgaXMgbm90IGEgdmFsaWQgYXJyYXkuJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjb2x1bW5JZCA9IHRoaXMuY29sdW1uRGVmICYmIHRoaXMuY29sdW1uRGVmLmlkIHx8ICcnO1xyXG4gICAgY29uc3QgcGxhY2Vob2xkZXIgPSB0aGlzLmNvbHVtbkVkaXRvciAmJiB0aGlzLmNvbHVtbkVkaXRvci5wbGFjZWhvbGRlciB8fCAnJztcclxuICAgIGNvbnN0IHRpdGxlID0gdGhpcy5jb2x1bW5FZGl0b3IgJiYgdGhpcy5jb2x1bW5FZGl0b3IudGl0bGUgfHwgJyc7XHJcblxyXG4gICAgdGhpcy5fJGVkaXRvckVsbSA9ICQoYDxpbnB1dCB0eXBlPVwidGV4dFwiIHJvbGU9XCJwcmVzZW50YXRpb25cIiBhdXRvY29tcGxldGU9XCJvZmZcIiBjbGFzcz1cImF1dG9jb21wbGV0ZSBlZGl0b3ItdGV4dCBlZGl0b3ItJHtjb2x1bW5JZH1cIiBwbGFjZWhvbGRlcj1cIiR7cGxhY2Vob2xkZXJ9XCIgdGl0bGU9XCIke3RpdGxlfVwiIC8+YClcclxuICAgICAgLmFwcGVuZFRvKHRoaXMuYXJncy5jb250YWluZXIpXHJcbiAgICAgIC5vbigna2V5ZG93bi5uYXYnLCAoZXZlbnQ6IEpRdWVyeS5FdmVudCkgPT4ge1xyXG4gICAgICAgIHRoaXMuX2xhc3RJbnB1dEV2ZW50ID0gZXZlbnQ7XHJcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IEtleUNvZGUuTEVGVCB8fCBldmVudC5rZXlDb2RlID09PSBLZXlDb2RlLlJJR0hUKSB7XHJcbiAgICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIC8vIGFkZCBhIDxzcGFuPiBpbiBvcmRlciB0byBhZGQgc3Bpbm5lciBzdHlsaW5nXHJcbiAgICAkKGA8c3Bhbj48L3NwYW4+YCkuYXBwZW5kVG8odGhpcy5hcmdzLmNvbnRhaW5lcik7XHJcblxyXG4gICAgLy8gdXNlciBtaWdodCBwYXNzIGhpcyBvd24gYXV0b2NvbXBsZXRlIG9wdGlvbnNcclxuICAgIGNvbnN0IGF1dG9Db21wbGV0ZU9wdGlvbnM6IEF1dG9jb21wbGV0ZU9wdGlvbiA9IHRoaXMuY29sdW1uRWRpdG9yLmVkaXRvck9wdGlvbnM7XHJcblxyXG4gICAgLy8gYXNzaWduIHRoZSBjb2xsZWN0aW9uIHRvIGEgdGVtcCB2YXJpYWJsZSBiZWZvcmUgZmlsdGVyaW5nL3NvcnRpbmcgdGhlIGNvbGxlY3Rpb25cclxuICAgIGxldCBmaW5hbENvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xyXG5cclxuICAgIC8vIHVzZXIgbWlnaHQgcHJvdmlkZSBoaXMgb3duIGN1c3RvbSBzdHJ1Y3R1cmVcclxuICAgIC8vIGpRdWVyeSBVSSBhdXRvY29tcGxldGUgcmVxdWlyZXMgYSBsYWJlbC92YWx1ZSBwYWlyLCBzbyB3ZSBtdXN0IHJlbWFwIHRoZW0gd2hlbiB1c2VyIHByb3ZpZGUgZGlmZmVyZW50IG9uZXNcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGZpbmFsQ29sbGVjdGlvbikpIHtcclxuICAgICAgZmluYWxDb2xsZWN0aW9uID0gZmluYWxDb2xsZWN0aW9uLm1hcCgoaXRlbSkgPT4ge1xyXG4gICAgICAgIHJldHVybiB7IGxhYmVsOiBpdGVtW3RoaXMubGFiZWxOYW1lXSwgdmFsdWU6IGl0ZW1bdGhpcy52YWx1ZU5hbWVdLCBsYWJlbFByZWZpeDogaXRlbVt0aGlzLmxhYmVsUHJlZml4TmFtZV0gfHwgJycsIGxhYmVsU3VmZml4OiBpdGVtW3RoaXMubGFiZWxTdWZmaXhOYW1lXSB8fCAnJyB9O1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBrZWVwIHRoZSBmaW5hbCBzb3VyY2UgY29sbGVjdGlvbiB1c2VkIGluIHRoZSBBdXRvQ29tcGxldGUgYXMgcmVmZXJlbmNlXHJcbiAgICB0aGlzLl9lbGVtZW50Q29sbGVjdGlvbiA9IGZpbmFsQ29sbGVjdGlvbjtcclxuXHJcbiAgICAvLyB3aGVuIHVzZXIgcGFzc2VzIGl0J3Mgb3duIGF1dG9jb21wbGV0ZSBvcHRpb25zXHJcbiAgICAvLyB3ZSBzdGlsbCBuZWVkIHRvIHByb3ZpZGUgb3VyIG93biBcInNlbGVjdFwiIGNhbGxiYWNrIGltcGxlbWVudGF0aW9uXHJcbiAgICBpZiAoYXV0b0NvbXBsZXRlT3B0aW9ucyAmJiBhdXRvQ29tcGxldGVPcHRpb25zLnNvdXJjZSkge1xyXG4gICAgICBhdXRvQ29tcGxldGVPcHRpb25zLnNlbGVjdCA9IChldmVudDogRXZlbnQsIHVpOiB7IGl0ZW06IGFueTsgfSkgPT4gdGhpcy5vblNlbGVjdChldmVudCwgdWkpO1xyXG4gICAgICB0aGlzLl9hdXRvQ29tcGxldGVPcHRpb25zID0geyAuLi5hdXRvQ29tcGxldGVPcHRpb25zIH07XHJcblxyXG4gICAgICAvLyB3aGVuIFwicmVuZGVySXRlbVwiIGlzIGRlZmluZWQsIHdlIG5lZWQgdG8gYWRkIG91ciBjdXN0b20gc3R5bGUgQ1NTIGNsYXNzXHJcbiAgICAgIGlmICh0aGlzLl9hdXRvQ29tcGxldGVPcHRpb25zLnJlbmRlckl0ZW0pIHtcclxuICAgICAgICB0aGlzLl9hdXRvQ29tcGxldGVPcHRpb25zLmNsYXNzZXMgPSB7XHJcbiAgICAgICAgICAndWktYXV0b2NvbXBsZXRlJzogYGF1dG9jb21wbGV0ZS1jdXN0b20tJHt0b0tlYmFiQ2FzZSh0aGlzLl9hdXRvQ29tcGxldGVPcHRpb25zLnJlbmRlckl0ZW0ubGF5b3V0KX1gXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgICAvLyBjcmVhdGUgdGhlIGpRdWVyeVVJIEF1dG9Db21wbGV0ZVxyXG4gICAgICB0aGlzLl8kZWRpdG9yRWxtLmF1dG9jb21wbGV0ZSh0aGlzLl9hdXRvQ29tcGxldGVPcHRpb25zKTtcclxuXHJcbiAgICAgIC8vIHdoZW4gXCJyZW5kZXJJdGVtXCIgaXMgZGVmaW5lZCwgd2UgbmVlZCB0byBjYWxsIHRoZSB1c2VyJ3MgY3VzdG9tIHJlbmRlckl0ZW0gdGVtcGxhdGUgY2FsbGJhY2tcclxuICAgICAgaWYgKHRoaXMuX2F1dG9Db21wbGV0ZU9wdGlvbnMucmVuZGVySXRlbSkge1xyXG4gICAgICAgIHRoaXMuXyRlZGl0b3JFbG0uYXV0b2NvbXBsZXRlKCdpbnN0YW5jZScpLl9yZW5kZXJJdGVtID0gdGhpcy5yZW5kZXJDdXN0b21JdGVtLmJpbmQodGhpcyk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0IGRlZmluZWRPcHRpb25zOiBBdXRvY29tcGxldGVPcHRpb24gPSB7XHJcbiAgICAgICAgc291cmNlOiBmaW5hbENvbGxlY3Rpb24sXHJcbiAgICAgICAgbWluTGVuZ3RoOiAwLFxyXG4gICAgICAgIHNlbGVjdDogKGV2ZW50OiBFdmVudCwgdWk6IHsgaXRlbTogYW55OyB9KSA9PiB0aGlzLm9uU2VsZWN0KGV2ZW50LCB1aSksXHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMuX2F1dG9Db21wbGV0ZU9wdGlvbnMgPSB7IC4uLmRlZmluZWRPcHRpb25zLCAuLi4odGhpcy5jb2x1bW5FZGl0b3IuZWRpdG9yT3B0aW9ucyBhcyBBdXRvY29tcGxldGVPcHRpb24pIH07XHJcbiAgICAgIHRoaXMuXyRlZGl0b3JFbG0uYXV0b2NvbXBsZXRlKHRoaXMuX2F1dG9Db21wbGV0ZU9wdGlvbnMpO1xyXG5cclxuICAgICAgLy8gd2UnbGwgdXNlIG91ciBvd24gcmVuZGVyZXIgc28gdGhhdCBpdCB3b3JrcyB3aXRoIGxhYmVsIHByZWZpeC9zdWZmaXggYW5kIGFsc28gd2l0aCBodG1sIHJlbmRlcmluZyB3aGVuIGVuYWJsZWRcclxuICAgICAgdGhpcy5fJGVkaXRvckVsbS5hdXRvY29tcGxldGUoJ2luc3RhbmNlJykuX3JlbmRlckl0ZW0gPSB0aGlzLnJlbmRlckNvbGxlY3Rpb25JdGVtLmJpbmQodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaW4gY2FzZSB0aGUgdXNlciB3YW50cyB0byBzYXZlIGV2ZW4gYW4gZW1wdHkgdmFsdWUsXHJcbiAgICAvLyB3ZSBuZWVkIHRvIHN1YnNjcmliZSB0byB0aGUgb25LZXlEb3duIGV2ZW50IGZvciB0aGF0IHVzZSBjYXNlIGFuZCBjbGVhciB0aGUgY3VycmVudCB2YWx1ZVxyXG4gICAgaWYgKHRoaXMuY29sdW1uRWRpdG9yLmFsd2F5c1NhdmVPbkVudGVyS2V5KSB7XHJcbiAgICAgIHRoaXMuXyRlZGl0b3JFbG0ua2V5ZG93bigoZXZlbnQ6IEpRdWVyeS5FdmVudCkgPT4ge1xyXG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBLZXlDb2RlLkVOVEVSKSB7XHJcbiAgICAgICAgICB0aGlzLl9jdXJyZW50VmFsdWUgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gd2UgY291bGQgb3B0aW9uYWxseSB0cmlnZ2VyIGEgc2VhcmNoIHdoZW4gY2xpY2tpbmcgb24gdGhlIEF1dG9Db21wbGV0ZVxyXG4gICAgaWYgKHRoaXMuZWRpdG9yT3B0aW9ucy5vcGVuU2VhcmNoTGlzdE9uRm9jdXMpIHtcclxuICAgICAgdGhpcy5fJGVkaXRvckVsbS5jbGljaygoKSA9PiB0aGlzLl8kZWRpdG9yRWxtLmF1dG9jb21wbGV0ZSgnc2VhcmNoJywgdGhpcy5fJGVkaXRvckVsbS52YWwoKSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHVzZXIgbWlnaHQgb3ZlcnJpZGUgYW55IG9mIHRoZSBqUXVlcnlVSSBjYWxsYmFjayBtZXRob2RzXHJcbiAgICBpZiAodGhpcy5jb2x1bW5FZGl0b3IuY2FsbGJhY2tzKSB7XHJcbiAgICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgT2JqZWN0LmtleXModGhpcy5jb2x1bW5FZGl0b3IuY2FsbGJhY2tzKSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5jb2x1bW5FZGl0b3IuY2FsbGJhY2tzW2NhbGxiYWNrXSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgdGhpcy5pbnN0YW5jZVtjYWxsYmFja10gPSB0aGlzLmNvbHVtbkVkaXRvci5jYWxsYmFja3NbY2FsbGJhY2tdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuXyRlZGl0b3JFbG0ub24oJ2ZvY3VzJywgKCkgPT4ge1xyXG4gICAgICB0aGlzLl8kZWRpdG9yRWxtLnNlbGVjdCgpO1xyXG5cclxuICAgICAgLy8gd2UgY291bGQgb3B0aW9uYWxseSB0cmlnZ2VyIGEgc2VhcmNoIHRvIG9wZW4gdGhlIEF1dG9Db21wbGV0ZSBzZWFyY2ggbGlzdFxyXG4gICAgICBpZiAodGhpcy5lZGl0b3JPcHRpb25zLm9wZW5TZWFyY2hMaXN0T25Gb2N1cykge1xyXG4gICAgICAgIHRoaXMuXyRlZGl0b3JFbG0uYXV0b2NvbXBsZXRlKCdzZWFyY2gnLCB0aGlzLl8kZWRpdG9yRWxtLnZhbCgpKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmZvY3VzKCksIDUwKTtcclxuICB9XHJcbn1cclxuIl19