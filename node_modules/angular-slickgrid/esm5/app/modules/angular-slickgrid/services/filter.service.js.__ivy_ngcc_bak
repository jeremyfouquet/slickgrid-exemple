import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import { isObservable, Subject } from 'rxjs';
import * as isequal_ from 'lodash.isequal';
var isequal = isequal_; // patch to fix rollup to work
import { EmitterType, FieldType, KeyCode, OperatorType, } from './../models/index';
import { executeBackendCallback, refreshBackendDataset } from './backend-utilities';
import { getDescendantProperty } from './utilities';
import { FilterConditions } from './../filter-conditions';
import { FilterFactory } from '../filters/filterFactory';
import { SharedService } from './shared.service';
// timer for keeping track of user typing waits
var timer;
var DEFAULT_FILTER_TYPING_DEBOUNCE = 500;
var FilterService = /** @class */ (function () {
    function FilterService(filterFactory, sharedService) {
        this.filterFactory = filterFactory;
        this.sharedService = sharedService;
        this._isFilterFirstRender = true;
        this._firstColumnIdRendered = '';
        this._filtersMetadata = [];
        this._columnFilters = {};
        this.httpCancelRequests$ = new Subject(); // this will be used to cancel any pending http request
        this.onFilterChanged = new Subject();
        this.onFilterCleared = new Subject();
        this._eventHandler = new Slick.EventHandler();
        this._onSearchChange = new Slick.Event();
    }
    Object.defineProperty(FilterService.prototype, "eventHandler", {
        /** Getter of the SlickGrid Event Handler */
        get: function () {
            return this._eventHandler;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FilterService.prototype, "isFilterFirstRender", {
        /** Getter to know if the filter was already rendered or if it was its first time render */
        get: function () {
            return this._isFilterFirstRender;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FilterService.prototype, "onSearchChange", {
        /** Getter of the SlickGrid Event Handler */
        get: function () {
            return this._onSearchChange;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FilterService.prototype, "_gridOptions", {
        /** Getter for the Grid Options pulled through the Grid Object */
        get: function () {
            return (this._grid && this._grid.getOptions) ? this._grid.getOptions() : {};
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FilterService.prototype, "_columnDefinitions", {
        /** Getter for the Column Definitions pulled through the Grid Object */
        get: function () {
            return (this._grid && this._grid.getColumns) ? this._grid.getColumns() : [];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FilterService.prototype, "_dataView", {
        /** Getter of SlickGrid DataView object */
        get: function () {
            return (this._grid && this._grid.getData) ? this._grid.getData() : {};
        },
        enumerable: true,
        configurable: true
    });
    FilterService.prototype.init = function (grid) {
        this._grid = grid;
        if (this._gridOptions && this._gridOptions.enableTreeData && this._gridOptions.treeDataOptions) {
            this._grid.setSortColumns([{ columnId: this._gridOptions.treeDataOptions.columnId, sortAsc: true }]);
        }
    };
    FilterService.prototype.dispose = function () {
        // unsubscribe all SlickGrid events
        if (this._eventHandler && this._eventHandler.unsubscribeAll) {
            this._eventHandler.unsubscribeAll();
        }
        if (isObservable(this.httpCancelRequests$)) {
            this.httpCancelRequests$.next(); // this cancels any pending http requests
        }
        this.disposeColumnFilters();
        this._onSearchChange = null;
        this.addFilterTemplateToHeaderRow = null;
        this.customLocalFilter = null;
        this.callbackSearchEvent = null;
        this.handleBackendOnSearchChange = null;
        this.handleLocalOnSearchChange = null;
    };
    /**
     * Dispose of the filters, since it's a singleton, we don't want to affect other grids with same columns
     */
    FilterService.prototype.disposeColumnFilters = function () {
        // we need to loop through all columnFilters and delete them 1 by 1
        // only trying to make columnFilter an empty (without looping) would not trigger a dataset change
        if (typeof this._columnFilters === 'object') {
            for (var columnId in this._columnFilters) {
                if (columnId && this._columnFilters[columnId]) {
                    delete this._columnFilters[columnId];
                }
            }
        }
        // also destroy each Filter instances
        if (Array.isArray(this._filtersMetadata)) {
            this._filtersMetadata.forEach(function (filter) {
                if (filter && filter.destroy) {
                    filter.destroy(true);
                }
            });
        }
        this._filtersMetadata = [];
    };
    /**
     * When clearing or disposing of all filters, we need to loop through all columnFilters and delete them 1 by 1
     * only trying to make columnFilter an empty (without looping) would not trigger a dataset change
     */
    FilterService.prototype.resetColumnFilters = function () {
        if (typeof this._columnFilters === 'object') {
            for (var columnId in this._columnFilters) {
                if (columnId && this._columnFilters[columnId]) {
                    delete this._columnFilters[columnId];
                }
            }
        }
    };
    /**
     * Bind a backend filter hook to the grid
     * @param grid SlickGrid Grid object
     */
    FilterService.prototype.bindBackendOnFilter = function (grid) {
        this._filtersMetadata = [];
        // subscribe to SlickGrid onHeaderRowCellRendered event to create filter template
        this._eventHandler.subscribe(grid.onHeaderRowCellRendered, this.handleBackendOnSearchChange.bind(this));
        // subscribe to the SlickGrid event and call the backend execution
        if (this._onSearchChange) {
            this._eventHandler.subscribe(this._onSearchChange, this.onBackendFilterChange.bind(this));
        }
    };
    FilterService.prototype.handleBackendOnSearchChange = function (_e, args) {
        // firstColumnIdRendered is null at first, so if it changes to being filled and equal, then we would know that it was already rendered
        // this is to avoid rendering the filter twice (only the Select Filter for now), rendering it again also clears the filter which has unwanted side effect
        if (args.column.id === this._firstColumnIdRendered) {
            this._isFilterFirstRender = false;
        }
        this.addFilterTemplateToHeaderRow(null, args, this._isFilterFirstRender);
        if (this._firstColumnIdRendered === '') {
            this._firstColumnIdRendered = args.column.id;
        }
    };
    /**
     * Bind a local filter hook to the grid
     * @param grid SlickGrid Grid object
     * @param dataView
     */
    FilterService.prototype.bindLocalOnFilter = function (grid) {
        this._filtersMetadata = [];
        this._dataView.setFilterArgs({ columnFilters: this._columnFilters, grid: this._grid, dataView: this._dataView });
        this._dataView.setFilter(this.customLocalFilter.bind(this));
        // bind any search filter change (e.g. input filter input change event)
        if (this._onSearchChange) {
            this._eventHandler.subscribe(this._onSearchChange, this.handleLocalOnSearchChange.bind(this));
            // subscribe to SlickGrid onHeaderRowCellRendered event to create filter template
            this._eventHandler.subscribe(grid.onHeaderRowCellRendered, this.addFilterTemplateToHeaderRow.bind(this));
        }
    };
    FilterService.prototype.handleLocalOnSearchChange = function (_e, args) {
        var isGridWithTreeData = this._gridOptions && this._gridOptions.enableTreeData || false;
        // When using Tree Data, we need to do it in 2 steps
        // step 1. we need to prefilter (search) the data prior, the result will be an array of IDs which are the node(s) and their parent nodes when necessary.
        // step 2. calling the DataView.refresh() is what triggers the final filtering, with "customLocalFilter()" which will decide which rows should persist
        if (isGridWithTreeData) {
            this._tmpPreFilteredData = this.preFilterTreeData(this._dataView.getItems(), this._columnFilters);
        }
        var columnId = args.columnId;
        if (columnId !== null) {
            this._dataView.refresh();
        }
        // emit an onFilterChanged event when it's not called by a clear filter
        if (args && !args.clearFilterTriggered) {
            this.emitFilterChanged(EmitterType.local);
        }
    };
    FilterService.prototype.clearFilterByColumnId = function (event, columnId) {
        // get current column filter before clearing, this allow us to know if the filter was empty prior to calling the clear filter
        var currentColumnFilters = Object.keys(this._columnFilters);
        var currentColFilter;
        if (Array.isArray(currentColumnFilters)) {
            currentColFilter = currentColumnFilters.find(function (name) { return name === columnId; });
        }
        // find the filter object and call its clear method with true (the argument tells the method it was called by a clear filter)
        var colFilter = this._filtersMetadata.find(function (filter) { return filter.columnDef.id === columnId; });
        if (colFilter && colFilter.clear) {
            colFilter.clear(true);
        }
        var emitter = EmitterType.local;
        var isBackendApi = this._gridOptions && this._gridOptions.backendServiceApi || false;
        // when using a backend service, we need to manually trigger a filter change but only if the filter was previously filled
        if (isBackendApi) {
            emitter = EmitterType.remote;
            if (currentColFilter) {
                this.onBackendFilterChange(event, { grid: this._grid, columnFilters: this._columnFilters });
            }
        }
        // emit an event when filter is cleared
        this.emitFilterChanged(emitter);
    };
    /** Clear the search filters (below the column titles) */
    FilterService.prototype.clearFilters = function (triggerChange) {
        var _this = this;
        if (triggerChange === void 0) { triggerChange = true; }
        this._filtersMetadata.forEach(function (filter) {
            if (filter && filter.clear) {
                // clear element but don't trigger individual clear change,
                // we'll do 1 trigger for all filters at once afterward
                filter.clear(false);
            }
        });
        // also reset the columnFilters object and remove any filters from the object
        this.resetColumnFilters();
        // we also need to refresh the dataView and optionally the grid (it's optional since we use DataView)
        if (this._dataView && this._grid) {
            this._dataView.refresh();
            this._grid.invalidate();
        }
        // when using backend service, we need to query only once so it's better to do it here
        var backendApi = this._gridOptions && this._gridOptions.backendServiceApi;
        if (backendApi && triggerChange) {
            var callbackArgs_1 = { clearFilterTriggered: true, shouldTriggerQuery: triggerChange, grid: this._grid, columnFilters: this._columnFilters };
            var queryResponse = backendApi.service.processOnFilterChanged(undefined, callbackArgs_1);
            if (queryResponse instanceof Promise && queryResponse.then) {
                // @deprecated, processOnFilterChanged in the future should be returned as a query string NOT as a Promise
                console.warn("[Angular-Slickgrid] please note that the \"processOnFilterChanged\" from your Backend Service, should now return a string instead of a Promise.\n          Returning a Promise will be deprecated in the future.");
                queryResponse.then(function (query) {
                    var totalItems = _this._gridOptions && _this._gridOptions.pagination && _this._gridOptions.pagination.totalItems;
                    executeBackendCallback(backendApi, query, callbackArgs_1, new Date(), totalItems, _this.emitFilterChanged.bind(_this));
                });
            }
            else {
                var query = queryResponse;
                var totalItems = this._gridOptions && this._gridOptions.pagination && this._gridOptions.pagination.totalItems;
                executeBackendCallback(backendApi, query, callbackArgs_1, new Date(), totalItems, this.emitFilterChanged.bind(this));
            }
        }
        // emit an event when filters are all cleared
        if (triggerChange) {
            this.onFilterCleared.next(true);
        }
    };
    /** Local Grid Filter search */
    FilterService.prototype.customLocalFilter = function (item, args) {
        var e_1, _a;
        var dataView = args && args.dataView;
        var grid = args && args.grid;
        var isGridWithTreeData = this._gridOptions && this._gridOptions.enableTreeData || false;
        var columnFilters = args && args.columnFilters || {};
        var treeDataOptions;
        // when the column is a Tree Data structure and the parent is collapsed, we won't go further and just continue with next row
        // so we always run this check even when there are no filter search, the reason is because the user might click on the expand/collapse
        if (isGridWithTreeData && this._gridOptions && this._gridOptions.treeDataOptions) {
            treeDataOptions = this._gridOptions.treeDataOptions;
            var collapsedPropName = treeDataOptions.collapsedPropName || '__collapsed';
            var parentPropName = treeDataOptions.parentPropName || '__parentId';
            var dataViewIdIdentifier = this._gridOptions.datasetIdPropertyName || 'id';
            if (item[parentPropName] !== null) {
                var parent_1 = this._dataView.getItemById(item[parentPropName]);
                while (parent_1) {
                    if (parent_1[collapsedPropName]) {
                        return false; // don't display any row that have their parent collapsed
                    }
                    parent_1 = this._dataView.getItemById(parent_1[parentPropName]);
                }
            }
            // filter out any row items that aren't part of our pre-processed "preFilterTreeData()" result
            if (Array.isArray(this._tmpPreFilteredData)) {
                return this._tmpPreFilteredData.includes(item[dataViewIdIdentifier]); // return true when found, false otherwise
            }
        }
        else {
            if (typeof columnFilters === 'object') {
                try {
                    for (var _b = tslib_1.__values(Object.keys(columnFilters)), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var columnId = _c.value;
                        var columnFilter = columnFilters[columnId];
                        var conditionOptions = this.getFilterConditionOptionsOrBoolean(item, columnFilter, columnId, grid, dataView);
                        if (typeof conditionOptions === 'boolean') {
                            return conditionOptions;
                        }
                        if (!FilterConditions.executeMappedCondition(conditionOptions)) {
                            return false;
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
        }
        // if it reaches here, that means the row is valid and passed all filter
        return true;
    };
    FilterService.prototype.getFilterConditionOptionsOrBoolean = function (item, columnFilter, columnId, grid, dataView) {
        var columnIndex = grid.getColumnIndex(columnId);
        var columnDef = grid.getColumns()[columnIndex];
        // it might be a hidden column, if so it won't be part of the getColumns (because it we hide a column via setColumns)
        // when that happens we can try to get the column definition from all defined columns
        if (!columnDef && this.sharedService && Array.isArray(this.sharedService.allColumns)) {
            columnIndex = this.sharedService.allColumns.findIndex(function (col) { return col.field === columnId; });
            columnDef = this.sharedService.allColumns[columnIndex];
        }
        // if we still don't have a column definition then we should return then row anyway (true)
        if (!columnDef) {
            return true;
        }
        // Row Detail View plugin, if the row is padding we just get the value we're filtering on from it's parent
        if (this._gridOptions.enableRowDetailView) {
            var metadataPrefix = this._gridOptions.rowDetailView && this._gridOptions.rowDetailView.keyPrefix || '__';
            if (item[metadataPrefix + "isPadding"] && item[metadataPrefix + "parent"]) {
                item = item[metadataPrefix + "parent"];
            }
        }
        var dataKey = columnDef.dataKey;
        var queryFieldName = (columnDef.filter && columnDef.filter.queryField) || columnDef.queryFieldFilter || columnDef.queryField || columnDef.field || '';
        if (typeof columnDef.queryFieldNameGetterFn === 'function') {
            queryFieldName = columnDef.queryFieldNameGetterFn(item);
        }
        var fieldType = (columnDef.filter && columnDef.filter.type) || columnDef.type || FieldType.string;
        var filterSearchType = (columnDef.filterSearchType) ? columnDef.filterSearchType : null;
        var cellValue = item[queryFieldName];
        // when item is a complex object (dot "." notation), we need to filter the value contained in the object tree
        if (queryFieldName && queryFieldName.indexOf('.') >= 0) {
            cellValue = getDescendantProperty(item, queryFieldName);
        }
        // if we find searchTerms use them but make a deep copy so that we don't affect original array
        // we might have to overwrite the value(s) locally that are returned
        // e.g: we don't want to operator within the search value, since it will fail filter condition check trigger afterward
        var searchValues = (columnFilter && columnFilter.searchTerms) ? $.extend(true, [], columnFilter.searchTerms) : [];
        var fieldSearchValue = (Array.isArray(searchValues) && searchValues.length === 1) ? searchValues[0] : '';
        var matches = null;
        if (fieldType !== FieldType.object) {
            fieldSearchValue = '' + fieldSearchValue; // make sure it's a string
            matches = fieldSearchValue.match(/^([<>!=\*]{0,2})(.*[^<>!=\*])([\*]?)$/); // group 1: Operator, 2: searchValue, 3: last char is '*' (meaning starts with, ex.: abc*)
        }
        var operator = columnFilter.operator || ((matches) ? matches[1] : '');
        var searchTerm = (!!matches) ? matches[2] : '';
        var lastValueChar = (!!matches) ? matches[3] : (operator === '*z' ? '*' : '');
        if (searchValues && searchValues.length > 1) {
            fieldSearchValue = searchValues.join(',');
        }
        else if (typeof fieldSearchValue === 'string') {
            // escaping the search value
            fieldSearchValue = fieldSearchValue.replace("'", "''"); // escape single quotes by doubling them
            if (operator === '*' || operator === 'a*' || operator === '*z' || lastValueChar === '*') {
                operator = (operator === '*' || operator === '*z') ? OperatorType.endsWith : OperatorType.startsWith;
            }
        }
        // no need to query if search value is empty or if the search value is in fact equal to the operator
        if (searchTerm === '' && (!searchValues || (Array.isArray(searchValues) && (searchValues.length === 0 || searchValues.length === 1 && operator === searchValues[0])))) {
            return true;
        }
        // if search value has a regex match we will only keep the value without the operator
        // in this case we need to overwrite the returned search values to truncate operator from the string search
        if (Array.isArray(matches) && matches.length >= 1 && (Array.isArray(searchValues) && searchValues.length === 1)) {
            searchValues[0] = searchTerm;
        }
        // filter search terms should always be string type (even though we permit the end user to input numbers)
        // so make sure each term are strings, if user has some default search terms, we will cast them to string
        if (searchValues && Array.isArray(searchValues) && fieldType !== FieldType.object) {
            for (var k = 0, ln = searchValues.length; k < ln; k++) {
                // make sure all search terms are strings
                searchValues[k] = ((searchValues[k] === undefined || searchValues[k] === null) ? '' : searchValues[k]) + '';
            }
        }
        // when using localization (i18n), we should use the formatter output to search as the new cell value
        if (columnDef && columnDef.params && columnDef.params.useFormatterOuputToFilter) {
            var idPropName = this._gridOptions.datasetIdPropertyName || 'id';
            var rowIndex = (dataView && typeof dataView.getIdxById === 'function') ? dataView.getIdxById(item[idPropName]) : 0;
            cellValue = (columnDef && typeof columnDef.formatter === 'function') ? columnDef.formatter(rowIndex, columnIndex, cellValue, columnDef, item, this._grid) : '';
        }
        // make sure cell value is always a string
        if (typeof cellValue === 'number') {
            cellValue = cellValue.toString();
        }
        var currentCellValue = cellValue;
        return {
            dataKey: dataKey,
            fieldType: fieldType,
            searchTerms: searchValues,
            cellValue: currentCellValue,
            operator: operator,
            cellValueLastChar: lastValueChar,
            filterSearchType: filterSearchType
        };
    };
    /**
     * When using Tree Data, we need to prefilter (search) the data prior, the result will be an array of IDs which are the node(s) and their parent nodes when necessary.
     * This will then be passed to the DataView setFilter(customLocalFilter), which will itself loop through the list of IDs and display/hide the row if found that array of IDs
     * We do this in 2 steps so that we can still use the DataSet setFilter()
     */
    FilterService.prototype.preFilterTreeData = function (inputArray, columnFilters) {
        var e_2, _a;
        var treeDataOptions = this._gridOptions && this._gridOptions.treeDataOptions;
        var parentPropName = treeDataOptions && treeDataOptions.parentPropName || '__parentId';
        var dataViewIdIdentifier = this._gridOptions && this._gridOptions.datasetIdPropertyName || 'id';
        var treeObj = {};
        var filteredChildrenAndParents = [];
        if (Array.isArray(inputArray)) {
            for (var i = 0; i < inputArray.length; i++) {
                treeObj[inputArray[i][dataViewIdIdentifier]] = inputArray[i];
                // as the filtered data is then used again as each subsequent letter
                // we need to delete the .__used property, otherwise the logic below
                // in the while loop (which checks for parents) doesn't work:
                delete treeObj[inputArray[i][dataViewIdIdentifier]].__used;
            }
            for (var i = 0; i < inputArray.length; i++) {
                var item = inputArray[i];
                var matchFilter = true; // valid until proven otherwise
                try {
                    // loop through all column filters and execute filter condition(s)
                    for (var _b = (e_2 = void 0, tslib_1.__values(Object.keys(columnFilters))), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var columnId = _c.value;
                        var columnFilter = columnFilters[columnId];
                        var conditionOptionResult = this.getFilterConditionOptionsOrBoolean(item, columnFilter, columnId, this._grid, this._dataView);
                        if (conditionOptionResult) {
                            var conditionResult = (typeof conditionOptionResult === 'boolean') ? conditionOptionResult : FilterConditions.executeMappedCondition(conditionOptionResult);
                            if (conditionResult) {
                                // don't return true since we still need to check other keys in columnFilters
                                continue;
                            }
                        }
                        matchFilter = false;
                        continue;
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                // build an array from the matched filters, anything valid from filter condition
                // will be pushed to the filteredChildrenAndParents array
                if (matchFilter) {
                    var len = filteredChildrenAndParents.length;
                    // add child (id):
                    filteredChildrenAndParents.splice(len, 0, item[dataViewIdIdentifier]);
                    var parent_2 = treeObj[item[parentPropName]] || false;
                    while (parent_2) {
                        // only add parent (id) if not already added:
                        parent_2.__used || filteredChildrenAndParents.splice(len, 0, parent_2[dataViewIdIdentifier]);
                        // mark each parent as used to not use them again later:
                        treeObj[parent_2[dataViewIdIdentifier]].__used = true;
                        // try to find parent of the current parent, if exists:
                        parent_2 = treeObj[parent_2[parentPropName]] || false;
                    }
                }
            }
        }
        return filteredChildrenAndParents;
    };
    FilterService.prototype.getColumnFilters = function () {
        return this._columnFilters;
    };
    FilterService.prototype.getFiltersMetadata = function () {
        return this._filtersMetadata;
    };
    FilterService.prototype.getCurrentLocalFilters = function () {
        var e_3, _a;
        var currentFilters = [];
        if (this._columnFilters) {
            try {
                for (var _b = tslib_1.__values(Object.keys(this._columnFilters)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var colId = _c.value;
                    var columnFilter = this._columnFilters[colId];
                    var filter = { columnId: colId || '' };
                    if (columnFilter && columnFilter.searchTerms) {
                        filter.searchTerms = columnFilter.searchTerms;
                    }
                    if (columnFilter.operator) {
                        filter.operator = columnFilter.operator;
                    }
                    if (Array.isArray(filter.searchTerms) && filter.searchTerms.length > 0 && filter.searchTerms[0] !== '') {
                        currentFilters.push(filter);
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
        }
        return currentFilters;
    };
    /**
     * A simple function that is binded to the subscriber and emit a change when the filter is called.
     * Other services, like Pagination, can then subscribe to it.
     * @param caller
     */
    FilterService.prototype.emitFilterChanged = function (caller) {
        if (caller === EmitterType.remote && this._gridOptions && this._gridOptions.backendServiceApi) {
            var currentFilters = [];
            var backendService = this._gridOptions.backendServiceApi.service;
            if (backendService && backendService.getCurrentFilters) {
                currentFilters = backendService.getCurrentFilters();
            }
            this.onFilterChanged.next(currentFilters);
        }
        else if (caller === EmitterType.local) {
            this.onFilterChanged.next(this.getCurrentLocalFilters());
        }
    };
    FilterService.prototype.onBackendFilterChange = function (event, args) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var backendApi, startTime, debounceTypingDelay, isTriggeredByClearFilter, eventType, eventKeyCode, query, totalItems;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!args || !args.grid) {
                            throw new Error('Something went wrong when trying to bind the "onBackendFilterChange(event, args)" function, it seems that "args" is not populated correctly');
                        }
                        backendApi = this._gridOptions.backendServiceApi;
                        if (!backendApi || !backendApi.process || !backendApi.service) {
                            throw new Error("BackendServiceApi requires at least a \"process\" function and a \"service\" defined");
                        }
                        startTime = new Date();
                        // run a preProcess callback if defined
                        if (backendApi.preProcess) {
                            backendApi.preProcess();
                        }
                        debounceTypingDelay = 0;
                        isTriggeredByClearFilter = args && args.clearFilterTriggered;
                        eventType = event && event.type;
                        eventKeyCode = event && event.keyCode;
                        if (!isTriggeredByClearFilter && eventKeyCode !== KeyCode.ENTER && (eventType === 'input' || eventType === 'keyup' || eventType === 'keydown')) {
                            debounceTypingDelay = backendApi.hasOwnProperty('filterTypingDebounce') ? backendApi.filterTypingDebounce : DEFAULT_FILTER_TYPING_DEBOUNCE;
                        }
                        if (!(args && args.shouldTriggerQuery)) return [3 /*break*/, 3];
                        // call the service to get a query back
                        // @deprecated TODO: remove async/await on next major change, refer to processOnFilterChanged in BackendService interface (with @deprecated)
                        clearTimeout(timer);
                        if (!(debounceTypingDelay > 0)) return [3 /*break*/, 1];
                        timer = setTimeout(function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                            var query, totalItems;
                            return tslib_1.__generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, backendApi.service.processOnFilterChanged(event, args)];
                                    case 1:
                                        query = _a.sent();
                                        totalItems = this._gridOptions && this._gridOptions.pagination && this._gridOptions.pagination.totalItems;
                                        executeBackendCallback(backendApi, query, args, startTime, totalItems, this.emitFilterChanged.bind(this), this.httpCancelRequests$);
                                        return [2 /*return*/];
                                }
                            });
                        }); }, debounceTypingDelay);
                        return [3 /*break*/, 3];
                    case 1: return [4 /*yield*/, backendApi.service.processOnFilterChanged(event, args)];
                    case 2:
                        query = _a.sent();
                        totalItems = this._gridOptions && this._gridOptions.pagination && this._gridOptions.pagination.totalItems;
                        executeBackendCallback(backendApi, query, args, startTime, totalItems, this.emitFilterChanged.bind(this), this.httpCancelRequests$);
                        _a.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * When user passes an array of preset filters, we need to pre-populate each column filter searchTerm(s)
     * The process is to loop through the preset filters array, find the associated column from columnDefinitions and fill in the filter object searchTerm(s)
     * This is basically the same as if we would manually add searchTerm(s) to a column filter object in the column definition, but we do it programmatically.
     * At the end of the day, when creating the Filter (DOM Element), it will use these searchTerm(s) so we can take advantage of that without recoding each Filter type (DOM element)
     */
    FilterService.prototype.populateColumnFilterSearchTermPresets = function (filters) {
        if (Array.isArray(filters) && filters.length > 0) {
            this._columnDefinitions.forEach(function (columnDef) {
                // clear any columnDef searchTerms before applying Presets
                if (columnDef.filter && columnDef.filter.searchTerms) {
                    delete columnDef.filter.searchTerms;
                }
                // from each presets, we will find the associated columnDef and apply the preset searchTerms & operator if there is
                var columnPreset = filters.find(function (presetFilter) { return presetFilter.columnId === columnDef.id; });
                if (columnPreset && columnPreset.searchTerms && Array.isArray(columnPreset.searchTerms)) {
                    columnDef.filter = columnDef.filter || {};
                    columnDef.filter.operator = columnPreset.operator || columnDef.filter.operator || '';
                    columnDef.filter.searchTerms = columnPreset.searchTerms;
                }
            });
            // when we have a Filter Presets on a Tree Data View grid, we need to call the pre-filtering of tree data
            this.refreshTreeDataFilters();
        }
        return this._columnDefinitions;
    };
    /**
     * when we have a Filter Presets on a Tree Data View grid, we need to call the pre-filtering of tree data
     * we need to do this because Tree Data is the only type of grid that requires a pre-filter (preFilterTreeData) to be executed before the final filtering
     * @param filters
     */
    FilterService.prototype.refreshTreeDataFilters = function () {
        if (this._dataView && this._dataView.getItems && this._gridOptions && this._gridOptions.enableTreeData) {
            this._tmpPreFilteredData = this.preFilterTreeData(this._dataView.getItems(), this._columnFilters);
            this._dataView.refresh(); // and finally this refresh() is what triggers a DataView filtering check
        }
    };
    /**
     * Toggle the Filter Functionality
     * @param {boolean} isFilterDisabled - optionally force a disable/enable of the Sort Functionality? Defaults to True
     * @param {boolean} clearFiltersWhenDisabled - when disabling the Filter, do we also want to clear all the filters as well? Defaults to True
     */
    FilterService.prototype.disableFilterFunctionality = function (isFilterDisabled, clearFiltersWhenDisabled) {
        if (isFilterDisabled === void 0) { isFilterDisabled = true; }
        if (clearFiltersWhenDisabled === void 0) { clearFiltersWhenDisabled = true; }
        var prevShowFilterFlag = this._gridOptions.enableFiltering;
        var newShowFilterFlag = !prevShowFilterFlag;
        if (newShowFilterFlag !== isFilterDisabled) {
            if (clearFiltersWhenDisabled && isFilterDisabled) {
                this.clearFilters();
            }
            this.disableAllFilteringCommands(isFilterDisabled);
            this._grid.setOptions({ enableFiltering: newShowFilterFlag }, false, true);
            this._grid.setHeaderRowVisibility(newShowFilterFlag);
            this._gridOptions.enableFiltering = !isFilterDisabled;
            this.sharedService.gridOptions = this._gridOptions;
            // when displaying header row, we'll call "setColumns" which in terms will recreate the header row filters
            this._grid.setColumns(this.sharedService.columnDefinitions);
        }
    };
    /**
     * Toggle the Filter Functionality (show/hide the header row filter bar as well)
     * @param {boolean} clearFiltersWhenDisabled - when disabling the filters, do we want to clear the filters before hiding the filters? Defaults to True
     */
    FilterService.prototype.toggleFilterFunctionality = function (clearFiltersWhenDisabled) {
        if (clearFiltersWhenDisabled === void 0) { clearFiltersWhenDisabled = true; }
        var prevShowFilterFlag = this._gridOptions.enableFiltering;
        this.disableFilterFunctionality(prevShowFilterFlag, clearFiltersWhenDisabled);
    };
    /**
     * Toggle the Header Row filter bar (this does not disable the Filtering itself, you can use "toggleFilterFunctionality()" instead, however this will reset any column positions)
     */
    FilterService.prototype.toggleHeaderFilterRow = function () {
        var showHeaderRow = this._gridOptions && this._gridOptions.showHeaderRow || false;
        showHeaderRow = !showHeaderRow; // inverse show header flag
        this._grid.setHeaderRowVisibility(showHeaderRow);
        // when displaying header row, we'll call "setColumns" which in terms will recreate the header row filters
        if (showHeaderRow === true) {
            this._grid.setColumns(this.sharedService.columnDefinitions);
        }
    };
    /**
     * Set the sort icons in the UI (ONLY the icons, it does not do any sorting)
     * The column sort icons are not necessarily inter-connected to the sorting functionality itself,
     * you can change the sorting icons separately by passing an array of columnId/sortAsc and that will change ONLY the icons
     * @param sortColumns
     */
    FilterService.prototype.setSortColumnIcons = function (sortColumns) {
        if (this._grid && Array.isArray(sortColumns)) {
            this._grid.setSortColumns(sortColumns);
        }
    };
    /**
     * Update Filters dynamically just by providing an array of filter(s).
     * You can also choose emit (default) a Filter Changed event that will be picked by the Grid State Service.
     *
     * Also for backend service only, you can choose to trigger a backend query (default) or not if you wish to do it later,
     * this could be useful when using updateFilters & updateSorting and you wish to only send the backend query once.
     * @param filters array
     * @param triggerEvent defaults to True, do we want to emit a filter changed event?
     * @param triggerBackendQuery defaults to True, which will query the backend.
     */
    FilterService.prototype.updateFilters = function (filters, emitChangedEvent, triggerBackendQuery, triggerOnSearchChangeEvent) {
        var _this = this;
        if (emitChangedEvent === void 0) { emitChangedEvent = true; }
        if (triggerBackendQuery === void 0) { triggerBackendQuery = true; }
        if (triggerOnSearchChangeEvent === void 0) { triggerOnSearchChangeEvent = false; }
        if (!this._filtersMetadata || this._filtersMetadata.length === 0 || !this._gridOptions || !this._gridOptions.enableFiltering) {
            throw new Error('[Angular-Slickgrid] in order to use "updateFilters" method, you need to have Filterable Columns defined in your grid and "enableFiltering" set in your Grid Options');
        }
        if (Array.isArray(filters)) {
            // start by clearing all filters (without triggering an event) before applying any new filters
            this.clearFilters(false);
            // pre-fill (value + operator) and render all filters in the DOM
            // loop through each Filters provided (which has a columnId property)
            // then find their associated Filter instances that were originally created in the grid
            filters.forEach(function (newFilter) {
                var uiFilter = _this._filtersMetadata.find(function (filter) { return newFilter.columnId === filter.columnDef.id; });
                if (newFilter && uiFilter) {
                    var newOperator = newFilter.operator || uiFilter.defaultOperator;
                    _this.updateColumnFilters(newFilter.searchTerms, uiFilter.columnDef, newOperator);
                    uiFilter.setValues(newFilter.searchTerms, newOperator);
                    if (triggerOnSearchChangeEvent) {
                        _this.callbackSearchEvent(null, { columnDef: uiFilter.columnDef, operator: newOperator, searchTerms: newFilter.searchTerms, shouldTriggerQuery: true });
                    }
                }
            });
            var backendApi = this._gridOptions && this._gridOptions.backendServiceApi;
            // refresh the DataView and trigger an event after all filters were updated and rendered
            this._dataView.refresh();
            if (backendApi) {
                var backendApiService = backendApi && backendApi.service;
                if (backendApiService) {
                    backendApiService.updateFilters(filters, true);
                    if (triggerBackendQuery) {
                        refreshBackendDataset(this._gridOptions);
                    }
                }
            }
            if (emitChangedEvent) {
                var emitterType = backendApi ? EmitterType.remote : EmitterType.local;
                this.emitFilterChanged(emitterType);
            }
        }
    };
    // --
    // private functions
    // -------------------
    /** Add all created filters (from their template) to the header row section area */
    FilterService.prototype.addFilterTemplateToHeaderRow = function (_event, args, isFilterFirstRender) {
        if (isFilterFirstRender === void 0) { isFilterFirstRender = true; }
        var columnDef = args.column;
        var columnId = columnDef && columnDef.id || '';
        if (columnDef && columnId !== 'selector' && columnDef.filterable) {
            var searchTerms = void 0;
            var operator = void 0;
            var newFilter_1 = this.filterFactory.createFilter(args.column.filter);
            operator = (columnDef && columnDef.filter && columnDef.filter.operator) || (newFilter_1 && newFilter_1.operator) || undefined;
            if (this._columnFilters[columnDef.id]) {
                searchTerms = this._columnFilters[columnDef.id].searchTerms || undefined;
                operator = this._columnFilters[columnDef.id].operator || undefined;
            }
            else if (columnDef.filter) {
                // when hiding/showing (with Column Picker or Grid Menu), it will try to re-create yet again the filters (since SlickGrid does a re-render)
                // because of that we need to first get searchTerm(s) from the columnFilters (that is what the user last typed in a filter search input)
                searchTerms = columnDef.filter.searchTerms || undefined;
                this.updateColumnFilters(searchTerms, columnDef, operator);
            }
            var filterArguments = {
                grid: this._grid,
                operator: operator,
                searchTerms: searchTerms,
                columnDef: columnDef,
                callback: this.callbackSearchEvent.bind(this)
            };
            if (newFilter_1) {
                newFilter_1.init(filterArguments, isFilterFirstRender);
                var filterExistIndex = this._filtersMetadata.findIndex(function (filter) { return newFilter_1.columnDef.id === filter.columnDef.id; });
                // add to the filters arrays or replace it when found
                if (filterExistIndex === -1) {
                    this._filtersMetadata.push(newFilter_1);
                }
                else {
                    this._filtersMetadata[filterExistIndex] = newFilter_1;
                }
                // when hiding/showing (with Column Picker or Grid Menu), it will try to re-create yet again the filters (since SlickGrid does a re-render)
                // we need to also set again the values in the DOM elements if the values were set by a searchTerm(s)
                if (searchTerms && newFilter_1.setValues) {
                    newFilter_1.setValues(searchTerms);
                }
            }
        }
    };
    /**
     * Callback method that is called and executed by the individual Filter (DOM element),
     * for example when user type in a word to search (which uses InputFilter), this Filter will execute the callback from an input change event.
     */
    FilterService.prototype.callbackSearchEvent = function (event, args) {
        if (args) {
            var searchTerm = ((event && event.target) ? event.target.value : undefined);
            var searchTerms = (args.searchTerms && Array.isArray(args.searchTerms)) ? args.searchTerms : (searchTerm ? [searchTerm] : undefined);
            var columnDef = args.columnDef || null;
            var columnId = columnDef && columnDef.id || '';
            var operator = args.operator || undefined;
            var hasSearchTerms = searchTerms && Array.isArray(searchTerms);
            var termsCount = hasSearchTerms && searchTerms && searchTerms.length;
            var oldColumnFilters = tslib_1.__assign({}, this._columnFilters);
            if (columnDef && columnId) {
                if (!hasSearchTerms || termsCount === 0 || (termsCount === 1 && Array.isArray(searchTerms) && searchTerms[0] === '')) {
                    // delete the property from the columnFilters when it becomes empty
                    // without doing this, it would leave an incorrect state of the previous column filters when filtering on another column
                    delete this._columnFilters[columnId];
                }
                else {
                    var colId = '' + columnId;
                    var colFilter = {
                        columnId: colId,
                        columnDef: columnDef,
                        searchTerms: searchTerms,
                    };
                    if (operator) {
                        colFilter.operator = operator;
                    }
                    this._columnFilters[colId] = colFilter;
                }
            }
            // event might have been created as a CustomEvent (e.g. CompoundDateFilter), without being a valid Slick.EventData,
            // if so we will create a new Slick.EventData and merge it with that CustomEvent to avoid having SlickGrid errors
            var eventData = (event && typeof event.isPropagationStopped !== 'function') ? $.extend({}, new Slick.EventData(), event) : event;
            // trigger an event only if Filters changed or if ENTER key was pressed
            var eventKey = event && event.key;
            var eventKeyCode = event && event.keyCode;
            if (this._onSearchChange && (eventKey === 'Enter' || eventKeyCode === KeyCode.ENTER || !isequal(oldColumnFilters, this._columnFilters))) {
                this._onSearchChange.notify({
                    clearFilterTriggered: args.clearFilterTriggered,
                    shouldTriggerQuery: args.shouldTriggerQuery,
                    columnId: columnId,
                    columnDef: columnDef,
                    columnFilters: this._columnFilters,
                    operator: operator,
                    searchTerms: searchTerms,
                    grid: this._grid
                }, eventData);
            }
        }
    };
    /**
     * Loop through all column definitions and do the following thing
     * 1. loop through each Header Menu commands and change the "hidden" commands to show/hide depending if it's enabled/disabled
     * Also note that we aren't deleting any properties, we just toggle their flags so that we can reloop through at later point in time.
     * (if we previously deleted these properties we wouldn't be able to change them back since these properties wouldn't exist anymore, hence why we just hide the commands)
     * @param {boolean} isDisabling - are we disabling the filter functionality? Defaults to true
     */
    FilterService.prototype.disableAllFilteringCommands = function (isDisabling) {
        if (isDisabling === void 0) { isDisabling = true; }
        var columnDefinitions = this._grid.getColumns();
        // loop through column definition to hide/show header menu commands
        columnDefinitions.forEach(function (col) {
            if (col && col.header && col.header.menu) {
                col.header.menu.items.forEach(function (menuItem) {
                    if (menuItem && typeof menuItem !== 'string') {
                        var menuCommand = menuItem.command;
                        if (menuCommand === 'clear-filter') {
                            menuItem.hidden = isDisabling;
                        }
                    }
                });
            }
        });
        // loop through column definition to hide/show grid menu commands
        if (this._gridOptions && this._gridOptions.gridMenu && this._gridOptions.gridMenu.customItems) {
            this._gridOptions.gridMenu.customItems.forEach(function (menuItem) {
                if (menuItem && typeof menuItem !== 'string') {
                    var menuCommand = menuItem.command;
                    if (menuCommand === 'clear-filter' || menuCommand === 'toggle-filter') {
                        menuItem.hidden = isDisabling;
                    }
                }
            });
        }
        return columnDefinitions;
    };
    FilterService.prototype.updateColumnFilters = function (searchTerms, columnDef, operator) {
        if (searchTerms && columnDef) {
            this._columnFilters[columnDef.id] = {
                columnId: columnDef.id,
                columnDef: columnDef,
                searchTerms: searchTerms,
                operator: operator
            };
        }
    };
    FilterService.ctorParameters = function () { return [
        { type: FilterFactory },
        { type: SharedService }
    ]; };
    FilterService = tslib_1.__decorate([
        Injectable()
    ], FilterService);
    return FilterService;
}());
export { FilterService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsdGVyLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9hbmd1bGFyLXNsaWNrZ3JpZC8iLCJzb3VyY2VzIjpbImFwcC9tb2R1bGVzL2FuZ3VsYXItc2xpY2tncmlkL3NlcnZpY2VzL2ZpbHRlci5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBRSxZQUFZLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBRTdDLE9BQU8sS0FBSyxRQUFRLE1BQU0sZ0JBQWdCLENBQUM7QUFDM0MsSUFBTSxPQUFPLEdBQUcsUUFBUSxDQUFDLENBQUMsOEJBQThCO0FBRXhELE9BQU8sRUFLTCxXQUFXLEVBQ1gsU0FBUyxFQU9ULE9BQU8sRUFFUCxZQUFZLEdBSWIsTUFBTSxtQkFBbUIsQ0FBQztBQUMzQixPQUFPLEVBQUUsc0JBQXNCLEVBQUUscUJBQXFCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUNwRixPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDcEQsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDMUQsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQ3pELE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQU1qRCwrQ0FBK0M7QUFDL0MsSUFBSSxLQUFVLENBQUM7QUFDZixJQUFNLDhCQUE4QixHQUFHLEdBQUcsQ0FBQztBQUczQztJQWFFLHVCQUFvQixhQUE0QixFQUFVLGFBQTRCO1FBQWxFLGtCQUFhLEdBQWIsYUFBYSxDQUFlO1FBQVUsa0JBQWEsR0FBYixhQUFhLENBQWU7UUFYOUUseUJBQW9CLEdBQUcsSUFBSSxDQUFDO1FBQzVCLDJCQUFzQixHQUFHLEVBQUUsQ0FBQztRQUM1QixxQkFBZ0IsR0FBVSxFQUFFLENBQUM7UUFDN0IsbUJBQWMs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dWxhci9jb3JlJztcclxuaW1wb3J0IHsgaXNPYnNlcnZhYmxlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XHJcblxyXG5pbXBvcnQgKiBhcyBpc2VxdWFsXyBmcm9tICdsb2Rhc2guaXNlcXVhbCc7XHJcbmNvbnN0IGlzZXF1YWwgPSBpc2VxdWFsXzsgLy8gcGF0Y2ggdG8gZml4IHJvbGx1cCB0byB3b3JrXHJcblxyXG5pbXBvcnQge1xyXG4gIENvbHVtbixcclxuICBDb2x1bW5GaWx0ZXIsXHJcbiAgQ29sdW1uRmlsdGVycyxcclxuICBDdXJyZW50RmlsdGVyLFxyXG4gIEVtaXR0ZXJUeXBlLFxyXG4gIEZpZWxkVHlwZSxcclxuICBGaWx0ZXIsXHJcbiAgRmlsdGVyQXJndW1lbnRzLFxyXG4gIEZpbHRlckNhbGxiYWNrQXJnLFxyXG4gIEZpbHRlckNoYW5nZWRBcmdzLFxyXG4gIEZpbHRlckNvbmRpdGlvbk9wdGlvbixcclxuICBHcmlkT3B0aW9uLFxyXG4gIEtleUNvZGUsXHJcbiAgT3BlcmF0b3JTdHJpbmcsXHJcbiAgT3BlcmF0b3JUeXBlLFxyXG4gIFNlYXJjaFRlcm0sXHJcbiAgU2xpY2tFdmVudCxcclxuICBTbGlja0V2ZW50SGFuZGxlcixcclxufSBmcm9tICcuLy4uL21vZGVscy9pbmRleCc7XHJcbmltcG9ydCB7IGV4ZWN1dGVCYWNrZW5kQ2FsbGJhY2ssIHJlZnJlc2hCYWNrZW5kRGF0YXNldCB9IGZyb20gJy4vYmFja2VuZC11dGlsaXRpZXMnO1xyXG5pbXBvcnQgeyBnZXREZXNjZW5kYW50UHJvcGVydHkgfSBmcm9tICcuL3V0aWxpdGllcyc7XHJcbmltcG9ydCB7IEZpbHRlckNvbmRpdGlvbnMgfSBmcm9tICcuLy4uL2ZpbHRlci1jb25kaXRpb25zJztcclxuaW1wb3J0IHsgRmlsdGVyRmFjdG9yeSB9IGZyb20gJy4uL2ZpbHRlcnMvZmlsdGVyRmFjdG9yeSc7XHJcbmltcG9ydCB7IFNoYXJlZFNlcnZpY2UgfSBmcm9tICcuL3NoYXJlZC5zZXJ2aWNlJztcclxuXHJcbi8vIHVzaW5nIGV4dGVybmFsIG5vbi10eXBlZCBqcyBsaWJyYXJpZXNcclxuZGVjbGFyZSBjb25zdCBTbGljazogYW55O1xyXG5kZWNsYXJlIGNvbnN0ICQ6IGFueTtcclxuXHJcbi8vIHRpbWVyIGZvciBrZWVwaW5nIHRyYWNrIG9mIHVzZXIgdHlwaW5nIHdhaXRzXHJcbmxldCB0aW1lcjogYW55O1xyXG5jb25zdCBERUZBVUxUX0ZJTFRFUl9UWVBJTkdfREVCT1VOQ0UgPSA1MDA7XHJcblxyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBGaWx0ZXJTZXJ2aWNlIHtcclxuICBwcml2YXRlIF9ldmVudEhhbmRsZXI6IFNsaWNrRXZlbnRIYW5kbGVyO1xyXG4gIHByaXZhdGUgX2lzRmlsdGVyRmlyc3RSZW5kZXIgPSB0cnVlO1xyXG4gIHByaXZhdGUgX2ZpcnN0Q29sdW1uSWRSZW5kZXJlZCA9ICcnO1xyXG4gIHByaXZhdGUgX2ZpbHRlcnNNZXRhZGF0YTogYW55W10gPSBbXTtcclxuICBwcml2YXRlIF9jb2x1bW5GaWx0ZXJzOiBDb2x1bW5GaWx0ZXJzID0ge307XHJcbiAgcHJpdmF0ZSBfZ3JpZDogYW55O1xyXG4gIHByaXZhdGUgX29uU2VhcmNoQ2hhbmdlOiBTbGlja0V2ZW50IHwgbnVsbDtcclxuICBwcml2YXRlIF90bXBQcmVGaWx0ZXJlZERhdGE6IG51bWJlcltdO1xyXG4gIHByaXZhdGUgaHR0cENhbmNlbFJlcXVlc3RzJDogU3ViamVjdDx2b2lkPiA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7IC8vIHRoaXMgd2lsbCBiZSB1c2VkIHRvIGNhbmNlbCBhbnkgcGVuZGluZyBodHRwIHJlcXVlc3RcclxuICBvbkZpbHRlckNoYW5nZWQgPSBuZXcgU3ViamVjdDxDdXJyZW50RmlsdGVyW10+KCk7XHJcbiAgb25GaWx0ZXJDbGVhcmVkID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcclxuXHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBmaWx0ZXJGYWN0b3J5OiBGaWx0ZXJGYWN0b3J5LCBwcml2YXRlIHNoYXJlZFNlcnZpY2U6IFNoYXJlZFNlcnZpY2UpIHtcclxuICAgIHRoaXMuX2V2ZW50SGFuZGxlciA9IG5ldyBTbGljay5FdmVudEhhbmRsZXIoKTtcclxuICAgIHRoaXMuX29uU2VhcmNoQ2hhbmdlID0gbmV3IFNsaWNrLkV2ZW50KCk7XHJcbiAgfVxyXG5cclxuICAvKiogR2V0dGVyIG9mIHRoZSBTbGlja0dyaWQgRXZlbnQgSGFuZGxlciAqL1xyXG4gIGdldCBldmVudEhhbmRsZXIoKTogU2xpY2tFdmVudEhhbmRsZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuX2V2ZW50SGFuZGxlcjtcclxuICB9XHJcblxyXG4gIC8qKiBHZXR0ZXIgdG8ga25vdyBpZiB0aGUgZmlsdGVyIHdhcyBhbHJlYWR5IHJlbmRlcmVkIG9yIGlmIGl0IHdhcyBpdHMgZmlyc3QgdGltZSByZW5kZXIgKi9cclxuICBnZXQgaXNGaWx0ZXJGaXJzdFJlbmRlcigpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLl9pc0ZpbHRlckZpcnN0UmVuZGVyO1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldHRlciBvZiB0aGUgU2xpY2tHcmlkIEV2ZW50IEhhbmRsZXIgKi9cclxuICBnZXQgb25TZWFyY2hDaGFuZ2UoKTogU2xpY2tFdmVudCB8IG51bGwge1xyXG4gICAgcmV0dXJuIHRoaXMuX29uU2VhcmNoQ2hhbmdlO1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldHRlciBmb3IgdGhlIEdyaWQgT3B0aW9ucyBwdWxsZWQgdGhyb3VnaCB0aGUgR3JpZCBPYmplY3QgKi9cclxuICBwcml2YXRlIGdldCBfZ3JpZE9wdGlvbnMoKTogR3JpZE9wdGlvbiB7XHJcbiAgICByZXR1cm4gKHRoaXMuX2dyaWQgJiYgdGhpcy5fZ3JpZC5nZXRPcHRpb25zKSA/IHRoaXMuX2dyaWQuZ2V0T3B0aW9ucygpIDoge307XHJcbiAgfVxyXG5cclxuICAvKiogR2V0dGVyIGZvciB0aGUgQ29sdW1uIERlZmluaXRpb25zIHB1bGxlZCB0aHJvdWdoIHRoZSBHcmlkIE9iamVjdCAqL1xyXG4gIHByaXZhdGUgZ2V0IF9jb2x1bW5EZWZpbml0aW9ucygpOiBDb2x1bW5bXSB7XHJcbiAgICByZXR1cm4gKHRoaXMuX2dyaWQgJiYgdGhpcy5fZ3JpZC5nZXRDb2x1bW5zKSA/IHRoaXMuX2dyaWQuZ2V0Q29sdW1ucygpIDogW107XHJcbiAgfVxyXG5cclxuICAvKiogR2V0dGVyIG9mIFNsaWNrR3JpZCBEYXRhVmlldyBvYmplY3QgKi9cclxuICBwcml2YXRlIGdldCBfZGF0YVZpZXcoKTogYW55IHtcclxuICAgIHJldHVybiAodGhpcy5fZ3JpZCAmJiB0aGlzLl9ncmlkLmdldERhdGEpID8gdGhpcy5fZ3JpZC5nZXREYXRhKCkgOiB7fTtcclxuICB9XHJcblxyXG4gIGluaXQoZ3JpZDogYW55KTogdm9pZCB7XHJcbiAgICB0aGlzLl9ncmlkID0gZ3JpZDtcclxuXHJcbiAgICBpZiAodGhpcy5fZ3JpZE9wdGlvbnMgJiYgdGhpcy5fZ3JpZE9wdGlvbnMuZW5hYmxlVHJlZURhdGEgJiYgdGhpcy5fZ3JpZE9wdGlvbnMudHJlZURhdGFPcHRpb25zKSB7XHJcbiAgICAgIHRoaXMuX2dyaWQuc2V0U29ydENvbHVtbnMoW3sgY29sdW1uSWQ6IHRoaXMuX2dyaWRPcHRpb25zLnRyZWVEYXRhT3B0aW9ucy5jb2x1bW5JZCwgc29ydEFzYzogdHJ1ZSB9XSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBkaXNwb3NlKCkge1xyXG4gICAgLy8gdW5zdWJzY3JpYmUgYWxsIFNsaWNrR3JpZCBldmVudHNcclxuICAgIGlmICh0aGlzLl9ldmVudEhhbmRsZXIgJiYgdGhpcy5fZXZlbnRIYW5kbGVyLnVuc3Vic2NyaWJlQWxsKSB7XHJcbiAgICAgIHRoaXMuX2V2ZW50SGFuZGxlci51bnN1YnNjcmliZUFsbCgpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzT2JzZXJ2YWJsZSh0aGlzLmh0dHBDYW5jZWxSZXF1ZXN0cyQpKSB7XHJcbiAgICAgIHRoaXMuaHR0cENhbmNlbFJlcXVlc3RzJC5uZXh0KCk7IC8vIHRoaXMgY2FuY2VscyBhbnkgcGVuZGluZyBodHRwIHJlcXVlc3RzXHJcbiAgICB9XHJcbiAgICB0aGlzLmRpc3Bvc2VDb2x1bW5GaWx0ZXJzKCk7XHJcbiAgICB0aGlzLl9vblNlYXJjaENoYW5nZSA9IG51bGw7XHJcbiAgICB0aGlzLmFkZEZpbHRlclRlbXBsYXRlVG9IZWFkZXJSb3cgPSBudWxsO1xyXG4gICAgdGhpcy5jdXN0b21Mb2NhbEZpbHRlciA9IG51bGw7XHJcbiAgICB0aGlzLmNhbGxiYWNrU2VhcmNoRXZlbnQgPSBudWxsO1xyXG4gICAgdGhpcy5oYW5kbGVCYWNrZW5kT25TZWFyY2hDaGFuZ2UgPSBudWxsO1xyXG4gICAgdGhpcy5oYW5kbGVMb2NhbE9uU2VhcmNoQ2hhbmdlID0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERpc3Bvc2Ugb2YgdGhlIGZpbHRlcnMsIHNpbmNlIGl0J3MgYSBzaW5nbGV0b24sIHdlIGRvbid0IHdhbnQgdG8gYWZmZWN0IG90aGVyIGdyaWRzIHdpdGggc2FtZSBjb2x1bW5zXHJcbiAgICovXHJcbiAgZGlzcG9zZUNvbHVtbkZpbHRlcnMoKSB7XHJcbiAgICAvLyB3ZSBuZWVkIHRvIGxvb3AgdGhyb3VnaCBhbGwgY29sdW1uRmlsdGVycyBhbmQgZGVsZXRlIHRoZW0gMSBieSAxXHJcbiAgICAvLyBvbmx5IHRyeWluZyB0byBtYWtlIGNvbHVtbkZpbHRlciBhbiBlbXB0eSAod2l0aG91dCBsb29waW5nKSB3b3VsZCBub3QgdHJpZ2dlciBhIGRhdGFzZXQgY2hhbmdlXHJcbiAgICBpZiAodHlwZW9mIHRoaXMuX2NvbHVtbkZpbHRlcnMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIGZvciAoY29uc3QgY29sdW1uSWQgaW4gdGhpcy5fY29sdW1uRmlsdGVycykge1xyXG4gICAgICAgIGlmIChjb2x1bW5JZCAmJiB0aGlzLl9jb2x1bW5GaWx0ZXJzW2NvbHVtbklkXSkge1xyXG4gICAgICAgICAgZGVsZXRlIHRoaXMuX2NvbHVtbkZpbHRlcnNbY29sdW1uSWRdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGFsc28gZGVzdHJveSBlYWNoIEZpbHRlciBpbnN0YW5jZXNcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuX2ZpbHRlcnNNZXRhZGF0YSkpIHtcclxuICAgICAgdGhpcy5fZmlsdGVyc01ldGFkYXRhLmZvckVhY2goKGZpbHRlcikgPT4ge1xyXG4gICAgICAgIGlmIChmaWx0ZXIgJiYgZmlsdGVyLmRlc3Ryb3kpIHtcclxuICAgICAgICAgIGZpbHRlci5kZXN0cm95KHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9maWx0ZXJzTWV0YWRhdGEgPSBbXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFdoZW4gY2xlYXJpbmcgb3IgZGlzcG9zaW5nIG9mIGFsbCBmaWx0ZXJzLCB3ZSBuZWVkIHRvIGxvb3AgdGhyb3VnaCBhbGwgY29sdW1uRmlsdGVycyBhbmQgZGVsZXRlIHRoZW0gMSBieSAxXHJcbiAgICogb25seSB0cnlpbmcgdG8gbWFrZSBjb2x1bW5GaWx0ZXIgYW4gZW1wdHkgKHdpdGhvdXQgbG9vcGluZykgd291bGQgbm90IHRyaWdnZXIgYSBkYXRhc2V0IGNoYW5nZVxyXG4gICAqL1xyXG4gIHJlc2V0Q29sdW1uRmlsdGVycygpIHtcclxuICAgIGlmICh0eXBlb2YgdGhpcy5fY29sdW1uRmlsdGVycyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgZm9yIChjb25zdCBjb2x1bW5JZCBpbiB0aGlzLl9jb2x1bW5GaWx0ZXJzKSB7XHJcbiAgICAgICAgaWYgKGNvbHVtbklkICYmIHRoaXMuX2NvbHVtbkZpbHRlcnNbY29sdW1uSWRdKSB7XHJcbiAgICAgICAgICBkZWxldGUgdGhpcy5fY29sdW1uRmlsdGVyc1tjb2x1bW5JZF07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBCaW5kIGEgYmFja2VuZCBmaWx0ZXIgaG9vayB0byB0aGUgZ3JpZFxyXG4gICAqIEBwYXJhbSBncmlkIFNsaWNrR3JpZCBHcmlkIG9iamVjdFxyXG4gICAqL1xyXG4gIGJpbmRCYWNrZW5kT25GaWx0ZXIoZ3JpZDogYW55KSB7XHJcbiAgICB0aGlzLl9maWx0ZXJzTWV0YWRhdGEgPSBbXTtcclxuXHJcbiAgICAvLyBzdWJzY3JpYmUgdG8gU2xpY2tHcmlkIG9uSGVhZGVyUm93Q2VsbFJlbmRlcmVkIGV2ZW50IHRvIGNyZWF0ZSBmaWx0ZXIgdGVtcGxhdGVcclxuICAgIHRoaXMuX2V2ZW50SGFuZGxlci5zdWJzY3JpYmUoZ3JpZC5vbkhlYWRlclJvd0NlbGxSZW5kZXJlZCwgdGhpcy5oYW5kbGVCYWNrZW5kT25TZWFyY2hDaGFuZ2UuYmluZCh0aGlzKSk7XHJcblxyXG4gICAgLy8gc3Vic2NyaWJlIHRvIHRoZSBTbGlja0dyaWQgZXZlbnQgYW5kIGNhbGwgdGhlIGJhY2tlbmQgZXhlY3V0aW9uXHJcbiAgICBpZiAodGhpcy5fb25TZWFyY2hDaGFuZ2UpIHtcclxuICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyLnN1YnNjcmliZSh0aGlzLl9vblNlYXJjaENoYW5nZSwgdGhpcy5vbkJhY2tlbmRGaWx0ZXJDaGFuZ2UuYmluZCh0aGlzKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBoYW5kbGVCYWNrZW5kT25TZWFyY2hDaGFuZ2UoX2U6IEtleWJvYXJkRXZlbnQsIGFyZ3M6IGFueSkge1xyXG4gICAgLy8gZmlyc3RDb2x1bW5JZFJlbmRlcmVkIGlzIG51bGwgYXQgZmlyc3QsIHNvIGlmIGl0IGNoYW5nZXMgdG8gYmVpbmcgZmlsbGVkIGFuZCBlcXVhbCwgdGhlbiB3ZSB3b3VsZCBrbm93IHRoYXQgaXQgd2FzIGFscmVhZHkgcmVuZGVyZWRcclxuICAgIC8vIHRoaXMgaXMgdG8gYXZvaWQgcmVuZGVyaW5nIHRoZSBmaWx0ZXIgdHdpY2UgKG9ubHkgdGhlIFNlbGVjdCBGaWx0ZXIgZm9yIG5vdyksIHJlbmRlcmluZyBpdCBhZ2FpbiBhbHNvIGNsZWFycyB0aGUgZmlsdGVyIHdoaWNoIGhhcyB1bndhbnRlZCBzaWRlIGVmZmVjdFxyXG4gICAgaWYgKGFyZ3MuY29sdW1uLmlkID09PSB0aGlzLl9maXJzdENvbHVtbklkUmVuZGVyZWQpIHtcclxuICAgICAgdGhpcy5faXNGaWx0ZXJGaXJzdFJlbmRlciA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgdGhpcy5hZGRGaWx0ZXJUZW1wbGF0ZVRvSGVhZGVyUm93KG51bGwsIGFyZ3MsIHRoaXMuX2lzRmlsdGVyRmlyc3RSZW5kZXIpO1xyXG4gICAgaWYgKHRoaXMuX2ZpcnN0Q29sdW1uSWRSZW5kZXJlZCA9PT0gJycpIHtcclxuICAgICAgdGhpcy5fZmlyc3RDb2x1bW5JZFJlbmRlcmVkID0gYXJncy5jb2x1bW4uaWQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBCaW5kIGEgbG9jYWwgZmlsdGVyIGhvb2sgdG8gdGhlIGdyaWRcclxuICAgKiBAcGFyYW0gZ3JpZCBTbGlja0dyaWQgR3JpZCBvYmplY3RcclxuICAgKiBAcGFyYW0gZGF0YVZpZXdcclxuICAgKi9cclxuICBiaW5kTG9jYWxPbkZpbHRlcihncmlkOiBhbnkpIHtcclxuICAgIHRoaXMuX2ZpbHRlcnNNZXRhZGF0YSA9IFtdO1xyXG5cclxuICAgIHRoaXMuX2RhdGFWaWV3LnNldEZpbHRlckFyZ3MoeyBjb2x1bW5GaWx0ZXJzOiB0aGlzLl9jb2x1bW5GaWx0ZXJzLCBncmlkOiB0aGlzLl9ncmlkLCBkYXRhVmlldzogdGhpcy5fZGF0YVZpZXcgfSk7XHJcbiAgICB0aGlzLl9kYXRhVmlldy5zZXRGaWx0ZXIodGhpcy5jdXN0b21Mb2NhbEZpbHRlci5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAvLyBiaW5kIGFueSBzZWFyY2ggZmlsdGVyIGNoYW5nZSAoZS5nLiBpbnB1dCBmaWx0ZXIgaW5wdXQgY2hhbmdlIGV2ZW50KVxyXG4gICAgaWYgKHRoaXMuX29uU2VhcmNoQ2hhbmdlKSB7XHJcbiAgICAgIHRoaXMuX2V2ZW50SGFuZGxlci5zdWJzY3JpYmUodGhpcy5fb25TZWFyY2hDaGFuZ2UsIHRoaXMuaGFuZGxlTG9jYWxPblNlYXJjaENoYW5nZS5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAgIC8vIHN1YnNjcmliZSB0byBTbGlja0dyaWQgb25IZWFkZXJSb3dDZWxsUmVuZGVyZWQgZXZlbnQgdG8gY3JlYXRlIGZpbHRlciB0ZW1wbGF0ZVxyXG4gICAgICB0aGlzLl9ldmVudEhhbmRsZXIuc3Vic2NyaWJlKGdyaWQub25IZWFkZXJSb3dDZWxsUmVuZGVyZWQsIHRoaXMuYWRkRmlsdGVyVGVtcGxhdGVUb0hlYWRlclJvdy5iaW5kKHRoaXMpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGhhbmRsZUxvY2FsT25TZWFyY2hDaGFuZ2UoX2U6IEtleWJvYXJkRXZlbnQsIGFyZ3M6IGFueSkge1xyXG4gICAgY29uc3QgaXNHcmlkV2l0aFRyZWVEYXRhID0gdGhpcy5fZ3JpZE9wdGlvbnMgJiYgdGhpcy5fZ3JpZE9wdGlvbnMuZW5hYmxlVHJlZURhdGEgfHwgZmFsc2U7XHJcblxyXG4gICAgLy8gV2hlbiB1c2luZyBUcmVlIERhdGEsIHdlIG5lZWQgdG8gZG8gaXQgaW4gMiBzdGVwc1xyXG4gICAgLy8gc3RlcCAxLiB3ZSBuZWVkIHRvIHByZWZpbHRlciAoc2VhcmNoKSB0aGUgZGF0YSBwcmlvciwgdGhlIHJlc3VsdCB3aWxsIGJlIGFuIGFycmF5IG9mIElEcyB3aGljaCBhcmUgdGhlIG5vZGUocykgYW5kIHRoZWlyIHBhcmVudCBub2RlcyB3aGVuIG5lY2Vzc2FyeS5cclxuICAgIC8vIHN0ZXAgMi4gY2FsbGluZyB0aGUgRGF0YVZpZXcucmVmcmVzaCgpIGlzIHdoYXQgdHJpZ2dlcnMgdGhlIGZpbmFsIGZpbHRlcmluZywgd2l0aCBcImN1c3RvbUxvY2FsRmlsdGVyKClcIiB3aGljaCB3aWxsIGRlY2lkZSB3aGljaCByb3dzIHNob3VsZCBwZXJzaXN0XHJcbiAgICBpZiAoaXNHcmlkV2l0aFRyZWVEYXRhKSB7XHJcbiAgICAgIHRoaXMuX3RtcFByZUZpbHRlcmVkRGF0YSA9IHRoaXMucHJlRmlsdGVyVHJlZURhdGEodGhpcy5fZGF0YVZpZXcuZ2V0SXRlbXMoKSwgdGhpcy5fY29sdW1uRmlsdGVycyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgY29sdW1uSWQgPSBhcmdzLmNvbHVtbklkO1xyXG4gICAgaWYgKGNvbHVtbklkICE9PSBudWxsKSB7XHJcbiAgICAgIHRoaXMuX2RhdGFWaWV3LnJlZnJlc2goKTtcclxuICAgIH1cclxuICAgIC8vIGVtaXQgYW4gb25GaWx0ZXJDaGFuZ2VkIGV2ZW50IHdoZW4gaXQncyBub3QgY2FsbGVkIGJ5IGEgY2xlYXIgZmlsdGVyXHJcbiAgICBpZiAoYXJncyAmJiAhYXJncy5jbGVhckZpbHRlclRyaWdnZXJlZCkge1xyXG4gICAgICB0aGlzLmVtaXRGaWx0ZXJDaGFuZ2VkKEVtaXR0ZXJUeXBlLmxvY2FsKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNsZWFyRmlsdGVyQnlDb2x1bW5JZChldmVudDogRXZlbnQsIGNvbHVtbklkOiBudW1iZXIgfCBzdHJpbmcpIHtcclxuICAgIC8vIGdldCBjdXJyZW50IGNvbHVtbiBmaWx0ZXIgYmVmb3JlIGNsZWFyaW5nLCB0aGlzIGFsbG93IHVzIHRvIGtub3cgaWYgdGhlIGZpbHRlciB3YXMgZW1wdHkgcHJpb3IgdG8gY2FsbGluZyB0aGUgY2xlYXIgZmlsdGVyXHJcbiAgICBjb25zdCBjdXJyZW50Q29sdW1uRmlsdGVycyA9IE9iamVjdC5rZXlzKHRoaXMuX2NvbHVtbkZpbHRlcnMpIGFzIENvbHVtbkZpbHRlcltdO1xyXG4gICAgbGV0IGN1cnJlbnRDb2xGaWx0ZXI6IENvbHVtbkZpbHRlcjtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnRDb2x1bW5GaWx0ZXJzKSkge1xyXG4gICAgICBjdXJyZW50Q29sRmlsdGVyID0gY3VycmVudENvbHVtbkZpbHRlcnMuZmluZCgobmFtZSkgPT4gbmFtZSA9PT0gY29sdW1uSWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGZpbmQgdGhlIGZpbHRlciBvYmplY3QgYW5kIGNhbGwgaXRzIGNsZWFyIG1ldGhvZCB3aXRoIHRydWUgKHRoZSBhcmd1bWVudCB0ZWxscyB0aGUgbWV0aG9kIGl0IHdhcyBjYWxsZWQgYnkgYSBjbGVhciBmaWx0ZXIpXHJcbiAgICBjb25zdCBjb2xGaWx0ZXI6IEZpbHRlciA9IHRoaXMuX2ZpbHRlcnNNZXRhZGF0YS5maW5kKChmaWx0ZXI6IEZpbHRlcikgPT4gZmlsdGVyLmNvbHVtbkRlZi5pZCA9PT0gY29sdW1uSWQpO1xyXG4gICAgaWYgKGNvbEZpbHRlciAmJiBjb2xGaWx0ZXIuY2xlYXIpIHtcclxuICAgICAgY29sRmlsdGVyLmNsZWFyKHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBlbWl0dGVyOiBFbWl0dGVyVHlwZSA9IEVtaXR0ZXJUeXBlLmxvY2FsO1xyXG4gICAgY29uc3QgaXNCYWNrZW5kQXBpID0gdGhpcy5fZ3JpZE9wdGlvbnMgJiYgdGhpcy5fZ3JpZE9wdGlvbnMuYmFja2VuZFNlcnZpY2VBcGkgfHwgZmFsc2U7XHJcblxyXG4gICAgLy8gd2hlbiB1c2luZyBhIGJhY2tlbmQgc2VydmljZSwgd2UgbmVlZCB0byBtYW51YWxseSB0cmlnZ2VyIGEgZmlsdGVyIGNoYW5nZSBidXQgb25seSBpZiB0aGUgZmlsdGVyIHdhcyBwcmV2aW91c2x5IGZpbGxlZFxyXG4gICAgaWYgKGlzQmFja2VuZEFwaSkge1xyXG4gICAgICBlbWl0dGVyID0gRW1pdHRlclR5cGUucmVtb3RlO1xyXG4gICAgICBpZiAoY3VycmVudENvbEZpbHRlcikge1xyXG4gICAgICAgIHRoaXMub25CYWNrZW5kRmlsdGVyQ2hhbmdlKGV2ZW50IGFzIEtleWJvYXJkRXZlbnQsIHsgZ3JpZDogdGhpcy5fZ3JpZCwgY29sdW1uRmlsdGVyczogdGhpcy5fY29sdW1uRmlsdGVycyB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGVtaXQgYW4gZXZlbnQgd2hlbiBmaWx0ZXIgaXMgY2xlYXJlZFxyXG4gICAgdGhpcy5lbWl0RmlsdGVyQ2hhbmdlZChlbWl0dGVyKTtcclxuICB9XHJcblxyXG4gIC8qKiBDbGVhciB0aGUgc2VhcmNoIGZpbHRlcnMgKGJlbG93IHRoZSBjb2x1bW4gdGl0bGVzKSAqL1xyXG4gIGNsZWFyRmlsdGVycyh0cmlnZ2VyQ2hhbmdlID0gdHJ1ZSkge1xyXG4gICAgdGhpcy5fZmlsdGVyc01ldGFkYXRhLmZvckVhY2goKGZpbHRlcjogRmlsdGVyKSA9PiB7XHJcbiAgICAgIGlmIChmaWx0ZXIgJiYgZmlsdGVyLmNsZWFyKSB7XHJcbiAgICAgICAgLy8gY2xlYXIgZWxlbWVudCBidXQgZG9uJ3QgdHJpZ2dlciBpbmRpdmlkdWFsIGNsZWFyIGNoYW5nZSxcclxuICAgICAgICAvLyB3ZSdsbCBkbyAxIHRyaWdnZXIgZm9yIGFsbCBmaWx0ZXJzIGF0IG9uY2UgYWZ0ZXJ3YXJkXHJcbiAgICAgICAgZmlsdGVyLmNsZWFyKGZhbHNlKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gYWxzbyByZXNldCB0aGUgY29sdW1uRmlsdGVycyBvYmplY3QgYW5kIHJlbW92ZSBhbnkgZmlsdGVycyBmcm9tIHRoZSBvYmplY3RcclxuICAgIHRoaXMucmVzZXRDb2x1bW5GaWx0ZXJzKCk7XHJcblxyXG4gICAgLy8gd2UgYWxzbyBuZWVkIHRvIHJlZnJlc2ggdGhlIGRhdGFWaWV3IGFuZCBvcHRpb25hbGx5IHRoZSBncmlkIChpdCdzIG9wdGlvbmFsIHNpbmNlIHdlIHVzZSBEYXRhVmlldylcclxuICAgIGlmICh0aGlzLl9kYXRhVmlldyAmJiB0aGlzLl9ncmlkKSB7XHJcbiAgICAgIHRoaXMuX2RhdGFWaWV3LnJlZnJlc2goKTtcclxuICAgICAgdGhpcy5fZ3JpZC5pbnZhbGlkYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gd2hlbiB1c2luZyBiYWNrZW5kIHNlcnZpY2UsIHdlIG5lZWQgdG8gcXVlcnkgb25seSBvbmNlIHNvIGl0J3MgYmV0dGVyIHRvIGRvIGl0IGhlcmVcclxuICAgIGNvbnN0IGJhY2tlbmRBcGkgPSB0aGlzLl9ncmlkT3B0aW9ucyAmJiB0aGlzLl9ncmlkT3B0aW9ucy5iYWNrZW5kU2VydmljZUFwaTtcclxuICAgIGlmIChiYWNrZW5kQXBpICYmIHRyaWdnZXJDaGFuZ2UpIHtcclxuICAgICAgY29uc3QgY2FsbGJhY2tBcmdzID0geyBjbGVhckZpbHRlclRyaWdnZXJlZDogdHJ1ZSwgc2hvdWxkVHJpZ2dlclF1ZXJ5OiB0cmlnZ2VyQ2hhbmdlLCBncmlkOiB0aGlzLl9ncmlkLCBjb2x1bW5GaWx0ZXJzOiB0aGlzLl9jb2x1bW5GaWx0ZXJzIH07XHJcbiAgICAgIGNvbnN0IHF1ZXJ5UmVzcG9uc2UgPSBiYWNrZW5kQXBpLnNlcnZpY2UucHJvY2Vzc09uRmlsdGVyQ2hhbmdlZCh1bmRlZmluZWQsIGNhbGxiYWNrQXJncyBhcyBGaWx0ZXJDaGFuZ2VkQXJncyk7XHJcbiAgICAgIGlmIChxdWVyeVJlc3BvbnNlIGluc3RhbmNlb2YgUHJvbWlzZSAmJiBxdWVyeVJlc3BvbnNlLnRoZW4pIHtcclxuICAgICAgICAvLyBAZGVwcmVjYXRlZCwgcHJvY2Vzc09uRmlsdGVyQ2hhbmdlZCBpbiB0aGUgZnV0dXJlIHNob3VsZCBiZSByZXR1cm5lZCBhcyBhIHF1ZXJ5IHN0cmluZyBOT1QgYXMgYSBQcm9taXNlXHJcbiAgICAgICAgY29uc29sZS53YXJuKGBbQW5ndWxhci1TbGlja2dyaWRdIHBsZWFzZSBub3RlIHRoYXQgdGhlIFwicHJvY2Vzc09uRmlsdGVyQ2hhbmdlZFwiIGZyb20geW91ciBCYWNrZW5kIFNlcnZpY2UsIHNob3VsZCBub3cgcmV0dXJuIGEgc3RyaW5nIGluc3RlYWQgb2YgYSBQcm9taXNlLlxyXG4gICAgICAgICAgUmV0dXJuaW5nIGEgUHJvbWlzZSB3aWxsIGJlIGRlcHJlY2F0ZWQgaW4gdGhlIGZ1dHVyZS5gKTtcclxuICAgICAgICBxdWVyeVJlc3BvbnNlLnRoZW4oKHF1ZXJ5OiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgIGNvbnN0IHRvdGFsSXRlbXMgPSB0aGlzLl9ncmlkT3B0aW9ucyAmJiB0aGlzLl9ncmlkT3B0aW9ucy5wYWdpbmF0aW9uICYmIHRoaXMuX2dyaWRPcHRpb25zLnBhZ2luYXRpb24udG90YWxJdGVtcztcclxuICAgICAgICAgIGV4ZWN1dGVCYWNrZW5kQ2FsbGJhY2soYmFja2VuZEFwaSwgcXVlcnksIGNhbGxiYWNrQXJncywgbmV3IERhdGUoKSwgdG90YWxJdGVtcywgdGhpcy5lbWl0RmlsdGVyQ2hhbmdlZC5iaW5kKHRoaXMpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCBxdWVyeSA9IHF1ZXJ5UmVzcG9uc2UgYXMgc3RyaW5nO1xyXG4gICAgICAgIGNvbnN0IHRvdGFsSXRlbXMgPSB0aGlzLl9ncmlkT3B0aW9ucyAmJiB0aGlzLl9ncmlkT3B0aW9ucy5wYWdpbmF0aW9uICYmIHRoaXMuX2dyaWRPcHRpb25zLnBhZ2luYXRpb24udG90YWxJdGVtcztcclxuICAgICAgICBleGVjdXRlQmFja2VuZENhbGxiYWNrKGJhY2tlbmRBcGksIHF1ZXJ5LCBjYWxsYmFja0FyZ3MsIG5ldyBEYXRlKCksIHRvdGFsSXRlbXMsIHRoaXMuZW1pdEZpbHRlckNoYW5nZWQuYmluZCh0aGlzKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBlbWl0IGFuIGV2ZW50IHdoZW4gZmlsdGVycyBhcmUgYWxsIGNsZWFyZWRcclxuICAgIGlmICh0cmlnZ2VyQ2hhbmdlKSB7XHJcbiAgICAgIHRoaXMub25GaWx0ZXJDbGVhcmVkLm5leHQodHJ1ZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogTG9jYWwgR3JpZCBGaWx0ZXIgc2VhcmNoICovXHJcbiAgY3VzdG9tTG9jYWxGaWx0ZXIoaXRlbTogYW55LCBhcmdzOiBhbnkpOiBib29sZWFuIHtcclxuICAgIGNvbnN0IGRhdGFWaWV3ID0gYXJncyAmJiBhcmdzLmRhdGFWaWV3O1xyXG4gICAgY29uc3QgZ3JpZCA9IGFyZ3MgJiYgYXJncy5ncmlkO1xyXG4gICAgY29uc3QgaXNHcmlkV2l0aFRyZWVEYXRhID0gdGhpcy5fZ3JpZE9wdGlvbnMgJiYgdGhpcy5fZ3JpZE9wdGlvbnMuZW5hYmxlVHJlZURhdGEgfHwgZmFsc2U7XHJcbiAgICBjb25zdCBjb2x1bW5GaWx0ZXJzID0gYXJncyAmJiBhcmdzLmNvbHVtbkZpbHRlcnMgfHwge307XHJcbiAgICBsZXQgdHJlZURhdGFPcHRpb25zO1xyXG5cclxuICAgIC8vIHdoZW4gdGhlIGNvbHVtbiBpcyBhIFRyZWUgRGF0YSBzdHJ1Y3R1cmUgYW5kIHRoZSBwYXJlbnQgaXMgY29sbGFwc2VkLCB3ZSB3b24ndCBnbyBmdXJ0aGVyIGFuZCBqdXN0IGNvbnRpbnVlIHdpdGggbmV4dCByb3dcclxuICAgIC8vIHNvIHdlIGFsd2F5cyBydW4gdGhpcyBjaGVjayBldmVuIHdoZW4gdGhlcmUgYXJlIG5vIGZpbHRlciBzZWFyY2gsIHRoZSByZWFzb24gaXMgYmVjYXVzZSB0aGUgdXNlciBtaWdodCBjbGljayBvbiB0aGUgZXhwYW5kL2NvbGxhcHNlXHJcbiAgICBpZiAoaXNHcmlkV2l0aFRyZWVEYXRhICYmIHRoaXMuX2dyaWRPcHRpb25zICYmIHRoaXMuX2dyaWRPcHRpb25zLnRyZWVEYXRhT3B0aW9ucykge1xyXG4gICAgICB0cmVlRGF0YU9wdGlvbnMgPSB0aGlzLl9ncmlkT3B0aW9ucy50cmVlRGF0YU9wdGlvbnM7XHJcbiAgICAgIGNvbnN0IGNvbGxhcHNlZFByb3BOYW1lID0gdHJlZURhdGFPcHRpb25zLmNvbGxhcHNlZFByb3BOYW1lIHx8ICdfX2NvbGxhcHNlZCc7XHJcbiAgICAgIGNvbnN0IHBhcmVudFByb3BOYW1lID0gdHJlZURhdGFPcHRpb25zLnBhcmVudFByb3BOYW1lIHx8ICdfX3BhcmVudElkJztcclxuICAgICAgY29uc3QgZGF0YVZpZXdJZElkZW50aWZpZXIgPSB0aGlzLl9ncmlkT3B0aW9ucy5kYXRhc2V0SWRQcm9wZXJ0eU5hbWUgfHwgJ2lkJztcclxuXHJcbiAgICAgIGlmIChpdGVtW3BhcmVudFByb3BOYW1lXSAhPT0gbnVsbCkge1xyXG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLl9kYXRhVmlldy5nZXRJdGVtQnlJZChpdGVtW3BhcmVudFByb3BOYW1lXSk7XHJcbiAgICAgICAgd2hpbGUgKHBhcmVudCkge1xyXG4gICAgICAgICAgaWYgKHBhcmVudFtjb2xsYXBzZWRQcm9wTmFtZV0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBkb24ndCBkaXNwbGF5IGFueSByb3cgdGhhdCBoYXZlIHRoZWlyIHBhcmVudCBjb2xsYXBzZWRcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHBhcmVudCA9IHRoaXMuX2RhdGFWaWV3LmdldEl0ZW1CeUlkKHBhcmVudFtwYXJlbnRQcm9wTmFtZV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gZmlsdGVyIG91dCBhbnkgcm93IGl0ZW1zIHRoYXQgYXJlbid0IHBhcnQgb2Ygb3VyIHByZS1wcm9jZXNzZWQgXCJwcmVGaWx0ZXJUcmVlRGF0YSgpXCIgcmVzdWx0XHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuX3RtcFByZUZpbHRlcmVkRGF0YSkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdG1wUHJlRmlsdGVyZWREYXRhLmluY2x1ZGVzKGl0ZW1bZGF0YVZpZXdJZElkZW50aWZpZXJdKTsgLy8gcmV0dXJuIHRydWUgd2hlbiBmb3VuZCwgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmICh0eXBlb2YgY29sdW1uRmlsdGVycyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGNvbHVtbklkIG9mIE9iamVjdC5rZXlzKGNvbHVtbkZpbHRlcnMpKSB7XHJcbiAgICAgICAgICBjb25zdCBjb2x1bW5GaWx0ZXIgPSBjb2x1bW5GaWx0ZXJzW2NvbHVtbklkXSBhcyBDb2x1bW5GaWx0ZXI7XHJcbiAgICAgICAgICBjb25zdCBjb25kaXRpb25PcHRpb25zID0gdGhpcy5nZXRGaWx0ZXJDb25kaXRpb25PcHRpb25zT3JCb29sZWFuKGl0ZW0sIGNvbHVtbkZpbHRlciwgY29sdW1uSWQsIGdyaWQsIGRhdGFWaWV3KTtcclxuICAgICAgICAgIGlmICh0eXBlb2YgY29uZGl0aW9uT3B0aW9ucyA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb25kaXRpb25PcHRpb25zO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmICghRmlsdGVyQ29uZGl0aW9ucy5leGVjdXRlTWFwcGVkQ29uZGl0aW9uKGNvbmRpdGlvbk9wdGlvbnMgYXMgRmlsdGVyQ29uZGl0aW9uT3B0aW9uKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaWYgaXQgcmVhY2hlcyBoZXJlLCB0aGF0IG1lYW5zIHRoZSByb3cgaXMgdmFsaWQgYW5kIHBhc3NlZCBhbGwgZmlsdGVyXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGdldEZpbHRlckNvbmRpdGlvbk9wdGlvbnNPckJvb2xlYW4oaXRlbTogYW55LCBjb2x1bW5GaWx0ZXI6IENvbHVtbkZpbHRlciwgY29sdW1uSWQ6IHN0cmluZyB8IG51bWJlciwgZ3JpZDogYW55LCBkYXRhVmlldzogYW55KTogRmlsdGVyQ29uZGl0aW9uT3B0aW9uIHwgYm9vbGVhbiB7XHJcbiAgICBsZXQgY29sdW1uSW5kZXggPSBncmlkLmdldENvbHVtbkluZGV4KGNvbHVtbklkKSBhcyBudW1iZXI7XHJcbiAgICBsZXQgY29sdW1uRGVmID0gZ3JpZC5nZXRDb2x1bW5zKClbY29sdW1uSW5kZXhdIGFzIENvbHVtbjtcclxuXHJcbiAgICAvLyBpdCBtaWdodCBiZSBhIGhpZGRlbiBjb2x1bW4sIGlmIHNvIGl0IHdvbid0IGJlIHBhcnQgb2YgdGhlIGdldENvbHVtbnMgKGJlY2F1c2UgaXQgd2UgaGlkZSBhIGNvbHVtbiB2aWEgc2V0Q29sdW1ucylcclxuICAgIC8vIHdoZW4gdGhhdCBoYXBwZW5zIHdlIGNhbiB0cnkgdG8gZ2V0IHRoZSBjb2x1bW4gZGVmaW5pdGlvbiBmcm9tIGFsbCBkZWZpbmVkIGNvbHVtbnNcclxuICAgIGlmICghY29sdW1uRGVmICYmIHRoaXMuc2hhcmVkU2VydmljZSAmJiBBcnJheS5pc0FycmF5KHRoaXMuc2hhcmVkU2VydmljZS5hbGxDb2x1bW5zKSkge1xyXG4gICAgICBjb2x1bW5JbmRleCA9IHRoaXMuc2hhcmVkU2VydmljZS5hbGxDb2x1bW5zLmZpbmRJbmRleCgoY29sKSA9PiBjb2wuZmllbGQgPT09IGNvbHVtbklkKTtcclxuICAgICAgY29sdW1uRGVmID0gdGhpcy5zaGFyZWRTZXJ2aWNlLmFsbENvbHVtbnNbY29sdW1uSW5kZXhdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGlmIHdlIHN0aWxsIGRvbid0IGhhdmUgYSBjb2x1bW4gZGVmaW5pdGlvbiB0aGVuIHdlIHNob3VsZCByZXR1cm4gdGhlbiByb3cgYW55d2F5ICh0cnVlKVxyXG4gICAgaWYgKCFjb2x1bW5EZWYpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUm93IERldGFpbCBWaWV3IHBsdWdpbiwgaWYgdGhlIHJvdyBpcyBwYWRkaW5nIHdlIGp1c3QgZ2V0IHRoZSB2YWx1ZSB3ZSdyZSBmaWx0ZXJpbmcgb24gZnJvbSBpdCdzIHBhcmVudFxyXG4gICAgaWYgKHRoaXMuX2dyaWRPcHRpb25zLmVuYWJsZVJvd0RldGFpbFZpZXcpIHtcclxuICAgICAgY29uc3QgbWV0YWRhdGFQcmVmaXggPSB0aGlzLl9ncmlkT3B0aW9ucy5yb3dEZXRhaWxWaWV3ICYmIHRoaXMuX2dyaWRPcHRpb25zLnJvd0RldGFpbFZpZXcua2V5UHJlZml4IHx8ICdfXyc7XHJcbiAgICAgIGlmIChpdGVtW2Ake21ldGFkYXRhUHJlZml4fWlzUGFkZGluZ2BdICYmIGl0ZW1bYCR7bWV0YWRhdGFQcmVmaXh9cGFyZW50YF0pIHtcclxuICAgICAgICBpdGVtID0gaXRlbVtgJHttZXRhZGF0YVByZWZpeH1wYXJlbnRgXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRhdGFLZXkgPSBjb2x1bW5EZWYuZGF0YUtleTtcclxuICAgIGxldCBxdWVyeUZpZWxkTmFtZSA9IChjb2x1bW5EZWYuZmlsdGVyICYmIGNvbHVtbkRlZi5maWx0ZXIucXVlcnlGaWVsZCkgfHwgY29sdW1uRGVmLnF1ZXJ5RmllbGRGaWx0ZXIgfHwgY29sdW1uRGVmLnF1ZXJ5RmllbGQgfHwgY29sdW1uRGVmLmZpZWxkIHx8ICcnO1xyXG4gICAgaWYgKHR5cGVvZiBjb2x1bW5EZWYucXVlcnlGaWVsZE5hbWVHZXR0ZXJGbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBxdWVyeUZpZWxkTmFtZSA9IGNvbHVtbkRlZi5xdWVyeUZpZWxkTmFtZUdldHRlckZuKGl0ZW0pO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZmllbGRUeXBlID0gKGNvbHVtbkRlZi5maWx0ZXIgJiYgY29sdW1uRGVmLmZpbHRlci50eXBlKSB8fCBjb2x1bW5EZWYudHlwZSB8fCBGaWVsZFR5cGUuc3RyaW5nO1xyXG4gICAgY29uc3QgZmlsdGVyU2VhcmNoVHlwZSA9IChjb2x1bW5EZWYuZmlsdGVyU2VhcmNoVHlwZSkgPyBjb2x1bW5EZWYuZmlsdGVyU2VhcmNoVHlwZSA6IG51bGw7XHJcbiAgICBsZXQgY2VsbFZhbHVlID0gaXRlbVtxdWVyeUZpZWxkTmFtZV07XHJcblxyXG4gICAgLy8gd2hlbiBpdGVtIGlzIGEgY29tcGxleCBvYmplY3QgKGRvdCBcIi5cIiBub3RhdGlvbiksIHdlIG5lZWQgdG8gZmlsdGVyIHRoZSB2YWx1ZSBjb250YWluZWQgaW4gdGhlIG9iamVjdCB0cmVlXHJcbiAgICBpZiAocXVlcnlGaWVsZE5hbWUgJiYgcXVlcnlGaWVsZE5hbWUuaW5kZXhPZignLicpID49IDApIHtcclxuICAgICAgY2VsbFZhbHVlID0gZ2V0RGVzY2VuZGFudFByb3BlcnR5KGl0ZW0sIHF1ZXJ5RmllbGROYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBpZiB3ZSBmaW5kIHNlYXJjaFRlcm1zIHVzZSB0aGVtIGJ1dCBtYWtlIGEgZGVlcCBjb3B5IHNvIHRoYXQgd2UgZG9uJ3QgYWZmZWN0IG9yaWdpbmFsIGFycmF5XHJcbiAgICAvLyB3ZSBtaWdodCBoYXZlIHRvIG92ZXJ3cml0ZSB0aGUgdmFsdWUocykgbG9jYWxseSB0aGF0IGFyZSByZXR1cm5lZFxyXG4gICAgLy8gZS5nOiB3ZSBkb24ndCB3YW50IHRvIG9wZXJhdG9yIHdpdGhpbiB0aGUgc2VhcmNoIHZhbHVlLCBzaW5jZSBpdCB3aWxsIGZhaWwgZmlsdGVyIGNvbmRpdGlvbiBjaGVjayB0cmlnZ2VyIGFmdGVyd2FyZFxyXG4gICAgY29uc3Qgc2VhcmNoVmFsdWVzOiBTZWFyY2hUZXJtW10gPSAoY29sdW1uRmlsdGVyICYmIGNvbHVtbkZpbHRlci5zZWFyY2hUZXJtcykgPyAkLmV4dGVuZCh0cnVlLCBbXSwgY29sdW1uRmlsdGVyLnNlYXJjaFRlcm1zKSA6IFtdO1xyXG4gICAgbGV0IGZpZWxkU2VhcmNoVmFsdWUgPSAoQXJyYXkuaXNBcnJheShzZWFyY2hWYWx1ZXMpICYmIHNlYXJjaFZhbHVlcy5sZW5ndGggPT09IDEpID8gc2VhcmNoVmFsdWVzWzBdIDogJyc7XHJcblxyXG4gICAgbGV0IG1hdGNoZXMgPSBudWxsO1xyXG4gICAgaWYgKGZpZWxkVHlwZSAhPT0gRmllbGRUeXBlLm9iamVjdCkge1xyXG4gICAgICBmaWVsZFNlYXJjaFZhbHVlID0gJycgKyBmaWVsZFNlYXJjaFZhbHVlOyAvLyBtYWtlIHN1cmUgaXQncyBhIHN0cmluZ1xyXG4gICAgICBtYXRjaGVzID0gZmllbGRTZWFyY2hWYWx1ZS5tYXRjaCgvXihbPD4hPVxcKl17MCwyfSkoLipbXjw+IT1cXCpdKShbXFwqXT8pJC8pOyAvLyBncm91cCAxOiBPcGVyYXRvciwgMjogc2VhcmNoVmFsdWUsIDM6IGxhc3QgY2hhciBpcyAnKicgKG1lYW5pbmcgc3RhcnRzIHdpdGgsIGV4LjogYWJjKilcclxuICAgIH1cclxuXHJcbiAgICBsZXQgb3BlcmF0b3IgPSBjb2x1bW5GaWx0ZXIub3BlcmF0b3IgfHwgKChtYXRjaGVzKSA/IG1hdGNoZXNbMV0gOiAnJyk7XHJcbiAgICBjb25zdCBzZWFyY2hUZXJtID0gKCEhbWF0Y2hlcykgPyBtYXRjaGVzWzJdIDogJyc7XHJcbiAgICBjb25zdCBsYXN0VmFsdWVDaGFyID0gKCEhbWF0Y2hlcykgPyBtYXRjaGVzWzNdIDogKG9wZXJhdG9yID09PSAnKnonID8gJyonIDogJycpO1xyXG5cclxuICAgIGlmIChzZWFyY2hWYWx1ZXMgJiYgc2VhcmNoVmFsdWVzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgZmllbGRTZWFyY2hWYWx1ZSA9IHNlYXJjaFZhbHVlcy5qb2luKCcsJyk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBmaWVsZFNlYXJjaFZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAvLyBlc2NhcGluZyB0aGUgc2VhcmNoIHZhbHVlXHJcbiAgICAgIGZpZWxkU2VhcmNoVmFsdWUgPSBmaWVsZFNlYXJjaFZhbHVlLnJlcGxhY2UoYCdgLCBgJydgKTsgLy8gZXNjYXBlIHNpbmdsZSBxdW90ZXMgYnkgZG91YmxpbmcgdGhlbVxyXG4gICAgICBpZiAob3BlcmF0b3IgPT09ICcqJyB8fCBvcGVyYXRvciA9PT0gJ2EqJyB8fCBvcGVyYXRvciA9PT0gJyp6JyB8fCBsYXN0VmFsdWVDaGFyID09PSAnKicpIHtcclxuICAgICAgICBvcGVyYXRvciA9IChvcGVyYXRvciA9PT0gJyonIHx8IG9wZXJhdG9yID09PSAnKnonKSA/IE9wZXJhdG9yVHlwZS5lbmRzV2l0aCA6IE9wZXJhdG9yVHlwZS5zdGFydHNXaXRoO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gbm8gbmVlZCB0byBxdWVyeSBpZiBzZWFyY2ggdmFsdWUgaXMgZW1wdHkgb3IgaWYgdGhlIHNlYXJjaCB2YWx1ZSBpcyBpbiBmYWN0IGVxdWFsIHRvIHRoZSBvcGVyYXRvclxyXG4gICAgaWYgKHNlYXJjaFRlcm0gPT09ICcnICYmICghc2VhcmNoVmFsdWVzIHx8IChBcnJheS5pc0FycmF5KHNlYXJjaFZhbHVlcykgJiYgKHNlYXJjaFZhbHVlcy5sZW5ndGggPT09IDAgfHwgc2VhcmNoVmFsdWVzLmxlbmd0aCA9PT0gMSAmJiBvcGVyYXRvciA9PT0gc2VhcmNoVmFsdWVzWzBdKSkpKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGlmIHNlYXJjaCB2YWx1ZSBoYXMgYSByZWdleCBtYXRjaCB3ZSB3aWxsIG9ubHkga2VlcCB0aGUgdmFsdWUgd2l0aG91dCB0aGUgb3BlcmF0b3JcclxuICAgIC8vIGluIHRoaXMgY2FzZSB3ZSBuZWVkIHRvIG92ZXJ3cml0ZSB0aGUgcmV0dXJuZWQgc2VhcmNoIHZhbHVlcyB0byB0cnVuY2F0ZSBvcGVyYXRvciBmcm9tIHRoZSBzdHJpbmcgc2VhcmNoXHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShtYXRjaGVzKSAmJiBtYXRjaGVzLmxlbmd0aCA+PSAxICYmIChBcnJheS5pc0FycmF5KHNlYXJjaFZhbHVlcykgJiYgc2VhcmNoVmFsdWVzLmxlbmd0aCA9PT0gMSkpIHtcclxuICAgICAgc2VhcmNoVmFsdWVzWzBdID0gc2VhcmNoVGVybTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBmaWx0ZXIgc2VhcmNoIHRlcm1zIHNob3VsZCBhbHdheXMgYmUgc3RyaW5nIHR5cGUgKGV2ZW4gdGhvdWdoIHdlIHBlcm1pdCB0aGUgZW5kIHVzZXIgdG8gaW5wdXQgbnVtYmVycylcclxuICAgIC8vIHNvIG1ha2Ugc3VyZSBlYWNoIHRlcm0gYXJlIHN0cmluZ3MsIGlmIHVzZXIgaGFzIHNvbWUgZGVmYXVsdCBzZWFyY2ggdGVybXMsIHdlIHdpbGwgY2FzdCB0aGVtIHRvIHN0cmluZ1xyXG4gICAgaWYgKHNlYXJjaFZhbHVlcyAmJiBBcnJheS5pc0FycmF5KHNlYXJjaFZhbHVlcykgJiYgZmllbGRUeXBlICE9PSBGaWVsZFR5cGUub2JqZWN0KSB7XHJcbiAgICAgIGZvciAobGV0IGsgPSAwLCBsbiA9IHNlYXJjaFZhbHVlcy5sZW5ndGg7IGsgPCBsbjsgaysrKSB7XHJcbiAgICAgICAgLy8gbWFrZSBzdXJlIGFsbCBzZWFyY2ggdGVybXMgYXJlIHN0cmluZ3NcclxuICAgICAgICBzZWFyY2hWYWx1ZXNba10gPSAoKHNlYXJjaFZhbHVlc1trXSA9PT0gdW5kZWZpbmVkIHx8IHNlYXJjaFZhbHVlc1trXSA9PT0gbnVsbCkgPyAnJyA6IHNlYXJjaFZhbHVlc1trXSkgKyAnJztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHdoZW4gdXNpbmcgbG9jYWxpemF0aW9uIChpMThuKSwgd2Ugc2hvdWxkIHVzZSB0aGUgZm9ybWF0dGVyIG91dHB1dCB0byBzZWFyY2ggYXMgdGhlIG5ldyBjZWxsIHZhbHVlXHJcbiAgICBpZiAoY29sdW1uRGVmICYmIGNvbHVtbkRlZi5wYXJhbXMgJiYgY29sdW1uRGVmLnBhcmFtcy51c2VGb3JtYXR0ZXJPdXB1dFRvRmlsdGVyKSB7XHJcbiAgICAgIGNvbnN0IGlkUHJvcE5hbWUgPSB0aGlzLl9ncmlkT3B0aW9ucy5kYXRhc2V0SWRQcm9wZXJ0eU5hbWUgfHwgJ2lkJztcclxuICAgICAgY29uc3Qgcm93SW5kZXggPSAoZGF0YVZpZXcgJiYgdHlwZW9mIGRhdGFWaWV3LmdldElkeEJ5SWQgPT09ICdmdW5jdGlvbicpID8gZGF0YVZpZXcuZ2V0SWR4QnlJZChpdGVtW2lkUHJvcE5hbWVdKSA6IDA7XHJcbiAgICAgIGNlbGxWYWx1ZSA9IChjb2x1bW5EZWYgJiYgdHlwZW9mIGNvbHVtbkRlZi5mb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpID8gY29sdW1uRGVmLmZvcm1hdHRlcihyb3dJbmRleCwgY29sdW1uSW5kZXgsIGNlbGxWYWx1ZSwgY29sdW1uRGVmLCBpdGVtLCB0aGlzLl9ncmlkKSA6ICcnO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIG1ha2Ugc3VyZSBjZWxsIHZhbHVlIGlzIGFsd2F5cyBhIHN0cmluZ1xyXG4gICAgaWYgKHR5cGVvZiBjZWxsVmFsdWUgPT09ICdudW1iZXInKSB7XHJcbiAgICAgIGNlbGxWYWx1ZSA9IGNlbGxWYWx1ZS50b1N0cmluZygpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGN1cnJlbnRDZWxsVmFsdWUgPSBjZWxsVmFsdWU7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBkYXRhS2V5LFxyXG4gICAgICBmaWVsZFR5cGUsXHJcbiAgICAgIHNlYXJjaFRlcm1zOiBzZWFyY2hWYWx1ZXMsXHJcbiAgICAgIGNlbGxWYWx1ZTogY3VycmVudENlbGxWYWx1ZSxcclxuICAgICAgb3BlcmF0b3I6IG9wZXJhdG9yIGFzIE9wZXJhdG9yU3RyaW5nLFxyXG4gICAgICBjZWxsVmFsdWVMYXN0Q2hhcjogbGFzdFZhbHVlQ2hhcixcclxuICAgICAgZmlsdGVyU2VhcmNoVHlwZVxyXG4gICAgfSBhcyBGaWx0ZXJDb25kaXRpb25PcHRpb247XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBXaGVuIHVzaW5nIFRyZWUgRGF0YSwgd2UgbmVlZCB0byBwcmVmaWx0ZXIgKHNlYXJjaCkgdGhlIGRhdGEgcHJpb3IsIHRoZSByZXN1bHQgd2lsbCBiZSBhbiBhcnJheSBvZiBJRHMgd2hpY2ggYXJlIHRoZSBub2RlKHMpIGFuZCB0aGVpciBwYXJlbnQgbm9kZXMgd2hlbiBuZWNlc3NhcnkuXHJcbiAgICogVGhpcyB3aWxsIHRoZW4gYmUgcGFzc2VkIHRvIHRoZSBEYXRhVmlldyBzZXRGaWx0ZXIoY3VzdG9tTG9jYWxGaWx0ZXIpLCB3aGljaCB3aWxsIGl0c2VsZiBsb29wIHRocm91Z2ggdGhlIGxpc3Qgb2YgSURzIGFuZCBkaXNwbGF5L2hpZGUgdGhlIHJvdyBpZiBmb3VuZCB0aGF0IGFycmF5IG9mIElEc1xyXG4gICAqIFdlIGRvIHRoaXMgaW4gMiBzdGVwcyBzbyB0aGF0IHdlIGNhbiBzdGlsbCB1c2UgdGhlIERhdGFTZXQgc2V0RmlsdGVyKClcclxuICAgKi9cclxuICBwcmVGaWx0ZXJUcmVlRGF0YShpbnB1dEFycmF5OiBhbnlbXSwgY29sdW1uRmlsdGVyczogQ29sdW1uRmlsdGVycykge1xyXG4gICAgY29uc3QgdHJlZURhdGFPcHRpb25zID0gdGhpcy5fZ3JpZE9wdGlvbnMgJiYgdGhpcy5fZ3JpZE9wdGlvbnMudHJlZURhdGFPcHRpb25zO1xyXG4gICAgY29uc3QgcGFyZW50UHJvcE5hbWUgPSB0cmVlRGF0YU9wdGlvbnMgJiYgdHJlZURhdGFPcHRpb25zLnBhcmVudFByb3BOYW1lIHx8ICdfX3BhcmVudElkJztcclxuICAgIGNvbnN0IGRhdGFWaWV3SWRJZGVudGlmaWVyID0gdGhpcy5fZ3JpZE9wdGlvbnMgJiYgdGhpcy5fZ3JpZE9wdGlvbnMuZGF0YXNldElkUHJvcGVydHlOYW1lIHx8ICdpZCc7XHJcblxyXG4gICAgY29uc3QgdHJlZU9iaiA9IHt9O1xyXG4gICAgY29uc3QgZmlsdGVyZWRDaGlsZHJlbkFuZFBhcmVudHM6IGFueVtdID0gW107XHJcblxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXRBcnJheSkpIHtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dEFycmF5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdHJlZU9ialtpbnB1dEFycmF5W2ldW2RhdGFWaWV3SWRJZGVudGlmaWVyXV0gPSBpbnB1dEFycmF5W2ldO1xyXG4gICAgICAgIC8vIGFzIHRoZSBmaWx0ZXJlZCBkYXRhIGlzIHRoZW4gdXNlZCBhZ2FpbiBhcyBlYWNoIHN1YnNlcXVlbnQgbGV0dGVyXHJcbiAgICAgICAgLy8gd2UgbmVlZCB0byBkZWxldGUgdGhlIC5fX3VzZWQgcHJvcGVydHksIG90aGVyd2lzZSB0aGUgbG9naWMgYmVsb3dcclxuICAgICAgICAvLyBpbiB0aGUgd2hpbGUgbG9vcCAod2hpY2ggY2hlY2tzIGZvciBwYXJlbnRzKSBkb2Vzbid0IHdvcms6XHJcbiAgICAgICAgZGVsZXRlIHRyZWVPYmpbaW5wdXRBcnJheVtpXVtkYXRhVmlld0lkSWRlbnRpZmllcl1dLl9fdXNlZDtcclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dEFycmF5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgaXRlbSA9IGlucHV0QXJyYXlbaV07XHJcbiAgICAgICAgbGV0IG1hdGNoRmlsdGVyID0gdHJ1ZTsgLy8gdmFsaWQgdW50aWwgcHJvdmVuIG90aGVyd2lzZVxyXG5cclxuICAgICAgICAvLyBsb29wIHRocm91Z2ggYWxsIGNvbHVtbiBmaWx0ZXJzIGFuZCBleGVjdXRlIGZpbHRlciBjb25kaXRpb24ocylcclxuICAgICAgICBmb3IgKGNvbnN0IGNvbHVtbklkIG9mIE9iamVjdC5rZXlzKGNvbHVtbkZpbHRlcnMpKSB7XHJcbiAgICAgICAgICBjb25zdCBjb2x1bW5GaWx0ZXIgPSBjb2x1bW5GaWx0ZXJzW2NvbHVtbklkXSBhcyBDb2x1bW5GaWx0ZXI7XHJcbiAgICAgICAgICBjb25zdCBjb25kaXRpb25PcHRpb25SZXN1bHQgPSB0aGlzLmdldEZpbHRlckNvbmRpdGlvbk9wdGlvbnNPckJvb2xlYW4oaXRlbSwgY29sdW1uRmlsdGVyLCBjb2x1bW5JZCwgdGhpcy5fZ3JpZCwgdGhpcy5fZGF0YVZpZXcpO1xyXG5cclxuICAgICAgICAgIGlmIChjb25kaXRpb25PcHRpb25SZXN1bHQpIHtcclxuICAgICAgICAgICAgY29uc3QgY29uZGl0aW9uUmVzdWx0ID0gKHR5cGVvZiBjb25kaXRpb25PcHRpb25SZXN1bHQgPT09ICdib29sZWFuJykgPyBjb25kaXRpb25PcHRpb25SZXN1bHQgOiBGaWx0ZXJDb25kaXRpb25zLmV4ZWN1dGVNYXBwZWRDb25kaXRpb24oY29uZGl0aW9uT3B0aW9uUmVzdWx0IGFzIEZpbHRlckNvbmRpdGlvbk9wdGlvbik7XHJcbiAgICAgICAgICAgIGlmIChjb25kaXRpb25SZXN1bHQpIHtcclxuICAgICAgICAgICAgICAvLyBkb24ndCByZXR1cm4gdHJ1ZSBzaW5jZSB3ZSBzdGlsbCBuZWVkIHRvIGNoZWNrIG90aGVyIGtleXMgaW4gY29sdW1uRmlsdGVyc1xyXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBtYXRjaEZpbHRlciA9IGZhbHNlO1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBidWlsZCBhbiBhcnJheSBmcm9tIHRoZSBtYXRjaGVkIGZpbHRlcnMsIGFueXRoaW5nIHZhbGlkIGZyb20gZmlsdGVyIGNvbmRpdGlvblxyXG4gICAgICAgIC8vIHdpbGwgYmUgcHVzaGVkIHRvIHRoZSBmaWx0ZXJlZENoaWxkcmVuQW5kUGFyZW50cyBhcnJheVxyXG4gICAgICAgIGlmIChtYXRjaEZpbHRlcikge1xyXG4gICAgICAgICAgY29uc3QgbGVuID0gZmlsdGVyZWRDaGlsZHJlbkFuZFBhcmVudHMubGVuZ3RoO1xyXG4gICAgICAgICAgLy8gYWRkIGNoaWxkIChpZCk6XHJcbiAgICAgICAgICBmaWx0ZXJlZENoaWxkcmVuQW5kUGFyZW50cy5zcGxpY2UobGVuLCAwLCBpdGVtW2RhdGFWaWV3SWRJZGVudGlmaWVyXSk7XHJcbiAgICAgICAgICBsZXQgcGFyZW50ID0gdHJlZU9ialtpdGVtW3BhcmVudFByb3BOYW1lXV0gfHwgZmFsc2U7XHJcbiAgICAgICAgICB3aGlsZSAocGFyZW50KSB7XHJcbiAgICAgICAgICAgIC8vIG9ubHkgYWRkIHBhcmVudCAoaWQpIGlmIG5vdCBhbHJlYWR5IGFkZGVkOlxyXG4gICAgICAgICAgICBwYXJlbnQuX191c2VkIHx8IGZpbHRlcmVkQ2hpbGRyZW5BbmRQYXJlbnRzLnNwbGljZShsZW4sIDAsIHBhcmVudFtkYXRhVmlld0lkSWRlbnRpZmllcl0pO1xyXG4gICAgICAgICAgICAvLyBtYXJrIGVhY2ggcGFyZW50IGFzIHVzZWQgdG8gbm90IHVzZSB0aGVtIGFnYWluIGxhdGVyOlxyXG4gICAgICAgICAgICB0cmVlT2JqW3BhcmVudFtkYXRhVmlld0lkSWRlbnRpZmllcl1dLl9fdXNlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIC8vIHRyeSB0byBmaW5kIHBhcmVudCBvZiB0aGUgY3VycmVudCBwYXJlbnQsIGlmIGV4aXN0czpcclxuICAgICAgICAgICAgcGFyZW50ID0gdHJlZU9ialtwYXJlbnRbcGFyZW50UHJvcE5hbWVdXSB8fCBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmaWx0ZXJlZENoaWxkcmVuQW5kUGFyZW50cztcclxuICB9XHJcblxyXG4gIGdldENvbHVtbkZpbHRlcnMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fY29sdW1uRmlsdGVycztcclxuICB9XHJcblxyXG4gIGdldEZpbHRlcnNNZXRhZGF0YSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9maWx0ZXJzTWV0YWRhdGE7XHJcbiAgfVxyXG5cclxuICBnZXRDdXJyZW50TG9jYWxGaWx0ZXJzKCk6IEN1cnJlbnRGaWx0ZXJbXSB7XHJcbiAgICBjb25zdCBjdXJyZW50RmlsdGVyczogQ3VycmVudEZpbHRlcltdID0gW107XHJcbiAgICBpZiAodGhpcy5fY29sdW1uRmlsdGVycykge1xyXG4gICAgICBmb3IgKGNvbnN0IGNvbElkIG9mIE9iamVjdC5rZXlzKHRoaXMuX2NvbHVtbkZpbHRlcnMpKSB7XHJcbiAgICAgICAgY29uc3QgY29sdW1uRmlsdGVyID0gdGhpcy5fY29sdW1uRmlsdGVyc1tjb2xJZF07XHJcbiAgICAgICAgY29uc3QgZmlsdGVyID0geyBjb2x1bW5JZDogY29sSWQgfHwgJycgfSBhcyBDdXJyZW50RmlsdGVyO1xyXG5cclxuICAgICAgICBpZiAoY29sdW1uRmlsdGVyICYmIGNvbHVtbkZpbHRlci5zZWFyY2hUZXJtcykge1xyXG4gICAgICAgICAgZmlsdGVyLnNlYXJjaFRlcm1zID0gY29sdW1uRmlsdGVyLnNlYXJjaFRlcm1zO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29sdW1uRmlsdGVyLm9wZXJhdG9yKSB7XHJcbiAgICAgICAgICBmaWx0ZXIub3BlcmF0b3IgPSBjb2x1bW5GaWx0ZXIub3BlcmF0b3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpbHRlci5zZWFyY2hUZXJtcykgJiYgZmlsdGVyLnNlYXJjaFRlcm1zLmxlbmd0aCA+IDAgJiYgZmlsdGVyLnNlYXJjaFRlcm1zWzBdICE9PSAnJykge1xyXG4gICAgICAgICAgY3VycmVudEZpbHRlcnMucHVzaChmaWx0ZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGN1cnJlbnRGaWx0ZXJzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQSBzaW1wbGUgZnVuY3Rpb24gdGhhdCBpcyBiaW5kZWQgdG8gdGhlIHN1YnNjcmliZXIgYW5kIGVtaXQgYSBjaGFuZ2Ugd2hlbiB0aGUgZmlsdGVyIGlzIGNhbGxlZC5cclxuICAgKiBPdGhlciBzZXJ2aWNlcywgbGlrZSBQYWdpbmF0aW9uLCBjYW4gdGhlbiBzdWJzY3JpYmUgdG8gaXQuXHJcbiAgICogQHBhcmFtIGNhbGxlclxyXG4gICAqL1xyXG4gIGVtaXRGaWx0ZXJDaGFuZ2VkKGNhbGxlcjogRW1pdHRlclR5cGUpIHtcclxuICAgIGlmIChjYWxsZXIgPT09IEVtaXR0ZXJUeXBlLnJlbW90ZSAmJiB0aGlzLl9ncmlkT3B0aW9ucyAmJiB0aGlzLl9ncmlkT3B0aW9ucy5iYWNrZW5kU2VydmljZUFwaSkge1xyXG4gICAgICBsZXQgY3VycmVudEZpbHRlcnM6IEN1cnJlbnRGaWx0ZXJbXSA9IFtdO1xyXG4gICAgICBjb25zdCBiYWNrZW5kU2VydmljZSA9IHRoaXMuX2dyaWRPcHRpb25zLmJhY2tlbmRTZXJ2aWNlQXBpLnNlcnZpY2U7XHJcbiAgICAgIGlmIChiYWNrZW5kU2VydmljZSAmJiBiYWNrZW5kU2VydmljZS5nZXRDdXJyZW50RmlsdGVycykge1xyXG4gICAgICAgIGN1cnJlbnRGaWx0ZXJzID0gYmFja2VuZFNlcnZpY2UuZ2V0Q3VycmVudEZpbHRlcnMoKSBhcyBDdXJyZW50RmlsdGVyW107XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5vbkZpbHRlckNoYW5nZWQubmV4dChjdXJyZW50RmlsdGVycyk7XHJcbiAgICB9IGVsc2UgaWYgKGNhbGxlciA9PT0gRW1pdHRlclR5cGUubG9jYWwpIHtcclxuICAgICAgdGhpcy5vbkZpbHRlckNoYW5nZWQubmV4dCh0aGlzLmdldEN1cnJlbnRMb2NhbEZpbHRlcnMoKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBvbkJhY2tlbmRGaWx0ZXJDaGFuZ2UoZXZlbnQ6IEtleWJvYXJkRXZlbnQsIGFyZ3M6IGFueSkge1xyXG4gICAgaWYgKCFhcmdzIHx8ICFhcmdzLmdyaWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTb21ldGhpbmcgd2VudCB3cm9uZyB3aGVuIHRyeWluZyB0byBiaW5kIHRoZSBcIm9uQmFja2VuZEZpbHRlckNoYW5nZShldmVudCwgYXJncylcIiBmdW5jdGlvbiwgaXQgc2VlbXMgdGhhdCBcImFyZ3NcIiBpcyBub3QgcG9wdWxhdGVkIGNvcnJlY3RseScpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNvbnN0IGdyaWRPcHRpb25zOiBHcmlkT3B0aW9uID0gKGFyZ3MuZ3JpZCAmJiBhcmdzLmdyaWQuZ2V0T3B0aW9ucykgPyBhcmdzLmdyaWQuZ2V0T3B0aW9ucygpIDoge307XHJcbiAgICBjb25zdCBiYWNrZW5kQXBpID0gdGhpcy5fZ3JpZE9wdGlvbnMuYmFja2VuZFNlcnZpY2VBcGk7XHJcblxyXG4gICAgaWYgKCFiYWNrZW5kQXBpIHx8ICFiYWNrZW5kQXBpLnByb2Nlc3MgfHwgIWJhY2tlbmRBcGkuc2VydmljZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEJhY2tlbmRTZXJ2aWNlQXBpIHJlcXVpcmVzIGF0IGxlYXN0IGEgXCJwcm9jZXNzXCIgZnVuY3Rpb24gYW5kIGEgXCJzZXJ2aWNlXCIgZGVmaW5lZGApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGtlZXAgc3RhcnQgdGltZSAmIGVuZCB0aW1lc3RhbXBzICYgcmV0dXJuIGl0IGFmdGVyIHByb2Nlc3MgZXhlY3V0aW9uXHJcbiAgICBjb25zdCBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpO1xyXG5cclxuICAgIC8vIHJ1biBhIHByZVByb2Nlc3MgY2FsbGJhY2sgaWYgZGVmaW5lZFxyXG4gICAgaWYgKGJhY2tlbmRBcGkucHJlUHJvY2Vzcykge1xyXG4gICAgICBiYWNrZW5kQXBpLnByZVByb2Nlc3MoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBvbmx5IGFkZCBhIGRlbGF5IHdoZW4gdXNlciBpcyB0eXBpbmcsIG9uIHNlbGVjdCBkcm9wZG93biBmaWx0ZXIgKG9yIFwiQ2xlYXIgRmlsdGVyXCIpIGl0IHdpbGwgZXhlY3V0ZSByaWdodCBhd2F5XHJcbiAgICBsZXQgZGVib3VuY2VUeXBpbmdEZWxheSA9IDA7XHJcbiAgICBjb25zdCBpc1RyaWdnZXJlZEJ5Q2xlYXJGaWx0ZXIgPSBhcmdzICYmIGFyZ3MuY2xlYXJGaWx0ZXJUcmlnZ2VyZWQ7IC8vIHdhcyBpdCB0cmlnZ2VyIGJ5IGEgXCJDbGVhciBGaWx0ZXJcIiBjb21tYW5kP1xyXG5cclxuICAgIGNvbnN0IGV2ZW50VHlwZSA9IGV2ZW50ICYmIGV2ZW50LnR5cGU7XHJcbiAgICBjb25zdCBldmVudEtleUNvZGUgPSBldmVudCAmJiBldmVudC5rZXlDb2RlO1xyXG4gICAgaWYgKCFpc1RyaWdnZXJlZEJ5Q2xlYXJGaWx0ZXIgJiYgZXZlbnRLZXlDb2RlICE9PSBLZXlDb2RlLkVOVEVSICYmIChldmVudFR5cGUgPT09ICdpbnB1dCcgfHwgZXZlbnRUeXBlID09PSAna2V5dXAnIHx8IGV2ZW50VHlwZSA9PT0gJ2tleWRvd24nKSkge1xyXG4gICAgICBkZWJvdW5jZVR5cGluZ0RlbGF5ID0gYmFja2VuZEFwaS5oYXNPd25Qcm9wZXJ0eSgnZmlsdGVyVHlwaW5nRGVib3VuY2UnKSA/IGJhY2tlbmRBcGkuZmlsdGVyVHlwaW5nRGVib3VuY2UgYXMgbnVtYmVyIDogREVGQVVMVF9GSUxURVJfVFlQSU5HX0RFQk9VTkNFO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHF1ZXJ5IGJhY2tlbmQsIGV4Y2VwdCB3aGVuIGl0J3MgY2FsbGVkIGJ5IGEgQ2xlYXJGaWx0ZXJzIHRoZW4gd2Ugd29uJ3RcclxuICAgIGlmIChhcmdzICYmIGFyZ3Muc2hvdWxkVHJpZ2dlclF1ZXJ5KSB7XHJcbiAgICAgIC8vIGNhbGwgdGhlIHNlcnZpY2UgdG8gZ2V0IGEgcXVlcnkgYmFja1xyXG4gICAgICAvLyBAZGVwcmVjYXRlZCBUT0RPOiByZW1vdmUgYXN5bmMvYXdhaXQgb24gbmV4dCBtYWpvciBjaGFuZ2UsIHJlZmVyIHRvIHByb2Nlc3NPbkZpbHRlckNoYW5nZWQgaW4gQmFja2VuZFNlcnZpY2UgaW50ZXJmYWNlICh3aXRoIEBkZXByZWNhdGVkKVxyXG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xyXG4gICAgICBpZiAoZGVib3VuY2VUeXBpbmdEZWxheSA+IDApIHtcclxuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgY29uc3QgcXVlcnkgPSBhd2FpdCBiYWNrZW5kQXBpLnNlcnZpY2UucHJvY2Vzc09uRmlsdGVyQ2hhbmdlZChldmVudCwgYXJncyk7XHJcbiAgICAgICAgICBjb25zdCB0b3RhbEl0ZW1zID0gdGhpcy5fZ3JpZE9wdGlvbnMgJiYgdGhpcy5fZ3JpZE9wdGlvbnMucGFnaW5hdGlvbiAmJiB0aGlzLl9ncmlkT3B0aW9ucy5wYWdpbmF0aW9uLnRvdGFsSXRlbXM7XHJcbiAgICAgICAgICBleGVjdXRlQmFja2VuZENhbGxiYWNrKGJhY2tlbmRBcGksIHF1ZXJ5LCBhcmdzLCBzdGFydFRpbWUsIHRvdGFsSXRlbXMsIHRoaXMuZW1pdEZpbHRlckNoYW5nZWQuYmluZCh0aGlzKSwgdGhpcy5odHRwQ2FuY2VsUmVxdWVzdHMkKTtcclxuICAgICAgICB9LCBkZWJvdW5jZVR5cGluZ0RlbGF5KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCBxdWVyeSA9IGF3YWl0IGJhY2tlbmRBcGkuc2VydmljZS5wcm9jZXNzT25GaWx0ZXJDaGFuZ2VkKGV2ZW50LCBhcmdzKTtcclxuICAgICAgICBjb25zdCB0b3RhbEl0ZW1zID0gdGhpcy5fZ3JpZE9wdGlvbnMgJiYgdGhpcy5fZ3JpZE9wdGlvbnMucGFnaW5hdGlvbiAmJiB0aGlzLl9ncmlkT3B0aW9ucy5wYWdpbmF0aW9uLnRvdGFsSXRlbXM7XHJcbiAgICAgICAgZXhlY3V0ZUJhY2tlbmRDYWxsYmFjayhiYWNrZW5kQXBpLCBxdWVyeSwgYXJncywgc3RhcnRUaW1lLCB0b3RhbEl0ZW1zLCB0aGlzLmVtaXRGaWx0ZXJDaGFuZ2VkLmJpbmQodGhpcyksIHRoaXMuaHR0cENhbmNlbFJlcXVlc3RzJCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFdoZW4gdXNlciBwYXNzZXMgYW4gYXJyYXkgb2YgcHJlc2V0IGZpbHRlcnMsIHdlIG5lZWQgdG8gcHJlLXBvcHVsYXRlIGVhY2ggY29sdW1uIGZpbHRlciBzZWFyY2hUZXJtKHMpXHJcbiAgICogVGhlIHByb2Nlc3MgaXMgdG8gbG9vcCB0aHJvdWdoIHRoZSBwcmVzZXQgZmlsdGVycyBhcnJheSwgZmluZCB0aGUgYXNzb2NpYXRlZCBjb2x1bW4gZnJvbSBjb2x1bW5EZWZpbml0aW9ucyBhbmQgZmlsbCBpbiB0aGUgZmlsdGVyIG9iamVjdCBzZWFyY2hUZXJtKHMpXHJcbiAgICogVGhpcyBpcyBiYXNpY2FsbHkgdGhlIHNhbWUgYXMgaWYgd2Ugd291bGQgbWFudWFsbHkgYWRkIHNlYXJjaFRlcm0ocykgdG8gYSBjb2x1bW4gZmlsdGVyIG9iamVjdCBpbiB0aGUgY29sdW1uIGRlZmluaXRpb24sIGJ1dCB3ZSBkbyBpdCBwcm9ncmFtbWF0aWNhbGx5LlxyXG4gICAqIEF0IHRoZSBlbmQgb2YgdGhlIGRheSwgd2hlbiBjcmVhdGluZyB0aGUgRmlsdGVyIChET00gRWxlbWVudCksIGl0IHdpbGwgdXNlIHRoZXNlIHNlYXJjaFRlcm0ocykgc28gd2UgY2FuIHRha2UgYWR2YW50YWdlIG9mIHRoYXQgd2l0aG91dCByZWNvZGluZyBlYWNoIEZpbHRlciB0eXBlIChET00gZWxlbWVudClcclxuICAgKi9cclxuICBwb3B1bGF0ZUNvbHVtbkZpbHRlclNlYXJjaFRlcm1QcmVzZXRzKGZpbHRlcnM6IEN1cnJlbnRGaWx0ZXJbXSkge1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZmlsdGVycykgJiYgZmlsdGVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIHRoaXMuX2NvbHVtbkRlZmluaXRpb25zLmZvckVhY2goKGNvbHVtbkRlZjogQ29sdW1uKSA9PiB7XHJcbiAgICAgICAgLy8gY2xlYXIgYW55IGNvbHVtbkRlZiBzZWFyY2hUZXJtcyBiZWZvcmUgYXBwbHlpbmcgUHJlc2V0c1xyXG4gICAgICAgIGlmIChjb2x1bW5EZWYuZmlsdGVyICYmIGNvbHVtbkRlZi5maWx0ZXIuc2VhcmNoVGVybXMpIHtcclxuICAgICAgICAgIGRlbGV0ZSBjb2x1bW5EZWYuZmlsdGVyLnNlYXJjaFRlcm1zO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gZnJvbSBlYWNoIHByZXNldHMsIHdlIHdpbGwgZmluZCB0aGUgYXNzb2NpYXRlZCBjb2x1bW5EZWYgYW5kIGFwcGx5IHRoZSBwcmVzZXQgc2VhcmNoVGVybXMgJiBvcGVyYXRvciBpZiB0aGVyZSBpc1xyXG4gICAgICAgIGNvbnN0IGNvbHVtblByZXNldCA9IGZpbHRlcnMuZmluZCgocHJlc2V0RmlsdGVyOiBDdXJyZW50RmlsdGVyKSA9PiBwcmVzZXRGaWx0ZXIuY29sdW1uSWQgPT09IGNvbHVtbkRlZi5pZCk7XHJcbiAgICAgICAgaWYgKGNvbHVtblByZXNldCAmJiBjb2x1bW5QcmVzZXQuc2VhcmNoVGVybXMgJiYgQXJyYXkuaXNBcnJheShjb2x1bW5QcmVzZXQuc2VhcmNoVGVybXMpKSB7XHJcbiAgICAgICAgICBjb2x1bW5EZWYuZmlsdGVyID0gY29sdW1uRGVmLmZpbHRlciB8fCB7fTtcclxuICAgICAgICAgIGNvbHVtbkRlZi5maWx0ZXIub3BlcmF0b3IgPSBjb2x1bW5QcmVzZXQub3BlcmF0b3IgfHwgY29sdW1uRGVmLmZpbHRlci5vcGVyYXRvciB8fCAnJztcclxuICAgICAgICAgIGNvbHVtbkRlZi5maWx0ZXIuc2VhcmNoVGVybXMgPSBjb2x1bW5QcmVzZXQuc2VhcmNoVGVybXM7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIHdoZW4gd2UgaGF2ZSBhIEZpbHRlciBQcmVzZXRzIG9uIGEgVHJlZSBEYXRhIFZpZXcgZ3JpZCwgd2UgbmVlZCB0byBjYWxsIHRoZSBwcmUtZmlsdGVyaW5nIG9mIHRyZWUgZGF0YVxyXG4gICAgICB0aGlzLnJlZnJlc2hUcmVlRGF0YUZpbHRlcnMoKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLl9jb2x1bW5EZWZpbml0aW9ucztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIHdoZW4gd2UgaGF2ZSBhIEZpbHRlciBQcmVzZXRzIG9uIGEgVHJlZSBEYXRhIFZpZXcgZ3JpZCwgd2UgbmVlZCB0byBjYWxsIHRoZSBwcmUtZmlsdGVyaW5nIG9mIHRyZWUgZGF0YVxyXG4gICAqIHdlIG5lZWQgdG8gZG8gdGhpcyBiZWNhdXNlIFRyZWUgRGF0YSBpcyB0aGUgb25seSB0eXBlIG9mIGdyaWQgdGhhdCByZXF1aXJlcyBhIHByZS1maWx0ZXIgKHByZUZpbHRlclRyZWVEYXRhKSB0byBiZSBleGVjdXRlZCBiZWZvcmUgdGhlIGZpbmFsIGZpbHRlcmluZ1xyXG4gICAqIEBwYXJhbSBmaWx0ZXJzXHJcbiAgICovXHJcbiAgcmVmcmVzaFRyZWVEYXRhRmlsdGVycygpIHtcclxuICAgIGlmICh0aGlzLl9kYXRhVmlldyAmJiB0aGlzLl9kYXRhVmlldy5nZXRJdGVtcyAmJiB0aGlzLl9ncmlkT3B0aW9ucyAmJiB0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVUcmVlRGF0YSkge1xyXG4gICAgICB0aGlzLl90bXBQcmVGaWx0ZXJlZERhdGEgPSB0aGlzLnByZUZpbHRlclRyZWVEYXRhKHRoaXMuX2RhdGFWaWV3LmdldEl0ZW1zKCksIHRoaXMuX2NvbHVtbkZpbHRlcnMpO1xyXG4gICAgICB0aGlzLl9kYXRhVmlldy5yZWZyZXNoKCk7IC8vIGFuZCBmaW5hbGx5IHRoaXMgcmVmcmVzaCgpIGlzIHdoYXQgdHJpZ2dlcnMgYSBEYXRhVmlldyBmaWx0ZXJpbmcgY2hlY2tcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRvZ2dsZSB0aGUgRmlsdGVyIEZ1bmN0aW9uYWxpdHlcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzRmlsdGVyRGlzYWJsZWQgLSBvcHRpb25hbGx5IGZvcmNlIGEgZGlzYWJsZS9lbmFibGUgb2YgdGhlIFNvcnQgRnVuY3Rpb25hbGl0eT8gRGVmYXVsdHMgdG8gVHJ1ZVxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xlYXJGaWx0ZXJzV2hlbkRpc2FibGVkIC0gd2hlbiBkaXNhYmxpbmcgdGhlIEZpbHRlciwgZG8gd2UgYWxzbyB3YW50IHRvIGNsZWFyIGFsbCB0aGUgZmlsdGVycyBhcyB3ZWxsPyBEZWZhdWx0cyB0byBUcnVlXHJcbiAgICovXHJcbiAgZGlzYWJsZUZpbHRlckZ1bmN0aW9uYWxpdHkoaXNGaWx0ZXJEaXNhYmxlZCA9IHRydWUsIGNsZWFyRmlsdGVyc1doZW5EaXNhYmxlZCA9IHRydWUpIHtcclxuICAgIGNvbnN0IHByZXZTaG93RmlsdGVyRmxhZyA9IHRoaXMuX2dyaWRPcHRpb25zLmVuYWJsZUZpbHRlcmluZztcclxuICAgIGNvbnN0IG5ld1Nob3dGaWx0ZXJGbGFnID0gIXByZXZTaG93RmlsdGVyRmxhZztcclxuXHJcbiAgICBpZiAobmV3U2hvd0ZpbHRlckZsYWcgIT09IGlzRmlsdGVyRGlzYWJsZWQpIHtcclxuICAgICAgaWYgKGNsZWFyRmlsdGVyc1doZW5EaXNhYmxlZCAmJiBpc0ZpbHRlckRpc2FibGVkKSB7XHJcbiAgICAgICAgdGhpcy5jbGVhckZpbHRlcnMoKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmRpc2FibGVBbGxGaWx0ZXJpbmdDb21tYW5kcyhpc0ZpbHRlckRpc2FibGVkKTtcclxuICAgICAgdGhpcy5fZ3JpZC5zZXRPcHRpb25zKHsgZW5hYmxlRmlsdGVyaW5nOiBuZXdTaG93RmlsdGVyRmxhZyB9LCBmYWxzZSwgdHJ1ZSk7XHJcbiAgICAgIHRoaXMuX2dyaWQuc2V0SGVhZGVyUm93VmlzaWJpbGl0eShuZXdTaG93RmlsdGVyRmxhZyk7XHJcbiAgICAgIHRoaXMuX2dyaWRPcHRpb25zLmVuYWJsZUZpbHRlcmluZyA9ICFpc0ZpbHRlckRpc2FibGVkO1xyXG4gICAgICB0aGlzLnNoYXJlZFNlcnZpY2UuZ3JpZE9wdGlvbnMgPSB0aGlzLl9ncmlkT3B0aW9ucztcclxuXHJcbiAgICAgIC8vIHdoZW4gZGlzcGxheWluZyBoZWFkZXIgcm93LCB3ZSdsbCBjYWxsIFwic2V0Q29sdW1uc1wiIHdoaWNoIGluIHRlcm1zIHdpbGwgcmVjcmVhdGUgdGhlIGhlYWRlciByb3cgZmlsdGVyc1xyXG4gICAgICB0aGlzLl9ncmlkLnNldENvbHVtbnModGhpcy5zaGFyZWRTZXJ2aWNlLmNvbHVtbkRlZmluaXRpb25zKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRvZ2dsZSB0aGUgRmlsdGVyIEZ1bmN0aW9uYWxpdHkgKHNob3cvaGlkZSB0aGUgaGVhZGVyIHJvdyBmaWx0ZXIgYmFyIGFzIHdlbGwpXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBjbGVhckZpbHRlcnNXaGVuRGlzYWJsZWQgLSB3aGVuIGRpc2FibGluZyB0aGUgZmlsdGVycywgZG8gd2Ugd2FudCB0byBjbGVhciB0aGUgZmlsdGVycyBiZWZvcmUgaGlkaW5nIHRoZSBmaWx0ZXJzPyBEZWZhdWx0cyB0byBUcnVlXHJcbiAgICovXHJcbiAgdG9nZ2xlRmlsdGVyRnVuY3Rpb25hbGl0eShjbGVhckZpbHRlcnNXaGVuRGlzYWJsZWQgPSB0cnVlKSB7XHJcbiAgICBjb25zdCBwcmV2U2hvd0ZpbHRlckZsYWcgPSB0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVGaWx0ZXJpbmc7XHJcbiAgICB0aGlzLmRpc2FibGVGaWx0ZXJGdW5jdGlvbmFsaXR5KHByZXZTaG93RmlsdGVyRmxhZywgY2xlYXJGaWx0ZXJzV2hlbkRpc2FibGVkKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRvZ2dsZSB0aGUgSGVhZGVyIFJvdyBmaWx0ZXIgYmFyICh0aGlzIGRvZXMgbm90IGRpc2FibGUgdGhlIEZpbHRlcmluZyBpdHNlbGYsIHlvdSBjYW4gdXNlIFwidG9nZ2xlRmlsdGVyRnVuY3Rpb25hbGl0eSgpXCIgaW5zdGVhZCwgaG93ZXZlciB0aGlzIHdpbGwgcmVzZXQgYW55IGNvbHVtbiBwb3NpdGlvbnMpXHJcbiAgICovXHJcbiAgdG9nZ2xlSGVhZGVyRmlsdGVyUm93KCkge1xyXG4gICAgbGV0IHNob3dIZWFkZXJSb3cgPSB0aGlzLl9ncmlkT3B0aW9ucyAmJiB0aGlzLl9ncmlkT3B0aW9ucy5zaG93SGVhZGVyUm93IHx8IGZhbHNlO1xyXG4gICAgc2hvd0hlYWRlclJvdyA9ICFzaG93SGVhZGVyUm93OyAvLyBpbnZlcnNlIHNob3cgaGVhZGVyIGZsYWdcclxuICAgIHRoaXMuX2dyaWQuc2V0SGVhZGVyUm93VmlzaWJpbGl0eShzaG93SGVhZGVyUm93KTtcclxuXHJcbiAgICAvLyB3aGVuIGRpc3BsYXlpbmcgaGVhZGVyIHJvdywgd2UnbGwgY2FsbCBcInNldENvbHVtbnNcIiB3aGljaCBpbiB0ZXJtcyB3aWxsIHJlY3JlYXRlIHRoZSBoZWFkZXIgcm93IGZpbHRlcnNcclxuICAgIGlmIChzaG93SGVhZGVyUm93ID09PSB0cnVlKSB7XHJcbiAgICAgIHRoaXMuX2dyaWQuc2V0Q29sdW1ucyh0aGlzLnNoYXJlZFNlcnZpY2UuY29sdW1uRGVmaW5pdGlvbnMpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHRoZSBzb3J0IGljb25zIGluIHRoZSBVSSAoT05MWSB0aGUgaWNvbnMsIGl0IGRvZXMgbm90IGRvIGFueSBzb3J0aW5nKVxyXG4gICAqIFRoZSBjb2x1bW4gc29ydCBpY29ucyBhcmUgbm90IG5lY2Vzc2FyaWx5IGludGVyLWNvbm5lY3RlZCB0byB0aGUgc29ydGluZyBmdW5jdGlvbmFsaXR5IGl0c2VsZixcclxuICAgKiB5b3UgY2FuIGNoYW5nZSB0aGUgc29ydGluZyBpY29ucyBzZXBhcmF0ZWx5IGJ5IHBhc3NpbmcgYW4gYXJyYXkgb2YgY29sdW1uSWQvc29ydEFzYyBhbmQgdGhhdCB3aWxsIGNoYW5nZSBPTkxZIHRoZSBpY29uc1xyXG4gICAqIEBwYXJhbSBzb3J0Q29sdW1uc1xyXG4gICAqL1xyXG4gIHNldFNvcnRDb2x1bW5JY29ucyhzb3J0Q29sdW1uczogeyBjb2x1bW5JZDogc3RyaW5nLCBzb3J0QXNjOiBib29sZWFuIH1bXSkge1xyXG4gICAgaWYgKHRoaXMuX2dyaWQgJiYgQXJyYXkuaXNBcnJheShzb3J0Q29sdW1ucykpIHtcclxuICAgICAgdGhpcy5fZ3JpZC5zZXRTb3J0Q29sdW1ucyhzb3J0Q29sdW1ucyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgRmlsdGVycyBkeW5hbWljYWxseSBqdXN0IGJ5IHByb3ZpZGluZyBhbiBhcnJheSBvZiBmaWx0ZXIocykuXHJcbiAgICogWW91IGNhbiBhbHNvIGNob29zZSBlbWl0IChkZWZhdWx0KSBhIEZpbHRlciBDaGFuZ2VkIGV2ZW50IHRoYXQgd2lsbCBiZSBwaWNrZWQgYnkgdGhlIEdyaWQgU3RhdGUgU2VydmljZS5cclxuICAgKlxyXG4gICAqIEFsc28gZm9yIGJhY2tlbmQgc2VydmljZSBvbmx5LCB5b3UgY2FuIGNob29zZSB0byB0cmlnZ2VyIGEgYmFja2VuZCBxdWVyeSAoZGVmYXVsdCkgb3Igbm90IGlmIHlvdSB3aXNoIHRvIGRvIGl0IGxhdGVyLFxyXG4gICAqIHRoaXMgY291bGQgYmUgdXNlZnVsIHdoZW4gdXNpbmcgdXBkYXRlRmlsdGVycyAmIHVwZGF0ZVNvcnRpbmcgYW5kIHlvdSB3aXNoIHRvIG9ubHkgc2VuZCB0aGUgYmFja2VuZCBxdWVyeSBvbmNlLlxyXG4gICAqIEBwYXJhbSBmaWx0ZXJzIGFycmF5XHJcbiAgICogQHBhcmFtIHRyaWdnZXJFdmVudCBkZWZhdWx0cyB0byBUcnVlLCBkbyB3ZSB3YW50IHRvIGVtaXQgYSBmaWx0ZXIgY2hhbmdlZCBldmVudD9cclxuICAgKiBAcGFyYW0gdHJpZ2dlckJhY2tlbmRRdWVyeSBkZWZhdWx0cyB0byBUcnVlLCB3aGljaCB3aWxsIHF1ZXJ5IHRoZSBiYWNrZW5kLlxyXG4gICAqL1xyXG4gIHVwZGF0ZUZpbHRlcnMoZmlsdGVyczogQ3VycmVudEZpbHRlcltdLCBlbWl0Q2hhbmdlZEV2ZW50ID0gdHJ1ZSwgdHJpZ2dlckJhY2tlbmRRdWVyeSA9IHRydWUsIHRyaWdnZXJPblNlYXJjaENoYW5nZUV2ZW50ID0gZmFsc2UpIHtcclxuICAgIGlmICghdGhpcy5fZmlsdGVyc01ldGFkYXRhIHx8IHRoaXMuX2ZpbHRlcnNNZXRhZGF0YS5sZW5ndGggPT09IDAgfHwgIXRoaXMuX2dyaWRPcHRpb25zIHx8ICF0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVGaWx0ZXJpbmcpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdbQW5ndWxhci1TbGlja2dyaWRdIGluIG9yZGVyIHRvIHVzZSBcInVwZGF0ZUZpbHRlcnNcIiBtZXRob2QsIHlvdSBuZWVkIHRvIGhhdmUgRmlsdGVyYWJsZSBDb2x1bW5zIGRlZmluZWQgaW4geW91ciBncmlkIGFuZCBcImVuYWJsZUZpbHRlcmluZ1wiIHNldCBpbiB5b3VyIEdyaWQgT3B0aW9ucycpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KGZpbHRlcnMpKSB7XHJcbiAgICAgIC8vIHN0YXJ0IGJ5IGNsZWFyaW5nIGFsbCBmaWx0ZXJzICh3aXRob3V0IHRyaWdnZXJpbmcgYW4gZXZlbnQpIGJlZm9yZSBhcHBseWluZyBhbnkgbmV3IGZpbHRlcnNcclxuICAgICAgdGhpcy5jbGVhckZpbHRlcnMoZmFsc2UpO1xyXG5cclxuICAgICAgLy8gcHJlLWZpbGwgKHZhbHVlICsgb3BlcmF0b3IpIGFuZCByZW5kZXIgYWxsIGZpbHRlcnMgaW4gdGhlIERPTVxyXG4gICAgICAvLyBsb29wIHRocm91Z2ggZWFjaCBGaWx0ZXJzIHByb3ZpZGVkICh3aGljaCBoYXMgYSBjb2x1bW5JZCBwcm9wZXJ0eSlcclxuICAgICAgLy8gdGhlbiBmaW5kIHRoZWlyIGFzc29jaWF0ZWQgRmlsdGVyIGluc3RhbmNlcyB0aGF0IHdlcmUgb3JpZ2luYWxseSBjcmVhdGVkIGluIHRoZSBncmlkXHJcbiAgICAgIGZpbHRlcnMuZm9yRWFjaCgobmV3RmlsdGVyKSA9PiB7XHJcbiAgICAgICAgY29uc3QgdWlGaWx0ZXIgPSB0aGlzLl9maWx0ZXJzTWV0YWRhdGEuZmluZCgoZmlsdGVyKSA9PiBuZXdGaWx0ZXIuY29sdW1uSWQgPT09IGZpbHRlci5jb2x1bW5EZWYuaWQpO1xyXG4gICAgICAgIGlmIChuZXdGaWx0ZXIgJiYgdWlGaWx0ZXIpIHtcclxuICAgICAgICAgIGNvbnN0IG5ld09wZXJhdG9yID0gbmV3RmlsdGVyLm9wZXJhdG9yIHx8IHVpRmlsdGVyLmRlZmF1bHRPcGVyYXRvcjtcclxuICAgICAgICAgIHRoaXMudXBkYXRlQ29sdW1uRmlsdGVycyhuZXdGaWx0ZXIuc2VhcmNoVGVybXMsIHVpRmlsdGVyLmNvbHVtbkRlZiwgbmV3T3BlcmF0b3IpO1xyXG4gICAgICAgICAgdWlGaWx0ZXIuc2V0VmFsdWVzKG5ld0ZpbHRlci5zZWFyY2hUZXJtcywgbmV3T3BlcmF0b3IpO1xyXG5cclxuICAgICAgICAgIGlmICh0cmlnZ2VyT25TZWFyY2hDaGFuZ2VFdmVudCkge1xyXG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrU2VhcmNoRXZlbnQobnVsbCwgeyBjb2x1bW5EZWY6IHVpRmlsdGVyLmNvbHVtbkRlZiwgb3BlcmF0b3I6IG5ld09wZXJhdG9yLCBzZWFyY2hUZXJtczogbmV3RmlsdGVyLnNlYXJjaFRlcm1zLCBzaG91bGRUcmlnZ2VyUXVlcnk6IHRydWUgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGNvbnN0IGJhY2tlbmRBcGkgPSB0aGlzLl9ncmlkT3B0aW9ucyAmJiB0aGlzLl9ncmlkT3B0aW9ucy5iYWNrZW5kU2VydmljZUFwaTtcclxuXHJcbiAgICAgIC8vIHJlZnJlc2ggdGhlIERhdGFWaWV3IGFuZCB0cmlnZ2VyIGFuIGV2ZW50IGFmdGVyIGFsbCBmaWx0ZXJzIHdlcmUgdXBkYXRlZCBhbmQgcmVuZGVyZWRcclxuICAgICAgdGhpcy5fZGF0YVZpZXcucmVmcmVzaCgpO1xyXG5cclxuICAgICAgaWYgKGJhY2tlbmRBcGkpIHtcclxuICAgICAgICBjb25zdCBiYWNrZW5kQXBpU2VydmljZSA9IGJhY2tlbmRBcGkgJiYgYmFja2VuZEFwaS5zZXJ2aWNlO1xyXG4gICAgICAgIGlmIChiYWNrZW5kQXBpU2VydmljZSkge1xyXG4gICAgICAgICAgYmFja2VuZEFwaVNlcnZpY2UudXBkYXRlRmlsdGVycyhmaWx0ZXJzLCB0cnVlKTtcclxuICAgICAgICAgIGlmICh0cmlnZ2VyQmFja2VuZFF1ZXJ5KSB7XHJcbiAgICAgICAgICAgIHJlZnJlc2hCYWNrZW5kRGF0YXNldCh0aGlzLl9ncmlkT3B0aW9ucyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoZW1pdENoYW5nZWRFdmVudCkge1xyXG4gICAgICAgIGNvbnN0IGVtaXR0ZXJUeXBlID0gYmFja2VuZEFwaSA/IEVtaXR0ZXJUeXBlLnJlbW90ZSA6IEVtaXR0ZXJUeXBlLmxvY2FsO1xyXG4gICAgICAgIHRoaXMuZW1pdEZpbHRlckNoYW5nZWQoZW1pdHRlclR5cGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyAtLVxyXG4gIC8vIHByaXZhdGUgZnVuY3Rpb25zXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAvKiogQWRkIGFsbCBjcmVhdGVkIGZpbHRlcnMgKGZyb20gdGhlaXIgdGVtcGxhdGUpIHRvIHRoZSBoZWFkZXIgcm93IHNlY3Rpb24gYXJlYSAqL1xyXG4gIHByaXZhdGUgYWRkRmlsdGVyVGVtcGxhdGVUb0hlYWRlclJvdyhfZXZlbnQ6IEV2ZW50LCBhcmdzOiB7IGNvbHVtbjogQ29sdW1uOyBncmlkOiBhbnk7IG5vZGU6IEhUTUxFbGVtZW50IH0sIGlzRmlsdGVyRmlyc3RSZW5kZXIgPSB0cnVlKSB7XHJcbiAgICBjb25zdCBjb2x1bW5EZWYgPSBhcmdzLmNvbHVtbjtcclxuICAgIGNvbnN0IGNvbHVtbklkID0gY29sdW1uRGVmICYmIGNvbHVtbkRlZi5pZCB8fCAnJztcclxuXHJcbiAgICBpZiAoY29sdW1uRGVmICYmIGNvbHVtbklkICE9PSAnc2VsZWN0b3InICYmIGNvbHVtbkRlZi5maWx0ZXJhYmxlKSB7XHJcbiAgICAgIGxldCBzZWFyY2hUZXJtczogU2VhcmNoVGVybVtdIHwgdW5kZWZpbmVkO1xyXG4gICAgICBsZXQgb3BlcmF0b3I6IE9wZXJhdG9yVHlwZSB8IE9wZXJhdG9yU3RyaW5nO1xyXG4gICAgICBjb25zdCBuZXdGaWx0ZXI6IEZpbHRlciB8IHVuZGVmaW5lZCA9IHRoaXMuZmlsdGVyRmFjdG9yeS5jcmVhdGVGaWx0ZXIoYXJncy5jb2x1bW4uZmlsdGVyKTtcclxuICAgICAgb3BlcmF0b3IgPSAoY29sdW1uRGVmICYmIGNvbHVtbkRlZi5maWx0ZXIgJiYgY29sdW1uRGVmLmZpbHRlci5vcGVyYXRvcikgfHwgKG5ld0ZpbHRlciAmJiBuZXdGaWx0ZXIub3BlcmF0b3IpIHx8IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgIGlmICh0aGlzLl9jb2x1bW5GaWx0ZXJzW2NvbHVtbkRlZi5pZF0pIHtcclxuICAgICAgICBzZWFyY2hUZXJtcyA9IHRoaXMuX2NvbHVtbkZpbHRlcnNbY29sdW1uRGVmLmlkXS5zZWFyY2hUZXJtcyB8fCB1bmRlZmluZWQ7XHJcbiAgICAgICAgb3BlcmF0b3IgPSB0aGlzLl9jb2x1bW5GaWx0ZXJzW2NvbHVtbkRlZi5pZF0ub3BlcmF0b3IgfHwgdW5kZWZpbmVkO1xyXG4gICAgICB9IGVsc2UgaWYgKGNvbHVtbkRlZi5maWx0ZXIpIHtcclxuICAgICAgICAvLyB3aGVuIGhpZGluZy9zaG93aW5nICh3aXRoIENvbHVtbiBQaWNrZXIgb3IgR3JpZCBNZW51KSwgaXQgd2lsbCB0cnkgdG8gcmUtY3JlYXRlIHlldCBhZ2FpbiB0aGUgZmlsdGVycyAoc2luY2UgU2xpY2tHcmlkIGRvZXMgYSByZS1yZW5kZXIpXHJcbiAgICAgICAgLy8gYmVjYXVzZSBvZiB0aGF0IHdlIG5lZWQgdG8gZmlyc3QgZ2V0IHNlYXJjaFRlcm0ocykgZnJvbSB0aGUgY29sdW1uRmlsdGVycyAodGhhdCBpcyB3aGF0IHRoZSB1c2VyIGxhc3QgdHlwZWQgaW4gYSBmaWx0ZXIgc2VhcmNoIGlucHV0KVxyXG4gICAgICAgIHNlYXJjaFRlcm1zID0gY29sdW1uRGVmLmZpbHRlci5zZWFyY2hUZXJtcyB8fCB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy51cGRhdGVDb2x1bW5GaWx0ZXJzKHNlYXJjaFRlcm1zLCBjb2x1bW5EZWYsIG9wZXJhdG9yKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgZmlsdGVyQXJndW1lbnRzOiBGaWx0ZXJBcmd1bWVudHMgPSB7XHJcbiAgICAgICAgZ3JpZDogdGhpcy5fZ3JpZCxcclxuICAgICAgICBvcGVyYXRvcixcclxuICAgICAgICBzZWFyY2hUZXJtcyxcclxuICAgICAgICBjb2x1bW5EZWYsXHJcbiAgICAgICAgY2FsbGJhY2s6IHRoaXMuY2FsbGJhY2tTZWFyY2hFdmVudC5iaW5kKHRoaXMpXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBpZiAobmV3RmlsdGVyKSB7XHJcbiAgICAgICAgbmV3RmlsdGVyLmluaXQoZmlsdGVyQXJndW1lbnRzLCBpc0ZpbHRlckZpcnN0UmVuZGVyKTtcclxuICAgICAgICBjb25zdCBmaWx0ZXJFeGlzdEluZGV4ID0gdGhpcy5fZmlsdGVyc01ldGFkYXRhLmZpbmRJbmRleCgoZmlsdGVyKSA9PiBuZXdGaWx0ZXIuY29sdW1uRGVmLmlkID09PSBmaWx0ZXIuY29sdW1uRGVmLmlkKTtcclxuXHJcbiAgICAgICAgLy8gYWRkIHRvIHRoZSBmaWx0ZXJzIGFycmF5cyBvciByZXBsYWNlIGl0IHdoZW4gZm91bmRcclxuICAgICAgICBpZiAoZmlsdGVyRXhpc3RJbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgIHRoaXMuX2ZpbHRlcnNNZXRhZGF0YS5wdXNoKG5ld0ZpbHRlcik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuX2ZpbHRlcnNNZXRhZGF0YVtmaWx0ZXJFeGlzdEluZGV4XSA9IG5ld0ZpbHRlcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHdoZW4gaGlkaW5nL3Nob3dpbmcgKHdpdGggQ29sdW1uIFBpY2tlciBvciBHcmlkIE1lbnUpLCBpdCB3aWxsIHRyeSB0byByZS1jcmVhdGUgeWV0IGFnYWluIHRoZSBmaWx0ZXJzIChzaW5jZSBTbGlja0dyaWQgZG9lcyBhIHJlLXJlbmRlcilcclxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGFsc28gc2V0IGFnYWluIHRoZSB2YWx1ZXMgaW4gdGhlIERPTSBlbGVtZW50cyBpZiB0aGUgdmFsdWVzIHdlcmUgc2V0IGJ5IGEgc2VhcmNoVGVybShzKVxyXG4gICAgICAgIGlmIChzZWFyY2hUZXJtcyAmJiBuZXdGaWx0ZXIuc2V0VmFsdWVzKSB7XHJcbiAgICAgICAgICBuZXdGaWx0ZXIuc2V0VmFsdWVzKHNlYXJjaFRlcm1zKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGxiYWNrIG1ldGhvZCB0aGF0IGlzIGNhbGxlZCBhbmQgZXhlY3V0ZWQgYnkgdGhlIGluZGl2aWR1YWwgRmlsdGVyIChET00gZWxlbWVudCksXHJcbiAgICogZm9yIGV4YW1wbGUgd2hlbiB1c2VyIHR5cGUgaW4gYSB3b3JkIHRvIHNlYXJjaCAod2hpY2ggdXNlcyBJbnB1dEZpbHRlciksIHRoaXMgRmlsdGVyIHdpbGwgZXhlY3V0ZSB0aGUgY2FsbGJhY2sgZnJvbSBhbiBpbnB1dCBjaGFuZ2UgZXZlbnQuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBjYWxsYmFja1NlYXJjaEV2ZW50KGV2ZW50OiBhbnksIGFyZ3M6IEZpbHRlckNhbGxiYWNrQXJnKSB7XHJcbiAgICBpZiAoYXJncykge1xyXG4gICAgICBjb25zdCBzZWFyY2hUZXJtID0gKChldmVudCAmJiBldmVudC50YXJnZXQpID8gKGV2ZW50LnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50KS52YWx1ZSA6IHVuZGVmaW5lZCk7XHJcbiAgICAgIGNvbnN0IHNlYXJjaFRlcm1zID0gKGFyZ3Muc2VhcmNoVGVybXMgJiYgQXJyYXkuaXNBcnJheShhcmdzLnNlYXJjaFRlcm1zKSkgPyBhcmdzLnNlYXJjaFRlcm1zIDogKHNlYXJjaFRlcm0gPyBbc2VhcmNoVGVybV0gOiB1bmRlZmluZWQpO1xyXG4gICAgICBjb25zdCBjb2x1bW5EZWYgPSBhcmdzLmNvbHVtbkRlZiB8fCBudWxsO1xyXG4gICAgICBjb25zdCBjb2x1bW5JZCA9IGNvbHVtbkRlZiAmJiBjb2x1bW5EZWYuaWQgfHwgJyc7XHJcbiAgICAgIGNvbnN0IG9wZXJhdG9yID0gYXJncy5vcGVyYXRvciB8fCB1bmRlZmluZWQ7XHJcbiAgICAgIGNvbnN0IGhhc1NlYXJjaFRlcm1zID0gc2VhcmNoVGVybXMgJiYgQXJyYXkuaXNBcnJheShzZWFyY2hUZXJtcyk7XHJcbiAgICAgIGNvbnN0IHRlcm1zQ291bnQgPSBoYXNTZWFyY2hUZXJtcyAmJiBzZWFyY2hUZXJtcyAmJiBzZWFyY2hUZXJtcy5sZW5ndGg7XHJcbiAgICAgIGNvbnN0IG9sZENvbHVtbkZpbHRlcnMgPSB7IC4uLnRoaXMuX2NvbHVtbkZpbHRlcnMgfTtcclxuXHJcbiAgICAgIGlmIChjb2x1bW5EZWYgJiYgY29sdW1uSWQpIHtcclxuICAgICAgICBpZiAoIWhhc1NlYXJjaFRlcm1zIHx8IHRlcm1zQ291bnQgPT09IDAgfHwgKHRlcm1zQ291bnQgPT09IDEgJiYgQXJyYXkuaXNBcnJheShzZWFyY2hUZXJtcykgJiYgc2VhcmNoVGVybXNbMF0gPT09ICcnKSkge1xyXG4gICAgICAgICAgLy8gZGVsZXRlIHRoZSBwcm9wZXJ0eSBmcm9tIHRoZSBjb2x1bW5GaWx0ZXJzIHdoZW4gaXQgYmVjb21lcyBlbXB0eVxyXG4gICAgICAgICAgLy8gd2l0aG91dCBkb2luZyB0aGlzLCBpdCB3b3VsZCBsZWF2ZSBhbiBpbmNvcnJlY3Qgc3RhdGUgb2YgdGhlIHByZXZpb3VzIGNvbHVtbiBmaWx0ZXJzIHdoZW4gZmlsdGVyaW5nIG9uIGFub3RoZXIgY29sdW1uXHJcbiAgICAgICAgICBkZWxldGUgdGhpcy5fY29sdW1uRmlsdGVyc1tjb2x1bW5JZF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNvbnN0IGNvbElkID0gJycgKyBjb2x1bW5JZCBhcyBzdHJpbmc7XHJcbiAgICAgICAgICBjb25zdCBjb2xGaWx0ZXI6IENvbHVtbkZpbHRlciA9IHtcclxuICAgICAgICAgICAgY29sdW1uSWQ6IGNvbElkLFxyXG4gICAgICAgICAgICBjb2x1bW5EZWYsXHJcbiAgICAgICAgICAgIHNlYXJjaFRlcm1zLFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIGlmIChvcGVyYXRvcikge1xyXG4gICAgICAgICAgICBjb2xGaWx0ZXIub3BlcmF0b3IgPSBvcGVyYXRvcjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRoaXMuX2NvbHVtbkZpbHRlcnNbY29sSWRdID0gY29sRmlsdGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gZXZlbnQgbWlnaHQgaGF2ZSBiZWVuIGNyZWF0ZWQgYXMgYSBDdXN0b21FdmVudCAoZS5nLiBDb21wb3VuZERhdGVGaWx0ZXIpLCB3aXRob3V0IGJlaW5nIGEgdmFsaWQgU2xpY2suRXZlbnREYXRhLFxyXG4gICAgICAvLyBpZiBzbyB3ZSB3aWxsIGNyZWF0ZSBhIG5ldyBTbGljay5FdmVudERhdGEgYW5kIG1lcmdlIGl0IHdpdGggdGhhdCBDdXN0b21FdmVudCB0byBhdm9pZCBoYXZpbmcgU2xpY2tHcmlkIGVycm9yc1xyXG4gICAgICBjb25zdCBldmVudERhdGEgPSAoZXZlbnQgJiYgdHlwZW9mIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkICE9PSAnZnVuY3Rpb24nKSA/ICQuZXh0ZW5kKHt9LCBuZXcgU2xpY2suRXZlbnREYXRhKCksIGV2ZW50KSA6IGV2ZW50O1xyXG5cclxuICAgICAgLy8gdHJpZ2dlciBhbiBldmVudCBvbmx5IGlmIEZpbHRlcnMgY2hhbmdlZCBvciBpZiBFTlRFUiBrZXkgd2FzIHByZXNzZWRcclxuICAgICAgY29uc3QgZXZlbnRLZXkgPSBldmVudCAmJiBldmVudC5rZXk7XHJcbiAgICAgIGNvbnN0IGV2ZW50S2V5Q29kZSA9IGV2ZW50ICYmIGV2ZW50LmtleUNvZGU7XHJcbiAgICAgIGlmICh0aGlzLl9vblNlYXJjaENoYW5nZSAmJiAoZXZlbnRLZXkgPT09ICdFbnRlcicgfHwgZXZlbnRLZXlDb2RlID09PSBLZXlDb2RlLkVOVEVSIHx8ICFpc2VxdWFsKG9sZENvbHVtbkZpbHRlcnMsIHRoaXMuX2NvbHVtbkZpbHRlcnMpKSkge1xyXG4gICAgICAgIHRoaXMuX29uU2VhcmNoQ2hhbmdlLm5vdGlmeSh7XHJcbiAgICAgICAgICBjbGVhckZpbHRlclRyaWdnZXJlZDogYXJncy5jbGVhckZpbHRlclRyaWdnZXJlZCxcclxuICAgICAgICAgIHNob3VsZFRyaWdnZXJRdWVyeTogYXJncy5zaG91bGRUcmlnZ2VyUXVlcnksXHJcbiAgICAgICAgICBjb2x1bW5JZCxcclxuICAgICAgICAgIGNvbHVtbkRlZixcclxuICAgICAgICAgIGNvbHVtbkZpbHRlcnM6IHRoaXMuX2NvbHVtbkZpbHRlcnMsXHJcbiAgICAgICAgICBvcGVyYXRvcixcclxuICAgICAgICAgIHNlYXJjaFRlcm1zLFxyXG4gICAgICAgICAgZ3JpZDogdGhpcy5fZ3JpZFxyXG4gICAgICAgIH0sIGV2ZW50RGF0YSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIExvb3AgdGhyb3VnaCBhbGwgY29sdW1uIGRlZmluaXRpb25zIGFuZCBkbyB0aGUgZm9sbG93aW5nIHRoaW5nXHJcbiAgICogMS4gbG9vcCB0aHJvdWdoIGVhY2ggSGVhZGVyIE1lbnUgY29tbWFuZHMgYW5kIGNoYW5nZSB0aGUgXCJoaWRkZW5cIiBjb21tYW5kcyB0byBzaG93L2hpZGUgZGVwZW5kaW5nIGlmIGl0J3MgZW5hYmxlZC9kaXNhYmxlZFxyXG4gICAqIEFsc28gbm90ZSB0aGF0IHdlIGFyZW4ndCBkZWxldGluZyBhbnkgcHJvcGVydGllcywgd2UganVzdCB0b2dnbGUgdGhlaXIgZmxhZ3Mgc28gdGhhdCB3ZSBjYW4gcmVsb29wIHRocm91Z2ggYXQgbGF0ZXIgcG9pbnQgaW4gdGltZS5cclxuICAgKiAoaWYgd2UgcHJldmlvdXNseSBkZWxldGVkIHRoZXNlIHByb3BlcnRpZXMgd2Ugd291bGRuJ3QgYmUgYWJsZSB0byBjaGFuZ2UgdGhlbSBiYWNrIHNpbmNlIHRoZXNlIHByb3BlcnRpZXMgd291bGRuJ3QgZXhpc3QgYW55bW9yZSwgaGVuY2Ugd2h5IHdlIGp1c3QgaGlkZSB0aGUgY29tbWFuZHMpXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBpc0Rpc2FibGluZyAtIGFyZSB3ZSBkaXNhYmxpbmcgdGhlIGZpbHRlciBmdW5jdGlvbmFsaXR5PyBEZWZhdWx0cyB0byB0cnVlXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBkaXNhYmxlQWxsRmlsdGVyaW5nQ29tbWFuZHMoaXNEaXNhYmxpbmcgPSB0cnVlKTogQ29sdW1uW10ge1xyXG4gICAgY29uc3QgY29sdW1uRGVmaW5pdGlvbnMgPSB0aGlzLl9ncmlkLmdldENvbHVtbnMoKTtcclxuXHJcbiAgICAvLyBsb29wIHRocm91Z2ggY29sdW1uIGRlZmluaXRpb24gdG8gaGlkZS9zaG93IGhlYWRlciBtZW51IGNvbW1hbmRzXHJcbiAgICBjb2x1bW5EZWZpbml0aW9ucy5mb3JFYWNoKChjb2wpID0+IHtcclxuICAgICAgaWYgKGNvbCAmJiBjb2wuaGVhZGVyICYmIGNvbC5oZWFkZXIubWVudSkge1xyXG4gICAgICAgIGNvbC5oZWFkZXIubWVudS5pdGVtcy5mb3JFYWNoKG1lbnVJdGVtID0+IHtcclxuICAgICAgICAgIGlmIChtZW51SXRlbSAmJiB0eXBlb2YgbWVudUl0ZW0gIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1lbnVDb21tYW5kID0gbWVudUl0ZW0uY29tbWFuZDtcclxuICAgICAgICAgICAgaWYgKG1lbnVDb21tYW5kID09PSAnY2xlYXItZmlsdGVyJykge1xyXG4gICAgICAgICAgICAgIG1lbnVJdGVtLmhpZGRlbiA9IGlzRGlzYWJsaW5nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIGxvb3AgdGhyb3VnaCBjb2x1bW4gZGVmaW5pdGlvbiB0byBoaWRlL3Nob3cgZ3JpZCBtZW51IGNvbW1hbmRzXHJcbiAgICBpZiAodGhpcy5fZ3JpZE9wdGlvbnMgJiYgdGhpcy5fZ3JpZE9wdGlvbnMuZ3JpZE1lbnUgJiYgdGhpcy5fZ3JpZE9wdGlvbnMuZ3JpZE1lbnUuY3VzdG9tSXRlbXMpIHtcclxuICAgICAgdGhpcy5fZ3JpZE9wdGlvbnMuZ3JpZE1lbnUuY3VzdG9tSXRlbXMuZm9yRWFjaCgobWVudUl0ZW0pID0+IHtcclxuICAgICAgICBpZiAobWVudUl0ZW0gJiYgdHlwZW9mIG1lbnVJdGVtICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgY29uc3QgbWVudUNvbW1hbmQgPSBtZW51SXRlbS5jb21tYW5kO1xyXG4gICAgICAgICAgaWYgKG1lbnVDb21tYW5kID09PSAnY2xlYXItZmlsdGVyJyB8fCBtZW51Q29tbWFuZCA9PT0gJ3RvZ2dsZS1maWx0ZXInKSB7XHJcbiAgICAgICAgICAgIG1lbnVJdGVtLmhpZGRlbiA9IGlzRGlzYWJsaW5nO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNvbHVtbkRlZmluaXRpb25zO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSB1cGRhdGVDb2x1bW5GaWx0ZXJzKHNlYXJjaFRlcm1zOiBTZWFyY2hUZXJtW10gfCB1bmRlZmluZWQsIGNvbHVtbkRlZjogYW55LCBvcGVyYXRvcj86IE9wZXJhdG9yVHlwZSB8IE9wZXJhdG9yU3RyaW5nKSB7XHJcbiAgICBpZiAoc2VhcmNoVGVybXMgJiYgY29sdW1uRGVmKSB7XHJcbiAgICAgIHRoaXMuX2NvbHVtbkZpbHRlcnNbY29sdW1uRGVmLmlkXSA9IHtcclxuICAgICAgICBjb2x1bW5JZDogY29sdW1uRGVmLmlkLFxyXG4gICAgICAgIGNvbHVtbkRlZixcclxuICAgICAgICBzZWFyY2hUZXJtcyxcclxuICAgICAgICBvcGVyYXRvclxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iXX0=