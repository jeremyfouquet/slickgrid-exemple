import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import { Subject } from 'rxjs';
import { ExtensionService } from './extension.service';
import { FilterService } from './filter.service';
import { GridStateService } from './gridState.service';
import { SharedService } from './shared.service';
import { SortService } from './sort.service';
import { arrayRemoveItemByIndex } from './utilities';
var highlightTimerEnd;
var GridServiceDeleteOptionDefaults = { triggerEvent: true };
var GridServiceInsertOptionDefaults = { highlightRow: true, position: 'top', resortGrid: false, selectRow: false, triggerEvent: true };
var GridServiceUpdateOptionDefaults = { highlightRow: true, selectRow: false, scrollRowIntoView: false, triggerEvent: true };
var HideColumnOptionDefaults = { autoResizeColumns: true, triggerEvent: true, hideFromColumnPicker: false, hideFromGridMenu: false };
var GridService = /** @class */ (function () {
    function GridService(extensionService, filterService, gridStateService, sharedService, sortService) {
        this.extensionService = extensionService;
        this.filterService = filterService;
        this.gridStateService = gridStateService;
        this.sharedService = sharedService;
        this.sortService = sortService;
        this.onItemAdded = new Subject();
        this.onItemDeleted = new Subject();
        this.onItemUpdated = new Subject();
        this.onItemUpserted = new Subject();
        this.onColumnsChanged = new Subject();
    }
    Object.defineProperty(GridService.prototype, "_gridOptions", {
        /** Getter for the Grid Options pulled through the Grid Object */
        get: function () {
            return (this._grid && this._grid.getOptions) ? this._grid.getOptions() : {};
        },
        enumerable: true,
        configurable: true
    });
    GridService.prototype.dispose = function () {
        if (this._rowSelectionPlugin && this._rowSelectionPlugin.destroy) {
            this._rowSelectionPlugin.destroy();
        }
    };
    GridService.prototype.init = function (grid, dataView) {
        this._grid = grid;
        this._dataView = dataView;
    };
    /** Clear all Filters & Sorts */
    GridService.prototype.clearAllFiltersAndSorts = function () {
        // call both clear Filters & Sort but only trigger the last one to avoid sending multiple backend queries
        if (this.sortService && this.sortService.clearSorting) {
            this.sortService.clearSorting(false); // skip event trigger on this one
        }
        if (this.filterService && this.filterService.clearFilters) {
            this.filterService.clearFilters();
        }
    };
    /**
     * Get all column set in the grid, that is all visible/hidden columns
     * and also include any extra columns used by some plugins (like Row Selection, Row Detail, ...)
     */
    GridService.prototype.getAllColumnDefinitions = function () {
        return this.sharedService.allColumns;
    };
    /** Get only visible column definitions and also include any extra columns by some plugins (like Row Selection, Row Detail, ...) */
    GridService.prototype.getVisibleColumnDefinitions = function () {
        return this.sharedService.visibleColumns;
    };
    /**
     * From a SlickGrid Event triggered get the Column Definition and Item Data Context
     *
     * For example the SlickGrid onClick will return cell arguments when subscribing to it.
     * From these cellArgs, we want to get the Column Definition and Item Data
     * @param cell event args
     * @return object with columnDef and dataContext
     */
    GridService.prototype.getColumnFromEventArguments = function (args) {
        if (!args || !args.grid || !args.grid.getColumns || !args.grid.getDataItem) {
            throw new Error('To get the column definition and data, we need to have these arguments passed as objects (row, cell, grid)');
        }
        return {
            row: args.row,
            cell: args.cell,
            columnDef: args.grid.getColumns()[args.cell],
            dataContext: args.grid.getDataItem(args.row),
            dataView: this._dataView,
            grid: this._grid
        };
    };
    /** Get data item by it's row index number */
    GridService.prototype.getDataItemByRowNumber = function (rowNumber) {
        if (!this._grid || typeof this._grid.getDataItem !== 'function') {
            throw new Error("We could not find SlickGrid Grid object or it's \"getDataItem\" method");
        }
        return this._grid.getDataItem(rowNumber);
    };
    /** Chain the item Metadata with our implementation of Metadata at given row index */
    GridService.prototype.getItemRowMetadataToHighlight = function (previousItemMetadata) {
        var _this = this;
        return function (rowNumber) {
            var item = _this._dataView.getItem(rowNumber);
            var meta = { cssClasses: '' };
            if (typeof previousItemMetadata === 'function') {
                meta = previousItemMetadata(rowNumber);
            }
            if (!meta) {
                meta = { cssClasses: '' };
            }
            if (item && item._dirty) {
                meta.cssClasses = (meta && meta.cssClasses || '') + ' dirty';
            }
            if (item && item.rowClass && meta) {
                meta.cssClasses += " " + item.rowClass;
                meta.cssClasses += " row" + rowNumber;
            }
            return meta;
        };
    };
    /**
       * @deprecated Hide a Column from the Grid (the column will just become hidden and will still show up in columnPicker/gridMenu)
       * @see hideColumnById
       * @param column
       */
    GridService.prototype.hideColumn = function (column) {
        if (this._grid && this._grid.getColumns && this._grid.setColumns && this._grid.getColumnIndex) {
            var columnIndex = this._grid.getColumnIndex(column.id);
            if (columnIndex >= 0) {
                this.hideColumnByIndex(columnIndex);
            }
        }
    };
    /**
     * @deprecated Hide a Column from the Grid by its column definition index (the column will just become hidden and will still show up in columnPicker/gridMenu)
     * @see hideColumnById Please use "hideColumnById(id)" or "hideColumnByIds([ids])" instead since it has a lot more options
     * @param columnIndex - column definition index
     * @param triggerEvent - do we want to trigger an event (onHeaderMenuColumnsChanged) when column becomes hidden? Defaults to true.
     */
    GridService.prototype.hideColumnByIndex = function (columnIndex, triggerEvent) {
        if (triggerEvent === void 0) { triggerEvent = true; }
        if (this._grid && this._grid.getColumns && this._grid.setColumns) {
            var currentColumns = this._grid.getColumns();
            var visibleColumns = arrayRemoveItemByIndex(currentColumns, columnIndex);
            this.sharedService.visibleColumns = visibleColumns;
            this._grid.setColumns(visibleColumns);
            if (triggerEvent) {
                this.onColumnsChanged.next(visibleColumns);
            }
        }
    };
    /**
     * Hide a Column from the Grid by its column definition id, the column will just become hidden and will still show up in columnPicker/gridMenu
     * @param {string | number} columnId - column definition id
     * @param {boolean} triggerEvent - do we want to trigger an event (onHeaderMenuColumnsChanged) when column becomes hidden? Defaults to true.
     * @return {number} columnIndex - column index position when found or -1
     */
    GridService.prototype.hideColumnById = function (columnId, options) {
        options = tslib_1.__assign({}, HideColumnOptionDefaults, options);
        if (this._grid && this._grid.getColumns && this._grid.setColumns) {
            var currentColumns = this._grid.getColumns();
            var colIndexFound = currentColumns.findIndex(function (col) { return col.id === columnId; });
            if (colIndexFound >= 0) {
                var visibleColumns = arrayRemoveItemByIndex(currentColumns, colIndexFound);
                this.sharedService.visibleColumns = visibleColumns;
                this._grid.setColumns(visibleColumns);
                var columnIndexFromAllColumns = this.sharedService.allColumns.findIndex(function (col) { return col.id === columnId; });
                if (columnIndexFromAllColumns) {
                    if (options && options.hideFromColumnPicker) {
                        this.sharedService.allColumns[columnIndexFromAllColumns].excludeFromColumnPicker = true;
                    }
                    if (options && options.hideFromGridMenu) {
                        this.sharedService.allColumns[columnIndexFromAllColumns].excludeFromGridMenu = true;
                    }
                }
                // do we want to auto-resize the columns in the grid after hidding some? most often yes
                if (options && options.autoResizeColumns) {
                    this._grid.autosizeColumns();
                }
                // do we want to trigger an event after hidding
                if (options && options.triggerEvent) {
                    this.onColumnsChanged.next(visibleColumns);
                }
                return colIndexFound;
            }
        }
        return -1;
    };
    /**
     * Hide a Column from the Grid by its column definition id(s), the column will just become hidden and will still show up in columnPicker/gridMenu
     * @param {Array<string | number>} columnIds - column definition ids, can be a single string and an array of strings
     * @param {boolean} triggerEvent - do we want to trigger an event (onHeaderMenuColumnsChanged) when column becomes hidden? Defaults to true.
     */
    GridService.prototype.hideColumnByIds = function (columnIds, options) {
        var e_1, _a;
        options = tslib_1.__assign({}, HideColumnOptionDefaults, options);
        if (Array.isArray(columnIds)) {
            try {
                for (var columnIds_1 = tslib_1.__values(columnIds), columnIds_1_1 = columnIds_1.next(); !columnIds_1_1.done; columnIds_1_1 = columnIds_1.next()) {
                    var columnId = columnIds_1_1.value;
                    // hide each column by its id but wait after the for loop to auto resize columns in the grid
                    this.hideColumnById(columnId, tslib_1.__assign({}, options, { triggerEvent: false, autoResizeColumns: false }));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (columnIds_1_1 && !columnIds_1_1.done && (_a = columnIds_1.return)) _a.call(columnIds_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            // do we want to auto-resize the columns in the grid after hidding some? most often yes
            if (options && options.autoResizeColumns) {
                this._grid.autosizeColumns();
            }
            // do we want to trigger an event after hidding
            if (options && options.triggerEvent) {
                this.onColumnsChanged.next(this.sharedService.visibleColumns);
            }
        }
    };
    /**
     * Highlight then fade a row for x seconds.
     * The implementation follows this SO answer: https://stackoverflow.com/a/19985148/1212166
     * @param rowNumber
     * @param fadeDelay
     */
    GridService.prototype.highlightRow = function (rowNumber, fadeDelay, fadeOutDelay) {
        var _this = this;
        if (fadeDelay === void 0) { fadeDelay = 1500; }
        if (fadeOutDelay === void 0) { fadeOutDelay = 300; }
        // create a SelectionModel if there's not one yet
        if (!this._grid.getSelectionModel() && Slick && Slick.RowSelectionModel) {
            this._rowSelectionPlugin = new Slick.RowSelectionModel(this._gridOptions.rowSelectionOptions || {});
            this._grid.setSelectionModel(this._rowSelectionPlugin);
        }
        if (Array.isArray(rowNumber)) {
            rowNumber.forEach(function (row) { return _this.highlightRowByMetadata(row, fadeDelay, fadeOutDelay); });
        }
        else {
            this.highlightRowByMetadata(rowNumber, fadeDelay, fadeOutDelay);
        }
    };
    GridService.prototype.highlightRowByMetadata = function (rowNumber, fadeDelay, fadeOutDelay) {
        var _this = this;
        if (fadeDelay === void 0) { fadeDelay = 1500; }
        if (fadeOutDelay === void 0) { fadeOutDelay = 300; }
        this._dataView.getItemMetadata = this.getItemRowMetadataToHighlight(this._dataView.getItemMetadata);
        var item = this._dataView.getItem(rowNumber);
        var idPropName = this._gridOptions.datasetIdPropertyName || 'id';
        if (item && item[idPropName]) {
            item.rowClass = 'highlight';
            this._dataView.updateItem(item[idPropName], item);
            this.renderGrid();
            // fade out
            clearTimeout(highlightTimerEnd);
            highlightTimerEnd = setTimeout(function () {
                item.rowClass = 'highlight-end';
                _this._dataView.updateItem(item[idPropName], item);
                _this.renderGrid();
            }, fadeOutDelay);
            // delete the row's CSS highlight classes once the delay is passed
            setTimeout(function () {
                if (item && item[idPropName]) {
                    delete item.rowClass;
                    if (_this._dataView.getIdxById(item[idPropName]) !== undefined) {
                        _this._dataView.updateItem(item[idPropName], item);
                        _this.renderGrid();
                    }
                }
            }, fadeDelay + fadeOutDelay);
        }
    };
    /** Get the Data Item from a grid row index */
    GridService.prototype.getDataItemByRowIndex = function (index) {
        if (!this._grid || typeof this._grid.getDataItem !== 'function') {
            throw new Error('We could not find SlickGrid Grid object and/or "getDataItem" method');
        }
        return this._grid.getDataItem(index);
    };
    /** Get the Data Item from an array of grid row indexes */
    GridService.prototype.getDataItemByRowIndexes = function (indexes) {
        var _this = this;
        if (!this._grid || typeof this._grid.getDataItem !== 'function') {
            throw new Error('We could not find SlickGrid Grid object and/or "getDataItem" method');
        }
        var dataItems = [];
        if (Array.isArray(indexes)) {
            indexes.forEach(function (idx) {
                dataItems.push(_this._grid.getDataItem(idx));
            });
        }
        return dataItems;
    };
    /** Get the currently selected row indexes */
    GridService.prototype.getSelectedRows = function () {
        if (!this._grid || typeof this._grid.getSelectedRows !== 'function') {
            throw new Error('We could not find SlickGrid Grid object and/or "getSelectedRows" method');
        }
        return this._grid.getSelectedRows();
    };
    /** Get the currently selected rows item data */
    GridService.prototype.getSelectedRowsDataItem = function () {
        if (!this._grid || typeof this._grid.getSelectedRows !== 'function') {
            throw new Error('We could not find SlickGrid Grid object and/or "getSelectedRows" method');
        }
        var selectedRowIndexes = this._grid.getSelectedRows();
        return this.getDataItemByRowIndexes(selectedRowIndexes);
    };
    /** Select the selected row by a row index */
    GridService.prototype.setSelectedRow = function (rowIndex) {
        if (this._grid && this._grid.setSelectedRows) {
            this._grid.setSelectedRows([rowIndex]);
        }
    };
    /** Set selected rows with provided array of row indexes */
    GridService.prototype.setSelectedRows = function (rowIndexes) {
        if (this._grid && this._grid.setSelectedRows) {
            this._grid.setSelectedRows(rowIndexes);
        }
    };
    /** Re-Render the Grid */
    GridService.prototype.renderGrid = function () {
        if (this._grid && typeof this._grid.invalidate === 'function') {
            this._grid.invalidate();
            this._grid.render();
        }
    };
    /**
     * Reset the grid to it's original state (clear any filters, sorting & pagination if exists) .
     * The column definitions could be passed as argument to reset (this can be used after a Grid State reset)
     * The reset will clear the Filters & Sort, then will reset the Columns to their original state
     */
    GridService.prototype.resetGrid = function (columnDefinitions) {
        // reset columns to original states & refresh the grid
        if (this._grid && this._dataView) {
            var originalColumns = this.extensionService.getAllColumns();
            if (Array.isArray(originalColumns) && originalColumns.length > 0) {
                // set the grid columns to it's original column definitions
                this._grid.setColumns(originalColumns);
                if (this._gridOptions && this._gridOptions.enableAutoSizeColumns) {
                    this._grid.autosizeColumns();
                }
                this.gridStateService.resetColumns(columnDefinitions);
            }
        }
        if (this.filterService && this.filterService.clearFilters) {
            this.filterService.clearFilters();
        }
        if (this.sortService && this.sortService.clearSorting) {
            this.sortService.clearSorting();
        }
    };
    /** @deprecated please use "addItem" method instead */
    GridService.prototype.addItemToDatagrid = function (item, shouldHighlightRow, shouldResortGrid, shouldTriggerEvent, shouldSelectRow) {
        if (shouldHighlightRow === void 0) { shouldHighlightRow = true; }
        if (shouldResortGrid === void 0) { shouldResortGrid = false; }
        if (shouldTriggerEvent === void 0) { shouldTriggerEvent = true; }
        if (shouldSelectRow === void 0) { shouldSelectRow = true; }
        console.warn('[Angular-Slickgrid - GridService] please consider using the new "addItem" method since "addItemToDatagrid" will be deprecated in the future.');
        return this.addItem(item, { highlightRow: shouldHighlightRow, resortGrid: shouldResortGrid, triggerEvent: shouldTriggerEvent, selectRow: shouldSelectRow });
    };
    /** @deprecated please use "addItems" method instead */
    GridService.prototype.addItemsToDatagrid = function (items, shouldHighlightRow, shouldResortGrid, shouldTriggerEvent, shouldSelectRow) {
        if (shouldHighlightRow === void 0) { shouldHighlightRow = true; }
        if (shouldResortGrid === void 0) { shouldResortGrid = false; }
        if (shouldTriggerEvent === void 0) { shouldTriggerEvent = true; }
        if (shouldSelectRow === void 0) { shouldSelectRow = true; }
        console.warn('[Angular-Slickgrid - GridService] please consider using the new "addItems" method since "addItemsToDatagrid" will be deprecated in the future.');
        return this.addItems(items, { highlightRow: shouldHighlightRow, resortGrid: shouldResortGrid, triggerEvent: shouldTriggerEvent, selectRow: shouldSelectRow });
    };
    /**
     * Add an item (data item) to the datagrid, by default it will highlight (flashing) the inserted row but we can disable it too
     * @param item object which must contain a unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, resortGrid, selectRow, triggerEvent)
     * @return rowIndex: typically index 0 when adding to position "top" or a different number when adding to the "bottom"
     */
    GridService.prototype.addItem = function (item, options) {
        options = tslib_1.__assign({}, GridServiceInsertOptionDefaults, options);
        if (!this._grid || !this._gridOptions || !this._dataView) {
            throw new Error('We could not find SlickGrid Grid, DataView objects');
        }
        var idPropName = this._gridOptions.datasetIdPropertyName || 'id';
        if (!item || !(idPropName in item)) {
            throw new Error("Adding an item requires the item to include an \"" + idPropName + "\" property");
        }
        // insert position top/bottom, defaults to top
        // when position is top we'll call insert at index 0, else call addItem which just push to the DataView array
        if (options && options.position === 'bottom') {
            this._dataView.addItem(item);
        }
        else {
            this._dataView.insertItem(0, item); // insert at index 0
        }
        // row number in the grid, by default it will be on first row (top is the default)
        var rowNumber = 0;
        // do we want the item to be sorted in the grid, when set to False it will insert on first row (defaults to false)
        if (options.resortGrid) {
            this._dataView.reSort();
            // find the row number in the grid and if user wanted to see highlighted row
            // we need to do it here after resort and get each row number because it possibly changes after the sort
            rowNumber = this._dataView.getRowById(item[idPropName]);
        }
        else {
            // scroll to row index 0 when inserting on top else scroll to the bottom where it got inserted
            rowNumber = (options && options.position === 'bottom') ? this._dataView.getRowById(item[idPropName]) : 0;
            this._grid.scrollRowIntoView(rowNumber);
        }
        // if highlight is enabled, we'll highlight the row we just added
        if (options.highlightRow) {
            this.highlightRow(rowNumber);
        }
        // if row selection (checkbox selector) is enabled, we'll select the row in the grid
        if (options.selectRow && this._gridOptions && (this._gridOptions.enableCheckboxSelector || this._gridOptions.enableRowSelection)) {
            this.setSelectedRow(rowNumber);
        }
        // do we want to trigger an event after adding the item
        if (options.triggerEvent) {
            this.onItemAdded.next(item);
        }
        return rowNumber;
    };
    /**
     * Add item array (data item) to the datagrid, by default it will highlight (flashing) the inserted row but we can disable it too
     * @param item object arrays, which must contain unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, resortGrid, selectRow, triggerEvent)
     */
    GridService.prototype.addItems = function (items, options) {
        var _this = this;
        options = tslib_1.__assign({}, GridServiceInsertOptionDefaults, options);
        var idPropName = this._gridOptions.datasetIdPropertyName || 'id';
        var rowNumbers = [];
        // loop through all items to add
        if (!Array.isArray(items)) {
            return [this.addItem(items, options)];
        }
        else {
            this._dataView.beginUpdate();
            items.forEach(function (item) { return _this.addItem(item, tslib_1.__assign({}, options, { highlightRow: false, resortGrid: false, triggerEvent: false, selectRow: false })); });
            this._dataView.endUpdate();
        }
        // do we want the item to be sorted in the grid, when set to False it will insert on first row (defaults to false)
        if (options.resortGrid) {
            this._dataView.reSort();
        }
        // scroll to row index 0 when inserting on top else scroll to the bottom where it got inserted
        (options && options.position === 'bottom') ? this._grid.navigateBottom() : this._grid.navigateTop();
        // get row numbers of all new inserted items
        // we need to do it after resort and get each row number because it possibly changed after the sort
        items.forEach(function (item) { return rowNumbers.push(_this._dataView.getRowById(item[idPropName])); });
        // if user wanted to see highlighted row
        if (options.highlightRow) {
            this.highlightRow(rowNumbers);
        }
        // select the row in the grid
        if (options.selectRow && this._gridOptions && (this._gridOptions.enableCheckboxSelector || this._gridOptions.enableRowSelection)) {
            this.setSelectedRows(rowNumbers);
        }
        // do we want to trigger an event after adding the item
        if (options.triggerEvent) {
            this.onItemAdded.next(items);
        }
        return rowNumbers;
    };
    /** @deprecated please use "deleteItem" method instead */
    GridService.prototype.deleteDataGridItem = function (item, shouldTriggerEvent) {
        if (shouldTriggerEvent === void 0) { shouldTriggerEvent = true; }
        console.warn('[Angular-Slickgrid - GridService] please consider using the new "deleteItem" method since "deleteDataGridItem" will be deprecated in the future.');
        this.deleteItem(item, { triggerEvent: shouldTriggerEvent });
    };
    /** @deprecated please use "deleteItems" method instead */
    GridService.prototype.deleteDataGridItems = function (items, shouldTriggerEvent) {
        if (shouldTriggerEvent === void 0) { shouldTriggerEvent = true; }
        console.warn('[Angular-Slickgrid - GridService] please consider using the new "deleteItems" method since "deleteDataGridItems" will be deprecated in the future.');
        this.deleteItems(items, { triggerEvent: shouldTriggerEvent });
    };
    /** @deprecated please use "deleteItemById" method instead */
    GridService.prototype.deleteDataGridItemById = function (itemId, shouldTriggerEvent) {
        if (shouldTriggerEvent === void 0) { shouldTriggerEvent = true; }
        console.warn('[Angular-Slickgrid - GridService] please consider using the new "deleteItemById" method since "deleteDataGridItemById" will be deprecated in the future.');
        this.deleteItemById(itemId, { triggerEvent: shouldTriggerEvent });
    };
    /** @deprecated please use "deleteItemByIds" method instead */
    GridService.prototype.deleteDataGridItemByIds = function (itemIds, shouldTriggerEvent) {
        if (shouldTriggerEvent === void 0) { shouldTriggerEvent = true; }
        console.warn('[Angular-Slickgrid - GridService] please consider using the new "deleteItemByIds" method since "deleteDataGridItemByIds" will be deprecated in the future.');
        this.deleteItemByIds(itemIds, { triggerEvent: shouldTriggerEvent });
    };
    /**
     * Delete an existing item from the datagrid (dataView)
     * @param item object which must contain a unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (triggerEvent)
     * @return item id deleted
     */
    GridService.prototype.deleteItem = function (item, options) {
        options = tslib_1.__assign({}, GridServiceDeleteOptionDefaults, options);
        var idPropName = this._gridOptions.datasetIdPropertyName || 'id';
        if (!item || !(idPropName in item)) {
            throw new Error("Deleting an item requires the item to include an \"" + idPropName + "\" property");
        }
        return this.deleteItemById(item[idPropName], options);
    };
    /**
     * Delete an array of existing items from the datagrid
     * @param item object which must contain a unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (triggerEvent)
     * @return item id deleted
     */
    GridService.prototype.deleteItems = function (items, options) {
        var _this = this;
        options = tslib_1.__assign({}, GridServiceDeleteOptionDefaults, options);
        var idPropName = this._gridOptions.datasetIdPropertyName || 'id';
        // when it's not an array, we can call directly the single item delete
        if (!Array.isArray(items)) {
            this.deleteItem(items, options);
            return [items[idPropName]];
        }
        this._dataView.beginUpdate();
        var itemIds = [];
        items.forEach(function (item) {
            if (item && item[idPropName] !== undefined) {
                itemIds.push(item[idPropName]);
            }
            _this.deleteItem(item, tslib_1.__assign({}, options, { triggerEvent: false }));
        });
        this._dataView.endUpdate();
        // do we want to trigger an event after deleting the item
        if (options.triggerEvent) {
            this.onItemDeleted.next(items);
        }
        return itemIds;
    };
    /**
     * Delete an existing item from the datagrid (dataView) by it's id
     * @param itemId: item unique id
     * @param options: provide the possibility to do certain actions after or during the upsert (triggerEvent)
     * @return item id deleted
     */
    GridService.prototype.deleteItemById = function (itemId, options) {
        options = tslib_1.__assign({}, GridServiceDeleteOptionDefaults, options);
        if (itemId === null || itemId === undefined) {
            throw new Error("Cannot delete a row without a valid \"id\"");
        }
        // when user has row selection enabled, we should clear any selection to avoid confusion after a delete
        var isSyncGridSelectionEnabled = this.gridStateService && this.gridStateService.needToPreserveRowSelection() || false;
        if (!isSyncGridSelectionEnabled && this._grid && this._gridOptions && (this._gridOptions.enableCheckboxSelector || this._gridOptions.enableRowSelection)) {
            this.setSelectedRows([]);
        }
        // delete the item from the dataView
        this._dataView.deleteItem(itemId);
        // do we want to trigger an event after deleting the item
        if (options.triggerEvent) {
            this.onItemDeleted.next(itemId);
        }
        return itemId;
    };
    /**
     * Delete an array of existing items from the datagrid
     * @param itemIds array of item unique IDs
     * @param options: provide the possibility to do certain actions after or during the upsert (triggerEvent)
     */
    GridService.prototype.deleteItemByIds = function (itemIds, options) {
        options = tslib_1.__assign({}, GridServiceDeleteOptionDefaults, options);
        // when it's not an array, we can call directly the single item delete
        if (Array.isArray(itemIds)) {
            this._dataView.beginUpdate();
            for (var i = 0; i < itemIds.length; i++) {
                if (itemIds[i] !== null) {
                    this.deleteItemById(itemIds[i], { triggerEvent: false });
                }
            }
            this._dataView.endUpdate();
            // do we want to trigger an event after deleting the item
            if (options.triggerEvent) {
                this.onItemDeleted.next(itemIds);
            }
            return itemIds;
        }
        return [];
    };
    /** @deprecated please use "updateItem" method instead */
    GridService.prototype.updateDataGridItem = function (item, shouldHighlightRow, shouldTriggerEvent, shouldSelectRow) {
        if (shouldHighlightRow === void 0) { shouldHighlightRow = true; }
        if (shouldTriggerEvent === void 0) { shouldTriggerEvent = true; }
        if (shouldSelectRow === void 0) { shouldSelectRow = true; }
        console.warn('[Angular-Slickgrid - GridService] please consider using the new "updateItem" method since "updateDataGridItem" will be deprecated in the future.');
        return this.updateItem(item, { highlightRow: shouldHighlightRow, triggerEvent: shouldTriggerEvent, selectRow: shouldSelectRow });
    };
    /** @deprecated please use "updateItems" method instead */
    GridService.prototype.updateDataGridItems = function (items, shouldHighlightRow, shouldTriggerEvent, shouldSelectRow) {
        if (shouldHighlightRow === void 0) { shouldHighlightRow = true; }
        if (shouldTriggerEvent === void 0) { shouldTriggerEvent = true; }
        if (shouldSelectRow === void 0) { shouldSelectRow = true; }
        console.warn('[Angular-Slickgrid - GridService] please consider using the new "updateItems" method since "updateDataGridItems" will be deprecated in the future.');
        return this.updateItems(items, { highlightRow: shouldHighlightRow, triggerEvent: shouldTriggerEvent, selectRow: shouldSelectRow });
    };
    /** @deprecated please use "updateItemById" method instead */
    GridService.prototype.updateDataGridItemById = function (itemId, item, shouldHighlightRow, shouldTriggerEvent, shouldSelectRow) {
        if (shouldHighlightRow === void 0) { shouldHighlightRow = true; }
        if (shouldTriggerEvent === void 0) { shouldTriggerEvent = true; }
        if (shouldSelectRow === void 0) { shouldSelectRow = true; }
        console.warn('[Angular-Slickgrid - GridService] please consider using the new "updateItemById" method since "updateDataGridItemById" will be deprecated in the future.');
        return this.updateItemById(itemId, item, { highlightRow: shouldHighlightRow, triggerEvent: shouldTriggerEvent, selectRow: shouldSelectRow });
    };
    /**
     * Update an existing item with new properties inside the datagrid
     * @param item object which must contain a unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, selectRow, triggerEvent)
     * @return grid row index
     */
    GridService.prototype.updateItem = function (item, options) {
        options = tslib_1.__assign({}, GridServiceUpdateOptionDefaults, options);
        var idPropName = this._gridOptions.datasetIdPropertyName || 'id';
        var itemId = (!item || !(idPropName in item)) ? undefined : item[idPropName];
        if (itemId === undefined) {
            throw new Error("Calling Update of an item requires the item to include an \"" + idPropName + "\" property");
        }
        return this.updateItemById(itemId, item, options);
    };
    /**
     * Update an array of existing items with new properties inside the datagrid
     * @param item object arrays, which must contain unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, selectRow, triggerEvent)
     * @return grid row indexes
     */
    GridService.prototype.updateItems = function (items, options) {
        var _this = this;
        options = tslib_1.__assign({}, GridServiceUpdateOptionDefaults, options);
        // when it's not an array, we can call directly the single item update
        if (!Array.isArray(items)) {
            return [this.updateItem(items, options)];
        }
        this._dataView.beginUpdate();
        var gridRowNumbers = [];
        items.forEach(function (item) {
            gridRowNumbers.push(_this.updateItem(item, tslib_1.__assign({}, options, { highlightRow: false, selectRow: false, triggerEvent: false })));
        });
        this._dataView.endUpdate();
        // only highlight at the end, all at once
        // we have to do this because doing highlight 1 by 1 would only re-select the last highlighted row which is wrong behavior
        if (options.highlightRow) {
            this.highlightRow(gridRowNumbers);
        }
        // select the row in the grid
        if (options.selectRow && this._gridOptions && (this._gridOptions.enableCheckboxSelector || this._gridOptions.enableRowSelection)) {
            this.setSelectedRows(gridRowNumbers);
        }
        // do we want to trigger an event after updating the item
        if (options.triggerEvent) {
            this.onItemUpdated.next(items);
        }
        return gridRowNumbers;
    };
    /**
     * Update an existing item in the datagrid by it's id and new properties
     * @param itemId: item unique id
     * @param item object which must contain a unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, selectRow, triggerEvent)
     * @return grid row number
     */
    GridService.prototype.updateItemById = function (itemId, item, options) {
        options = tslib_1.__assign({}, GridServiceUpdateOptionDefaults, options);
        if (itemId === undefined) {
            throw new Error("Cannot update a row without a valid \"id\"");
        }
        var rowNumber = this._dataView.getRowById(itemId);
        if (!item || rowNumber === undefined) {
            throw new Error("The item to update in the grid was not found with id: " + itemId);
        }
        if (this._dataView.getIdxById(itemId) !== undefined) {
            // Update the item itself inside the dataView
            this._dataView.updateItem(itemId, item);
            this._grid.updateRow(rowNumber);
            // do we want to scroll to the row so that it shows in the Viewport (UI)
            if (options.scrollRowIntoView) {
                this._grid.scrollRowIntoView(rowNumber);
            }
            // highlight the row we just updated, if defined
            if (options.highlightRow) {
                this.highlightRow(rowNumber);
            }
            // select the row in the grid
            if (options.selectRow && this._gridOptions && (this._gridOptions.enableCheckboxSelector || this._gridOptions.enableRowSelection)) {
                this.setSelectedRow(rowNumber);
            }
            // do we want to trigger an event after updating the item
            if (options.triggerEvent) {
                this.onItemUpdated.next(item);
            }
        }
        return rowNumber;
    };
    /**
     * Insert a row into the grid if it doesn't already exist or update if it does.
     * @param item object which must contain a unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, resortGrid, selectRow, triggerEvent)
     */
    GridService.prototype.upsertItem = function (item, options) {
        options = tslib_1.__assign({}, GridServiceInsertOptionDefaults, options);
        var idPropName = this._gridOptions.datasetIdPropertyName || 'id';
        var itemId = (!item || !(idPropName in item)) ? undefined : item[idPropName];
        if (itemId === undefined) {
            throw new Error("Calling Upsert of an item requires the item to include an \"" + idPropName + "\" property");
        }
        return this.upsertItemById(itemId, item, options);
    };
    /**
     * Update an array of existing items with new properties inside the datagrid
     * @param item object arrays, which must contain unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, resortGrid, selectRow, triggerEvent)
     * @return row numbers in the grid
     */
    GridService.prototype.upsertItems = function (items, options) {
        var _this = this;
        options = tslib_1.__assign({}, GridServiceInsertOptionDefaults, options);
        // when it's not an array, we can call directly the single item update
        if (!Array.isArray(items)) {
            return [this.upsertItem(items, options)];
        }
        this._dataView.beginUpdate();
        var upsertedRows = [];
        items.forEach(function (item) {
            upsertedRows.push(_this.upsertItem(item, tslib_1.__assign({}, options, { highlightRow: false, resortGrid: false, selectRow: false, triggerEvent: false })));
        });
        this._dataView.endUpdate();
        var rowNumbers = upsertedRows.map(function (upsertRow) { return upsertRow.added !== undefined ? upsertRow.added : upsertRow.updated; });
        // only highlight at the end, all at once
        // we have to do this because doing highlight 1 by 1 would only re-select the last highlighted row which is wrong behavior
        if (options.highlightRow) {
            this.highlightRow(rowNumbers);
        }
        // select the row in the grid
        if (options.selectRow && this._gridOptions && (this._gridOptions.enableCheckboxSelector || this._gridOptions.enableRowSelection)) {
            this.setSelectedRows(rowNumbers);
        }
        // do we want to trigger an event after updating the item
        if (options.triggerEvent) {
            this.onItemUpserted.next(items);
            var addedItems = upsertedRows.filter(function (upsertRow) { return upsertRow.added !== undefined; });
            if (Array.isArray(addedItems) && addedItems.length > 0) {
                this.onItemAdded.next(addedItems);
            }
            var updatedItems = upsertedRows.filter(function (upsertRow) { return upsertRow.updated !== undefined; });
            if (Array.isArray(updatedItems) && updatedItems.length > 0) {
                this.onItemUpdated.next(updatedItems);
            }
        }
        return upsertedRows;
    };
    /**
     * Update an existing item in the datagrid by it's id and new properties
     * @param itemId: item unique id
     * @param item object which must contain a unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, resortGrid, selectRow, triggerEvent)
     * @return grid row number in the grid
     */
    GridService.prototype.upsertItemById = function (itemId, item, options) {
        var isItemAdded = false;
        options = tslib_1.__assign({}, GridServiceInsertOptionDefaults, options);
        if (itemId === undefined) {
            throw new Error("Calling Upsert of an item requires the item to include a valid and unique \"id\" property");
        }
        var rowNumberAdded;
        var rowNumberUpdated;
        if (this._dataView.getRowById(itemId) === undefined) {
            rowNumberAdded = this.addItem(item, options);
            isItemAdded = true;
        }
        else {
            rowNumberUpdated = this.updateItem(item, { highlightRow: options.highlightRow, selectRow: options.selectRow, triggerEvent: options.triggerEvent });
            isItemAdded = false;
        }
        // do we want to trigger an event after updating the item
        if (options.triggerEvent) {
            this.onItemUpserted.next(item);
            isItemAdded ? this.onItemAdded.next(item) : this.onItemUpdated.next(item);
        }
        return { added: rowNumberAdded, updated: rowNumberUpdated };
    };
    GridService.ctorParameters = function () { return [
        { type: ExtensionService },
        { type: FilterService },
        { type: GridStateService },
        { type: SharedService },
        { type: SortService }
    ]; };
    GridService = tslib_1.__decorate([
        Injectable()
    ], GridService);
    return GridService;
}());
export { GridService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JpZC5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci1zbGlja2dyaWQvIiwic291cmNlcyI6WyJhcHAvbW9kdWxlcy9hbmd1bGFyLXNsaWNrZ3JpZC9zZXJ2aWNlcy9ncmlkLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQVkvQixPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUN2RCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDakQsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDdkQsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQ2pELE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUM3QyxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFJckQsSUFBSSxpQkFBc0IsQ0FBQztBQUUzQixJQUFNLCtCQUErQixHQUE0QixFQUFFLFlBQVksRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN4RixJQUFNLCtCQUErQixHQUE0QixFQUFFLFlBQVksRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLElBQUksRUFBRSxDQUFDO0FBQ2xLLElBQU0sK0JBQStCLEdBQTRCLEVBQUUsWUFBWSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLGlCQUFpQixFQUFFLEtBQUssRUFBRSxZQUFZLEVBQUUsSUFBSSxFQUFFLENBQUM7QUFDeEosSUFBTSx3QkFBd0IsR0FBcUIsRUFBRSxpQkFBaUIsRUFBRSxJQUFJLEVBQUUsWUFBWSxFQUFF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QUMzQixJQUFJLGdCQUF3QixDQUFDO1FBQzdCLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLEtBQUssU0FBUyxFQUFFO1lBQ25ELGNBQWMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFJLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQztZQUNoRCxXQUFXLEdBQUcsSUFBSSxDQUFDO1NBQ3BCO2FBQU07WUFDTCxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFJLElBQUksRUFBRSxFQUFFLFlBQVksRUFBRSxPQUFPLENBQUMsWUFBWSxFQUFFLFNBQVMsRUFBRSxPQUFPLENBQUMsU0FBUyxFQUFFLFlBQVksRUFBRSxPQUFPLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQztZQUN0SixXQUFXLEdBQUcsS0FBSyxDQUFDO1NBQ3JCO1FBRUQseURBQXlEO1FBQ3pELElBQUksT0FBTyxDQUFDLFlBQVksRUFBRTtZQUN4QixJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUMvQixXQUFXLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUMzRTtRQUNELE9BQU8sRUFBRSxLQUFLLEVBQUUsY0FBYyxFQUFFLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxDQUFDO0lBQzlELENBQUM7O2dCQTd5QjJCLGdCQUFnQjtnQkFDbkIsYUFBYTtnQkFDVixnQkFBZ0I7Z0JBQ25CLGFBQWE7Z0JBQ2YsV0FBVzs7SUFmdkIsV0FBVztRQUR2QixVQUFVLEVBQUU7T0FDQSxXQUFXLENBeXpCdkI7SUFBRCxrQkFBQztDQUFBLEFBenpCRCxJQXl6QkM7U0F6ekJZLFdBQVciLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcclxuXHJcbmltcG9ydCB7XHJcbiAgQ2VsbEFyZ3MsXHJcbiAgQ29sdW1uLFxyXG4gIEdyaWRPcHRpb24sXHJcbiAgR3JpZFNlcnZpY2VEZWxldGVPcHRpb24sXHJcbiAgR3JpZFNlcnZpY2VJbnNlcnRPcHRpb24sXHJcbiAgR3JpZFNlcnZpY2VVcGRhdGVPcHRpb24sXHJcbiAgSGlkZUNvbHVtbk9wdGlvbixcclxuICBPbkV2ZW50QXJnc1xyXG59IGZyb20gJy4vLi4vbW9kZWxzL2luZGV4JztcclxuaW1wb3J0IHsgRXh0ZW5zaW9uU2VydmljZSB9IGZyb20gJy4vZXh0ZW5zaW9uLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBGaWx0ZXJTZXJ2aWNlIH0gZnJvbSAnLi9maWx0ZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IEdyaWRTdGF0ZVNlcnZpY2UgfSBmcm9tICcuL2dyaWRTdGF0ZS5zZXJ2aWNlJztcclxuaW1wb3J0IHsgU2hhcmVkU2VydmljZSB9IGZyb20gJy4vc2hhcmVkLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBTb3J0U2VydmljZSB9IGZyb20gJy4vc29ydC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgYXJyYXlSZW1vdmVJdGVtQnlJbmRleCB9IGZyb20gJy4vdXRpbGl0aWVzJztcclxuXHJcbi8vIHVzaW5nIGV4dGVybmFsIG5vbi10eXBlZCBqcyBsaWJyYXJpZXNcclxuZGVjbGFyZSBjb25zdCBTbGljazogYW55O1xyXG5sZXQgaGlnaGxpZ2h0VGltZXJFbmQ6IGFueTtcclxuXHJcbmNvbnN0IEdyaWRTZXJ2aWNlRGVsZXRlT3B0aW9uRGVmYXVsdHM6IEdyaWRTZXJ2aWNlRGVsZXRlT3B0aW9uID0geyB0cmlnZ2VyRXZlbnQ6IHRydWUgfTtcclxuY29uc3QgR3JpZFNlcnZpY2VJbnNlcnRPcHRpb25EZWZhdWx0czogR3JpZFNlcnZpY2VJbnNlcnRPcHRpb24gPSB7IGhpZ2hsaWdodFJvdzogdHJ1ZSwgcG9zaXRpb246ICd0b3AnLCByZXNvcnRHcmlkOiBmYWxzZSwgc2VsZWN0Um93OiBmYWxzZSwgdHJpZ2dlckV2ZW50OiB0cnVlIH07XHJcbmNvbnN0IEdyaWRTZXJ2aWNlVXBkYXRlT3B0aW9uRGVmYXVsdHM6IEdyaWRTZXJ2aWNlVXBkYXRlT3B0aW9uID0geyBoaWdobGlnaHRSb3c6IHRydWUsIHNlbGVjdFJvdzogZmFsc2UsIHNjcm9sbFJvd0ludG9WaWV3OiBmYWxzZSwgdHJpZ2dlckV2ZW50OiB0cnVlIH07XHJcbmNvbnN0IEhpZGVDb2x1bW5PcHRpb25EZWZhdWx0czogSGlkZUNvbHVtbk9wdGlvbiA9IHsgYXV0b1Jlc2l6ZUNvbHVtbnM6IHRydWUsIHRyaWdnZXJFdmVudDogdHJ1ZSwgaGlkZUZyb21Db2x1bW5QaWNrZXI6IGZhbHNlLCBoaWRlRnJvbUdyaWRNZW51OiBmYWxzZSB9O1xyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgR3JpZFNlcnZpY2Uge1xyXG4gIHByaXZhdGUgX2dyaWQ6IGFueTtcclxuICBwcml2YXRlIF9kYXRhVmlldzogYW55O1xyXG4gIHByaXZhdGUgX3Jvd1NlbGVjdGlvblBsdWdpbjogYW55O1xyXG4gIG9uSXRlbUFkZGVkID0gbmV3IFN1YmplY3Q8YW55IHwgYW55W10+KCk7XHJcbiAgb25JdGVtRGVsZXRlZCA9IG5ldyBTdWJqZWN0PGFueSB8IGFueVtdPigpO1xyXG4gIG9uSXRlbVVwZGF0ZWQgPSBuZXcgU3ViamVjdDxhbnkgfCBhbnlbXT4oKTtcclxuICBvbkl0ZW1VcHNlcnRlZCA9IG5ldyBTdWJqZWN0PGFueSB8IGFueVtdPigpO1xyXG4gIG9uQ29sdW1uc0NoYW5nZWQgPSBuZXcgU3ViamVjdDxDb2x1bW5bXT4oKTtcclxuXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBwcml2YXRlIGV4dGVuc2lvblNlcnZpY2U6IEV4dGVuc2lvblNlcnZpY2UsXHJcbiAgICBwcml2YXRlIGZpbHRlclNlcnZpY2U6IEZpbHRlclNlcnZpY2UsXHJcbiAgICBwcml2YXRlIGdyaWRTdGF0ZVNlcnZpY2U6IEdyaWRTdGF0ZVNlcnZpY2UsXHJcbiAgICBwcml2YXRlIHNoYXJlZFNlcnZpY2U6IFNoYXJlZFNlcnZpY2UsXHJcbiAgICBwcml2YXRlIHNvcnRTZXJ2aWNlOiBTb3J0U2VydmljZVxyXG4gICkgeyB9XHJcblxyXG4gIC8qKiBHZXR0ZXIgZm9yIHRoZSBHcmlkIE9wdGlvbnMgcHVsbGVkIHRocm91Z2ggdGhlIEdyaWQgT2JqZWN0ICovXHJcbiAgcHJpdmF0ZSBnZXQgX2dyaWRPcHRpb25zKCk6IEdyaWRPcHRpb24ge1xyXG4gICAgcmV0dXJuICh0aGlzLl9ncmlkICYmIHRoaXMuX2dyaWQuZ2V0T3B0aW9ucykgPyB0aGlzLl9ncmlkLmdldE9wdGlvbnMoKSA6IHt9O1xyXG4gIH1cclxuXHJcbiAgZGlzcG9zZSgpIHtcclxuICAgIGlmICh0aGlzLl9yb3dTZWxlY3Rpb25QbHVnaW4gJiYgdGhpcy5fcm93U2VsZWN0aW9uUGx1Z2luLmRlc3Ryb3kpIHtcclxuICAgICAgdGhpcy5fcm93U2VsZWN0aW9uUGx1Z2luLmRlc3Ryb3koKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGluaXQoZ3JpZDogYW55LCBkYXRhVmlldzogYW55KTogdm9pZCB7XHJcbiAgICB0aGlzLl9ncmlkID0gZ3JpZDtcclxuICAgIHRoaXMuX2RhdGFWaWV3ID0gZGF0YVZpZXc7XHJcbiAgfVxyXG5cclxuICAvKiogQ2xlYXIgYWxsIEZpbHRlcnMgJiBTb3J0cyAqL1xyXG4gIGNsZWFyQWxsRmlsdGVyc0FuZFNvcnRzKCkge1xyXG4gICAgLy8gY2FsbCBib3RoIGNsZWFyIEZpbHRlcnMgJiBTb3J0IGJ1dCBvbmx5IHRyaWdnZXIgdGhlIGxhc3Qgb25lIHRvIGF2b2lkIHNlbmRpbmcgbXVsdGlwbGUgYmFja2VuZCBxdWVyaWVzXHJcbiAgICBpZiAodGhpcy5zb3J0U2VydmljZSAmJiB0aGlzLnNvcnRTZXJ2aWNlLmNsZWFyU29ydGluZykge1xyXG4gICAgICB0aGlzLnNvcnRTZXJ2aWNlLmNsZWFyU29ydGluZyhmYWxzZSk7IC8vIHNraXAgZXZlbnQgdHJpZ2dlciBvbiB0aGlzIG9uZVxyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuZmlsdGVyU2VydmljZSAmJiB0aGlzLmZpbHRlclNlcnZpY2UuY2xlYXJGaWx0ZXJzKSB7XHJcbiAgICAgIHRoaXMuZmlsdGVyU2VydmljZS5jbGVhckZpbHRlcnMoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBhbGwgY29sdW1uIHNldCBpbiB0aGUgZ3JpZCwgdGhhdCBpcyBhbGwgdmlzaWJsZS9oaWRkZW4gY29sdW1uc1xyXG4gICAqIGFuZCBhbHNvIGluY2x1ZGUgYW55IGV4dHJhIGNvbHVtbnMgdXNlZCBieSBzb21lIHBsdWdpbnMgKGxpa2UgUm93IFNlbGVjdGlvbiwgUm93IERldGFpbCwgLi4uKVxyXG4gICAqL1xyXG4gIGdldEFsbENvbHVtbkRlZmluaXRpb25zKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc2hhcmVkU2VydmljZS5hbGxDb2x1bW5zO1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldCBvbmx5IHZpc2libGUgY29sdW1uIGRlZmluaXRpb25zIGFuZCBhbHNvIGluY2x1ZGUgYW55IGV4dHJhIGNvbHVtbnMgYnkgc29tZSBwbHVnaW5zIChsaWtlIFJvdyBTZWxlY3Rpb24sIFJvdyBEZXRhaWwsIC4uLikgKi9cclxuICBnZXRWaXNpYmxlQ29sdW1uRGVmaW5pdGlvbnMoKTogQ29sdW1uW10ge1xyXG4gICAgcmV0dXJuIHRoaXMuc2hhcmVkU2VydmljZS52aXNpYmxlQ29sdW1ucztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZyb20gYSBTbGlja0dyaWQgRXZlbnQgdHJpZ2dlcmVkIGdldCB0aGUgQ29sdW1uIERlZmluaXRpb24gYW5kIEl0ZW0gRGF0YSBDb250ZXh0XHJcbiAgICpcclxuICAgKiBGb3IgZXhhbXBsZSB0aGUgU2xpY2tHcmlkIG9uQ2xpY2sgd2lsbCByZXR1cm4gY2VsbCBhcmd1bWVudHMgd2hlbiBzdWJzY3JpYmluZyB0byBpdC5cclxuICAgKiBGcm9tIHRoZXNlIGNlbGxBcmdzLCB3ZSB3YW50IHRvIGdldCB0aGUgQ29sdW1uIERlZmluaXRpb24gYW5kIEl0ZW0gRGF0YVxyXG4gICAqIEBwYXJhbSBjZWxsIGV2ZW50IGFyZ3NcclxuICAgKiBAcmV0dXJuIG9iamVjdCB3aXRoIGNvbHVtbkRlZiBhbmQgZGF0YUNvbnRleHRcclxuICAgKi9cclxuICBnZXRDb2x1bW5Gcm9tRXZlbnRBcmd1bWVudHMoYXJnczogQ2VsbEFyZ3MpOiBPbkV2ZW50QXJncyB7XHJcbiAgICBpZiAoIWFyZ3MgfHwgIWFyZ3MuZ3JpZCB8fCAhYXJncy5ncmlkLmdldENvbHVtbnMgfHwgIWFyZ3MuZ3JpZC5nZXREYXRhSXRlbSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvIGdldCB0aGUgY29sdW1uIGRlZmluaXRpb24gYW5kIGRhdGEsIHdlIG5lZWQgdG8gaGF2ZSB0aGVzZSBhcmd1bWVudHMgcGFzc2VkIGFzIG9iamVjdHMgKHJvdywgY2VsbCwgZ3JpZCknKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICByb3c6IGFyZ3Mucm93LFxyXG4gICAgICBjZWxsOiBhcmdzLmNlbGwsXHJcbiAgICAgIGNvbHVtbkRlZjogYXJncy5ncmlkLmdldENvbHVtbnMoKVthcmdzLmNlbGxdLFxyXG4gICAgICBkYXRhQ29udGV4dDogYXJncy5ncmlkLmdldERhdGFJdGVtKGFyZ3Mucm93KSxcclxuICAgICAgZGF0YVZpZXc6IHRoaXMuX2RhdGFWaWV3LFxyXG4gICAgICBncmlkOiB0aGlzLl9ncmlkXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldCBkYXRhIGl0ZW0gYnkgaXQncyByb3cgaW5kZXggbnVtYmVyICovXHJcbiAgZ2V0RGF0YUl0ZW1CeVJvd051bWJlcjxUID0gYW55Pihyb3dOdW1iZXI6IG51bWJlcik6IFQge1xyXG4gICAgaWYgKCF0aGlzLl9ncmlkIHx8IHR5cGVvZiB0aGlzLl9ncmlkLmdldERhdGFJdGVtICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgV2UgY291bGQgbm90IGZpbmQgU2xpY2tHcmlkIEdyaWQgb2JqZWN0IG9yIGl0J3MgXCJnZXREYXRhSXRlbVwiIG1ldGhvZGApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuX2dyaWQuZ2V0RGF0YUl0ZW0ocm93TnVtYmVyKTtcclxuICB9XHJcblxyXG4gIC8qKiBDaGFpbiB0aGUgaXRlbSBNZXRhZGF0YSB3aXRoIG91ciBpbXBsZW1lbnRhdGlvbiBvZiBNZXRhZGF0YSBhdCBnaXZlbiByb3cgaW5kZXggKi9cclxuICBnZXRJdGVtUm93TWV0YWRhdGFUb0hpZ2hsaWdodChwcmV2aW91c0l0ZW1NZXRhZGF0YTogYW55KSB7XHJcbiAgICByZXR1cm4gKHJvd051bWJlcjogbnVtYmVyKSA9PiB7XHJcbiAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9kYXRhVmlldy5nZXRJdGVtKHJvd051bWJlcik7XHJcbiAgICAgIGxldCBtZXRhID0geyBjc3NDbGFzc2VzOiAnJyB9O1xyXG4gICAgICBpZiAodHlwZW9mIHByZXZpb3VzSXRlbU1ldGFkYXRhID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgbWV0YSA9IHByZXZpb3VzSXRlbU1ldGFkYXRhKHJvd051bWJlcik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghbWV0YSkge1xyXG4gICAgICAgIG1ldGEgPSB7IGNzc0NsYXNzZXM6ICcnIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpdGVtICYmIGl0ZW0uX2RpcnR5KSB7XHJcbiAgICAgICAgbWV0YS5jc3NDbGFzc2VzID0gKG1ldGEgJiYgbWV0YS5jc3NDbGFzc2VzIHx8ICcnKSArICcgZGlydHknO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaXRlbSAmJiBpdGVtLnJvd0NsYXNzICYmIG1ldGEpIHtcclxuICAgICAgICBtZXRhLmNzc0NsYXNzZXMgKz0gYCAke2l0ZW0ucm93Q2xhc3N9YDtcclxuICAgICAgICBtZXRhLmNzc0NsYXNzZXMgKz0gYCByb3cke3Jvd051bWJlcn1gO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbWV0YTtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgICAqIEBkZXByZWNhdGVkIEhpZGUgYSBDb2x1bW4gZnJvbSB0aGUgR3JpZCAodGhlIGNvbHVtbiB3aWxsIGp1c3QgYmVjb21lIGhpZGRlbiBhbmQgd2lsbCBzdGlsbCBzaG93IHVwIGluIGNvbHVtblBpY2tlci9ncmlkTWVudSlcclxuICAgICAqIEBzZWUgaGlkZUNvbHVtbkJ5SWRcclxuICAgICAqIEBwYXJhbSBjb2x1bW5cclxuICAgICAqL1xyXG4gIGhpZGVDb2x1bW4oY29sdW1uOiBDb2x1bW4pIHtcclxuICAgIGlmICh0aGlzLl9ncmlkICYmIHRoaXMuX2dyaWQuZ2V0Q29sdW1ucyAmJiB0aGlzLl9ncmlkLnNldENvbHVtbnMgJiYgdGhpcy5fZ3JpZC5nZXRDb2x1bW5JbmRleCkge1xyXG4gICAgICBjb25zdCBjb2x1bW5JbmRleCA9IHRoaXMuX2dyaWQuZ2V0Q29sdW1uSW5kZXgoY29sdW1uLmlkKTtcclxuICAgICAgaWYgKGNvbHVtbkluZGV4ID49IDApIHtcclxuICAgICAgICB0aGlzLmhpZGVDb2x1bW5CeUluZGV4KGNvbHVtbkluZGV4KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGRlcHJlY2F0ZWQgSGlkZSBhIENvbHVtbiBmcm9tIHRoZSBHcmlkIGJ5IGl0cyBjb2x1bW4gZGVmaW5pdGlvbiBpbmRleCAodGhlIGNvbHVtbiB3aWxsIGp1c3QgYmVjb21lIGhpZGRlbiBhbmQgd2lsbCBzdGlsbCBzaG93IHVwIGluIGNvbHVtblBpY2tlci9ncmlkTWVudSlcclxuICAgKiBAc2VlIGhpZGVDb2x1bW5CeUlkIFBsZWFzZSB1c2UgXCJoaWRlQ29sdW1uQnlJZChpZClcIiBvciBcImhpZGVDb2x1bW5CeUlkcyhbaWRzXSlcIiBpbnN0ZWFkIHNpbmNlIGl0IGhhcyBhIGxvdCBtb3JlIG9wdGlvbnNcclxuICAgKiBAcGFyYW0gY29sdW1uSW5kZXggLSBjb2x1bW4gZGVmaW5pdGlvbiBpbmRleFxyXG4gICAqIEBwYXJhbSB0cmlnZ2VyRXZlbnQgLSBkbyB3ZSB3YW50IHRvIHRyaWdnZXIgYW4gZXZlbnQgKG9uSGVhZGVyTWVudUNvbHVtbnNDaGFuZ2VkKSB3aGVuIGNvbHVtbiBiZWNvbWVzIGhpZGRlbj8gRGVmYXVsdHMgdG8gdHJ1ZS5cclxuICAgKi9cclxuICBoaWRlQ29sdW1uQnlJbmRleChjb2x1bW5JbmRleDogbnVtYmVyLCB0cmlnZ2VyRXZlbnQgPSB0cnVlKSB7XHJcbiAgICBpZiAodGhpcy5fZ3JpZCAmJiB0aGlzLl9ncmlkLmdldENvbHVtbnMgJiYgdGhpcy5fZ3JpZC5zZXRDb2x1bW5zKSB7XHJcbiAgICAgIGNvbnN0IGN1cnJlbnRDb2x1bW5zID0gdGhpcy5fZ3JpZC5nZXRDb2x1bW5zKCk7XHJcbiAgICAgIGNvbnN0IHZpc2libGVDb2x1bW5zID0gYXJyYXlSZW1vdmVJdGVtQnlJbmRleDxDb2x1bW4+KGN1cnJlbnRDb2x1bW5zLCBjb2x1bW5JbmRleCk7XHJcbiAgICAgIHRoaXMuc2hhcmVkU2VydmljZS52aXNpYmxlQ29sdW1ucyA9IHZpc2libGVDb2x1bW5zO1xyXG4gICAgICB0aGlzLl9ncmlkLnNldENvbHVtbnModmlzaWJsZUNvbHVtbnMpO1xyXG4gICAgICBpZiAodHJpZ2dlckV2ZW50KSB7XHJcbiAgICAgICAgdGhpcy5vbkNvbHVtbnNDaGFuZ2VkLm5leHQodmlzaWJsZUNvbHVtbnMpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBIaWRlIGEgQ29sdW1uIGZyb20gdGhlIEdyaWQgYnkgaXRzIGNvbHVtbiBkZWZpbml0aW9uIGlkLCB0aGUgY29sdW1uIHdpbGwganVzdCBiZWNvbWUgaGlkZGVuIGFuZCB3aWxsIHN0aWxsIHNob3cgdXAgaW4gY29sdW1uUGlja2VyL2dyaWRNZW51XHJcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJ9IGNvbHVtbklkIC0gY29sdW1uIGRlZmluaXRpb24gaWRcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHRyaWdnZXJFdmVudCAtIGRvIHdlIHdhbnQgdG8gdHJpZ2dlciBhbiBldmVudCAob25IZWFkZXJNZW51Q29sdW1uc0NoYW5nZWQpIHdoZW4gY29sdW1uIGJlY29tZXMgaGlkZGVuPyBEZWZhdWx0cyB0byB0cnVlLlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gY29sdW1uSW5kZXggLSBjb2x1bW4gaW5kZXggcG9zaXRpb24gd2hlbiBmb3VuZCBvciAtMVxyXG4gICAqL1xyXG4gIGhpZGVDb2x1bW5CeUlkKGNvbHVtbklkOiBzdHJpbmcgfCBudW1iZXIsIG9wdGlvbnM/OiBIaWRlQ29sdW1uT3B0aW9uKTogbnVtYmVyIHtcclxuICAgIG9wdGlvbnMgPSB7IC4uLkhpZGVDb2x1bW5PcHRpb25EZWZhdWx0cywgLi4ub3B0aW9ucyB9O1xyXG4gICAgaWYgKHRoaXMuX2dyaWQgJiYgdGhpcy5fZ3JpZC5nZXRDb2x1bW5zICYmIHRoaXMuX2dyaWQuc2V0Q29sdW1ucykge1xyXG4gICAgICBjb25zdCBjdXJyZW50Q29sdW1ucyA9IHRoaXMuX2dyaWQuZ2V0Q29sdW1ucygpO1xyXG4gICAgICBjb25zdCBjb2xJbmRleEZvdW5kID0gY3VycmVudENvbHVtbnMuZmluZEluZGV4KGNvbCA9PiBjb2wuaWQgPT09IGNvbHVtbklkKTtcclxuXHJcbiAgICAgIGlmIChjb2xJbmRleEZvdW5kID49IDApIHtcclxuICAgICAgICBjb25zdCB2aXNpYmxlQ29sdW1ucyA9IGFycmF5UmVtb3ZlSXRlbUJ5SW5kZXg8Q29sdW1uPihjdXJyZW50Q29sdW1ucywgY29sSW5kZXhGb3VuZCk7XHJcbiAgICAgICAgdGhpcy5zaGFyZWRTZXJ2aWNlLnZpc2libGVDb2x1bW5zID0gdmlzaWJsZUNvbHVtbnM7XHJcbiAgICAgICAgdGhpcy5fZ3JpZC5zZXRDb2x1bW5zKHZpc2libGVDb2x1bW5zKTtcclxuXHJcbiAgICAgICAgY29uc3QgY29sdW1uSW5kZXhGcm9tQWxsQ29sdW1ucyA9IHRoaXMuc2hhcmVkU2VydmljZS5hbGxDb2x1bW5zLmZpbmRJbmRleChjb2wgPT4gY29sLmlkID09PSBjb2x1bW5JZCk7XHJcbiAgICAgICAgaWYgKGNvbHVtbkluZGV4RnJvbUFsbENvbHVtbnMpIHtcclxuICAgICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaGlkZUZyb21Db2x1bW5QaWNrZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5zaGFyZWRTZXJ2aWNlLmFsbENvbHVtbnNbY29sdW1uSW5kZXhGcm9tQWxsQ29sdW1uc10uZXhjbHVkZUZyb21Db2x1bW5QaWNrZXIgPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5oaWRlRnJvbUdyaWRNZW51KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hhcmVkU2VydmljZS5hbGxDb2x1bW5zW2NvbHVtbkluZGV4RnJvbUFsbENvbHVtbnNdLmV4Y2x1ZGVGcm9tR3JpZE1lbnUgPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gZG8gd2Ugd2FudCB0byBhdXRvLXJlc2l6ZSB0aGUgY29sdW1ucyBpbiB0aGUgZ3JpZCBhZnRlciBoaWRkaW5nIHNvbWU/IG1vc3Qgb2Z0ZW4geWVzXHJcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hdXRvUmVzaXplQ29sdW1ucykge1xyXG4gICAgICAgICAgdGhpcy5fZ3JpZC5hdXRvc2l6ZUNvbHVtbnMoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGRvIHdlIHdhbnQgdG8gdHJpZ2dlciBhbiBldmVudCBhZnRlciBoaWRkaW5nXHJcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy50cmlnZ2VyRXZlbnQpIHtcclxuICAgICAgICAgIHRoaXMub25Db2x1bW5zQ2hhbmdlZC5uZXh0KHZpc2libGVDb2x1bW5zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbEluZGV4Rm91bmQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiAtMTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEhpZGUgYSBDb2x1bW4gZnJvbSB0aGUgR3JpZCBieSBpdHMgY29sdW1uIGRlZmluaXRpb24gaWQocyksIHRoZSBjb2x1bW4gd2lsbCBqdXN0IGJlY29tZSBoaWRkZW4gYW5kIHdpbGwgc3RpbGwgc2hvdyB1cCBpbiBjb2x1bW5QaWNrZXIvZ3JpZE1lbnVcclxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZyB8IG51bWJlcj59IGNvbHVtbklkcyAtIGNvbHVtbiBkZWZpbml0aW9uIGlkcywgY2FuIGJlIGEgc2luZ2xlIHN0cmluZyBhbmQgYW4gYXJyYXkgb2Ygc3RyaW5nc1xyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdHJpZ2dlckV2ZW50IC0gZG8gd2Ugd2FudCB0byB0cmlnZ2VyIGFuIGV2ZW50IChvbkhlYWRlck1lbnVDb2x1bW5zQ2hhbmdlZCkgd2hlbiBjb2x1bW4gYmVjb21lcyBoaWRkZW4/IERlZmF1bHRzIHRvIHRydWUuXHJcbiAgICovXHJcbiAgaGlkZUNvbHVtbkJ5SWRzKGNvbHVtbklkczogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPiwgb3B0aW9ucz86IEhpZGVDb2x1bW5PcHRpb24pIHtcclxuICAgIG9wdGlvbnMgPSB7IC4uLkhpZGVDb2x1bW5PcHRpb25EZWZhdWx0cywgLi4ub3B0aW9ucyB9O1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29sdW1uSWRzKSkge1xyXG4gICAgICBmb3IgKGNvbnN0IGNvbHVtbklkIG9mIGNvbHVtbklkcykge1xyXG4gICAgICAgIC8vIGhpZGUgZWFjaCBjb2x1bW4gYnkgaXRzIGlkIGJ1dCB3YWl0IGFmdGVyIHRoZSBmb3IgbG9vcCB0byBhdXRvIHJlc2l6ZSBjb2x1bW5zIGluIHRoZSBncmlkXHJcbiAgICAgICAgdGhpcy5oaWRlQ29sdW1uQnlJZChjb2x1bW5JZCwgeyAuLi5vcHRpb25zLCB0cmlnZ2VyRXZlbnQ6IGZhbHNlLCBhdXRvUmVzaXplQ29sdW1uczogZmFsc2UgfSk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gZG8gd2Ugd2FudCB0byBhdXRvLXJlc2l6ZSB0aGUgY29sdW1ucyBpbiB0aGUgZ3JpZCBhZnRlciBoaWRkaW5nIHNvbWU/IG1vc3Qgb2Z0ZW4geWVzXHJcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYXV0b1Jlc2l6ZUNvbHVtbnMpIHtcclxuICAgICAgICB0aGlzLl9ncmlkLmF1dG9zaXplQ29sdW1ucygpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIGRvIHdlIHdhbnQgdG8gdHJpZ2dlciBhbiBldmVudCBhZnRlciBoaWRkaW5nXHJcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMudHJpZ2dlckV2ZW50KSB7XHJcbiAgICAgICAgdGhpcy5vbkNvbHVtbnNDaGFuZ2VkLm5leHQodGhpcy5zaGFyZWRTZXJ2aWNlLnZpc2libGVDb2x1bW5zKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSGlnaGxpZ2h0IHRoZW4gZmFkZSBhIHJvdyBmb3IgeCBzZWNvbmRzLlxyXG4gICAqIFRoZSBpbXBsZW1lbnRhdGlvbiBmb2xsb3dzIHRoaXMgU08gYW5zd2VyOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTk5ODUxNDgvMTIxMjE2NlxyXG4gICAqIEBwYXJhbSByb3dOdW1iZXJcclxuICAgKiBAcGFyYW0gZmFkZURlbGF5XHJcbiAgICovXHJcbiAgaGlnaGxpZ2h0Um93KHJvd051bWJlcjogbnVtYmVyIHwgbnVtYmVyW10sIGZhZGVEZWxheSA9IDE1MDAsIGZhZGVPdXREZWxheSA9IDMwMCkge1xyXG4gICAgLy8gY3JlYXRlIGEgU2VsZWN0aW9uTW9kZWwgaWYgdGhlcmUncyBub3Qgb25lIHlldFxyXG4gICAgaWYgKCF0aGlzLl9ncmlkLmdldFNlbGVjdGlvbk1vZGVsKCkgJiYgU2xpY2sgJiYgU2xpY2suUm93U2VsZWN0aW9uTW9kZWwpIHtcclxuICAgICAgdGhpcy5fcm93U2VsZWN0aW9uUGx1Z2luID0gbmV3IFNsaWNrLlJvd1NlbGVjdGlvbk1vZGVsKHRoaXMuX2dyaWRPcHRpb25zLnJvd1NlbGVjdGlvbk9wdGlvbnMgfHwge30pO1xyXG4gICAgICB0aGlzLl9ncmlkLnNldFNlbGVjdGlvbk1vZGVsKHRoaXMuX3Jvd1NlbGVjdGlvblBsdWdpbik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocm93TnVtYmVyKSkge1xyXG4gICAgICByb3dOdW1iZXIuZm9yRWFjaChyb3cgPT4gdGhpcy5oaWdobGlnaHRSb3dCeU1ldGFkYXRhKHJvdywgZmFkZURlbGF5LCBmYWRlT3V0RGVsYXkpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuaGlnaGxpZ2h0Um93QnlNZXRhZGF0YShyb3dOdW1iZXIsIGZhZGVEZWxheSwgZmFkZU91dERlbGF5KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGhpZ2hsaWdodFJvd0J5TWV0YWRhdGEocm93TnVtYmVyOiBudW1iZXIsIGZhZGVEZWxheSA9IDE1MDAsIGZhZGVPdXREZWxheSA9IDMwMCkge1xyXG4gICAgdGhpcy5fZGF0YVZpZXcuZ2V0SXRlbU1ldGFkYXRhID0gdGhpcy5nZXRJdGVtUm93TWV0YWRhdGFUb0hpZ2hsaWdodCh0aGlzLl9kYXRhVmlldy5nZXRJdGVtTWV0YWRhdGEpO1xyXG5cclxuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9kYXRhVmlldy5nZXRJdGVtKHJvd051bWJlcik7XHJcbiAgICBjb25zdCBpZFByb3BOYW1lID0gdGhpcy5fZ3JpZE9wdGlvbnMuZGF0YXNldElkUHJvcGVydHlOYW1lIHx8ICdpZCc7XHJcblxyXG4gICAgaWYgKGl0ZW0gJiYgaXRlbVtpZFByb3BOYW1lXSkge1xyXG4gICAgICBpdGVtLnJvd0NsYXNzID0gJ2hpZ2hsaWdodCc7XHJcbiAgICAgIHRoaXMuX2RhdGFWaWV3LnVwZGF0ZUl0ZW0oaXRlbVtpZFByb3BOYW1lXSwgaXRlbSk7XHJcbiAgICAgIHRoaXMucmVuZGVyR3JpZCgpO1xyXG5cclxuICAgICAgLy8gZmFkZSBvdXRcclxuICAgICAgY2xlYXJUaW1lb3V0KGhpZ2hsaWdodFRpbWVyRW5kKTtcclxuICAgICAgaGlnaGxpZ2h0VGltZXJFbmQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBpdGVtLnJvd0NsYXNzID0gJ2hpZ2hsaWdodC1lbmQnO1xyXG4gICAgICAgIHRoaXMuX2RhdGFWaWV3LnVwZGF0ZUl0ZW0oaXRlbVtpZFByb3BOYW1lXSwgaXRlbSk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJHcmlkKCk7XHJcbiAgICAgIH0sIGZhZGVPdXREZWxheSk7XHJcblxyXG4gICAgICAvLyBkZWxldGUgdGhlIHJvdydzIENTUyBoaWdobGlnaHQgY2xhc3NlcyBvbmNlIHRoZSBkZWxheSBpcyBwYXNzZWRcclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbVtpZFByb3BOYW1lXSkge1xyXG4gICAgICAgICAgZGVsZXRlIGl0ZW0ucm93Q2xhc3M7XHJcbiAgICAgICAgICBpZiAodGhpcy5fZGF0YVZpZXcuZ2V0SWR4QnlJZChpdGVtW2lkUHJvcE5hbWVdKSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RhdGFWaWV3LnVwZGF0ZUl0ZW0oaXRlbVtpZFByb3BOYW1lXSwgaXRlbSk7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyR3JpZCgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSwgZmFkZURlbGF5ICsgZmFkZU91dERlbGF5KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKiBHZXQgdGhlIERhdGEgSXRlbSBmcm9tIGEgZ3JpZCByb3cgaW5kZXggKi9cclxuICBnZXREYXRhSXRlbUJ5Um93SW5kZXg8VCA9IGFueT4oaW5kZXg6IG51bWJlcik6IFQge1xyXG4gICAgaWYgKCF0aGlzLl9ncmlkIHx8IHR5cGVvZiB0aGlzLl9ncmlkLmdldERhdGFJdGVtICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2UgY291bGQgbm90IGZpbmQgU2xpY2tHcmlkIEdyaWQgb2JqZWN0IGFuZC9vciBcImdldERhdGFJdGVtXCIgbWV0aG9kJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX2dyaWQuZ2V0RGF0YUl0ZW0oaW5kZXgpO1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldCB0aGUgRGF0YSBJdGVtIGZyb20gYW4gYXJyYXkgb2YgZ3JpZCByb3cgaW5kZXhlcyAqL1xyXG4gIGdldERhdGFJdGVtQnlSb3dJbmRleGVzPFQgPSBhbnk+KGluZGV4ZXM6IG51bWJlcltdKTogVFtdIHtcclxuICAgIGlmICghdGhpcy5fZ3JpZCB8fCB0eXBlb2YgdGhpcy5fZ3JpZC5nZXREYXRhSXRlbSAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlIGNvdWxkIG5vdCBmaW5kIFNsaWNrR3JpZCBHcmlkIG9iamVjdCBhbmQvb3IgXCJnZXREYXRhSXRlbVwiIG1ldGhvZCcpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRhdGFJdGVtcyA9IFtdO1xyXG5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KGluZGV4ZXMpKSB7XHJcbiAgICAgIGluZGV4ZXMuZm9yRWFjaCgoaWR4KSA9PiB7XHJcbiAgICAgICAgZGF0YUl0ZW1zLnB1c2godGhpcy5fZ3JpZC5nZXREYXRhSXRlbShpZHgpKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRhdGFJdGVtcztcclxuICB9XHJcblxyXG4gIC8qKiBHZXQgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCByb3cgaW5kZXhlcyAqL1xyXG4gIGdldFNlbGVjdGVkUm93cygpOiBudW1iZXJbXSB7XHJcbiAgICBpZiAoIXRoaXMuX2dyaWQgfHwgdHlwZW9mIHRoaXMuX2dyaWQuZ2V0U2VsZWN0ZWRSb3dzICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2UgY291bGQgbm90IGZpbmQgU2xpY2tHcmlkIEdyaWQgb2JqZWN0IGFuZC9vciBcImdldFNlbGVjdGVkUm93c1wiIG1ldGhvZCcpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuX2dyaWQuZ2V0U2VsZWN0ZWRSb3dzKCk7XHJcbiAgfVxyXG5cclxuICAvKiogR2V0IHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgcm93cyBpdGVtIGRhdGEgKi9cclxuICBnZXRTZWxlY3RlZFJvd3NEYXRhSXRlbTxUID0gYW55PigpOiBUW10ge1xyXG4gICAgaWYgKCF0aGlzLl9ncmlkIHx8IHR5cGVvZiB0aGlzLl9ncmlkLmdldFNlbGVjdGVkUm93cyAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlIGNvdWxkIG5vdCBmaW5kIFNsaWNrR3JpZCBHcmlkIG9iamVjdCBhbmQvb3IgXCJnZXRTZWxlY3RlZFJvd3NcIiBtZXRob2QnKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzZWxlY3RlZFJvd0luZGV4ZXMgPSB0aGlzLl9ncmlkLmdldFNlbGVjdGVkUm93cygpO1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0RGF0YUl0ZW1CeVJvd0luZGV4ZXM8VD4oc2VsZWN0ZWRSb3dJbmRleGVzKTtcclxuICB9XHJcblxyXG4gIC8qKiBTZWxlY3QgdGhlIHNlbGVjdGVkIHJvdyBieSBhIHJvdyBpbmRleCAqL1xyXG4gIHNldFNlbGVjdGVkUm93KHJvd0luZGV4OiBudW1iZXIpIHtcclxuICAgIGlmICh0aGlzLl9ncmlkICYmIHRoaXMuX2dyaWQuc2V0U2VsZWN0ZWRSb3dzKSB7XHJcbiAgICAgIHRoaXMuX2dyaWQuc2V0U2VsZWN0ZWRSb3dzKFtyb3dJbmRleF0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqIFNldCBzZWxlY3RlZCByb3dzIHdpdGggcHJvdmlkZWQgYXJyYXkgb2Ygcm93IGluZGV4ZXMgKi9cclxuICBzZXRTZWxlY3RlZFJvd3Mocm93SW5kZXhlczogbnVtYmVyW10pIHtcclxuICAgIGlmICh0aGlzLl9ncmlkICYmIHRoaXMuX2dyaWQuc2V0U2VsZWN0ZWRSb3dzKSB7XHJcbiAgICAgIHRoaXMuX2dyaWQuc2V0U2VsZWN0ZWRSb3dzKHJvd0luZGV4ZXMpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqIFJlLVJlbmRlciB0aGUgR3JpZCAqL1xyXG4gIHJlbmRlckdyaWQoKSB7XHJcbiAgICBpZiAodGhpcy5fZ3JpZCAmJiB0eXBlb2YgdGhpcy5fZ3JpZC5pbnZhbGlkYXRlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHRoaXMuX2dyaWQuaW52YWxpZGF0ZSgpO1xyXG4gICAgICB0aGlzLl9ncmlkLnJlbmRlcigpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzZXQgdGhlIGdyaWQgdG8gaXQncyBvcmlnaW5hbCBzdGF0ZSAoY2xlYXIgYW55IGZpbHRlcnMsIHNvcnRpbmcgJiBwYWdpbmF0aW9uIGlmIGV4aXN0cykgLlxyXG4gICAqIFRoZSBjb2x1bW4gZGVmaW5pdGlvbnMgY291bGQgYmUgcGFzc2VkIGFzIGFyZ3VtZW50IHRvIHJlc2V0ICh0aGlzIGNhbiBiZSB1c2VkIGFmdGVyIGEgR3JpZCBTdGF0ZSByZXNldClcclxuICAgKiBUaGUgcmVzZXQgd2lsbCBjbGVhciB0aGUgRmlsdGVycyAmIFNvcnQsIHRoZW4gd2lsbCByZXNldCB0aGUgQ29sdW1ucyB0byB0aGVpciBvcmlnaW5hbCBzdGF0ZVxyXG4gICAqL1xyXG4gIHJlc2V0R3JpZChjb2x1bW5EZWZpbml0aW9ucz86IENvbHVtbltdKSB7XHJcbiAgICAvLyByZXNldCBjb2x1bW5zIHRvIG9yaWdpbmFsIHN0YXRlcyAmIHJlZnJlc2ggdGhlIGdyaWRcclxuICAgIGlmICh0aGlzLl9ncmlkICYmIHRoaXMuX2RhdGFWaWV3KSB7XHJcbiAgICAgIGNvbnN0IG9yaWdpbmFsQ29sdW1ucyA9IHRoaXMuZXh0ZW5zaW9uU2VydmljZS5nZXRBbGxDb2x1bW5zKCk7XHJcblxyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvcmlnaW5hbENvbHVtbnMpICYmIG9yaWdpbmFsQ29sdW1ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgLy8gc2V0IHRoZSBncmlkIGNvbHVtbnMgdG8gaXQncyBvcmlnaW5hbCBjb2x1bW4gZGVmaW5pdGlvbnNcclxuICAgICAgICB0aGlzLl9ncmlkLnNldENvbHVtbnMob3JpZ2luYWxDb2x1bW5zKTtcclxuICAgICAgICBpZiAodGhpcy5fZ3JpZE9wdGlvbnMgJiYgdGhpcy5fZ3JpZE9wdGlvbnMuZW5hYmxlQXV0b1NpemVDb2x1bW5zKSB7XHJcbiAgICAgICAgICB0aGlzLl9ncmlkLmF1dG9zaXplQ29sdW1ucygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmdyaWRTdGF0ZVNlcnZpY2UucmVzZXRDb2x1bW5zKGNvbHVtbkRlZmluaXRpb25zKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmZpbHRlclNlcnZpY2UgJiYgdGhpcy5maWx0ZXJTZXJ2aWNlLmNsZWFyRmlsdGVycykge1xyXG4gICAgICB0aGlzLmZpbHRlclNlcnZpY2UuY2xlYXJGaWx0ZXJzKCk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5zb3J0U2VydmljZSAmJiB0aGlzLnNvcnRTZXJ2aWNlLmNsZWFyU29ydGluZykge1xyXG4gICAgICB0aGlzLnNvcnRTZXJ2aWNlLmNsZWFyU29ydGluZygpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqIEBkZXByZWNhdGVkIHBsZWFzZSB1c2UgXCJhZGRJdGVtXCIgbWV0aG9kIGluc3RlYWQgKi9cclxuICBhZGRJdGVtVG9EYXRhZ3JpZChpdGVtOiBhbnksIHNob3VsZEhpZ2hsaWdodFJvdyA9IHRydWUsIHNob3VsZFJlc29ydEdyaWQgPSBmYWxzZSwgc2hvdWxkVHJpZ2dlckV2ZW50ID0gdHJ1ZSwgc2hvdWxkU2VsZWN0Um93ID0gdHJ1ZSk6IG51bWJlciB7XHJcbiAgICBjb25zb2xlLndhcm4oJ1tBbmd1bGFyLVNsaWNrZ3JpZCAtIEdyaWRTZXJ2aWNlXSBwbGVhc2UgY29uc2lkZXIgdXNpbmcgdGhlIG5ldyBcImFkZEl0ZW1cIiBtZXRob2Qgc2luY2UgXCJhZGRJdGVtVG9EYXRhZ3JpZFwiIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiB0aGUgZnV0dXJlLicpO1xyXG4gICAgcmV0dXJuIHRoaXMuYWRkSXRlbShpdGVtLCB7IGhpZ2hsaWdodFJvdzogc2hvdWxkSGlnaGxpZ2h0Um93LCByZXNvcnRHcmlkOiBzaG91bGRSZXNvcnRHcmlkLCB0cmlnZ2VyRXZlbnQ6IHNob3VsZFRyaWdnZXJFdmVudCwgc2VsZWN0Um93OiBzaG91bGRTZWxlY3RSb3cgfSk7XHJcbiAgfVxyXG5cclxuICAvKiogQGRlcHJlY2F0ZWQgcGxlYXNlIHVzZSBcImFkZEl0ZW1zXCIgbWV0aG9kIGluc3RlYWQgKi9cclxuICBhZGRJdGVtc1RvRGF0YWdyaWQoaXRlbXM6IGFueVtdLCBzaG91bGRIaWdobGlnaHRSb3cgPSB0cnVlLCBzaG91bGRSZXNvcnRHcmlkID0gZmFsc2UsIHNob3VsZFRyaWdnZXJFdmVudCA9IHRydWUsIHNob3VsZFNlbGVjdFJvdyA9IHRydWUpOiBudW1iZXJbXSB7XHJcbiAgICBjb25zb2xlLndhcm4oJ1tBbmd1bGFyLVNsaWNrZ3JpZCAtIEdyaWRTZXJ2aWNlXSBwbGVhc2UgY29uc2lkZXIgdXNpbmcgdGhlIG5ldyBcImFkZEl0ZW1zXCIgbWV0aG9kIHNpbmNlIFwiYWRkSXRlbXNUb0RhdGFncmlkXCIgd2lsbCBiZSBkZXByZWNhdGVkIGluIHRoZSBmdXR1cmUuJyk7XHJcbiAgICByZXR1cm4gdGhpcy5hZGRJdGVtcyhpdGVtcywgeyBoaWdobGlnaHRSb3c6IHNob3VsZEhpZ2hsaWdodFJvdywgcmVzb3J0R3JpZDogc2hvdWxkUmVzb3J0R3JpZCwgdHJpZ2dlckV2ZW50OiBzaG91bGRUcmlnZ2VyRXZlbnQsIHNlbGVjdFJvdzogc2hvdWxkU2VsZWN0Um93IH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIGFuIGl0ZW0gKGRhdGEgaXRlbSkgdG8gdGhlIGRhdGFncmlkLCBieSBkZWZhdWx0IGl0IHdpbGwgaGlnaGxpZ2h0IChmbGFzaGluZykgdGhlIGluc2VydGVkIHJvdyBidXQgd2UgY2FuIGRpc2FibGUgaXQgdG9vXHJcbiAgICogQHBhcmFtIGl0ZW0gb2JqZWN0IHdoaWNoIG11c3QgY29udGFpbiBhIHVuaXF1ZSBcImlkXCIgcHJvcGVydHkgYW5kIGFueSBvdGhlciBzdWl0YWJsZSBwcm9wZXJ0aWVzXHJcbiAgICogQHBhcmFtIG9wdGlvbnM6IHByb3ZpZGUgdGhlIHBvc3NpYmlsaXR5IHRvIGRvIGNlcnRhaW4gYWN0aW9ucyBhZnRlciBvciBkdXJpbmcgdGhlIHVwc2VydCAoaGlnaGxpZ2h0Um93LCByZXNvcnRHcmlkLCBzZWxlY3RSb3csIHRyaWdnZXJFdmVudClcclxuICAgKiBAcmV0dXJuIHJvd0luZGV4OiB0eXBpY2FsbHkgaW5kZXggMCB3aGVuIGFkZGluZyB0byBwb3NpdGlvbiBcInRvcFwiIG9yIGEgZGlmZmVyZW50IG51bWJlciB3aGVuIGFkZGluZyB0byB0aGUgXCJib3R0b21cIlxyXG4gICAqL1xyXG4gIGFkZEl0ZW08VCA9IGFueT4oaXRlbTogVCwgb3B0aW9ucz86IEdyaWRTZXJ2aWNlSW5zZXJ0T3B0aW9uKTogbnVtYmVyIHtcclxuICAgIG9wdGlvbnMgPSB7IC4uLkdyaWRTZXJ2aWNlSW5zZXJ0T3B0aW9uRGVmYXVsdHMsIC4uLm9wdGlvbnMgfTtcclxuXHJcbiAgICBpZiAoIXRoaXMuX2dyaWQgfHwgIXRoaXMuX2dyaWRPcHRpb25zIHx8ICF0aGlzLl9kYXRhVmlldykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlIGNvdWxkIG5vdCBmaW5kIFNsaWNrR3JpZCBHcmlkLCBEYXRhVmlldyBvYmplY3RzJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBpZFByb3BOYW1lID0gdGhpcy5fZ3JpZE9wdGlvbnMuZGF0YXNldElkUHJvcGVydHlOYW1lIHx8ICdpZCc7XHJcbiAgICBpZiAoIWl0ZW0gfHwgIShpZFByb3BOYW1lIGluIGl0ZW0pKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQWRkaW5nIGFuIGl0ZW0gcmVxdWlyZXMgdGhlIGl0ZW0gdG8gaW5jbHVkZSBhbiBcIiR7aWRQcm9wTmFtZX1cIiBwcm9wZXJ0eWApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGluc2VydCBwb3NpdGlvbiB0b3AvYm90dG9tLCBkZWZhdWx0cyB0byB0b3BcclxuICAgIC8vIHdoZW4gcG9zaXRpb24gaXMgdG9wIHdlJ2xsIGNhbGwgaW5zZXJ0IGF0IGluZGV4IDAsIGVsc2UgY2FsbCBhZGRJdGVtIHdoaWNoIGp1c3QgcHVzaCB0byB0aGUgRGF0YVZpZXcgYXJyYXlcclxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMucG9zaXRpb24gPT09ICdib3R0b20nKSB7XHJcbiAgICAgIHRoaXMuX2RhdGFWaWV3LmFkZEl0ZW0oaXRlbSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl9kYXRhVmlldy5pbnNlcnRJdGVtKDAsIGl0ZW0pOyAvLyBpbnNlcnQgYXQgaW5kZXggMFxyXG4gICAgfVxyXG5cclxuICAgIC8vIHJvdyBudW1iZXIgaW4gdGhlIGdyaWQsIGJ5IGRlZmF1bHQgaXQgd2lsbCBiZSBvbiBmaXJzdCByb3cgKHRvcCBpcyB0aGUgZGVmYXVsdClcclxuICAgIGxldCByb3dOdW1iZXIgPSAwO1xyXG5cclxuICAgIC8vIGRvIHdlIHdhbnQgdGhlIGl0ZW0gdG8gYmUgc29ydGVkIGluIHRoZSBncmlkLCB3aGVuIHNldCB0byBGYWxzZSBpdCB3aWxsIGluc2VydCBvbiBmaXJzdCByb3cgKGRlZmF1bHRzIHRvIGZhbHNlKVxyXG4gICAgaWYgKG9wdGlvbnMucmVzb3J0R3JpZCkge1xyXG4gICAgICB0aGlzLl9kYXRhVmlldy5yZVNvcnQoKTtcclxuXHJcbiAgICAgIC8vIGZpbmQgdGhlIHJvdyBudW1iZXIgaW4gdGhlIGdyaWQgYW5kIGlmIHVzZXIgd2FudGVkIHRvIHNlZSBoaWdobGlnaHRlZCByb3dcclxuICAgICAgLy8gd2UgbmVlZCB0byBkbyBpdCBoZXJlIGFmdGVyIHJlc29ydCBhbmQgZ2V0IGVhY2ggcm93IG51bWJlciBiZWNhdXNlIGl0IHBvc3NpYmx5IGNoYW5nZXMgYWZ0ZXIgdGhlIHNvcnRcclxuICAgICAgcm93TnVtYmVyID0gdGhpcy5fZGF0YVZpZXcuZ2V0Um93QnlJZChpdGVtW2lkUHJvcE5hbWVdKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIHNjcm9sbCB0byByb3cgaW5kZXggMCB3aGVuIGluc2VydGluZyBvbiB0b3AgZWxzZSBzY3JvbGwgdG8gdGhlIGJvdHRvbSB3aGVyZSBpdCBnb3QgaW5zZXJ0ZWRcclxuICAgICAgcm93TnVtYmVyID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2JvdHRvbScpID8gdGhpcy5fZGF0YVZpZXcuZ2V0Um93QnlJZChpdGVtW2lkUHJvcE5hbWVdKSA6IDA7XHJcbiAgICAgIHRoaXMuX2dyaWQuc2Nyb2xsUm93SW50b1ZpZXcocm93TnVtYmVyKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBpZiBoaWdobGlnaHQgaXMgZW5hYmxlZCwgd2UnbGwgaGlnaGxpZ2h0IHRoZSByb3cgd2UganVzdCBhZGRlZFxyXG4gICAgaWYgKG9wdGlvbnMuaGlnaGxpZ2h0Um93KSB7XHJcbiAgICAgIHRoaXMuaGlnaGxpZ2h0Um93KHJvd051bWJlcik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaWYgcm93IHNlbGVjdGlvbiAoY2hlY2tib3ggc2VsZWN0b3IpIGlzIGVuYWJsZWQsIHdlJ2xsIHNlbGVjdCB0aGUgcm93IGluIHRoZSBncmlkXHJcbiAgICBpZiAob3B0aW9ucy5zZWxlY3RSb3cgJiYgdGhpcy5fZ3JpZE9wdGlvbnMgJiYgKHRoaXMuX2dyaWRPcHRpb25zLmVuYWJsZUNoZWNrYm94U2VsZWN0b3IgfHwgdGhpcy5fZ3JpZE9wdGlvbnMuZW5hYmxlUm93U2VsZWN0aW9uKSkge1xyXG4gICAgICB0aGlzLnNldFNlbGVjdGVkUm93KHJvd051bWJlcik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZG8gd2Ugd2FudCB0byB0cmlnZ2VyIGFuIGV2ZW50IGFmdGVyIGFkZGluZyB0aGUgaXRlbVxyXG4gICAgaWYgKG9wdGlvbnMudHJpZ2dlckV2ZW50KSB7XHJcbiAgICAgIHRoaXMub25JdGVtQWRkZWQubmV4dChpdGVtKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcm93TnVtYmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIGl0ZW0gYXJyYXkgKGRhdGEgaXRlbSkgdG8gdGhlIGRhdGFncmlkLCBieSBkZWZhdWx0IGl0IHdpbGwgaGlnaGxpZ2h0IChmbGFzaGluZykgdGhlIGluc2VydGVkIHJvdyBidXQgd2UgY2FuIGRpc2FibGUgaXQgdG9vXHJcbiAgICogQHBhcmFtIGl0ZW0gb2JqZWN0IGFycmF5cywgd2hpY2ggbXVzdCBjb250YWluIHVuaXF1ZSBcImlkXCIgcHJvcGVydHkgYW5kIGFueSBvdGhlciBzdWl0YWJsZSBwcm9wZXJ0aWVzXHJcbiAgICogQHBhcmFtIG9wdGlvbnM6IHByb3ZpZGUgdGhlIHBvc3NpYmlsaXR5IHRvIGRvIGNlcnRhaW4gYWN0aW9ucyBhZnRlciBvciBkdXJpbmcgdGhlIHVwc2VydCAoaGlnaGxpZ2h0Um93LCByZXNvcnRHcmlkLCBzZWxlY3RSb3csIHRyaWdnZXJFdmVudClcclxuICAgKi9cclxuICBhZGRJdGVtczxUID0gYW55PihpdGVtczogVCB8IFRbXSwgb3B0aW9ucz86IEdyaWRTZXJ2aWNlSW5zZXJ0T3B0aW9uKTogbnVtYmVyW10ge1xyXG4gICAgb3B0aW9ucyA9IHsgLi4uR3JpZFNlcnZpY2VJbnNlcnRPcHRpb25EZWZhdWx0cywgLi4ub3B0aW9ucyB9O1xyXG4gICAgY29uc3QgaWRQcm9wTmFtZSA9IHRoaXMuX2dyaWRPcHRpb25zLmRhdGFzZXRJZFByb3BlcnR5TmFtZSB8fCAnaWQnO1xyXG4gICAgY29uc3Qgcm93TnVtYmVyczogbnVtYmVyW10gPSBbXTtcclxuXHJcbiAgICAvLyBsb29wIHRocm91Z2ggYWxsIGl0ZW1zIHRvIGFkZFxyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xyXG4gICAgICByZXR1cm4gW3RoaXMuYWRkSXRlbTxUPihpdGVtcywgb3B0aW9ucyldO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5fZGF0YVZpZXcuYmVnaW5VcGRhdGUoKTtcclxuICAgICAgaXRlbXMuZm9yRWFjaCgoaXRlbTogVCkgPT4gdGhpcy5hZGRJdGVtPFQ+KGl0ZW0sIHsgLi4ub3B0aW9ucywgaGlnaGxpZ2h0Um93OiBmYWxzZSwgcmVzb3J0R3JpZDogZmFsc2UsIHRyaWdnZXJFdmVudDogZmFsc2UsIHNlbGVjdFJvdzogZmFsc2UgfSkpO1xyXG4gICAgICB0aGlzLl9kYXRhVmlldy5lbmRVcGRhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBkbyB3ZSB3YW50IHRoZSBpdGVtIHRvIGJlIHNvcnRlZCBpbiB0aGUgZ3JpZCwgd2hlbiBzZXQgdG8gRmFsc2UgaXQgd2lsbCBpbnNlcnQgb24gZmlyc3Qgcm93IChkZWZhdWx0cyB0byBmYWxzZSlcclxuICAgIGlmIChvcHRpb25zLnJlc29ydEdyaWQpIHtcclxuICAgICAgdGhpcy5fZGF0YVZpZXcucmVTb3J0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc2Nyb2xsIHRvIHJvdyBpbmRleCAwIHdoZW4gaW5zZXJ0aW5nIG9uIHRvcCBlbHNlIHNjcm9sbCB0byB0aGUgYm90dG9tIHdoZXJlIGl0IGdvdCBpbnNlcnRlZFxyXG4gICAgKG9wdGlvbnMgJiYgb3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2JvdHRvbScpID8gdGhpcy5fZ3JpZC5uYXZpZ2F0ZUJvdHRvbSgpIDogdGhpcy5fZ3JpZC5uYXZpZ2F0ZVRvcCgpO1xyXG5cclxuICAgIC8vIGdldCByb3cgbnVtYmVycyBvZiBhbGwgbmV3IGluc2VydGVkIGl0ZW1zXHJcbiAgICAvLyB3ZSBuZWVkIHRvIGRvIGl0IGFmdGVyIHJlc29ydCBhbmQgZ2V0IGVhY2ggcm93IG51bWJlciBiZWNhdXNlIGl0IHBvc3NpYmx5IGNoYW5nZWQgYWZ0ZXIgdGhlIHNvcnRcclxuICAgIGl0ZW1zLmZvckVhY2goKGl0ZW06IGFueSkgPT4gcm93TnVtYmVycy5wdXNoKHRoaXMuX2RhdGFWaWV3LmdldFJvd0J5SWQoaXRlbVtpZFByb3BOYW1lXSkpKTtcclxuXHJcbiAgICAvLyBpZiB1c2VyIHdhbnRlZCB0byBzZWUgaGlnaGxpZ2h0ZWQgcm93XHJcbiAgICBpZiAob3B0aW9ucy5oaWdobGlnaHRSb3cpIHtcclxuICAgICAgdGhpcy5oaWdobGlnaHRSb3cocm93TnVtYmVycyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc2VsZWN0IHRoZSByb3cgaW4gdGhlIGdyaWRcclxuICAgIGlmIChvcHRpb25zLnNlbGVjdFJvdyAmJiB0aGlzLl9ncmlkT3B0aW9ucyAmJiAodGhpcy5fZ3JpZE9wdGlvbnMuZW5hYmxlQ2hlY2tib3hTZWxlY3RvciB8fCB0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVSb3dTZWxlY3Rpb24pKSB7XHJcbiAgICAgIHRoaXMuc2V0U2VsZWN0ZWRSb3dzKHJvd051bWJlcnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGRvIHdlIHdhbnQgdG8gdHJpZ2dlciBhbiBldmVudCBhZnRlciBhZGRpbmcgdGhlIGl0ZW1cclxuICAgIGlmIChvcHRpb25zLnRyaWdnZXJFdmVudCkge1xyXG4gICAgICB0aGlzLm9uSXRlbUFkZGVkLm5leHQoaXRlbXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByb3dOdW1iZXJzO1xyXG4gIH1cclxuXHJcbiAgLyoqIEBkZXByZWNhdGVkIHBsZWFzZSB1c2UgXCJkZWxldGVJdGVtXCIgbWV0aG9kIGluc3RlYWQgKi9cclxuICBkZWxldGVEYXRhR3JpZEl0ZW0oaXRlbTogYW55LCBzaG91bGRUcmlnZ2VyRXZlbnQgPSB0cnVlKSB7XHJcbiAgICBjb25zb2xlLndhcm4oJ1tBbmd1bGFyLVNsaWNrZ3JpZCAtIEdyaWRTZXJ2aWNlXSBwbGVhc2UgY29uc2lkZXIgdXNpbmcgdGhlIG5ldyBcImRlbGV0ZUl0ZW1cIiBtZXRob2Qgc2luY2UgXCJkZWxldGVEYXRhR3JpZEl0ZW1cIiB3aWxsIGJlIGRlcHJlY2F0ZWQgaW4gdGhlIGZ1dHVyZS4nKTtcclxuICAgIHRoaXMuZGVsZXRlSXRlbShpdGVtLCB7IHRyaWdnZXJFdmVudDogc2hvdWxkVHJpZ2dlckV2ZW50IH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqIEBkZXByZWNhdGVkIHBsZWFzZSB1c2UgXCJkZWxldGVJdGVtc1wiIG1ldGhvZCBpbnN0ZWFkICovXHJcbiAgZGVsZXRlRGF0YUdyaWRJdGVtcyhpdGVtczogYW55W10sIHNob3VsZFRyaWdnZXJFdmVudCA9IHRydWUpIHtcclxuICAgIGNvbnNvbGUud2FybignW0FuZ3VsYXItU2xpY2tncmlkIC0gR3JpZFNlcnZpY2VdIHBsZWFzZSBjb25zaWRlciB1c2luZyB0aGUgbmV3IFwiZGVsZXRlSXRlbXNcIiBtZXRob2Qgc2luY2UgXCJkZWxldGVEYXRhR3JpZEl0ZW1zXCIgd2lsbCBiZSBkZXByZWNhdGVkIGluIHRoZSBmdXR1cmUuJyk7XHJcbiAgICB0aGlzLmRlbGV0ZUl0ZW1zKGl0ZW1zLCB7IHRyaWdnZXJFdmVudDogc2hvdWxkVHJpZ2dlckV2ZW50IH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqIEBkZXByZWNhdGVkIHBsZWFzZSB1c2UgXCJkZWxldGVJdGVtQnlJZFwiIG1ldGhvZCBpbnN0ZWFkICovXHJcbiAgZGVsZXRlRGF0YUdyaWRJdGVtQnlJZChpdGVtSWQ6IHN0cmluZyB8IG51bWJlciwgc2hvdWxkVHJpZ2dlckV2ZW50ID0gdHJ1ZSkge1xyXG4gICAgY29uc29sZS53YXJuKCdbQW5ndWxhci1TbGlja2dyaWQgLSBHcmlkU2VydmljZV0gcGxlYXNlIGNvbnNpZGVyIHVzaW5nIHRoZSBuZXcgXCJkZWxldGVJdGVtQnlJZFwiIG1ldGhvZCBzaW5jZSBcImRlbGV0ZURhdGFHcmlkSXRlbUJ5SWRcIiB3aWxsIGJlIGRlcHJlY2F0ZWQgaW4gdGhlIGZ1dHVyZS4nKTtcclxuICAgIHRoaXMuZGVsZXRlSXRlbUJ5SWQoaXRlbUlkLCB7IHRyaWdnZXJFdmVudDogc2hvdWxkVHJpZ2dlckV2ZW50IH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqIEBkZXByZWNhdGVkIHBsZWFzZSB1c2UgXCJkZWxldGVJdGVtQnlJZHNcIiBtZXRob2QgaW5zdGVhZCAqL1xyXG4gIGRlbGV0ZURhdGFHcmlkSXRlbUJ5SWRzKGl0ZW1JZHM6IG51bWJlcltdIHwgc3RyaW5nW10sIHNob3VsZFRyaWdnZXJFdmVudCA9IHRydWUpIHtcclxuICAgIGNvbnNvbGUud2FybignW0FuZ3VsYXItU2xpY2tncmlkIC0gR3JpZFNlcnZpY2VdIHBsZWFzZSBjb25zaWRlciB1c2luZyB0aGUgbmV3IFwiZGVsZXRlSXRlbUJ5SWRzXCIgbWV0aG9kIHNpbmNlIFwiZGVsZXRlRGF0YUdyaWRJdGVtQnlJZHNcIiB3aWxsIGJlIGRlcHJlY2F0ZWQgaW4gdGhlIGZ1dHVyZS4nKTtcclxuICAgIHRoaXMuZGVsZXRlSXRlbUJ5SWRzKGl0ZW1JZHMsIHsgdHJpZ2dlckV2ZW50OiBzaG91bGRUcmlnZ2VyRXZlbnQgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZWxldGUgYW4gZXhpc3RpbmcgaXRlbSBmcm9tIHRoZSBkYXRhZ3JpZCAoZGF0YVZpZXcpXHJcbiAgICogQHBhcmFtIGl0ZW0gb2JqZWN0IHdoaWNoIG11c3QgY29udGFpbiBhIHVuaXF1ZSBcImlkXCIgcHJvcGVydHkgYW5kIGFueSBvdGhlciBzdWl0YWJsZSBwcm9wZXJ0aWVzXHJcbiAgICogQHBhcmFtIG9wdGlvbnM6IHByb3ZpZGUgdGhlIHBvc3NpYmlsaXR5IHRvIGRvIGNlcnRhaW4gYWN0aW9ucyBhZnRlciBvciBkdXJpbmcgdGhlIHVwc2VydCAodHJpZ2dlckV2ZW50KVxyXG4gICAqIEByZXR1cm4gaXRlbSBpZCBkZWxldGVkXHJcbiAgICovXHJcbiAgZGVsZXRlSXRlbTxUID0gYW55PihpdGVtOiBULCBvcHRpb25zPzogR3JpZFNlcnZpY2VEZWxldGVPcHRpb24pOiBudW1iZXIgfCBzdHJpbmcge1xyXG4gICAgb3B0aW9ucyA9IHsgLi4uR3JpZFNlcnZpY2VEZWxldGVPcHRpb25EZWZhdWx0cywgLi4ub3B0aW9ucyB9O1xyXG4gICAgY29uc3QgaWRQcm9wTmFtZSA9IHRoaXMuX2dyaWRPcHRpb25zLmRhdGFzZXRJZFByb3BlcnR5TmFtZSB8fCAnaWQnO1xyXG5cclxuICAgIGlmICghaXRlbSB8fCAhKGlkUHJvcE5hbWUgaW4gaXRlbSkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBEZWxldGluZyBhbiBpdGVtIHJlcXVpcmVzIHRoZSBpdGVtIHRvIGluY2x1ZGUgYW4gXCIke2lkUHJvcE5hbWV9XCIgcHJvcGVydHlgKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLmRlbGV0ZUl0ZW1CeUlkKGl0ZW1baWRQcm9wTmFtZV0sIG9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVsZXRlIGFuIGFycmF5IG9mIGV4aXN0aW5nIGl0ZW1zIGZyb20gdGhlIGRhdGFncmlkXHJcbiAgICogQHBhcmFtIGl0ZW0gb2JqZWN0IHdoaWNoIG11c3QgY29udGFpbiBhIHVuaXF1ZSBcImlkXCIgcHJvcGVydHkgYW5kIGFueSBvdGhlciBzdWl0YWJsZSBwcm9wZXJ0aWVzXHJcbiAgICogQHBhcmFtIG9wdGlvbnM6IHByb3ZpZGUgdGhlIHBvc3NpYmlsaXR5IHRvIGRvIGNlcnRhaW4gYWN0aW9ucyBhZnRlciBvciBkdXJpbmcgdGhlIHVwc2VydCAodHJpZ2dlckV2ZW50KVxyXG4gICAqIEByZXR1cm4gaXRlbSBpZCBkZWxldGVkXHJcbiAgICovXHJcbiAgZGVsZXRlSXRlbXM8VCA9IGFueT4oaXRlbXM6IFQgfCBUW10sIG9wdGlvbnM/OiBHcmlkU2VydmljZURlbGV0ZU9wdGlvbik6IG51bWJlcltdIHwgc3RyaW5nW10ge1xyXG4gICAgb3B0aW9ucyA9IHsgLi4uR3JpZFNlcnZpY2VEZWxldGVPcHRpb25EZWZhdWx0cywgLi4ub3B0aW9ucyB9O1xyXG4gICAgY29uc3QgaWRQcm9wTmFtZSA9IHRoaXMuX2dyaWRPcHRpb25zLmRhdGFzZXRJZFByb3BlcnR5TmFtZSB8fCAnaWQnO1xyXG5cclxuICAgIC8vIHdoZW4gaXQncyBub3QgYW4gYXJyYXksIHdlIGNhbiBjYWxsIGRpcmVjdGx5IHRoZSBzaW5nbGUgaXRlbSBkZWxldGVcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShpdGVtcykpIHtcclxuICAgICAgdGhpcy5kZWxldGVJdGVtPFQ+KGl0ZW1zLCBvcHRpb25zKTtcclxuICAgICAgcmV0dXJuIFtpdGVtc1tpZFByb3BOYW1lXV07XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fZGF0YVZpZXcuYmVnaW5VcGRhdGUoKTtcclxuICAgIGNvbnN0IGl0ZW1JZHMgPSBbXTtcclxuICAgIGl0ZW1zLmZvckVhY2goKGl0ZW06IFQpID0+IHtcclxuICAgICAgaWYgKGl0ZW0gJiYgaXRlbVtpZFByb3BOYW1lXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaXRlbUlkcy5wdXNoKGl0ZW1baWRQcm9wTmFtZV0pO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuZGVsZXRlSXRlbTxUPihpdGVtLCB7IC4uLm9wdGlvbnMsIHRyaWdnZXJFdmVudDogZmFsc2UgfSk7XHJcbiAgICB9KTtcclxuICAgIHRoaXMuX2RhdGFWaWV3LmVuZFVwZGF0ZSgpO1xyXG5cclxuICAgIC8vIGRvIHdlIHdhbnQgdG8gdHJpZ2dlciBhbiBldmVudCBhZnRlciBkZWxldGluZyB0aGUgaXRlbVxyXG4gICAgaWYgKG9wdGlvbnMudHJpZ2dlckV2ZW50KSB7XHJcbiAgICAgIHRoaXMub25JdGVtRGVsZXRlZC5uZXh0KGl0ZW1zKTtcclxuICAgIH1cclxuICAgIHJldHVybiBpdGVtSWRzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVsZXRlIGFuIGV4aXN0aW5nIGl0ZW0gZnJvbSB0aGUgZGF0YWdyaWQgKGRhdGFWaWV3KSBieSBpdCdzIGlkXHJcbiAgICogQHBhcmFtIGl0ZW1JZDogaXRlbSB1bmlxdWUgaWRcclxuICAgKiBAcGFyYW0gb3B0aW9uczogcHJvdmlkZSB0aGUgcG9zc2liaWxpdHkgdG8gZG8gY2VydGFpbiBhY3Rpb25zIGFmdGVyIG9yIGR1cmluZyB0aGUgdXBzZXJ0ICh0cmlnZ2VyRXZlbnQpXHJcbiAgICogQHJldHVybiBpdGVtIGlkIGRlbGV0ZWRcclxuICAgKi9cclxuICBkZWxldGVJdGVtQnlJZChpdGVtSWQ6IHN0cmluZyB8IG51bWJlciwgb3B0aW9ucz86IEdyaWRTZXJ2aWNlRGVsZXRlT3B0aW9uKTogbnVtYmVyIHwgc3RyaW5nIHtcclxuICAgIG9wdGlvbnMgPSB7IC4uLkdyaWRTZXJ2aWNlRGVsZXRlT3B0aW9uRGVmYXVsdHMsIC4uLm9wdGlvbnMgfTtcclxuXHJcbiAgICBpZiAoaXRlbUlkID09PSBudWxsIHx8IGl0ZW1JZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGRlbGV0ZSBhIHJvdyB3aXRob3V0IGEgdmFsaWQgXCJpZFwiYCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gd2hlbiB1c2VyIGhhcyByb3cgc2VsZWN0aW9uIGVuYWJsZWQsIHdlIHNob3VsZCBjbGVhciBhbnkgc2VsZWN0aW9uIHRvIGF2b2lkIGNvbmZ1c2lvbiBhZnRlciBhIGRlbGV0ZVxyXG4gICAgY29uc3QgaXNTeW5jR3JpZFNlbGVjdGlvbkVuYWJsZWQgPSB0aGlzLmdyaWRTdGF0ZVNlcnZpY2UgJiYgdGhpcy5ncmlkU3RhdGVTZXJ2aWNlLm5lZWRUb1ByZXNlcnZlUm93U2VsZWN0aW9uKCkgfHwgZmFsc2U7XHJcbiAgICBpZiAoIWlzU3luY0dyaWRTZWxlY3Rpb25FbmFibGVkICYmIHRoaXMuX2dyaWQgJiYgdGhpcy5fZ3JpZE9wdGlvbnMgJiYgKHRoaXMuX2dyaWRPcHRpb25zLmVuYWJsZUNoZWNrYm94U2VsZWN0b3IgfHwgdGhpcy5fZ3JpZE9wdGlvbnMuZW5hYmxlUm93U2VsZWN0aW9uKSkge1xyXG4gICAgICB0aGlzLnNldFNlbGVjdGVkUm93cyhbXSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZGVsZXRlIHRoZSBpdGVtIGZyb20gdGhlIGRhdGFWaWV3XHJcbiAgICB0aGlzLl9kYXRhVmlldy5kZWxldGVJdGVtKGl0ZW1JZCk7XHJcblxyXG4gICAgLy8gZG8gd2Ugd2FudCB0byB0cmlnZ2VyIGFuIGV2ZW50IGFmdGVyIGRlbGV0aW5nIHRoZSBpdGVtXHJcbiAgICBpZiAob3B0aW9ucy50cmlnZ2VyRXZlbnQpIHtcclxuICAgICAgdGhpcy5vbkl0ZW1EZWxldGVkLm5leHQoaXRlbUlkKTtcclxuICAgIH1cclxuICAgIHJldHVybiBpdGVtSWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZWxldGUgYW4gYXJyYXkgb2YgZXhpc3RpbmcgaXRlbXMgZnJvbSB0aGUgZGF0YWdyaWRcclxuICAgKiBAcGFyYW0gaXRlbUlkcyBhcnJheSBvZiBpdGVtIHVuaXF1ZSBJRHNcclxuICAgKiBAcGFyYW0gb3B0aW9uczogcHJvdmlkZSB0aGUgcG9zc2liaWxpdHkgdG8gZG8gY2VydGFpbiBhY3Rpb25zIGFmdGVyIG9yIGR1cmluZyB0aGUgdXBzZXJ0ICh0cmlnZ2VyRXZlbnQpXHJcbiAgICovXHJcbiAgZGVsZXRlSXRlbUJ5SWRzKGl0ZW1JZHM6IG51bWJlcltdIHwgc3RyaW5nW10sIG9wdGlvbnM/OiBHcmlkU2VydmljZURlbGV0ZU9wdGlvbik6IG51bWJlcltdIHwgc3RyaW5nW10ge1xyXG4gICAgb3B0aW9ucyA9IHsgLi4uR3JpZFNlcnZpY2VEZWxldGVPcHRpb25EZWZhdWx0cywgLi4ub3B0aW9ucyB9O1xyXG5cclxuICAgIC8vIHdoZW4gaXQncyBub3QgYW4gYXJyYXksIHdlIGNhbiBjYWxsIGRpcmVjdGx5IHRoZSBzaW5nbGUgaXRlbSBkZWxldGVcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW1JZHMpKSB7XHJcbiAgICAgIHRoaXMuX2RhdGFWaWV3LmJlZ2luVXBkYXRlKCk7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbUlkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChpdGVtSWRzW2ldICE9PSBudWxsKSB7XHJcbiAgICAgICAgICB0aGlzLmRlbGV0ZUl0ZW1CeUlkKGl0ZW1JZHNbaV0sIHsgdHJpZ2dlckV2ZW50OiBmYWxzZSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fZGF0YVZpZXcuZW5kVXBkYXRlKCk7XHJcblxyXG4gICAgICAvLyBkbyB3ZSB3YW50IHRvIHRyaWdnZXIgYW4gZXZlbnQgYWZ0ZXIgZGVsZXRpbmcgdGhlIGl0ZW1cclxuICAgICAgaWYgKG9wdGlvbnMudHJpZ2dlckV2ZW50KSB7XHJcbiAgICAgICAgdGhpcy5vbkl0ZW1EZWxldGVkLm5leHQoaXRlbUlkcyk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGl0ZW1JZHM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG5cclxuICAvKiogQGRlcHJlY2F0ZWQgcGxlYXNlIHVzZSBcInVwZGF0ZUl0ZW1cIiBtZXRob2QgaW5zdGVhZCAqL1xyXG4gIHVwZGF0ZURhdGFHcmlkSXRlbShpdGVtOiBhbnksIHNob3VsZEhpZ2hsaWdodFJvdyA9IHRydWUsIHNob3VsZFRyaWdnZXJFdmVudCA9IHRydWUsIHNob3VsZFNlbGVjdFJvdyA9IHRydWUpOiBudW1iZXIge1xyXG4gICAgY29uc29sZS53YXJuKCdbQW5ndWxhci1TbGlja2dyaWQgLSBHcmlkU2VydmljZV0gcGxlYXNlIGNvbnNpZGVyIHVzaW5nIHRoZSBuZXcgXCJ1cGRhdGVJdGVtXCIgbWV0aG9kIHNpbmNlIFwidXBkYXRlRGF0YUdyaWRJdGVtXCIgd2lsbCBiZSBkZXByZWNhdGVkIGluIHRoZSBmdXR1cmUuJyk7XHJcbiAgICByZXR1cm4gdGhpcy51cGRhdGVJdGVtKGl0ZW0sIHsgaGlnaGxpZ2h0Um93OiBzaG91bGRIaWdobGlnaHRSb3csIHRyaWdnZXJFdmVudDogc2hvdWxkVHJpZ2dlckV2ZW50LCBzZWxlY3RSb3c6IHNob3VsZFNlbGVjdFJvdyB9KTtcclxuICB9XHJcblxyXG4gIC8qKiBAZGVwcmVjYXRlZCBwbGVhc2UgdXNlIFwidXBkYXRlSXRlbXNcIiBtZXRob2QgaW5zdGVhZCAqL1xyXG4gIHVwZGF0ZURhdGFHcmlkSXRlbXMoaXRlbXM6IGFueSB8IGFueVtdLCBzaG91bGRIaWdobGlnaHRSb3cgPSB0cnVlLCBzaG91bGRUcmlnZ2VyRXZlbnQgPSB0cnVlLCBzaG91bGRTZWxlY3RSb3cgPSB0cnVlKTogbnVtYmVyW10ge1xyXG4gICAgY29uc29sZS53YXJuKCdbQW5ndWxhci1TbGlja2dyaWQgLSBHcmlkU2VydmljZV0gcGxlYXNlIGNvbnNpZGVyIHVzaW5nIHRoZSBuZXcgXCJ1cGRhdGVJdGVtc1wiIG1ldGhvZCBzaW5jZSBcInVwZGF0ZURhdGFHcmlkSXRlbXNcIiB3aWxsIGJlIGRlcHJlY2F0ZWQgaW4gdGhlIGZ1dHVyZS4nKTtcclxuICAgIHJldHVybiB0aGlzLnVwZGF0ZUl0ZW1zKGl0ZW1zLCB7IGhpZ2hsaWdodFJvdzogc2hvdWxkSGlnaGxpZ2h0Um93LCB0cmlnZ2VyRXZlbnQ6IHNob3VsZFRyaWdnZXJFdmVudCwgc2VsZWN0Um93OiBzaG91bGRTZWxlY3RSb3cgfSk7XHJcbiAgfVxyXG5cclxuICAvKiogQGRlcHJlY2F0ZWQgcGxlYXNlIHVzZSBcInVwZGF0ZUl0ZW1CeUlkXCIgbWV0aG9kIGluc3RlYWQgKi9cclxuICB1cGRhdGVEYXRhR3JpZEl0ZW1CeUlkKGl0ZW1JZDogbnVtYmVyIHwgc3RyaW5nLCBpdGVtOiBhbnksIHNob3VsZEhpZ2hsaWdodFJvdyA9IHRydWUsIHNob3VsZFRyaWdnZXJFdmVudCA9IHRydWUsIHNob3VsZFNlbGVjdFJvdyA9IHRydWUpOiBudW1iZXIge1xyXG4gICAgY29uc29sZS53YXJuKCdbQW5ndWxhci1TbGlja2dyaWQgLSBHcmlkU2VydmljZV0gcGxlYXNlIGNvbnNpZGVyIHVzaW5nIHRoZSBuZXcgXCJ1cGRhdGVJdGVtQnlJZFwiIG1ldGhvZCBzaW5jZSBcInVwZGF0ZURhdGFHcmlkSXRlbUJ5SWRcIiB3aWxsIGJlIGRlcHJlY2F0ZWQgaW4gdGhlIGZ1dHVyZS4nKTtcclxuICAgIHJldHVybiB0aGlzLnVwZGF0ZUl0ZW1CeUlkKGl0ZW1JZCwgaXRlbSwgeyBoaWdobGlnaHRSb3c6IHNob3VsZEhpZ2hsaWdodFJvdywgdHJpZ2dlckV2ZW50OiBzaG91bGRUcmlnZ2VyRXZlbnQsIHNlbGVjdFJvdzogc2hvdWxkU2VsZWN0Um93IH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIGFuIGV4aXN0aW5nIGl0ZW0gd2l0aCBuZXcgcHJvcGVydGllcyBpbnNpZGUgdGhlIGRhdGFncmlkXHJcbiAgICogQHBhcmFtIGl0ZW0gb2JqZWN0IHdoaWNoIG11c3QgY29udGFpbiBhIHVuaXF1ZSBcImlkXCIgcHJvcGVydHkgYW5kIGFueSBvdGhlciBzdWl0YWJsZSBwcm9wZXJ0aWVzXHJcbiAgICogQHBhcmFtIG9wdGlvbnM6IHByb3ZpZGUgdGhlIHBvc3NpYmlsaXR5IHRvIGRvIGNlcnRhaW4gYWN0aW9ucyBhZnRlciBvciBkdXJpbmcgdGhlIHVwc2VydCAoaGlnaGxpZ2h0Um93LCBzZWxlY3RSb3csIHRyaWdnZXJFdmVudClcclxuICAgKiBAcmV0dXJuIGdyaWQgcm93IGluZGV4XHJcbiAgICovXHJcbiAgdXBkYXRlSXRlbTxUID0gYW55PihpdGVtOiBULCBvcHRpb25zPzogR3JpZFNlcnZpY2VVcGRhdGVPcHRpb24pOiBudW1iZXIge1xyXG4gICAgb3B0aW9ucyA9IHsgLi4uR3JpZFNlcnZpY2VVcGRhdGVPcHRpb25EZWZhdWx0cywgLi4ub3B0aW9ucyB9O1xyXG4gICAgY29uc3QgaWRQcm9wTmFtZSA9IHRoaXMuX2dyaWRPcHRpb25zLmRhdGFzZXRJZFByb3BlcnR5TmFtZSB8fCAnaWQnO1xyXG4gICAgY29uc3QgaXRlbUlkID0gKCFpdGVtIHx8ICEoaWRQcm9wTmFtZSBpbiBpdGVtKSkgPyB1bmRlZmluZWQgOiBpdGVtW2lkUHJvcE5hbWVdO1xyXG5cclxuICAgIGlmIChpdGVtSWQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbGxpbmcgVXBkYXRlIG9mIGFuIGl0ZW0gcmVxdWlyZXMgdGhlIGl0ZW0gdG8gaW5jbHVkZSBhbiBcIiR7aWRQcm9wTmFtZX1cIiBwcm9wZXJ0eWApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLnVwZGF0ZUl0ZW1CeUlkPFQ+KGl0ZW1JZCwgaXRlbSwgb3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgYW4gYXJyYXkgb2YgZXhpc3RpbmcgaXRlbXMgd2l0aCBuZXcgcHJvcGVydGllcyBpbnNpZGUgdGhlIGRhdGFncmlkXHJcbiAgICogQHBhcmFtIGl0ZW0gb2JqZWN0IGFycmF5cywgd2hpY2ggbXVzdCBjb250YWluIHVuaXF1ZSBcImlkXCIgcHJvcGVydHkgYW5kIGFueSBvdGhlciBzdWl0YWJsZSBwcm9wZXJ0aWVzXHJcbiAgICogQHBhcmFtIG9wdGlvbnM6IHByb3ZpZGUgdGhlIHBvc3NpYmlsaXR5IHRvIGRvIGNlcnRhaW4gYWN0aW9ucyBhZnRlciBvciBkdXJpbmcgdGhlIHVwc2VydCAoaGlnaGxpZ2h0Um93LCBzZWxlY3RSb3csIHRyaWdnZXJFdmVudClcclxuICAgKiBAcmV0dXJuIGdyaWQgcm93IGluZGV4ZXNcclxuICAgKi9cclxuICB1cGRhdGVJdGVtczxUID0gYW55PihpdGVtczogVCB8IFRbXSwgb3B0aW9ucz86IEdyaWRTZXJ2aWNlVXBkYXRlT3B0aW9uKTogbnVtYmVyW10ge1xyXG4gICAgb3B0aW9ucyA9IHsgLi4uR3JpZFNlcnZpY2VVcGRhdGVPcHRpb25EZWZhdWx0cywgLi4ub3B0aW9ucyB9O1xyXG5cclxuICAgIC8vIHdoZW4gaXQncyBub3QgYW4gYXJyYXksIHdlIGNhbiBjYWxsIGRpcmVjdGx5IHRoZSBzaW5nbGUgaXRlbSB1cGRhdGVcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShpdGVtcykpIHtcclxuICAgICAgcmV0dXJuIFt0aGlzLnVwZGF0ZUl0ZW08VD4oaXRlbXMsIG9wdGlvbnMpXTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgdGhpcy5fZGF0YVZpZXcuYmVnaW5VcGRhdGUoKTtcclxuICAgIGNvbnN0IGdyaWRSb3dOdW1iZXJzOiBudW1iZXJbXSA9IFtdO1xyXG4gICAgaXRlbXMuZm9yRWFjaCgoaXRlbTogYW55KSA9PiB7XHJcbiAgICAgIGdyaWRSb3dOdW1iZXJzLnB1c2godGhpcy51cGRhdGVJdGVtPFQ+KGl0ZW0sIHsgLi4ub3B0aW9ucywgaGlnaGxpZ2h0Um93OiBmYWxzZSwgc2VsZWN0Um93OiBmYWxzZSwgdHJpZ2dlckV2ZW50OiBmYWxzZSB9KSk7XHJcbiAgICB9KTtcclxuICAgIHRoaXMuX2RhdGFWaWV3LmVuZFVwZGF0ZSgpO1xyXG5cclxuICAgIC8vIG9ubHkgaGlnaGxpZ2h0IGF0IHRoZSBlbmQsIGFsbCBhdCBvbmNlXHJcbiAgICAvLyB3ZSBoYXZlIHRvIGRvIHRoaXMgYmVjYXVzZSBkb2luZyBoaWdobGlnaHQgMSBieSAxIHdvdWxkIG9ubHkgcmUtc2VsZWN0IHRoZSBsYXN0IGhpZ2hsaWdodGVkIHJvdyB3aGljaCBpcyB3cm9uZyBiZWhhdmlvclxyXG4gICAgaWYgKG9wdGlvbnMuaGlnaGxpZ2h0Um93KSB7XHJcbiAgICAgIHRoaXMuaGlnaGxpZ2h0Um93KGdyaWRSb3dOdW1iZXJzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBzZWxlY3QgdGhlIHJvdyBpbiB0aGUgZ3JpZFxyXG4gICAgaWYgKG9wdGlvbnMuc2VsZWN0Um93ICYmIHRoaXMuX2dyaWRPcHRpb25zICYmICh0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVDaGVja2JveFNlbGVjdG9yIHx8IHRoaXMuX2dyaWRPcHRpb25zLmVuYWJsZVJvd1NlbGVjdGlvbikpIHtcclxuICAgICAgdGhpcy5zZXRTZWxlY3RlZFJvd3MoZ3JpZFJvd051bWJlcnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGRvIHdlIHdhbnQgdG8gdHJpZ2dlciBhbiBldmVudCBhZnRlciB1cGRhdGluZyB0aGUgaXRlbVxyXG4gICAgaWYgKG9wdGlvbnMudHJpZ2dlckV2ZW50KSB7XHJcbiAgICAgIHRoaXMub25JdGVtVXBkYXRlZC5uZXh0KGl0ZW1zKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZ3JpZFJvd051bWJlcnM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgYW4gZXhpc3RpbmcgaXRlbSBpbiB0aGUgZGF0YWdyaWQgYnkgaXQncyBpZCBhbmQgbmV3IHByb3BlcnRpZXNcclxuICAgKiBAcGFyYW0gaXRlbUlkOiBpdGVtIHVuaXF1ZSBpZFxyXG4gICAqIEBwYXJhbSBpdGVtIG9iamVjdCB3aGljaCBtdXN0IGNvbnRhaW4gYSB1bmlxdWUgXCJpZFwiIHByb3BlcnR5IGFuZCBhbnkgb3RoZXIgc3VpdGFibGUgcHJvcGVydGllc1xyXG4gICAqIEBwYXJhbSBvcHRpb25zOiBwcm92aWRlIHRoZSBwb3NzaWJpbGl0eSB0byBkbyBjZXJ0YWluIGFjdGlvbnMgYWZ0ZXIgb3IgZHVyaW5nIHRoZSB1cHNlcnQgKGhpZ2hsaWdodFJvdywgc2VsZWN0Um93LCB0cmlnZ2VyRXZlbnQpXHJcbiAgICogQHJldHVybiBncmlkIHJvdyBudW1iZXJcclxuICAgKi9cclxuICB1cGRhdGVJdGVtQnlJZDxUID0gYW55PihpdGVtSWQ6IG51bWJlciB8IHN0cmluZywgaXRlbTogVCwgb3B0aW9ucz86IEdyaWRTZXJ2aWNlVXBkYXRlT3B0aW9uKTogbnVtYmVyIHtcclxuICAgIG9wdGlvbnMgPSB7IC4uLkdyaWRTZXJ2aWNlVXBkYXRlT3B0aW9uRGVmYXVsdHMsIC4uLm9wdGlvbnMgfTtcclxuICAgIGlmIChpdGVtSWQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCB1cGRhdGUgYSByb3cgd2l0aG91dCBhIHZhbGlkIFwiaWRcImApO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgcm93TnVtYmVyID0gdGhpcy5fZGF0YVZpZXcuZ2V0Um93QnlJZChpdGVtSWQpO1xyXG5cclxuICAgIGlmICghaXRlbSB8fCByb3dOdW1iZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBpdGVtIHRvIHVwZGF0ZSBpbiB0aGUgZ3JpZCB3YXMgbm90IGZvdW5kIHdpdGggaWQ6ICR7aXRlbUlkfWApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9kYXRhVmlldy5nZXRJZHhCeUlkKGl0ZW1JZCkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAvLyBVcGRhdGUgdGhlIGl0ZW0gaXRzZWxmIGluc2lkZSB0aGUgZGF0YVZpZXdcclxuICAgICAgdGhpcy5fZGF0YVZpZXcudXBkYXRlSXRlbShpdGVtSWQsIGl0ZW0pO1xyXG4gICAgICB0aGlzLl9ncmlkLnVwZGF0ZVJvdyhyb3dOdW1iZXIpO1xyXG5cclxuICAgICAgLy8gZG8gd2Ugd2FudCB0byBzY3JvbGwgdG8gdGhlIHJvdyBzbyB0aGF0IGl0IHNob3dzIGluIHRoZSBWaWV3cG9ydCAoVUkpXHJcbiAgICAgIGlmIChvcHRpb25zLnNjcm9sbFJvd0ludG9WaWV3KSB7XHJcbiAgICAgICAgdGhpcy5fZ3JpZC5zY3JvbGxSb3dJbnRvVmlldyhyb3dOdW1iZXIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBoaWdobGlnaHQgdGhlIHJvdyB3ZSBqdXN0IHVwZGF0ZWQsIGlmIGRlZmluZWRcclxuICAgICAgaWYgKG9wdGlvbnMuaGlnaGxpZ2h0Um93KSB7XHJcbiAgICAgICAgdGhpcy5oaWdobGlnaHRSb3cocm93TnVtYmVyKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gc2VsZWN0IHRoZSByb3cgaW4gdGhlIGdyaWRcclxuICAgICAgaWYgKG9wdGlvbnMuc2VsZWN0Um93ICYmIHRoaXMuX2dyaWRPcHRpb25zICYmICh0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVDaGVja2JveFNlbGVjdG9yIHx8IHRoaXMuX2dyaWRPcHRpb25zLmVuYWJsZVJvd1NlbGVjdGlvbikpIHtcclxuICAgICAgICB0aGlzLnNldFNlbGVjdGVkUm93KHJvd051bWJlcik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGRvIHdlIHdhbnQgdG8gdHJpZ2dlciBhbiBldmVudCBhZnRlciB1cGRhdGluZyB0aGUgaXRlbVxyXG4gICAgICBpZiAob3B0aW9ucy50cmlnZ2VyRXZlbnQpIHtcclxuICAgICAgICB0aGlzLm9uSXRlbVVwZGF0ZWQubmV4dChpdGVtKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJvd051bWJlcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEluc2VydCBhIHJvdyBpbnRvIHRoZSBncmlkIGlmIGl0IGRvZXNuJ3QgYWxyZWFkeSBleGlzdCBvciB1cGRhdGUgaWYgaXQgZG9lcy5cclxuICAgKiBAcGFyYW0gaXRlbSBvYmplY3Qgd2hpY2ggbXVzdCBjb250YWluIGEgdW5pcXVlIFwiaWRcIiBwcm9wZXJ0eSBhbmQgYW55IG90aGVyIHN1aXRhYmxlIHByb3BlcnRpZXNcclxuICAgKiBAcGFyYW0gb3B0aW9uczogcHJvdmlkZSB0aGUgcG9zc2liaWxpdHkgdG8gZG8gY2VydGFpbiBhY3Rpb25zIGFmdGVyIG9yIGR1cmluZyB0aGUgdXBzZXJ0IChoaWdobGlnaHRSb3csIHJlc29ydEdyaWQsIHNlbGVjdFJvdywgdHJpZ2dlckV2ZW50KVxyXG4gICAqL1xyXG4gIHVwc2VydEl0ZW08VCA9IGFueT4oaXRlbTogVCwgb3B0aW9ucz86IEdyaWRTZXJ2aWNlSW5zZXJ0T3B0aW9uKTogeyBhZGRlZDogbnVtYmVyLCB1cGRhdGVkOiBudW1iZXIgfSB7XHJcbiAgICBvcHRpb25zID0geyAuLi5HcmlkU2VydmljZUluc2VydE9wdGlvbkRlZmF1bHRzLCAuLi5vcHRpb25zIH07XHJcbiAgICBjb25zdCBpZFByb3BOYW1lID0gdGhpcy5fZ3JpZE9wdGlvbnMuZGF0YXNldElkUHJvcGVydHlOYW1lIHx8ICdpZCc7XHJcbiAgICBjb25zdCBpdGVtSWQgPSAoIWl0ZW0gfHwgIShpZFByb3BOYW1lIGluIGl0ZW0pKSA/IHVuZGVmaW5lZCA6IGl0ZW1baWRQcm9wTmFtZV07XHJcblxyXG4gICAgaWYgKGl0ZW1JZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FsbGluZyBVcHNlcnQgb2YgYW4gaXRlbSByZXF1aXJlcyB0aGUgaXRlbSB0byBpbmNsdWRlIGFuIFwiJHtpZFByb3BOYW1lfVwiIHByb3BlcnR5YCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMudXBzZXJ0SXRlbUJ5SWQ8VD4oaXRlbUlkLCBpdGVtLCBvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBhbiBhcnJheSBvZiBleGlzdGluZyBpdGVtcyB3aXRoIG5ldyBwcm9wZXJ0aWVzIGluc2lkZSB0aGUgZGF0YWdyaWRcclxuICAgKiBAcGFyYW0gaXRlbSBvYmplY3QgYXJyYXlzLCB3aGljaCBtdXN0IGNvbnRhaW4gdW5pcXVlIFwiaWRcIiBwcm9wZXJ0eSBhbmQgYW55IG90aGVyIHN1aXRhYmxlIHByb3BlcnRpZXNcclxuICAgKiBAcGFyYW0gb3B0aW9uczogcHJvdmlkZSB0aGUgcG9zc2liaWxpdHkgdG8gZG8gY2VydGFpbiBhY3Rpb25zIGFmdGVyIG9yIGR1cmluZyB0aGUgdXBzZXJ0IChoaWdobGlnaHRSb3csIHJlc29ydEdyaWQsIHNlbGVjdFJvdywgdHJpZ2dlckV2ZW50KVxyXG4gICAqIEByZXR1cm4gcm93IG51bWJlcnMgaW4gdGhlIGdyaWRcclxuICAgKi9cclxuICB1cHNlcnRJdGVtczxUID0gYW55PihpdGVtczogVCB8IFRbXSwgb3B0aW9ucz86IEdyaWRTZXJ2aWNlSW5zZXJ0T3B0aW9uKTogeyBhZGRlZDogbnVtYmVyLCB1cGRhdGVkOiBudW1iZXIgfVtdIHtcclxuICAgIG9wdGlvbnMgPSB7IC4uLkdyaWRTZXJ2aWNlSW5zZXJ0T3B0aW9uRGVmYXVsdHMsIC4uLm9wdGlvbnMgfTtcclxuICAgIC8vIHdoZW4gaXQncyBub3QgYW4gYXJyYXksIHdlIGNhbiBjYWxsIGRpcmVjdGx5IHRoZSBzaW5nbGUgaXRlbSB1cGRhdGVcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShpdGVtcykpIHtcclxuICAgICAgcmV0dXJuIFt0aGlzLnVwc2VydEl0ZW08VD4oaXRlbXMsIG9wdGlvbnMpXTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9kYXRhVmlldy5iZWdpblVwZGF0ZSgpO1xyXG4gICAgY29uc3QgdXBzZXJ0ZWRSb3dzOiB7IGFkZGVkOiBudW1iZXIsIHVwZGF0ZWQ6IG51bWJlciB9W10gPSBbXTtcclxuICAgIGl0ZW1zLmZvckVhY2goKGl0ZW06IFQpID0+IHtcclxuICAgICAgdXBzZXJ0ZWRSb3dzLnB1c2godGhpcy51cHNlcnRJdGVtPFQ+KGl0ZW0sIHsgLi4ub3B0aW9ucywgaGlnaGxpZ2h0Um93OiBmYWxzZSwgcmVzb3J0R3JpZDogZmFsc2UsIHNlbGVjdFJvdzogZmFsc2UsIHRyaWdnZXJFdmVudDogZmFsc2UgfSkpO1xyXG4gICAgfSk7XHJcbiAgICB0aGlzLl9kYXRhVmlldy5lbmRVcGRhdGUoKTtcclxuXHJcbiAgICBjb25zdCByb3dOdW1iZXJzID0gdXBzZXJ0ZWRSb3dzLm1hcCgodXBzZXJ0Um93KSA9PiB1cHNlcnRSb3cuYWRkZWQgIT09IHVuZGVmaW5lZCA/IHVwc2VydFJvdy5hZGRlZCA6IHVwc2VydFJvdy51cGRhdGVkKTtcclxuICAgIC8vIG9ubHkgaGlnaGxpZ2h0IGF0IHRoZSBlbmQsIGFsbCBhdCBvbmNlXHJcbiAgICAvLyB3ZSBoYXZlIHRvIGRvIHRoaXMgYmVjYXVzZSBkb2luZyBoaWdobGlnaHQgMSBieSAxIHdvdWxkIG9ubHkgcmUtc2VsZWN0IHRoZSBsYXN0IGhpZ2hsaWdodGVkIHJvdyB3aGljaCBpcyB3cm9uZyBiZWhhdmlvclxyXG4gICAgaWYgKG9wdGlvbnMuaGlnaGxpZ2h0Um93KSB7XHJcbiAgICAgIHRoaXMuaGlnaGxpZ2h0Um93KHJvd051bWJlcnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHNlbGVjdCB0aGUgcm93IGluIHRoZSBncmlkXHJcbiAgICBpZiAob3B0aW9ucy5zZWxlY3RSb3cgJiYgdGhpcy5fZ3JpZE9wdGlvbnMgJiYgKHRoaXMuX2dyaWRPcHRpb25zLmVuYWJsZUNoZWNrYm94U2VsZWN0b3IgfHwgdGhpcy5fZ3JpZE9wdGlvbnMuZW5hYmxlUm93U2VsZWN0aW9uKSkge1xyXG4gICAgICB0aGlzLnNldFNlbGVjdGVkUm93cyhyb3dOdW1iZXJzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBkbyB3ZSB3YW50IHRvIHRyaWdnZXIgYW4gZXZlbnQgYWZ0ZXIgdXBkYXRpbmcgdGhlIGl0ZW1cclxuICAgIGlmIChvcHRpb25zLnRyaWdnZXJFdmVudCkge1xyXG4gICAgICB0aGlzLm9uSXRlbVVwc2VydGVkLm5leHQoaXRlbXMpO1xyXG4gICAgICBjb25zdCBhZGRlZEl0ZW1zID0gdXBzZXJ0ZWRSb3dzLmZpbHRlcigodXBzZXJ0Um93KSA9PiB1cHNlcnRSb3cuYWRkZWQgIT09IHVuZGVmaW5lZCk7XHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFkZGVkSXRlbXMpICYmIGFkZGVkSXRlbXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHRoaXMub25JdGVtQWRkZWQubmV4dChhZGRlZEl0ZW1zKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCB1cGRhdGVkSXRlbXMgPSB1cHNlcnRlZFJvd3MuZmlsdGVyKCh1cHNlcnRSb3cpID0+IHVwc2VydFJvdy51cGRhdGVkICE9PSB1bmRlZmluZWQpO1xyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh1cGRhdGVkSXRlbXMpICYmIHVwZGF0ZWRJdGVtcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdGhpcy5vbkl0ZW1VcGRhdGVkLm5leHQodXBkYXRlZEl0ZW1zKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHVwc2VydGVkUm93cztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBhbiBleGlzdGluZyBpdGVtIGluIHRoZSBkYXRhZ3JpZCBieSBpdCdzIGlkIGFuZCBuZXcgcHJvcGVydGllc1xyXG4gICAqIEBwYXJhbSBpdGVtSWQ6IGl0ZW0gdW5pcXVlIGlkXHJcbiAgICogQHBhcmFtIGl0ZW0gb2JqZWN0IHdoaWNoIG11c3QgY29udGFpbiBhIHVuaXF1ZSBcImlkXCIgcHJvcGVydHkgYW5kIGFueSBvdGhlciBzdWl0YWJsZSBwcm9wZXJ0aWVzXHJcbiAgICogQHBhcmFtIG9wdGlvbnM6IHByb3ZpZGUgdGhlIHBvc3NpYmlsaXR5IHRvIGRvIGNlcnRhaW4gYWN0aW9ucyBhZnRlciBvciBkdXJpbmcgdGhlIHVwc2VydCAoaGlnaGxpZ2h0Um93LCByZXNvcnRHcmlkLCBzZWxlY3RSb3csIHRyaWdnZXJFdmVudClcclxuICAgKiBAcmV0dXJuIGdyaWQgcm93IG51bWJlciBpbiB0aGUgZ3JpZFxyXG4gICAqL1xyXG4gIHVwc2VydEl0ZW1CeUlkPFQgPSBhbnk+KGl0ZW1JZDogbnVtYmVyIHwgc3RyaW5nLCBpdGVtOiBULCBvcHRpb25zPzogR3JpZFNlcnZpY2VJbnNlcnRPcHRpb24pOiB7IGFkZGVkOiBudW1iZXIsIHVwZGF0ZWQ6IG51bWJlciB9IHtcclxuICAgIGxldCBpc0l0ZW1BZGRlZCA9IGZhbHNlO1xyXG4gICAgb3B0aW9ucyA9IHsgLi4uR3JpZFNlcnZpY2VJbnNlcnRPcHRpb25EZWZhdWx0cywgLi4ub3B0aW9ucyB9O1xyXG4gICAgaWYgKGl0ZW1JZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FsbGluZyBVcHNlcnQgb2YgYW4gaXRlbSByZXF1aXJlcyB0aGUgaXRlbSB0byBpbmNsdWRlIGEgdmFsaWQgYW5kIHVuaXF1ZSBcImlkXCIgcHJvcGVydHlgKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgcm93TnVtYmVyQWRkZWQ6IG51bWJlcjtcclxuICAgIGxldCByb3dOdW1iZXJVcGRhdGVkOiBudW1iZXI7XHJcbiAgICBpZiAodGhpcy5fZGF0YVZpZXcuZ2V0Um93QnlJZChpdGVtSWQpID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgcm93TnVtYmVyQWRkZWQgPSB0aGlzLmFkZEl0ZW08VD4oaXRlbSwgb3B0aW9ucyk7XHJcbiAgICAgIGlzSXRlbUFkZGVkID0gdHJ1ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJvd051bWJlclVwZGF0ZWQgPSB0aGlzLnVwZGF0ZUl0ZW08VD4oaXRlbSwgeyBoaWdobGlnaHRSb3c6IG9wdGlvbnMuaGlnaGxpZ2h0Um93LCBzZWxlY3RSb3c6IG9wdGlvbnMuc2VsZWN0Um93LCB0cmlnZ2VyRXZlbnQ6IG9wdGlvbnMudHJpZ2dlckV2ZW50IH0pO1xyXG4gICAgICBpc0l0ZW1BZGRlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGRvIHdlIHdhbnQgdG8gdHJpZ2dlciBhbiBldmVudCBhZnRlciB1cGRhdGluZyB0aGUgaXRlbVxyXG4gICAgaWYgKG9wdGlvbnMudHJpZ2dlckV2ZW50KSB7XHJcbiAgICAgIHRoaXMub25JdGVtVXBzZXJ0ZWQubmV4dChpdGVtKTtcclxuICAgICAgaXNJdGVtQWRkZWQgPyB0aGlzLm9uSXRlbUFkZGVkLm5leHQoaXRlbSkgOiB0aGlzLm9uSXRlbVVwZGF0ZWQubmV4dChpdGVtKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IGFkZGVkOiByb3dOdW1iZXJBZGRlZCwgdXBkYXRlZDogcm93TnVtYmVyVXBkYXRlZCB9O1xyXG4gIH1cclxufVxyXG4iXX0=