import * as tslib_1 from "tslib";
import { isObservable, Subject } from 'rxjs';
import { EmitterType, FieldType, SortDirection, SortDirectionNumber, } from './../models/index';
import { executeBackendCallback, refreshBackendDataset } from './backend-utilities';
import { convertHierarchicalViewToParentChildArray, getDescendantProperty } from './utilities';
import { sortByFieldType } from '../sorters/sorterUtilities';
import { SharedService } from './shared.service';
import { Injectable } from '@angular/core';
var SortService = /** @class */ (function () {
    function SortService(sharedService) {
        this.sharedService = sharedService;
        this._currentLocalSorters = [];
        this._isBackendGrid = false;
        this.httpCancelRequests$ = new Subject(); // this will be used to cancel any pending http request
        this.onSortChanged = new Subject();
        this.onSortCleared = new Subject();
        this._eventHandler = new Slick.EventHandler();
    }
    Object.defineProperty(SortService.prototype, "eventHandler", {
        /** Getter of the SlickGrid Event Handler */
        get: function () {
            return this._eventHandler;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SortService.prototype, "_gridOptions", {
        /** Getter for the Grid Options pulled through the Grid Object */
        get: function () {
            return (this._grid && this._grid.getOptions) ? this._grid.getOptions() : {};
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SortService.prototype, "_columnDefinitions", {
        /** Getter for the Column Definitions pulled through the Grid Object */
        get: function () {
            return (this._grid && this._grid.getColumns) ? this._grid.getColumns() : [];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SortService.prototype, "_dataView", {
        /** Getter of SlickGrid DataView object */
        get: function () {
            return (this._grid && this._grid.getData) ? this._grid.getData() : {};
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Bind a backend sort (single/multi) hook to the grid
     * @param grid SlickGrid Grid object
     * @param dataView SlickGrid DataView object
     */
    SortService.prototype.bindBackendOnSort = function (grid) {
        this._isBackendGrid = true;
        this._grid = grid;
        // subscribe to the SlickGrid event and call the backend execution
        this._eventHandler.subscribe(grid.onSort, this.onBackendSortChanged.bind(this));
    };
    /**
     * Bind a local sort (single/multi) hook to the grid
     * @param grid SlickGrid Grid object
     * @param gridOptions Grid Options object
     * @param dataView
     */
    SortService.prototype.bindLocalOnSort = function (grid) {
        this._isBackendGrid = false;
        this._grid = grid;
        this.processTreeDataInitialSort();
        this._eventHandler.subscribe(grid.onSort, this.handleLocalOnSort.bind(this));
    };
    SortService.prototype.handleLocalOnSort = function (_e, args) {
        var _this = this;
        if (args && (args.sortCols || args.sortCol)) {
            // multiSort and singleSort are not exactly the same, but we want to structure it the same for the (for loop) after
            // also to avoid having to rewrite the for loop in the sort, we will make the singleSort an array of 1 object
            var sortColumns = (args.multiColumnSort) ? args.sortCols : new Array({ sortAsc: args.sortAsc, sortCol: args.sortCol });
            // keep current sorters
            this._currentLocalSorters = []; // reset current local sorters
            if (Array.isArray(sortColumns)) {
                sortColumns.forEach(function (sortColumn) {
                    if (sortColumn.sortCol) {
                        _this._currentLocalSorters.push({
                            columnId: sortColumn.sortCol.id,
                            direction: sortColumn.sortAsc ? SortDirection.ASC : SortDirection.DESC
                        });
                    }
                });
            }
            this.onLocalSortChanged(this._grid, sortColumns);
            this.emitSortChanged(EmitterType.local);
        }
    };
    SortService.prototype.clearSortByColumnId = function (event, columnId) {
        // get previously sorted columns
        var allSortedCols = this.getCurrentColumnSorts();
        var sortedColsWithoutCurrent = this.getCurrentColumnSorts("" + columnId);
        if (Array.isArray(allSortedCols) && Array.isArray(sortedColsWithoutCurrent) && allSortedCols.length !== sortedColsWithoutCurrent.length) {
            if (this._gridOptions.backendServiceApi) {
                this.onBackendSortChanged(event, { multiColumnSort: true, sortCols: sortedColsWithoutCurrent, grid: this._grid });
            }
            else if (this._dataView) {
                this.onLocalSortChanged(this._grid, sortedColsWithoutCurrent, true, true);
            }
            else {
                // when using customDataView, we will simply send it as a onSort event with notify
                var isMultiSort = this._gridOptions && this._gridOptions.multiColumnSort || false;
                var sortOutput = isMultiSort ? sortedColsWithoutCurrent : sortedColsWithoutCurrent[0];
                this._grid.onSort.notify(sortOutput);
            }
            // update the grid sortColumns array which will at the same add the visual sort icon(s) on the UI
            var updatedSortColumns = sortedColsWithoutCurrent.map(function (col) {
                return {
                    columnId: col && col.sortCol && col.sortCol.id,
                    sortAsc: col && col.sortAsc,
                    sortCol: col && col.sortCol,
                };
            });
            this._grid.setSortColumns(updatedSortColumns); // add sort icon in UI
        }
        // when there's no more sorting, we re-sort by the default sort field, user can customize it "defaultColumnSortFieldId", defaults to "id"
        if (Array.isArray(sortedColsWithoutCurrent) && sortedColsWithoutCurrent.length === 0) {
            this.sortLocalGridByDefaultSortFieldId();
        }
    };
    /**
     * Clear Sorting
     * - 1st, remove the SlickGrid sort icons (this setSortColumns function call really does only that)
     * - 2nd, we also need to trigger a sort change
     *   - for a backend grid, we will trigger a backend sort changed with an empty sort columns array
     *   - however for a local grid, we need to pass a sort column and so we will sort by the 1st column
     * @param trigger query event after executing clear filter?
     */
    SortService.prototype.clearSorting = function (triggerQueryEvent) {
        if (triggerQueryEvent === void 0) { triggerQueryEvent = true; }
        if (this._grid && this._gridOptions && this._dataView) {
            // remove any sort icons (this setSortColumns function call really does only that)
            this._grid.setSortColumns([]);
            // we also need to trigger a sort change
            // for a backend grid, we will trigger a backend sort changed with an empty sort columns array
            // however for a local grid, we need to pass a sort column and so we will sort by the 1st column
            if (triggerQueryEvent) {
                if (this._isBackendGrid) {
                    this.onBackendSortChanged(undefined, { grid: this._grid, sortCols: [], clearSortTriggered: true });
                }
                else {
                    if (this._columnDefinitions && Array.isArray(this._columnDefinitions)) {
                        this.sortLocalGridByDefaultSortFieldId();
                    }
                }
            }
            else if (this._isBackendGrid) {
                var backendService = this._gridOptions && this._gridOptions.backendServiceApi && this._gridOptions.backendServiceApi.service;
                if (backendService && backendService.clearSorters) {
                    backendService.clearSorters();
                }
            }
        }
        // set current sorter to empty & emit a sort changed event
        this._currentLocalSorters = [];
        // emit an event when sorts are all cleared
        this.onSortCleared.next(true);
    };
    SortService.prototype.dispose = function () {
        // unsubscribe all SlickGrid events
        if (this._eventHandler && this._eventHandler.unsubscribeAll) {
            this._eventHandler.unsubscribeAll();
        }
        if (isObservable(this.httpCancelRequests$)) {
            this.httpCancelRequests$.next(); // this cancels any pending http requests
        }
    };
    /**
     * Toggle the Sorting Functionality
     * @param {boolean} isSortingDisabled - optionally force a disable/enable of the Sort Functionality? Defaults to True
     * @param {boolean} clearSortingWhenDisabled - when disabling the sorting, do we also want to clear the sorting as well? Defaults to True
     */
    SortService.prototype.disableSortFunctionality = function (isSortingDisabled, clearSortingWhenDisabled) {
        var _this = this;
        if (isSortingDisabled === void 0) { isSortingDisabled = true; }
        if (clearSortingWhenDisabled === void 0) { clearSortingWhenDisabled = true; }
        var prevSorting = this._gridOptions.enableSorting;
        var newSorting = !prevSorting;
        this._gridOptions.enableSorting = newSorting;
        var updatedColumnDefinitions;
        if (isSortingDisabled) {
            if (clearSortingWhenDisabled) {
                this.clearSorting();
            }
            this._eventHandler.unsubscribeAll();
            updatedColumnDefinitions = this.disableAllSortingCommands(true);
        }
        else {
            updatedColumnDefinitions = this.disableAllSortingCommands(false);
            var onSortHandler = this._grid.onSort;
            this._eventHandler.subscribe(onSortHandler, function (e, args) { return _this.handleLocalOnSort(e, args); });
        }
        this._grid.setOptions({ enableSorting: this._gridOptions.enableSorting }, false, true);
        this.sharedService.gridOptions = this._gridOptions;
        // reset columns so that it recreate the column headers and remove/add the sort icon hints
        // basically without this, the sort icon hints were still showing up even after disabling the Sorting
        this._grid.setColumns(updatedColumnDefinitions);
    };
    /**
     * Toggle the Sorting functionality
     * @param {boolean} clearSortingWhenDisabled - when disabling the sorting, do we also want to clear the sorting as well? Defaults to True
     */
    SortService.prototype.toggleSortFunctionality = function (clearSortingOnDisable) {
        if (clearSortingOnDisable === void 0) { clearSortingOnDisable = true; }
        var previousSorting = this._gridOptions.enableSorting;
        this.disableSortFunctionality(previousSorting, clearSortingOnDisable);
    };
    /**
     * A simple function that is binded to the subscriber and emit a change when the sort is called.
     * Other services, like Pagination, can then subscribe to it.
     * @param sender
     */
    SortService.prototype.emitSortChanged = function (sender, currentLocalSorters) {
        if (sender === EmitterType.remote && this._gridOptions && this._gridOptions.backendServiceApi) {
            var currentSorters = [];
            var backendService = this._gridOptions.backendServiceApi.service;
            if (backendService && backendService.getCurrentSorters) {
                currentSorters = backendService.getCurrentSorters();
            }
            this.onSortChanged.next(currentSorters);
        }
        else if (sender === EmitterType.local) {
            if (currentLocalSorters) {
                this._currentLocalSorters = currentLocalSorters;
            }
            this.onSortChanged.next(this.getCurrentLocalSorters());
        }
    };
    SortService.prototype.getCurrentLocalSorters = function () {
        return this._currentLocalSorters;
    };
    /**
     * Get current column sorts,
     * If a column is passed as an argument, that will be exclusion so we won't add this column to our output array since it is already in the array.
     * The usage of this method is that we want to know the sort prior to calling the next sorting command
     */
    SortService.prototype.getCurrentColumnSorts = function (excludedColumnId) {
        var _this = this;
        // getSortColumns() only returns sortAsc & columnId, we want the entire column definition
        var oldSortColumns = this._grid && this._grid.getSortColumns();
        // get the column definition but only keep column which are not equal to our current column
        if (Array.isArray(oldSortColumns)) {
            var sortedCols = oldSortColumns.reduce(function (cols, col) {
                if (!excludedColumnId || col.columnId !== excludedColumnId) {
                    cols.push({ sortCol: _this._columnDefinitions[_this._grid.getColumnIndex(col.columnId)], sortAsc: col.sortAsc });
                }
                return cols;
            }, []);
            return sortedCols;
        }
        return [];
    };
    /** Load defined Sorting (sorters) into the grid */
    SortService.prototype.loadGridSorters = function (sorters) {
        var _this = this;
        this._currentLocalSorters = []; // reset current local sorters
        var sortCols = [];
        if (Array.isArray(sorters)) {
            sorters.forEach(function (sorter) {
                var gridColumn = _this._columnDefinitions.find(function (col) { return col.id === sorter.columnId; });
                if (gridColumn) {
                    sortCols.push({
                        columnId: gridColumn.id,
                        sortAsc: ((sorter.direction.toUpperCase() === SortDirection.ASC) ? true : false),
                        sortCol: gridColumn
                    });
                    // keep current sorters
                    _this._currentLocalSorters.push({
                        columnId: gridColumn.id + '',
                        direction: sorter.direction.toUpperCase()
                    });
                }
            });
        }
        if (sortCols.length > 0) {
            this.onLocalSortChanged(this._grid, sortCols);
            this._grid.setSortColumns(sortCols); // use this to add sort icon(s) in UI
        }
        return sortCols;
    };
    /** Process the initial sort, typically it will sort ascending by the column that has the Tree Data unless user specifies a different initialSort */
    SortService.prototype.processTreeDataInitialSort = function () {
        // when a Tree Data view is defined, we must sort the data so that the UI works correctly
        if (this._gridOptions && this._gridOptions.enableTreeData && this._gridOptions.treeDataOptions) {
            // first presort it once by tree level
            var treeDataOptions_1 = this._gridOptions.treeDataOptions;
            var columnWithTreeData = this._columnDefinitions.find(function (col) { return col && col.id === treeDataOptions_1.columnId; });
            if (columnWithTreeData) {
                var sortDirection = SortDirection.ASC;
                var sortTreeLevelColumn = { columnId: treeDataOptions_1.columnId, sortCol: columnWithTreeData, sortAsc: true };
                // user could provide a custom sort field id, if so get that column and sort by it
                if (treeDataOptions_1 && treeDataOptions_1.initialSort && treeDataOptions_1.initialSort.columnId) {
                    var initialSortColumnId_1 = treeDataOptions_1.initialSort.columnId;
                    var initialSortColumn = this._columnDefinitions.find(function (col) { return col.id === initialSortColumnId_1; });
                    sortDirection = (treeDataOptions_1.initialSort.direction || SortDirection.ASC).toUpperCase();
                    sortTreeLevelColumn = { columnId: initialSortColumnId_1, sortCol: initialSortColumn, sortAsc: (sortDirection === SortDirection.ASC) };
                }
                // when we have a valid column with Tree Data, we can sort by that column
                if (sortTreeLevelColumn && sortTreeLevelColumn.columnId) {
                    this.updateSorting([{ columnId: sortTreeLevelColumn.columnId || '', direction: sortDirection }]);
                }
            }
        }
    };
    SortService.prototype.onBackendSortChanged = function (event, args) {
        if (!args || !args.grid) {
            throw new Error('Something went wrong when trying to bind the "onBackendSortChanged(event, args)" function, it seems that "args" is not populated correctly');
        }
        var gridOptions = (args.grid && args.grid.getOptions) ? args.grid.getOptions() : {};
        var backendApi = gridOptions.backendServiceApi;
        if (!backendApi || !backendApi.process || !backendApi.service) {
            throw new Error("BackendServiceApi requires at least a \"process\" function and a \"service\" defined");
        }
        // keep start time & end timestamps & return it after process execution
        var startTime = new Date();
        if (backendApi.preProcess) {
            backendApi.preProcess();
        }
        // query backend
        var query = backendApi.service.processOnSortChanged(event, args);
        var totalItems = gridOptions && gridOptions.pagination && gridOptions.pagination.totalItems;
        executeBackendCallback(backendApi, query, args, startTime, totalItems, this.emitSortChanged.bind(this), this.httpCancelRequests$);
    };
    /** When a Sort Changes on a Local grid (JSON dataset) */
    SortService.prototype.onLocalSortChanged = function (grid, sortColumns, forceReSort, emitSortChanged) {
        if (forceReSort === void 0) { forceReSort = false; }
        if (emitSortChanged === void 0) { emitSortChanged = false; }
        var isTreeDataEnabled = this._gridOptions && this._gridOptions.enableTreeData || false;
        var dataView = grid && grid.getData && grid.getData();
        if (grid && dataView) {
            if (forceReSort && !isTreeDataEnabled) {
                dataView.reSort();
            }
            if (isTreeDataEnabled && this.sharedService && Array.isArray(this.sharedService.hierarchicalDataset)) {
                var hierarchicalDataset = this.sharedService.hierarchicalDataset;
                this.sortTreeData(hierarchicalDataset, sortColumns);
                var dataViewIdIdentifier = this._gridOptions && this._gridOptions.datasetIdPropertyName || 'id';
                var treeDataOpt = this._gridOptions && this._gridOptions.treeDataOptions || { columnId: '' };
                var treeDataOptions = tslib_1.__assign({}, treeDataOpt, { identifierPropName: treeDataOpt.identifierPropName || dataViewIdIdentifier });
                var sortedFlatArray = convertHierarchicalViewToParentChildArray(hierarchicalDataset, treeDataOptions);
                dataView.setItems(sortedFlatArray, this._gridOptions && this._gridOptions.datasetIdPropertyName || 'id');
            }
            else {
                dataView.sort(this.sortComparers.bind(this, sortColumns));
            }
            grid.invalidate();
            grid.render();
            if (emitSortChanged) {
                this.emitSortChanged(EmitterType.local, sortColumns.map(function (col) {
                    return {
                        columnId: col.sortCol && col.sortCol.id || 'id',
                        direction: col.sortAsc ? SortDirection.ASC : SortDirection.DESC
                    };
                }));
            }
        }
    };
    /** Call a local grid sort by its default sort field id (user can customize default field by configuring "defaultColumnSortFieldId" in the grid options, defaults to "id") */
    SortService.prototype.sortLocalGridByDefaultSortFieldId = function () {
        var sortColFieldId = this._gridOptions && this._gridOptions.defaultColumnSortFieldId || this._gridOptions.datasetIdPropertyName || 'id';
        var sortCol = { id: sortColFieldId, field: sortColFieldId };
        this.onLocalSortChanged(this._grid, new Array({ sortAsc: true, sortCol: sortCol, clearSortTriggered: true }));
    };
    SortService.prototype.sortComparers = function (sortColumns, dataRow1, dataRow2) {
        var e_1, _a;
        if (Array.isArray(sortColumns)) {
            try {
                for (var sortColumns_1 = tslib_1.__values(sortColumns), sortColumns_1_1 = sortColumns_1.next(); !sortColumns_1_1.done; sortColumns_1_1 = sortColumns_1.next()) {
                    var sortColumn = sortColumns_1_1.value;
                    var result = this.sortComparer(sortColumn, dataRow1, dataRow2);
                    if (result !== undefined) {
                        return result;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (sortColumns_1_1 && !sortColumns_1_1.done && (_a = sortColumns_1.return)) _a.call(sortColumns_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        return SortDirectionNumber.neutral;
    };
    SortService.prototype.sortComparer = function (sortColumn, dataRow1, dataRow2, querySortField) {
        if (sortColumn && sortColumn.sortCol) {
            var columnDef = sortColumn.sortCol;
            var sortDirection = sortColumn.sortAsc ? SortDirectionNumber.asc : SortDirectionNumber.desc;
            var queryFieldName1 = querySortField || columnDef.queryFieldSorter || columnDef.queryField || columnDef.field;
            var queryFieldName2 = queryFieldName1;
            var fieldType = columnDef.type || FieldType.string;
            // if user provided a query field name getter callback, we need to get the name on each item independently
            if (typeof columnDef.queryFieldNameGetterFn === 'function') {
                queryFieldName1 = columnDef.queryFieldNameGetterFn(dataRow1);
                queryFieldName2 = columnDef.queryFieldNameGetterFn(dataRow2);
            }
            var value1 = dataRow1[queryFieldName1];
            var value2 = dataRow2[queryFieldName2];
            // when item is a complex object (dot "." notation), we need to filter the value contained in the object tree
            if (queryFieldName1 && queryFieldName1.indexOf('.') >= 0) {
                value1 = getDescendantProperty(dataRow1, queryFieldName1);
            }
            if (queryFieldName2 && queryFieldName2.indexOf('.') >= 0) {
                value2 = getDescendantProperty(dataRow2, queryFieldName2);
            }
            // user could provide his own custom Sorter
            if (columnDef.sorter) {
                var customSortResult = columnDef.sorter(value1, value2, sortDirection, columnDef);
                if (customSortResult !== SortDirectionNumber.neutral) {
                    return customSortResult;
                }
            }
            else {
                var sortResult = sortByFieldType(fieldType, value1, value2, sortDirection, columnDef);
                if (sortResult !== SortDirectionNumber.neutral) {
                    return sortResult;
                }
            }
        }
        return undefined;
    };
    SortService.prototype.sortTreeData = function (hierarchicalArray, sortColumns) {
        var e_2, _a;
        if (Array.isArray(sortColumns)) {
            try {
                for (var sortColumns_2 = tslib_1.__values(sortColumns), sortColumns_2_1 = sortColumns_2.next(); !sortColumns_2_1.done; sortColumns_2_1 = sortColumns_2.next()) {
                    var sortColumn = sortColumns_2_1.value;
                    this.sortTreeChild(hierarchicalArray, sortColumn, 0);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (sortColumns_2_1 && !sortColumns_2_1.done && (_a = sortColumns_2.return)) _a.call(sortColumns_2);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    };
    /** Sort the Tree Children of a hierarchical dataset by recursion */
    SortService.prototype.sortTreeChild = function (hierarchicalArray, sortColumn, treeLevel) {
        var e_3, _a;
        var _this = this;
        var treeDataOptions = this._gridOptions && this._gridOptions.treeDataOptions;
        var childrenPropName = treeDataOptions && treeDataOptions.childrenPropName || 'children';
        hierarchicalArray.sort(function (a, b) { return _this.sortComparer(sortColumn, a, b) || SortDirectionNumber.neutral; });
        try {
            // when item has a child, we'll sort recursively
            for (var hierarchicalArray_1 = tslib_1.__values(hierarchicalArray), hierarchicalArray_1_1 = hierarchicalArray_1.next(); !hierarchicalArray_1_1.done; hierarchicalArray_1_1 = hierarchicalArray_1.next()) {
                var item = hierarchicalArray_1_1.value;
                if (item) {
                    var hasChildren = item.hasOwnProperty(childrenPropName) && Array.isArray(item[childrenPropName]);
                    // when item has a child, we'll sort recursively
                    if (hasChildren) {
                        treeLevel++;
                        this.sortTreeChild(item[childrenPropName], sortColumn, treeLevel);
                        treeLevel--;
                    }
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (hierarchicalArray_1_1 && !hierarchicalArray_1_1.done && (_a = hierarchicalArray_1.return)) _a.call(hierarchicalArray_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
    };
    /**
     * Update Sorting (sorters) dynamically just by providing an array of sorter(s).
     * You can also choose emit (default) a Sort Changed event that will be picked by the Grid State Service.
     *
     * Also for backend service only, you can choose to trigger a backend query (default) or not if you wish to do it later,
     * this could be useful when using updateFilters & updateSorting and you wish to only send the backend query once.
     * @param sorters array
     * @param triggerEvent defaults to True, do we want to emit a sort changed event?
     * @param triggerBackendQuery defaults to True, which will query the backend.
     */
    SortService.prototype.updateSorting = function (sorters, emitChangedEvent, triggerBackendQuery) {
        if (emitChangedEvent === void 0) { emitChangedEvent = true; }
        if (triggerBackendQuery === void 0) { triggerBackendQuery = true; }
        if (!this._gridOptions || !this._gridOptions.enableSorting) {
            throw new Error('[Angular-Slickgrid] in order to use "updateSorting" method, you need to have Sortable Columns defined in your grid and "enableSorting" set in your Grid Options');
        }
        if (Array.isArray(sorters)) {
            var backendApi = this._gridOptions && this._gridOptions.backendServiceApi;
            if (backendApi) {
                var backendApiService = backendApi && backendApi.service;
                if (backendApiService) {
                    backendApiService.updateSorters(undefined, sorters);
                    if (triggerBackendQuery) {
                        refreshBackendDataset(this._gridOptions);
                    }
                }
            }
            else {
                this.loadGridSorters(sorters);
            }
            if (emitChangedEvent) {
                var emitterType = backendApi ? EmitterType.remote : EmitterType.local;
                this.emitSortChanged(emitterType);
            }
        }
    };
    // --
    // private functions
    // -------------------
    /**
     * Loop through all column definitions and do the following 2 things
     * 1. disable/enable the "sortable" property of each column
     * 2. loop through each Header Menu commands and change the "hidden" commands to show/hide depending if it's enabled/disabled
     * Also note that we aren't deleting any properties, we just toggle their flags so that we can reloop through at later point in time.
     * (if we previously deleted these properties we wouldn't be able to change them back since these properties wouldn't exist anymore, hence why we just hide the commands)
     * @param {boolean} isDisabling - are we disabling the sort functionality? Defaults to true
     */
    SortService.prototype.disableAllSortingCommands = function (isDisabling) {
        if (isDisabling === void 0) { isDisabling = true; }
        var columnDefinitions = this._grid.getColumns();
        // loop through column definition to hide/show header menu commands
        columnDefinitions.forEach(function (col) {
            if (typeof col.sortable !== undefined) {
                col.sortable = !isDisabling;
            }
            if (col && col.header && col.header.menu) {
                col.header.menu.items.forEach(function (menuItem) {
                    if (menuItem && typeof menuItem !== 'string') {
                        var menuCommand = menuItem.command;
                        if (menuCommand === 'sort-asc' || menuCommand === 'sort-desc' || menuCommand === 'clear-sort') {
                            menuItem.hidden = isDisabling;
                        }
                    }
                });
            }
        });
        // loop through column definition to hide/show grid menu commands
        if (this._gridOptions && this._gridOptions.gridMenu && this._gridOptions.gridMenu.customItems) {
            this._gridOptions.gridMenu.customItems.forEach(function (menuItem) {
                if (menuItem && typeof menuItem !== 'string') {
                    var menuCommand = menuItem.command;
                    if (menuCommand === 'clear-sorting') {
                        menuItem.hidden = isDisabling;
                    }
                }
            });
        }
        return columnDefinitions;
    };
    SortService.ctorParameters = function () { return [
        { type: SharedService }
    ]; };
    SortService = tslib_1.__decorate([
        Injectable()
    ], SortService);
    return SortService;
}());
export { SortService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29ydC5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci1zbGlja2dyaWQvIiwic291cmNlcyI6WyJhcHAvbW9kdWxlcy9hbmd1bGFyLXNsaWNrZ3JpZC9zZXJ2aWNlcy9zb3J0LnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxZQUFZLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBRTdDLE9BQU8sRUFJTCxXQUFXLEVBQ1gsU0FBUyxFQUdULGFBQWEsRUFDYixtQkFBbUIsR0FHcEIsTUFBTSxtQkFBbUIsQ0FBQztBQUMzQixPQUFPLEVBQUUsc0JBQXNCLEVBQUUscUJBQXFCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUNwRixPQUFPLEVBQUUseUNBQXlDLEVBQUUscUJBQXFCLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDL0YsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQzdELE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUNqRCxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBTTNDO0lBU0UscUJBQW9CLGFBQTRCO1FBQTVCLGtCQUFhLEdBQWIsYUFBYSxDQUFlO1FBUnhDLHlCQUFvQixHQUFvQixFQUFFLENBQUM7UUFHM0MsbUJBQWMsR0FBRyxLQUFLLENBQUM7UUFDdkIsd0JBQW1CLEdBQWtCLElBQUksT0FBTyxFQUFRLENBQUMsQ0FBQyx1REFBdUQ7UUFDekgsa0JBQWEsR0FBRyxJQUFJLE9BQU8sRUFBbUIsQ0FBQztRQUMvQyxrQkFBYSxHQUFHLElBQUksT0FBTyxFQUFXLENBQUM7UUFHckMsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLEtBQUssQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUNoRCxDQUFDO0lBR0Qsc0JBQUkscUNBQVk7UUFEaEIsNENBQTRDO2FBQzVDO1lBQ0UsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFD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LENBQUMsWUFBWSxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRTtZQUM3RixJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLFVBQUMsUUFBUTtnQkFDdEQsSUFBSSxRQUFRLElBQUksT0FBTyxRQUFRLEtBQUssUUFBUSxFQUFFO29CQUM1QyxJQUFNLFdBQVcsR0FBRyxRQUFRLENBQUMsT0FBTyxDQUFDO29CQUNyQyxJQUFJLFdBQVcsS0FBSyxlQUFlLEVBQUU7d0JBQ25DLFFBQVEsQ0FBQyxNQUFNLEdBQUcsV0FBVyxDQUFDO3FCQUMvQjtpQkFDRjtZQUNILENBQUMsQ0FBQyxDQUFDO1NBQ0o7UUFFRCxPQUFPLGlCQUFpQixDQUFDO0lBQzNCLENBQUM7O2dCQXRoQmtDLGFBQWE7O0lBVHJDLFdBQVc7UUFEdkIsVUFBVSxFQUFFO09BQ0EsV0FBVyxDQWdpQnZCO0lBQUQsa0JBQUM7Q0FBQSxBQWhpQkQsSUFnaUJDO1NBaGlCWSxXQUFXIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNPYnNlcnZhYmxlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7XG4gIENvbHVtbixcbiAgQ29sdW1uU29ydCxcbiAgQ3VycmVudFNvcnRlcixcbiAgRW1pdHRlclR5cGUsXG4gIEZpZWxkVHlwZSxcbiAgR3JpZE9wdGlvbixcbiAgU2xpY2tFdmVudEhhbmRsZXIsXG4gIFNvcnREaXJlY3Rpb24sXG4gIFNvcnREaXJlY3Rpb25OdW1iZXIsXG4gIFNvcnREaXJlY3Rpb25TdHJpbmcsXG4gIFRyZWVEYXRhT3B0aW9uLFxufSBmcm9tICcuLy4uL21vZGVscy9pbmRleCc7XG5pbXBvcnQgeyBleGVjdXRlQmFja2VuZENhbGxiYWNrLCByZWZyZXNoQmFja2VuZERhdGFzZXQgfSBmcm9tICcuL2JhY2tlbmQtdXRpbGl0aWVzJztcbmltcG9ydCB7IGNvbnZlcnRIaWVyYXJjaGljYWxWaWV3VG9QYXJlbnRDaGlsZEFycmF5LCBnZXREZXNjZW5kYW50UHJvcGVydHkgfSBmcm9tICcuL3V0aWxpdGllcyc7XG5pbXBvcnQgeyBzb3J0QnlGaWVsZFR5cGUgfSBmcm9tICcuLi9zb3J0ZXJzL3NvcnRlclV0aWxpdGllcyc7XG5pbXBvcnQgeyBTaGFyZWRTZXJ2aWNlIH0gZnJvbSAnLi9zaGFyZWQuc2VydmljZSc7XG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbi8vIHVzaW5nIGV4dGVybmFsIG5vbi10eXBlZCBqcyBsaWJyYXJpZXNcbmRlY2xhcmUgY29uc3QgU2xpY2s6IGFueTtcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFNvcnRTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBfY3VycmVudExvY2FsU29ydGVyczogQ3VycmVudFNvcnRlcltdID0gW107XG4gIHByaXZhdGUgX2V2ZW50SGFuZGxlcjogU2xpY2tFdmVudEhhbmRsZXI7XG4gIHByaXZhdGUgX2dyaWQ6IGFueTtcbiAgcHJpdmF0ZSBfaXNCYWNrZW5kR3JpZCA9IGZhbHNlO1xuICBwcml2YXRlIGh0dHBDYW5jZWxSZXF1ZXN0cyQ6IFN1YmplY3Q8dm9pZD4gPSBuZXcgU3ViamVjdDx2b2lkPigpOyAvLyB0aGlzIHdpbGwgYmUgdXNlZCB0byBjYW5jZWwgYW55IHBlbmRpbmcgaHR0cCByZXF1ZXN0XG4gIG9uU29ydENoYW5nZWQgPSBuZXcgU3ViamVjdDxDdXJyZW50U29ydGVyW10+KCk7XG4gIG9uU29ydENsZWFyZWQgPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgc2hhcmVkU2VydmljZTogU2hhcmVkU2VydmljZSkge1xuICAgIHRoaXMuX2V2ZW50SGFuZGxlciA9IG5ldyBTbGljay5FdmVudEhhbmRsZXIoKTtcbiAgfVxuXG4gIC8qKiBHZXR0ZXIgb2YgdGhlIFNsaWNrR3JpZCBFdmVudCBIYW5kbGVyICovXG4gIGdldCBldmVudEhhbmRsZXIoKTogU2xpY2tFdmVudEhhbmRsZXIge1xuICAgIHJldHVybiB0aGlzLl9ldmVudEhhbmRsZXI7XG4gIH1cblxuICAvKiogR2V0dGVyIGZvciB0aGUgR3JpZCBPcHRpb25zIHB1bGxlZCB0aHJvdWdoIHRoZSBHcmlkIE9iamVjdCAqL1xuICBwcml2YXRlIGdldCBfZ3JpZE9wdGlvbnMoKTogR3JpZE9wdGlvbiB7XG4gICAgcmV0dXJuICh0aGlzLl9ncmlkICYmIHRoaXMuX2dyaWQuZ2V0T3B0aW9ucykgPyB0aGlzLl9ncmlkLmdldE9wdGlvbnMoKSA6IHt9O1xuICB9XG5cbiAgLyoqIEdldHRlciBmb3IgdGhlIENvbHVtbiBEZWZpbml0aW9ucyBwdWxsZWQgdGhyb3VnaCB0aGUgR3JpZCBPYmplY3QgKi9cbiAgcHJpdmF0ZSBnZXQgX2NvbHVtbkRlZmluaXRpb25zKCk6IENvbHVtbltdIHtcbiAgICByZXR1cm4gKHRoaXMuX2dyaWQgJiYgdGhpcy5fZ3JpZC5nZXRDb2x1bW5zKSA/IHRoaXMuX2dyaWQuZ2V0Q29sdW1ucygpIDogW107XG4gIH1cblxuICAvKiogR2V0dGVyIG9mIFNsaWNrR3JpZCBEYXRhVmlldyBvYmplY3QgKi9cbiAgcHJpdmF0ZSBnZXQgX2RhdGFWaWV3KCk6IGFueSB7XG4gICAgcmV0dXJuICh0aGlzLl9ncmlkICYmIHRoaXMuX2dyaWQuZ2V0RGF0YSkgPyB0aGlzLl9ncmlkLmdldERhdGEoKSA6IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIEJpbmQgYSBiYWNrZW5kIHNvcnQgKHNpbmdsZS9tdWx0aSkgaG9vayB0byB0aGUgZ3JpZFxuICAgKiBAcGFyYW0gZ3JpZCBTbGlja0dyaWQgR3JpZCBvYmplY3RcbiAgICogQHBhcmFtIGRhdGFWaWV3IFNsaWNrR3JpZCBEYXRhVmlldyBvYmplY3RcbiAgICovXG4gIGJpbmRCYWNrZW5kT25Tb3J0KGdyaWQ6IGFueSkge1xuICAgIHRoaXMuX2lzQmFja2VuZEdyaWQgPSB0cnVlO1xuICAgIHRoaXMuX2dyaWQgPSBncmlkO1xuXG4gICAgLy8gc3Vic2NyaWJlIHRvIHRoZSBTbGlja0dyaWQgZXZlbnQgYW5kIGNhbGwgdGhlIGJhY2tlbmQgZXhlY3V0aW9uXG4gICAgdGhpcy5fZXZlbnRIYW5kbGVyLnN1YnNjcmliZShncmlkLm9uU29ydCwgdGhpcy5vbkJhY2tlbmRTb3J0Q2hhbmdlZC5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kIGEgbG9jYWwgc29ydCAoc2luZ2xlL211bHRpKSBob29rIHRvIHRoZSBncmlkXG4gICAqIEBwYXJhbSBncmlkIFNsaWNrR3JpZCBHcmlkIG9iamVjdFxuICAgKiBAcGFyYW0gZ3JpZE9wdGlvbnMgR3JpZCBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0gZGF0YVZpZXdcbiAgICovXG4gIGJpbmRMb2NhbE9uU29ydChncmlkOiBhbnkpIHtcbiAgICB0aGlzLl9pc0JhY2tlbmRHcmlkID0gZmFsc2U7XG4gICAgdGhpcy5fZ3JpZCA9IGdyaWQ7XG5cbiAgICB0aGlzLnByb2Nlc3NUcmVlRGF0YUluaXRpYWxTb3J0KCk7XG4gICAgdGhpcy5fZXZlbnRIYW5kbGVyLnN1YnNjcmliZShncmlkLm9uU29ydCwgdGhpcy5oYW5kbGVMb2NhbE9uU29ydC5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIGhhbmRsZUxvY2FsT25Tb3J0KF9lOiBhbnksIGFyZ3M6IGFueSkge1xuICAgIGlmIChhcmdzICYmIChhcmdzLnNvcnRDb2xzIHx8IGFyZ3Muc29ydENvbCkpIHtcbiAgICAgIC8vIG11bHRpU29ydCBhbmQgc2luZ2xlU29ydCBhcmUgbm90IGV4YWN0bHkgdGhlIHNhbWUsIGJ1dCB3ZSB3YW50IHRvIHN0cnVjdHVyZSBpdCB0aGUgc2FtZSBmb3IgdGhlIChmb3IgbG9vcCkgYWZ0ZXJcbiAgICAgIC8vIGFsc28gdG8gYXZvaWQgaGF2aW5nIHRvIHJld3JpdGUgdGhlIGZvciBsb29wIGluIHRoZSBzb3J0LCB3ZSB3aWxsIG1ha2UgdGhlIHNpbmdsZVNvcnQgYW4gYXJyYXkgb2YgMSBvYmplY3RcbiAgICAgIGNvbnN0IHNvcnRDb2x1bW5zID0gKGFyZ3MubXVsdGlDb2x1bW5Tb3J0KSA/IGFyZ3Muc29ydENvbHMgOiBuZXcgQXJyYXkoeyBzb3J0QXNjOiBhcmdzLnNvcnRBc2MsIHNvcnRDb2w6IGFyZ3Muc29ydENvbCB9KTtcblxuICAgICAgLy8ga2VlcCBjdXJyZW50IHNvcnRlcnNcbiAgICAgIHRoaXMuX2N1cnJlbnRMb2NhbFNvcnRlcnMgPSBbXTsgLy8gcmVzZXQgY3VycmVudCBsb2NhbCBzb3J0ZXJzXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShzb3J0Q29sdW1ucykpIHtcbiAgICAgICAgc29ydENvbHVtbnMuZm9yRWFjaCgoc29ydENvbHVtbjogeyBzb3J0Q29sOiBDb2x1bW47IHNvcnRBc2M6IGJvb2xlYW47IH0pID0+IHtcbiAgICAgICAgICBpZiAoc29ydENvbHVtbi5zb3J0Q29sKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50TG9jYWxTb3J0ZXJzLnB1c2goe1xuICAgICAgICAgICAgICBjb2x1bW5JZDogc29ydENvbHVtbi5zb3J0Q29sLmlkLFxuICAgICAgICAgICAgICBkaXJlY3Rpb246IHNvcnRDb2x1bW4uc29ydEFzYyA/IFNvcnREaXJlY3Rpb24uQVNDIDogU29ydERpcmVjdGlvbi5ERVNDXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm9uTG9jYWxTb3J0Q2hhbmdlZCh0aGlzLl9ncmlkLCBzb3J0Q29sdW1ucyk7XG4gICAgICB0aGlzLmVtaXRTb3J0Q2hhbmdlZChFbWl0dGVyVHlwZS5sb2NhbCk7XG4gICAgfVxuICB9XG5cbiAgY2xlYXJTb3J0QnlDb2x1bW5JZChldmVudDogRXZlbnQgfCB1bmRlZmluZWQsIGNvbHVtbklkOiBzdHJpbmcgfCBudW1iZXIpIHtcbiAgICAvLyBnZXQgcHJldmlvdXNseSBzb3J0ZWQgY29sdW1uc1xuICAgIGNvbnN0IGFsbFNvcnRlZENvbHM6IENvbHVtblNvcnRbXSA9IHRoaXMuZ2V0Q3VycmVudENvbHVtblNvcnRzKCk7XG4gICAgY29uc3Qgc29ydGVkQ29sc1dpdGhvdXRDdXJyZW50OiBDb2x1bW5Tb3J0W10gPSB0aGlzLmdldEN1cnJlbnRDb2x1bW5Tb3J0cyhgJHtjb2x1bW5JZH1gKTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGFsbFNvcnRlZENvbHMpICYmIEFycmF5LmlzQXJyYXkoc29ydGVkQ29sc1dpdGhvdXRDdXJyZW50KSAmJiBhbGxTb3J0ZWRDb2xzLmxlbmd0aCAhPT0gc29ydGVkQ29sc1dpdGhvdXRDdXJyZW50Lmxlbmd0aCkge1xuICAgICAgaWYgKHRoaXMuX2dyaWRPcHRpb25zLmJhY2tlbmRTZXJ2aWNlQXBpKSB7XG4gICAgICAgIHRoaXMub25CYWNrZW5kU29ydENoYW5nZWQoZXZlbnQsIHsgbXVsdGlDb2x1bW5Tb3J0OiB0cnVlLCBzb3J0Q29sczogc29ydGVkQ29sc1dpdGhvdXRDdXJyZW50LCBncmlkOiB0aGlzLl9ncmlkIH0pO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9kYXRhVmlldykge1xuICAgICAgICB0aGlzLm9uTG9jYWxTb3J0Q2hhbmdlZCh0aGlzLl9ncmlkLCBzb3J0ZWRDb2xzV2l0aG91dEN1cnJlbnQsIHRydWUsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gd2hlbiB1c2luZyBjdXN0b21EYXRhVmlldywgd2Ugd2lsbCBzaW1wbHkgc2VuZCBpdCBhcyBhIG9uU29ydCBldmVudCB3aXRoIG5vdGlmeVxuICAgICAgICBjb25zdCBpc011bHRpU29ydCA9IHRoaXMuX2dyaWRPcHRpb25zICYmIHRoaXMuX2dyaWRPcHRpb25zLm11bHRpQ29sdW1uU29ydCB8fCBmYWxzZTtcbiAgICAgICAgY29uc3Qgc29ydE91dHB1dCA9IGlzTXVsdGlTb3J0ID8gc29ydGVkQ29sc1dpdGhvdXRDdXJyZW50IDogc29ydGVkQ29sc1dpdGhvdXRDdXJyZW50WzBdO1xuICAgICAgICB0aGlzLl9ncmlkLm9uU29ydC5ub3RpZnkoc29ydE91dHB1dCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHVwZGF0ZSB0aGUgZ3JpZCBzb3J0Q29sdW1ucyBhcnJheSB3aGljaCB3aWxsIGF0IHRoZSBzYW1lIGFkZCB0aGUgdmlzdWFsIHNvcnQgaWNvbihzKSBvbiB0aGUgVUlcbiAgICAgIGNvbnN0IHVwZGF0ZWRTb3J0Q29sdW1uczogQ29sdW1uU29ydFtdID0gc29ydGVkQ29sc1dpdGhvdXRDdXJyZW50Lm1hcCgoY29sKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY29sdW1uSWQ6IGNvbCAmJiBjb2wuc29ydENvbCAmJiBjb2wuc29ydENvbC5pZCxcbiAgICAgICAgICBzb3J0QXNjOiBjb2wgJiYgY29sLnNvcnRBc2MsXG4gICAgICAgICAgc29ydENvbDogY29sICYmIGNvbC5zb3J0Q29sLFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9ncmlkLnNldFNvcnRDb2x1bW5zKHVwZGF0ZWRTb3J0Q29sdW1ucyk7IC8vIGFkZCBzb3J0IGljb24gaW4gVUlcbiAgICB9XG5cbiAgICAvLyB3aGVuIHRoZXJlJ3Mgbm8gbW9yZSBzb3J0aW5nLCB3ZSByZS1zb3J0IGJ5IHRoZSBkZWZhdWx0IHNvcnQgZmllbGQsIHVzZXIgY2FuIGN1c3RvbWl6ZSBpdCBcImRlZmF1bHRDb2x1bW5Tb3J0RmllbGRJZFwiLCBkZWZhdWx0cyB0byBcImlkXCJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzb3J0ZWRDb2xzV2l0aG91dEN1cnJlbnQpICYmIHNvcnRlZENvbHNXaXRob3V0Q3VycmVudC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuc29ydExvY2FsR3JpZEJ5RGVmYXVsdFNvcnRGaWVsZElkKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIFNvcnRpbmdcbiAgICogLSAxc3QsIHJlbW92ZSB0aGUgU2xpY2tHcmlkIHNvcnQgaWNvbnMgKHRoaXMgc2V0U29ydENvbHVtbnMgZnVuY3Rpb24gY2FsbCByZWFsbHkgZG9lcyBvbmx5IHRoYXQpXG4gICAqIC0gMm5kLCB3ZSBhbHNvIG5lZWQgdG8gdHJpZ2dlciBhIHNvcnQgY2hhbmdlXG4gICAqICAgLSBmb3IgYSBiYWNrZW5kIGdyaWQsIHdlIHdpbGwgdHJpZ2dlciBhIGJhY2tlbmQgc29ydCBjaGFuZ2VkIHdpdGggYW4gZW1wdHkgc29ydCBjb2x1bW5zIGFycmF5XG4gICAqICAgLSBob3dldmVyIGZvciBhIGxvY2FsIGdyaWQsIHdlIG5lZWQgdG8gcGFzcyBhIHNvcnQgY29sdW1uIGFuZCBzbyB3ZSB3aWxsIHNvcnQgYnkgdGhlIDFzdCBjb2x1bW5cbiAgICogQHBhcmFtIHRyaWdnZXIgcXVlcnkgZXZlbnQgYWZ0ZXIgZXhlY3V0aW5nIGNsZWFyIGZpbHRlcj9cbiAgICovXG4gIGNsZWFyU29ydGluZyh0cmlnZ2VyUXVlcnlFdmVudCA9IHRydWUpIHtcbiAgICBpZiAodGhpcy5fZ3JpZCAmJiB0aGlzLl9ncmlkT3B0aW9ucyAmJiB0aGlzLl9kYXRhVmlldykge1xuICAgICAgLy8gcmVtb3ZlIGFueSBzb3J0IGljb25zICh0aGlzIHNldFNvcnRDb2x1bW5zIGZ1bmN0aW9uIGNhbGwgcmVhbGx5IGRvZXMgb25seSB0aGF0KVxuICAgICAgdGhpcy5fZ3JpZC5zZXRTb3J0Q29sdW1ucyhbXSk7XG5cbiAgICAgIC8vIHdlIGFsc28gbmVlZCB0byB0cmlnZ2VyIGEgc29ydCBjaGFuZ2VcbiAgICAgIC8vIGZvciBhIGJhY2tlbmQgZ3JpZCwgd2Ugd2lsbCB0cmlnZ2VyIGEgYmFja2VuZCBzb3J0IGNoYW5nZWQgd2l0aCBhbiBlbXB0eSBzb3J0IGNvbHVtbnMgYXJyYXlcbiAgICAgIC8vIGhvd2V2ZXIgZm9yIGEgbG9jYWwgZ3JpZCwgd2UgbmVlZCB0byBwYXNzIGEgc29ydCBjb2x1bW4gYW5kIHNvIHdlIHdpbGwgc29ydCBieSB0aGUgMXN0IGNvbHVtblxuICAgICAgaWYgKHRyaWdnZXJRdWVyeUV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0JhY2tlbmRHcmlkKSB7XG4gICAgICAgICAgdGhpcy5vbkJhY2tlbmRTb3J0Q2hhbmdlZCh1bmRlZmluZWQsIHsgZ3JpZDogdGhpcy5fZ3JpZCwgc29ydENvbHM6IFtdLCBjbGVhclNvcnRUcmlnZ2VyZWQ6IHRydWUgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2NvbHVtbkRlZmluaXRpb25zICYmIEFycmF5LmlzQXJyYXkodGhpcy5fY29sdW1uRGVmaW5pdGlvbnMpKSB7XG4gICAgICAgICAgICB0aGlzLnNvcnRMb2NhbEdyaWRCeURlZmF1bHRTb3J0RmllbGRJZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9pc0JhY2tlbmRHcmlkKSB7XG4gICAgICAgIGNvbnN0IGJhY2tlbmRTZXJ2aWNlID0gdGhpcy5fZ3JpZE9wdGlvbnMgJiYgdGhpcy5fZ3JpZE9wdGlvbnMuYmFja2VuZFNlcnZpY2VBcGkgJiYgdGhpcy5fZ3JpZE9wdGlvbnMuYmFja2VuZFNlcnZpY2VBcGkuc2VydmljZTtcbiAgICAgICAgaWYgKGJhY2tlbmRTZXJ2aWNlICYmIGJhY2tlbmRTZXJ2aWNlLmNsZWFyU29ydGVycykge1xuICAgICAgICAgIGJhY2tlbmRTZXJ2aWNlLmNsZWFyU29ydGVycygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2V0IGN1cnJlbnQgc29ydGVyIHRvIGVtcHR5ICYgZW1pdCBhIHNvcnQgY2hhbmdlZCBldmVudFxuICAgIHRoaXMuX2N1cnJlbnRMb2NhbFNvcnRlcnMgPSBbXTtcblxuICAgIC8vIGVtaXQgYW4gZXZlbnQgd2hlbiBzb3J0cyBhcmUgYWxsIGNsZWFyZWRcbiAgICB0aGlzLm9uU29ydENsZWFyZWQubmV4dCh0cnVlKTtcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgLy8gdW5zdWJzY3JpYmUgYWxsIFNsaWNrR3JpZCBldmVudHNcbiAgICBpZiAodGhpcy5fZXZlbnRIYW5kbGVyICYmIHRoaXMuX2V2ZW50SGFuZGxlci51bnN1YnNjcmliZUFsbCkge1xuICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyLnVuc3Vic2NyaWJlQWxsKCk7XG4gICAgfVxuICAgIGlmIChpc09ic2VydmFibGUodGhpcy5odHRwQ2FuY2VsUmVxdWVzdHMkKSkge1xuICAgICAgdGhpcy5odHRwQ2FuY2VsUmVxdWVzdHMkLm5leHQoKTsgLy8gdGhpcyBjYW5jZWxzIGFueSBwZW5kaW5nIGh0dHAgcmVxdWVzdHNcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlIHRoZSBTb3J0aW5nIEZ1bmN0aW9uYWxpdHlcbiAgICogQHBhcmFtIHtib29sZWFufSBpc1NvcnRpbmdEaXNhYmxlZCAtIG9wdGlvbmFsbHkgZm9yY2UgYSBkaXNhYmxlL2VuYWJsZSBvZiB0aGUgU29ydCBGdW5jdGlvbmFsaXR5PyBEZWZhdWx0cyB0byBUcnVlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xlYXJTb3J0aW5nV2hlbkRpc2FibGVkIC0gd2hlbiBkaXNhYmxpbmcgdGhlIHNvcnRpbmcsIGRvIHdlIGFsc28gd2FudCB0byBjbGVhciB0aGUgc29ydGluZyBhcyB3ZWxsPyBEZWZhdWx0cyB0byBUcnVlXG4gICAqL1xuICBkaXNhYmxlU29ydEZ1bmN0aW9uYWxpdHkoaXNTb3J0aW5nRGlzYWJsZWQgPSB0cnVlLCBjbGVhclNvcnRpbmdXaGVuRGlzYWJsZWQgPSB0cnVlKSB7XG4gICAgY29uc3QgcHJldlNvcnRpbmcgPSB0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVTb3J0aW5nO1xuICAgIGNvbnN0IG5ld1NvcnRpbmcgPSAhcHJldlNvcnRpbmc7XG5cbiAgICB0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVTb3J0aW5nID0gbmV3U29ydGluZztcbiAgICBsZXQgdXBkYXRlZENvbHVtbkRlZmluaXRpb25zO1xuICAgIGlmIChpc1NvcnRpbmdEaXNhYmxlZCkge1xuICAgICAgaWYgKGNsZWFyU29ydGluZ1doZW5EaXNhYmxlZCkge1xuICAgICAgICB0aGlzLmNsZWFyU29ydGluZygpO1xuICAgICAgfVxuICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyLnVuc3Vic2NyaWJlQWxsKCk7XG4gICAgICB1cGRhdGVkQ29sdW1uRGVmaW5pdGlvbnMgPSB0aGlzLmRpc2FibGVBbGxTb3J0aW5nQ29tbWFuZHModHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZWRDb2x1bW5EZWZpbml0aW9ucyA9IHRoaXMuZGlzYWJsZUFsbFNvcnRpbmdDb21tYW5kcyhmYWxzZSk7XG4gICAgICBjb25zdCBvblNvcnRIYW5kbGVyID0gdGhpcy5fZ3JpZC5vblNvcnQ7XG4gICAgICB0aGlzLl9ldmVudEhhbmRsZXIuc3Vic2NyaWJlKG9uU29ydEhhbmRsZXIsIChlOiBFdmVudCwgYXJnczogYW55KSA9PiB0aGlzLmhhbmRsZUxvY2FsT25Tb3J0KGUsIGFyZ3MpKTtcbiAgICB9XG4gICAgdGhpcy5fZ3JpZC5zZXRPcHRpb25zKHsgZW5hYmxlU29ydGluZzogdGhpcy5fZ3JpZE9wdGlvbnMuZW5hYmxlU29ydGluZyB9LCBmYWxzZSwgdHJ1ZSk7XG4gICAgdGhpcy5zaGFyZWRTZXJ2aWNlLmdyaWRPcHRpb25zID0gdGhpcy5fZ3JpZE9wdGlvbnM7XG5cbiAgICAvLyByZXNldCBjb2x1bW5zIHNvIHRoYXQgaXQgcmVjcmVhdGUgdGhlIGNvbHVtbiBoZWFkZXJzIGFuZCByZW1vdmUvYWRkIHRoZSBzb3J0IGljb24gaGludHNcbiAgICAvLyBiYXNpY2FsbHkgd2l0aG91dCB0aGlzLCB0aGUgc29ydCBpY29uIGhpbnRzIHdlcmUgc3RpbGwgc2hvd2luZyB1cCBldmVuIGFmdGVyIGRpc2FibGluZyB0aGUgU29ydGluZ1xuICAgIHRoaXMuX2dyaWQuc2V0Q29sdW1ucyh1cGRhdGVkQ29sdW1uRGVmaW5pdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZSB0aGUgU29ydGluZyBmdW5jdGlvbmFsaXR5XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xlYXJTb3J0aW5nV2hlbkRpc2FibGVkIC0gd2hlbiBkaXNhYmxpbmcgdGhlIHNvcnRpbmcsIGRvIHdlIGFsc28gd2FudCB0byBjbGVhciB0aGUgc29ydGluZyBhcyB3ZWxsPyBEZWZhdWx0cyB0byBUcnVlXG4gICAqL1xuICB0b2dnbGVTb3J0RnVuY3Rpb25hbGl0eShjbGVhclNvcnRpbmdPbkRpc2FibGUgPSB0cnVlKSB7XG4gICAgY29uc3QgcHJldmlvdXNTb3J0aW5nID0gdGhpcy5fZ3JpZE9wdGlvbnMuZW5hYmxlU29ydGluZztcbiAgICB0aGlzLmRpc2FibGVTb3J0RnVuY3Rpb25hbGl0eShwcmV2aW91c1NvcnRpbmcsIGNsZWFyU29ydGluZ09uRGlzYWJsZSk7XG4gIH1cblxuICAvKipcbiAgICogQSBzaW1wbGUgZnVuY3Rpb24gdGhhdCBpcyBiaW5kZWQgdG8gdGhlIHN1YnNjcmliZXIgYW5kIGVtaXQgYSBjaGFuZ2Ugd2hlbiB0aGUgc29ydCBpcyBjYWxsZWQuXG4gICAqIE90aGVyIHNlcnZpY2VzLCBsaWtlIFBhZ2luYXRpb24sIGNhbiB0aGVuIHN1YnNjcmliZSB0byBpdC5cbiAgICogQHBhcmFtIHNlbmRlclxuICAgKi9cbiAgZW1pdFNvcnRDaGFuZ2VkKHNlbmRlcjogRW1pdHRlclR5cGUsIGN1cnJlbnRMb2NhbFNvcnRlcnM/OiBDdXJyZW50U29ydGVyW10pIHtcbiAgICBpZiAoc2VuZGVyID09PSBFbWl0dGVyVHlwZS5yZW1vdGUgJiYgdGhpcy5fZ3JpZE9wdGlvbnMgJiYgdGhpcy5fZ3JpZE9wdGlvbnMuYmFja2VuZFNlcnZpY2VBcGkpIHtcbiAgICAgIGxldCBjdXJyZW50U29ydGVyczogQ3VycmVudFNvcnRlcltdID0gW107XG4gICAgICBjb25zdCBiYWNrZW5kU2VydmljZSA9IHRoaXMuX2dyaWRPcHRpb25zLmJhY2tlbmRTZXJ2aWNlQXBpLnNlcnZpY2U7XG4gICAgICBpZiAoYmFja2VuZFNlcnZpY2UgJiYgYmFja2VuZFNlcnZpY2UuZ2V0Q3VycmVudFNvcnRlcnMpIHtcbiAgICAgICAgY3VycmVudFNvcnRlcnMgPSBiYWNrZW5kU2VydmljZS5nZXRDdXJyZW50U29ydGVycygpIGFzIEN1cnJlbnRTb3J0ZXJbXTtcbiAgICAgIH1cbiAgICAgIHRoaXMub25Tb3J0Q2hhbmdlZC5uZXh0KGN1cnJlbnRTb3J0ZXJzKTtcbiAgICB9IGVsc2UgaWYgKHNlbmRlciA9PT0gRW1pdHRlclR5cGUubG9jYWwpIHtcbiAgICAgIGlmIChjdXJyZW50TG9jYWxTb3J0ZXJzKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRMb2NhbFNvcnRlcnMgPSBjdXJyZW50TG9jYWxTb3J0ZXJzO1xuICAgICAgfVxuICAgICAgdGhpcy5vblNvcnRDaGFuZ2VkLm5leHQodGhpcy5nZXRDdXJyZW50TG9jYWxTb3J0ZXJzKCkpO1xuICAgIH1cbiAgfVxuXG4gIGdldEN1cnJlbnRMb2NhbFNvcnRlcnMoKTogQ3VycmVudFNvcnRlcltdIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudExvY2FsU29ydGVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgY3VycmVudCBjb2x1bW4gc29ydHMsXG4gICAqIElmIGEgY29sdW1uIGlzIHBhc3NlZCBhcyBhbiBhcmd1bWVudCwgdGhhdCB3aWxsIGJlIGV4Y2x1c2lvbiBzbyB3ZSB3b24ndCBhZGQgdGhpcyBjb2x1bW4gdG8gb3VyIG91dHB1dCBhcnJheSBzaW5jZSBpdCBpcyBhbHJlYWR5IGluIHRoZSBhcnJheS5cbiAgICogVGhlIHVzYWdlIG9mIHRoaXMgbWV0aG9kIGlzIHRoYXQgd2Ugd2FudCB0byBrbm93IHRoZSBzb3J0IHByaW9yIHRvIGNhbGxpbmcgdGhlIG5leHQgc29ydGluZyBjb21tYW5kXG4gICAqL1xuICBnZXRDdXJyZW50Q29sdW1uU29ydHMoZXhjbHVkZWRDb2x1bW5JZD86IHN0cmluZyk6IHsgc29ydENvbDogQ29sdW1uOyBzb3J0QXNjOiBib29sZWFuOyB9W10ge1xuICAgIC8vIGdldFNvcnRDb2x1bW5zKCkgb25seSByZXR1cm5zIHNvcnRBc2MgJiBjb2x1bW5JZCwgd2Ugd2FudCB0aGUgZW50aXJlIGNvbHVtbiBkZWZpbml0aW9uXG4gICAgY29uc3Qgb2xkU29ydENvbHVtbnMgPSB0aGlzLl9ncmlkICYmIHRoaXMuX2dyaWQuZ2V0U29ydENvbHVtbnMoKTtcblxuICAgIC8vIGdldCB0aGUgY29sdW1uIGRlZmluaXRpb24gYnV0IG9ubHkga2VlcCBjb2x1bW4gd2hpY2ggYXJlIG5vdCBlcXVhbCB0byBvdXIgY3VycmVudCBjb2x1bW5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvbGRTb3J0Q29sdW1ucykpIHtcbiAgICAgIGNvbnN0IHNvcnRlZENvbHMgPSBvbGRTb3J0Q29sdW1ucy5yZWR1Y2UoKGNvbHMsIGNvbCkgPT4ge1xuICAgICAgICBpZiAoIWV4Y2x1ZGVkQ29sdW1uSWQgfHwgY29sLmNvbHVtbklkICE9PSBleGNsdWRlZENvbHVtbklkKSB7XG4gICAgICAgICAgY29scy5wdXNoKHsgc29ydENvbDogdGhpcy5fY29sdW1uRGVmaW5pdGlvbnNbdGhpcy5fZ3JpZC5nZXRDb2x1bW5JbmRleChjb2wuY29sdW1uSWQpXSwgc29ydEFzYzogY29sLnNvcnRBc2MgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbHM7XG4gICAgICB9LCBbXSk7XG5cbiAgICAgIHJldHVybiBzb3J0ZWRDb2xzO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cblxuICAvKiogTG9hZCBkZWZpbmVkIFNvcnRpbmcgKHNvcnRlcnMpIGludG8gdGhlIGdyaWQgKi9cbiAgbG9hZEdyaWRTb3J0ZXJzKHNvcnRlcnM6IEN1cnJlbnRTb3J0ZXJbXSk6IENvbHVtblNvcnRbXSB7XG4gICAgdGhpcy5fY3VycmVudExvY2FsU29ydGVycyA9IFtdOyAvLyByZXNldCBjdXJyZW50IGxvY2FsIHNvcnRlcnNcbiAgICBjb25zdCBzb3J0Q29sczogQ29sdW1uU29ydFtdID0gW107XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShzb3J0ZXJzKSkge1xuICAgICAgc29ydGVycy5mb3JFYWNoKChzb3J0ZXI6IEN1cnJlbnRTb3J0ZXIpID0+IHtcbiAgICAgICAgY29uc3QgZ3JpZENvbHVtbiA9IHRoaXMuX2NvbHVtbkRlZmluaXRpb25zLmZpbmQoKGNvbDogQ29sdW1uKSA9PiBjb2wuaWQgPT09IHNvcnRlci5jb2x1bW5JZCk7XG4gICAgICAgIGlmIChncmlkQ29sdW1uKSB7XG4gICAgICAgICAgc29ydENvbHMucHVzaCh7XG4gICAgICAgICAgICBjb2x1bW5JZDogZ3JpZENvbHVtbi5pZCxcbiAgICAgICAgICAgIHNvcnRBc2M6ICgoc29ydGVyLmRpcmVjdGlvbi50b1VwcGVyQ2FzZSgpID09PSBTb3J0RGlyZWN0aW9uLkFTQykgPyB0cnVlIDogZmFsc2UpLFxuICAgICAgICAgICAgc29ydENvbDogZ3JpZENvbHVtblxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8ga2VlcCBjdXJyZW50IHNvcnRlcnNcbiAgICAgICAgICB0aGlzLl9jdXJyZW50TG9jYWxTb3J0ZXJzLnB1c2goe1xuICAgICAgICAgICAgY29sdW1uSWQ6IGdyaWRDb2x1bW4uaWQgKyAnJyxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogc29ydGVyLmRpcmVjdGlvbi50b1VwcGVyQ2FzZSgpIGFzIFNvcnREaXJlY3Rpb25TdHJpbmdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHNvcnRDb2xzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMub25Mb2NhbFNvcnRDaGFuZ2VkKHRoaXMuX2dyaWQsIHNvcnRDb2xzKTtcbiAgICAgIHRoaXMuX2dyaWQuc2V0U29ydENvbHVtbnMoc29ydENvbHMpOyAvLyB1c2UgdGhpcyB0byBhZGQgc29ydCBpY29uKHMpIGluIFVJXG4gICAgfVxuXG4gICAgcmV0dXJuIHNvcnRDb2xzO1xuICB9XG5cbiAgLyoqIFByb2Nlc3MgdGhlIGluaXRpYWwgc29ydCwgdHlwaWNhbGx5IGl0IHdpbGwgc29ydCBhc2NlbmRpbmcgYnkgdGhlIGNvbHVtbiB0aGF0IGhhcyB0aGUgVHJlZSBEYXRhIHVubGVzcyB1c2VyIHNwZWNpZmllcyBhIGRpZmZlcmVudCBpbml0aWFsU29ydCAqL1xuICBwcm9jZXNzVHJlZURhdGFJbml0aWFsU29ydCgpIHtcbiAgICAvLyB3aGVuIGEgVHJlZSBEYXRhIHZpZXcgaXMgZGVmaW5lZCwgd2UgbXVzdCBzb3J0IHRoZSBkYXRhIHNvIHRoYXQgdGhlIFVJIHdvcmtzIGNvcnJlY3RseVxuICAgIGlmICh0aGlzLl9ncmlkT3B0aW9ucyAmJiB0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVUcmVlRGF0YSAmJiB0aGlzLl9ncmlkT3B0aW9ucy50cmVlRGF0YU9wdGlvbnMpIHtcbiAgICAgIC8vIGZpcnN0IHByZXNvcnQgaXQgb25jZSBieSB0cmVlIGxldmVsXG4gICAgICBjb25zdCB0cmVlRGF0YU9wdGlvbnMgPSB0aGlzLl9ncmlkT3B0aW9ucy50cmVlRGF0YU9wdGlvbnM7XG4gICAgICBjb25zdCBjb2x1bW5XaXRoVHJlZURhdGEgPSB0aGlzLl9jb2x1bW5EZWZpbml0aW9ucy5maW5kKChjb2w6IENvbHVtbikgPT4gY29sICYmIGNvbC5pZCA9PT0gdHJlZURhdGFPcHRpb25zLmNvbHVtbklkKTtcbiAgICAgIGlmIChjb2x1bW5XaXRoVHJlZURhdGEpIHtcbiAgICAgICAgbGV0IHNvcnREaXJlY3Rpb24gPSBTb3J0RGlyZWN0aW9uLkFTQztcbiAgICAgICAgbGV0IHNvcnRUcmVlTGV2ZWxDb2x1bW46IENvbHVtblNvcnQgPSB7IGNvbHVtbklkOiB0cmVlRGF0YU9wdGlvbnMuY29sdW1uSWQsIHNvcnRDb2w6IGNvbHVtbldpdGhUcmVlRGF0YSwgc29ydEFzYzogdHJ1ZSB9O1xuXG4gICAgICAgIC8vIHVzZXIgY291bGQgcHJvdmlkZSBhIGN1c3RvbSBzb3J0IGZpZWxkIGlkLCBpZiBzbyBnZXQgdGhhdCBjb2x1bW4gYW5kIHNvcnQgYnkgaXRcbiAgICAgICAgaWYgKHRyZWVEYXRhT3B0aW9ucyAmJiB0cmVlRGF0YU9wdGlvbnMuaW5pdGlhbFNvcnQgJiYgdHJlZURhdGFPcHRpb25zLmluaXRpYWxTb3J0LmNvbHVtbklkKSB7XG4gICAgICAgICAgY29uc3QgaW5pdGlhbFNvcnRDb2x1bW5JZCA9IHRyZWVEYXRhT3B0aW9ucy5pbml0aWFsU29ydC5jb2x1bW5JZDtcbiAgICAgICAgICBjb25zdCBpbml0aWFsU29ydENvbHVtbiA9IHRoaXMuX2NvbHVtbkRlZmluaXRpb25zLmZpbmQoKGNvbDogQ29sdW1uKSA9PiBjb2wuaWQgPT09IGluaXRpYWxTb3J0Q29sdW1uSWQpO1xuICAgICAgICAgIHNvcnREaXJlY3Rpb24gPSAodHJlZURhdGFPcHRpb25zLmluaXRpYWxTb3J0LmRpcmVjdGlvbiB8fCBTb3J0RGlyZWN0aW9uLkFTQykudG9VcHBlckNhc2UoKSBhcyBTb3J0RGlyZWN0aW9uO1xuICAgICAgICAgIHNvcnRUcmVlTGV2ZWxDb2x1bW4gPSB7IGNvbHVtbklkOiBpbml0aWFsU29ydENvbHVtbklkLCBzb3J0Q29sOiBpbml0aWFsU29ydENvbHVtbiwgc29ydEFzYzogKHNvcnREaXJlY3Rpb24gPT09IFNvcnREaXJlY3Rpb24uQVNDKSB9IGFzIENvbHVtblNvcnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3aGVuIHdlIGhhdmUgYSB2YWxpZCBjb2x1bW4gd2l0aCBUcmVlIERhdGEsIHdlIGNhbiBzb3J0IGJ5IHRoYXQgY29sdW1uXG4gICAgICAgIGlmIChzb3J0VHJlZUxldmVsQ29sdW1uICYmIHNvcnRUcmVlTGV2ZWxDb2x1bW4uY29sdW1uSWQpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZVNvcnRpbmcoW3sgY29sdW1uSWQ6IHNvcnRUcmVlTGV2ZWxDb2x1bW4uY29sdW1uSWQgfHwgJycsIGRpcmVjdGlvbjogc29ydERpcmVjdGlvbiB9XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkJhY2tlbmRTb3J0Q2hhbmdlZChldmVudDogRXZlbnQsIGFyZ3M6IHsgbXVsdGlDb2x1bW5Tb3J0PzogYm9vbGVhbjsgZ3JpZDogYW55OyBzb3J0Q29sczogQ29sdW1uU29ydFtdOyBjbGVhclNvcnRUcmlnZ2VyZWQ/OiBib29sZWFuOyB9KSB7XG4gICAgaWYgKCFhcmdzIHx8ICFhcmdzLmdyaWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU29tZXRoaW5nIHdlbnQgd3Jvbmcgd2hlbiB0cnlpbmcgdG8gYmluZCB0aGUgXCJvbkJhY2tlbmRTb3J0Q2hhbmdlZChldmVudCwgYXJncylcIiBmdW5jdGlvbiwgaXQgc2VlbXMgdGhhdCBcImFyZ3NcIiBpcyBub3QgcG9wdWxhdGVkIGNvcnJlY3RseScpO1xuICAgIH1cbiAgICBjb25zdCBncmlkT3B0aW9uczogR3JpZE9wdGlvbiA9IChhcmdzLmdyaWQgJiYgYXJncy5ncmlkLmdldE9wdGlvbnMpID8gYXJncy5ncmlkLmdldE9wdGlvbnMoKSA6IHt9O1xuICAgIGNvbnN0IGJhY2tlbmRBcGkgPSBncmlkT3B0aW9ucy5iYWNrZW5kU2VydmljZUFwaTtcblxuICAgIGlmICghYmFja2VuZEFwaSB8fCAhYmFja2VuZEFwaS5wcm9jZXNzIHx8ICFiYWNrZW5kQXBpLnNlcnZpY2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQmFja2VuZFNlcnZpY2VBcGkgcmVxdWlyZXMgYXQgbGVhc3QgYSBcInByb2Nlc3NcIiBmdW5jdGlvbiBhbmQgYSBcInNlcnZpY2VcIiBkZWZpbmVkYCk7XG4gICAgfVxuXG4gICAgLy8ga2VlcCBzdGFydCB0aW1lICYgZW5kIHRpbWVzdGFtcHMgJiByZXR1cm4gaXQgYWZ0ZXIgcHJvY2VzcyBleGVjdXRpb25cbiAgICBjb25zdCBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpO1xuXG4gICAgaWYgKGJhY2tlbmRBcGkucHJlUHJvY2Vzcykge1xuICAgICAgYmFja2VuZEFwaS5wcmVQcm9jZXNzKCk7XG4gICAgfVxuXG4gICAgLy8gcXVlcnkgYmFja2VuZFxuICAgIGNvbnN0IHF1ZXJ5ID0gYmFja2VuZEFwaS5zZXJ2aWNlLnByb2Nlc3NPblNvcnRDaGFuZ2VkKGV2ZW50LCBhcmdzKTtcbiAgICBjb25zdCB0b3RhbEl0ZW1zID0gZ3JpZE9wdGlvbnMgJiYgZ3JpZE9wdGlvbnMucGFnaW5hdGlvbiAmJiBncmlkT3B0aW9ucy5wYWdpbmF0aW9uLnRvdGFsSXRlbXM7XG4gICAgZXhlY3V0ZUJhY2tlbmRDYWxsYmFjayhiYWNrZW5kQXBpLCBxdWVyeSwgYXJncywgc3RhcnRUaW1lLCB0b3RhbEl0ZW1zLCB0aGlzLmVtaXRTb3J0Q2hhbmdlZC5iaW5kKHRoaXMpLCB0aGlzLmh0dHBDYW5jZWxSZXF1ZXN0cyQpO1xuICB9XG5cbiAgLyoqIFdoZW4gYSBTb3J0IENoYW5nZXMgb24gYSBMb2NhbCBncmlkIChKU09OIGRhdGFzZXQpICovXG4gIG9uTG9jYWxTb3J0Q2hhbmdlZChncmlkOiBhbnksIHNvcnRDb2x1bW5zOiBDb2x1bW5Tb3J0W10sIGZvcmNlUmVTb3J0ID0gZmFsc2UsIGVtaXRTb3J0Q2hhbmdlZCA9IGZhbHNlKSB7XG4gICAgY29uc3QgaXNUcmVlRGF0YUVuYWJsZWQgPSB0aGlzLl9ncmlkT3B0aW9ucyAmJiB0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVUcmVlRGF0YSB8fCBmYWxzZTtcbiAgICBjb25zdCBkYXRhVmlldyA9IGdyaWQgJiYgZ3JpZC5nZXREYXRhICYmIGdyaWQuZ2V0RGF0YSgpO1xuXG4gICAgaWYgKGdyaWQgJiYgZGF0YVZpZXcpIHtcbiAgICAgIGlmIChmb3JjZVJlU29ydCAmJiAhaXNUcmVlRGF0YUVuYWJsZWQpIHtcbiAgICAgICAgZGF0YVZpZXcucmVTb3J0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1RyZWVEYXRhRW5hYmxlZCAmJiB0aGlzLnNoYXJlZFNlcnZpY2UgJiYgQXJyYXkuaXNBcnJheSh0aGlzLnNoYXJlZFNlcnZpY2UuaGllcmFyY2hpY2FsRGF0YXNldCkpIHtcbiAgICAgICAgY29uc3QgaGllcmFyY2hpY2FsRGF0YXNldCA9IHRoaXMuc2hhcmVkU2VydmljZS5oaWVyYXJjaGljYWxEYXRhc2V0O1xuICAgICAgICB0aGlzLnNvcnRUcmVlRGF0YShoaWVyYXJjaGljYWxEYXRhc2V0LCBzb3J0Q29sdW1ucyk7XG4gICAgICAgIGNvbnN0IGRhdGFWaWV3SWRJZGVudGlmaWVyID0gdGhpcy5fZ3JpZE9wdGlvbnMgJiYgdGhpcy5fZ3JpZE9wdGlvbnMuZGF0YXNldElkUHJvcGVydHlOYW1lIHx8ICdpZCc7XG4gICAgICAgIGNvbnN0IHRyZWVEYXRhT3B0OiBUcmVlRGF0YU9wdGlvbiA9IHRoaXMuX2dyaWRPcHRpb25zICYmIHRoaXMuX2dyaWRPcHRpb25zLnRyZWVEYXRhT3B0aW9ucyB8fCB7IGNvbHVtbklkOiAnJyB9O1xuICAgICAgICBjb25zdCB0cmVlRGF0YU9wdGlvbnMgPSB7IC4uLnRyZWVEYXRhT3B0LCBpZGVudGlmaWVyUHJvcE5hbWU6IHRyZWVEYXRhT3B0LmlkZW50aWZpZXJQcm9wTmFtZSB8fCBkYXRhVmlld0lkSWRlbnRpZmllciB9O1xuICAgICAgICBjb25zdCBzb3J0ZWRGbGF0QXJyYXkgPSBjb252ZXJ0SGllcmFyY2hpY2FsVmlld1RvUGFyZW50Q2hpbGRBcnJheShoaWVyYXJjaGljYWxEYXRhc2V0LCB0cmVlRGF0YU9wdGlvbnMpO1xuICAgICAgICBkYXRhVmlldy5zZXRJdGVtcyhzb3J0ZWRGbGF0QXJyYXksIHRoaXMuX2dyaWRPcHRpb25zICYmIHRoaXMuX2dyaWRPcHRpb25zLmRhdGFzZXRJZFByb3BlcnR5TmFtZSB8fCAnaWQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGFWaWV3LnNvcnQodGhpcy5zb3J0Q29tcGFyZXJzLmJpbmQodGhpcywgc29ydENvbHVtbnMpKTtcbiAgICAgIH1cblxuICAgICAgZ3JpZC5pbnZhbGlkYXRlKCk7XG4gICAgICBncmlkLnJlbmRlcigpO1xuXG4gICAgICBpZiAoZW1pdFNvcnRDaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMuZW1pdFNvcnRDaGFuZ2VkKEVtaXR0ZXJUeXBlLmxvY2FsLCBzb3J0Q29sdW1ucy5tYXAoY29sID0+IHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29sdW1uSWQ6IGNvbC5zb3J0Q29sICYmIGNvbC5zb3J0Q29sLmlkIHx8ICdpZCcsXG4gICAgICAgICAgICBkaXJlY3Rpb246IGNvbC5zb3J0QXNjID8gU29ydERpcmVjdGlvbi5BU0MgOiBTb3J0RGlyZWN0aW9uLkRFU0NcbiAgICAgICAgICB9O1xuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqIENhbGwgYSBsb2NhbCBncmlkIHNvcnQgYnkgaXRzIGRlZmF1bHQgc29ydCBmaWVsZCBpZCAodXNlciBjYW4gY3VzdG9taXplIGRlZmF1bHQgZmllbGQgYnkgY29uZmlndXJpbmcgXCJkZWZhdWx0Q29sdW1uU29ydEZpZWxkSWRcIiBpbiB0aGUgZ3JpZCBvcHRpb25zLCBkZWZhdWx0cyB0byBcImlkXCIpICovXG4gIHNvcnRMb2NhbEdyaWRCeURlZmF1bHRTb3J0RmllbGRJZCgpIHtcbiAgICBjb25zdCBzb3J0Q29sRmllbGRJZCA9IHRoaXMuX2dyaWRPcHRpb25zICYmIHRoaXMuX2dyaWRPcHRpb25zLmRlZmF1bHRDb2x1bW5Tb3J0RmllbGRJZCB8fCB0aGlzLl9ncmlkT3B0aW9ucy5kYXRhc2V0SWRQcm9wZXJ0eU5hbWUgfHwgJ2lkJztcbiAgICBjb25zdCBzb3J0Q29sID0geyBpZDogc29ydENvbEZpZWxkSWQsIGZpZWxkOiBzb3J0Q29sRmllbGRJZCB9IGFzIENvbHVtbjtcbiAgICB0aGlzLm9uTG9jYWxTb3J0Q2hhbmdlZCh0aGlzLl9ncmlkLCBuZXcgQXJyYXkoeyBzb3J0QXNjOiB0cnVlLCBzb3J0Q29sLCBjbGVhclNvcnRUcmlnZ2VyZWQ6IHRydWUgfSkpO1xuICB9XG5cbiAgc29ydENvbXBhcmVycyhzb3J0Q29sdW1uczogQ29sdW1uU29ydFtdLCBkYXRhUm93MTogYW55LCBkYXRhUm93MjogYW55KTogbnVtYmVyIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzb3J0Q29sdW1ucykpIHtcbiAgICAgIGZvciAoY29uc3Qgc29ydENvbHVtbiBvZiBzb3J0Q29sdW1ucykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnNvcnRDb21wYXJlcihzb3J0Q29sdW1uLCBkYXRhUm93MSwgZGF0YVJvdzIpO1xuICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBTb3J0RGlyZWN0aW9uTnVtYmVyLm5ldXRyYWw7XG4gIH1cblxuICBzb3J0Q29tcGFyZXIoc29ydENvbHVtbjogQ29sdW1uU29ydCwgZGF0YVJvdzE6IGFueSwgZGF0YVJvdzI6IGFueSwgcXVlcnlTb3J0RmllbGQ/OiBzdHJpbmcpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICAgIGlmIChzb3J0Q29sdW1uICYmIHNvcnRDb2x1bW4uc29ydENvbCkge1xuICAgICAgY29uc3QgY29sdW1uRGVmID0gc29ydENvbHVtbi5zb3J0Q29sO1xuICAgICAgY29uc3Qgc29ydERpcmVjdGlvbiA9IHNvcnRDb2x1bW4uc29ydEFzYyA/IFNvcnREaXJlY3Rpb25OdW1iZXIuYXNjIDogU29ydERpcmVjdGlvbk51bWJlci5kZXNjO1xuICAgICAgbGV0IHF1ZXJ5RmllbGROYW1lMSA9IHF1ZXJ5U29ydEZpZWxkIHx8IGNvbHVtbkRlZi5xdWVyeUZpZWxkU29ydGVyIHx8IGNvbHVtbkRlZi5xdWVyeUZpZWxkIHx8IGNvbHVtbkRlZi5maWVsZDtcbiAgICAgIGxldCBxdWVyeUZpZWxkTmFtZTIgPSBxdWVyeUZpZWxkTmFtZTE7XG4gICAgICBjb25zdCBmaWVsZFR5cGUgPSBjb2x1bW5EZWYudHlwZSB8fCBGaWVsZFR5cGUuc3RyaW5nO1xuXG4gICAgICAvLyBpZiB1c2VyIHByb3ZpZGVkIGEgcXVlcnkgZmllbGQgbmFtZSBnZXR0ZXIgY2FsbGJhY2ssIHdlIG5lZWQgdG8gZ2V0IHRoZSBuYW1lIG9uIGVhY2ggaXRlbSBpbmRlcGVuZGVudGx5XG4gICAgICBpZiAodHlwZW9mIGNvbHVtbkRlZi5xdWVyeUZpZWxkTmFtZUdldHRlckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHF1ZXJ5RmllbGROYW1lMSA9IGNvbHVtbkRlZi5xdWVyeUZpZWxkTmFtZUdldHRlckZuKGRhdGFSb3cxKTtcbiAgICAgICAgcXVlcnlGaWVsZE5hbWUyID0gY29sdW1uRGVmLnF1ZXJ5RmllbGROYW1lR2V0dGVyRm4oZGF0YVJvdzIpO1xuICAgICAgfVxuXG4gICAgICBsZXQgdmFsdWUxID0gZGF0YVJvdzFbcXVlcnlGaWVsZE5hbWUxXTtcbiAgICAgIGxldCB2YWx1ZTIgPSBkYXRhUm93MltxdWVyeUZpZWxkTmFtZTJdO1xuXG4gICAgICAvLyB3aGVuIGl0ZW0gaXMgYSBjb21wbGV4IG9iamVjdCAoZG90IFwiLlwiIG5vdGF0aW9uKSwgd2UgbmVlZCB0byBmaWx0ZXIgdGhlIHZhbHVlIGNvbnRhaW5lZCBpbiB0aGUgb2JqZWN0IHRyZWVcbiAgICAgIGlmIChxdWVyeUZpZWxkTmFtZTEgJiYgcXVlcnlGaWVsZE5hbWUxLmluZGV4T2YoJy4nKSA+PSAwKSB7XG4gICAgICAgIHZhbHVlMSA9IGdldERlc2NlbmRhbnRQcm9wZXJ0eShkYXRhUm93MSwgcXVlcnlGaWVsZE5hbWUxKTtcbiAgICAgIH1cbiAgICAgIGlmIChxdWVyeUZpZWxkTmFtZTIgJiYgcXVlcnlGaWVsZE5hbWUyLmluZGV4T2YoJy4nKSA+PSAwKSB7XG4gICAgICAgIHZhbHVlMiA9IGdldERlc2NlbmRhbnRQcm9wZXJ0eShkYXRhUm93MiwgcXVlcnlGaWVsZE5hbWUyKTtcbiAgICAgIH1cblxuICAgICAgLy8gdXNlciBjb3VsZCBwcm92aWRlIGhpcyBvd24gY3VzdG9tIFNvcnRlclxuICAgICAgaWYgKGNvbHVtbkRlZi5zb3J0ZXIpIHtcbiAgICAgICAgY29uc3QgY3VzdG9tU29ydFJlc3VsdCA9IGNvbHVtbkRlZi5zb3J0ZXIodmFsdWUxLCB2YWx1ZTIsIHNvcnREaXJlY3Rpb24sIGNvbHVtbkRlZik7XG4gICAgICAgIGlmIChjdXN0b21Tb3J0UmVzdWx0ICE9PSBTb3J0RGlyZWN0aW9uTnVtYmVyLm5ldXRyYWwpIHtcbiAgICAgICAgICByZXR1cm4gY3VzdG9tU29ydFJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc29ydFJlc3VsdCA9IHNvcnRCeUZpZWxkVHlwZShmaWVsZFR5cGUsIHZhbHVlMSwgdmFsdWUyLCBzb3J0RGlyZWN0aW9uLCBjb2x1bW5EZWYpO1xuICAgICAgICBpZiAoc29ydFJlc3VsdCAhPT0gU29ydERpcmVjdGlvbk51bWJlci5uZXV0cmFsKSB7XG4gICAgICAgICAgcmV0dXJuIHNvcnRSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHNvcnRUcmVlRGF0YShoaWVyYXJjaGljYWxBcnJheTogYW55W10sIHNvcnRDb2x1bW5zOiBDb2x1bW5Tb3J0W10pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzb3J0Q29sdW1ucykpIHtcbiAgICAgIGZvciAoY29uc3Qgc29ydENvbHVtbiBvZiBzb3J0Q29sdW1ucykge1xuICAgICAgICB0aGlzLnNvcnRUcmVlQ2hpbGQoaGllcmFyY2hpY2FsQXJyYXksIHNvcnRDb2x1bW4sIDApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKiBTb3J0IHRoZSBUcmVlIENoaWxkcmVuIG9mIGEgaGllcmFyY2hpY2FsIGRhdGFzZXQgYnkgcmVjdXJzaW9uICovXG4gIHNvcnRUcmVlQ2hpbGQoaGllcmFyY2hpY2FsQXJyYXk6IGFueVtdLCBzb3J0Q29sdW1uOiBDb2x1bW5Tb3J0LCB0cmVlTGV2ZWw6IG51bWJlcikge1xuICAgIGNvbnN0IHRyZWVEYXRhT3B0aW9ucyA9IHRoaXMuX2dyaWRPcHRpb25zICYmIHRoaXMuX2dyaWRPcHRpb25zLnRyZWVEYXRhT3B0aW9ucztcbiAgICBjb25zdCBjaGlsZHJlblByb3BOYW1lID0gdHJlZURhdGFPcHRpb25zICYmIHRyZWVEYXRhT3B0aW9ucy5jaGlsZHJlblByb3BOYW1lIHx8ICdjaGlsZHJlbic7XG4gICAgaGllcmFyY2hpY2FsQXJyYXkuc29ydCgoYTogYW55LCBiOiBhbnkpID0+IHRoaXMuc29ydENvbXBhcmVyKHNvcnRDb2x1bW4sIGEsIGIpIHx8IFNvcnREaXJlY3Rpb25OdW1iZXIubmV1dHJhbCk7XG5cbiAgICAvLyB3aGVuIGl0ZW0gaGFzIGEgY2hpbGQsIHdlJ2xsIHNvcnQgcmVjdXJzaXZlbHlcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaGllcmFyY2hpY2FsQXJyYXkpIHtcbiAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgIGNvbnN0IGhhc0NoaWxkcmVuID0gaXRlbS5oYXNPd25Qcm9wZXJ0eShjaGlsZHJlblByb3BOYW1lKSAmJiBBcnJheS5pc0FycmF5KGl0ZW1bY2hpbGRyZW5Qcm9wTmFtZV0pO1xuICAgICAgICAvLyB3aGVuIGl0ZW0gaGFzIGEgY2hpbGQsIHdlJ2xsIHNvcnQgcmVjdXJzaXZlbHlcbiAgICAgICAgaWYgKGhhc0NoaWxkcmVuKSB7XG4gICAgICAgICAgdHJlZUxldmVsKys7XG4gICAgICAgICAgdGhpcy5zb3J0VHJlZUNoaWxkKGl0ZW1bY2hpbGRyZW5Qcm9wTmFtZV0sIHNvcnRDb2x1bW4sIHRyZWVMZXZlbCk7XG4gICAgICAgICAgdHJlZUxldmVsLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIFNvcnRpbmcgKHNvcnRlcnMpIGR5bmFtaWNhbGx5IGp1c3QgYnkgcHJvdmlkaW5nIGFuIGFycmF5IG9mIHNvcnRlcihzKS5cbiAgICogWW91IGNhbiBhbHNvIGNob29zZSBlbWl0IChkZWZhdWx0KSBhIFNvcnQgQ2hhbmdlZCBldmVudCB0aGF0IHdpbGwgYmUgcGlja2VkIGJ5IHRoZSBHcmlkIFN0YXRlIFNlcnZpY2UuXG4gICAqXG4gICAqIEFsc28gZm9yIGJhY2tlbmQgc2VydmljZSBvbmx5LCB5b3UgY2FuIGNob29zZSB0byB0cmlnZ2VyIGEgYmFja2VuZCBxdWVyeSAoZGVmYXVsdCkgb3Igbm90IGlmIHlvdSB3aXNoIHRvIGRvIGl0IGxhdGVyLFxuICAgKiB0aGlzIGNvdWxkIGJlIHVzZWZ1bCB3aGVuIHVzaW5nIHVwZGF0ZUZpbHRlcnMgJiB1cGRhdGVTb3J0aW5nIGFuZCB5b3Ugd2lzaCB0byBvbmx5IHNlbmQgdGhlIGJhY2tlbmQgcXVlcnkgb25jZS5cbiAgICogQHBhcmFtIHNvcnRlcnMgYXJyYXlcbiAgICogQHBhcmFtIHRyaWdnZXJFdmVudCBkZWZhdWx0cyB0byBUcnVlLCBkbyB3ZSB3YW50IHRvIGVtaXQgYSBzb3J0IGNoYW5nZWQgZXZlbnQ/XG4gICAqIEBwYXJhbSB0cmlnZ2VyQmFja2VuZFF1ZXJ5IGRlZmF1bHRzIHRvIFRydWUsIHdoaWNoIHdpbGwgcXVlcnkgdGhlIGJhY2tlbmQuXG4gICAqL1xuICB1cGRhdGVTb3J0aW5nKHNvcnRlcnM6IEN1cnJlbnRTb3J0ZXJbXSwgZW1pdENoYW5nZWRFdmVudCA9IHRydWUsIHRyaWdnZXJCYWNrZW5kUXVlcnkgPSB0cnVlKSB7XG4gICAgaWYgKCF0aGlzLl9ncmlkT3B0aW9ucyB8fCAhdGhpcy5fZ3JpZE9wdGlvbnMuZW5hYmxlU29ydGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdbQW5ndWxhci1TbGlja2dyaWRdIGluIG9yZGVyIHRvIHVzZSBcInVwZGF0ZVNvcnRpbmdcIiBtZXRob2QsIHlvdSBuZWVkIHRvIGhhdmUgU29ydGFibGUgQ29sdW1ucyBkZWZpbmVkIGluIHlvdXIgZ3JpZCBhbmQgXCJlbmFibGVTb3J0aW5nXCIgc2V0IGluIHlvdXIgR3JpZCBPcHRpb25zJyk7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc29ydGVycykpIHtcbiAgICAgIGNvbnN0IGJhY2tlbmRBcGkgPSB0aGlzLl9ncmlkT3B0aW9ucyAmJiB0aGlzLl9ncmlkT3B0aW9ucy5iYWNrZW5kU2VydmljZUFwaTtcblxuICAgICAgaWYgKGJhY2tlbmRBcGkpIHtcbiAgICAgICAgY29uc3QgYmFja2VuZEFwaVNlcnZpY2UgPSBiYWNrZW5kQXBpICYmIGJhY2tlbmRBcGkuc2VydmljZTtcbiAgICAgICAgaWYgKGJhY2tlbmRBcGlTZXJ2aWNlKSB7XG4gICAgICAgICAgYmFja2VuZEFwaVNlcnZpY2UudXBkYXRlU29ydGVycyh1bmRlZmluZWQsIHNvcnRlcnMpO1xuICAgICAgICAgIGlmICh0cmlnZ2VyQmFja2VuZFF1ZXJ5KSB7XG4gICAgICAgICAgICByZWZyZXNoQmFja2VuZERhdGFzZXQodGhpcy5fZ3JpZE9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sb2FkR3JpZFNvcnRlcnMoc29ydGVycyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbWl0Q2hhbmdlZEV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGVtaXR0ZXJUeXBlID0gYmFja2VuZEFwaSA/IEVtaXR0ZXJUeXBlLnJlbW90ZSA6IEVtaXR0ZXJUeXBlLmxvY2FsO1xuICAgICAgICB0aGlzLmVtaXRTb3J0Q2hhbmdlZChlbWl0dGVyVHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gLS1cbiAgLy8gcHJpdmF0ZSBmdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBMb29wIHRocm91Z2ggYWxsIGNvbHVtbiBkZWZpbml0aW9ucyBhbmQgZG8gdGhlIGZvbGxvd2luZyAyIHRoaW5nc1xuICAgKiAxLiBkaXNhYmxlL2VuYWJsZSB0aGUgXCJzb3J0YWJsZVwiIHByb3BlcnR5IG9mIGVhY2ggY29sdW1uXG4gICAqIDIuIGxvb3AgdGhyb3VnaCBlYWNoIEhlYWRlciBNZW51IGNvbW1hbmRzIGFuZCBjaGFuZ2UgdGhlIFwiaGlkZGVuXCIgY29tbWFuZHMgdG8gc2hvdy9oaWRlIGRlcGVuZGluZyBpZiBpdCdzIGVuYWJsZWQvZGlzYWJsZWRcbiAgICogQWxzbyBub3RlIHRoYXQgd2UgYXJlbid0IGRlbGV0aW5nIGFueSBwcm9wZXJ0aWVzLCB3ZSBqdXN0IHRvZ2dsZSB0aGVpciBmbGFncyBzbyB0aGF0IHdlIGNhbiByZWxvb3AgdGhyb3VnaCBhdCBsYXRlciBwb2ludCBpbiB0aW1lLlxuICAgKiAoaWYgd2UgcHJldmlvdXNseSBkZWxldGVkIHRoZXNlIHByb3BlcnRpZXMgd2Ugd291bGRuJ3QgYmUgYWJsZSB0byBjaGFuZ2UgdGhlbSBiYWNrIHNpbmNlIHRoZXNlIHByb3BlcnRpZXMgd291bGRuJ3QgZXhpc3QgYW55bW9yZSwgaGVuY2Ugd2h5IHdlIGp1c3QgaGlkZSB0aGUgY29tbWFuZHMpXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNEaXNhYmxpbmcgLSBhcmUgd2UgZGlzYWJsaW5nIHRoZSBzb3J0IGZ1bmN0aW9uYWxpdHk/IERlZmF1bHRzIHRvIHRydWVcbiAgICovXG4gIHByaXZhdGUgZGlzYWJsZUFsbFNvcnRpbmdDb21tYW5kcyhpc0Rpc2FibGluZyA9IHRydWUpOiBDb2x1bW5bXSB7XG4gICAgY29uc3QgY29sdW1uRGVmaW5pdGlvbnMgPSB0aGlzLl9ncmlkLmdldENvbHVtbnMoKTtcblxuICAgIC8vIGxvb3AgdGhyb3VnaCBjb2x1bW4gZGVmaW5pdGlvbiB0byBoaWRlL3Nob3cgaGVhZGVyIG1lbnUgY29tbWFuZHNcbiAgICBjb2x1bW5EZWZpbml0aW9ucy5mb3JFYWNoKChjb2wpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgY29sLnNvcnRhYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29sLnNvcnRhYmxlID0gIWlzRGlzYWJsaW5nO1xuICAgICAgfVxuICAgICAgaWYgKGNvbCAmJiBjb2wuaGVhZGVyICYmIGNvbC5oZWFkZXIubWVudSkge1xuICAgICAgICBjb2wuaGVhZGVyLm1lbnUuaXRlbXMuZm9yRWFjaChtZW51SXRlbSA9PiB7XG4gICAgICAgICAgaWYgKG1lbnVJdGVtICYmIHR5cGVvZiBtZW51SXRlbSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lbnVDb21tYW5kID0gbWVudUl0ZW0uY29tbWFuZDtcbiAgICAgICAgICAgIGlmIChtZW51Q29tbWFuZCA9PT0gJ3NvcnQtYXNjJyB8fCBtZW51Q29tbWFuZCA9PT0gJ3NvcnQtZGVzYycgfHwgbWVudUNvbW1hbmQgPT09ICdjbGVhci1zb3J0Jykge1xuICAgICAgICAgICAgICBtZW51SXRlbS5oaWRkZW4gPSBpc0Rpc2FibGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gbG9vcCB0aHJvdWdoIGNvbHVtbiBkZWZpbml0aW9uIHRvIGhpZGUvc2hvdyBncmlkIG1lbnUgY29tbWFuZHNcbiAgICBpZiAodGhpcy5fZ3JpZE9wdGlvbnMgJiYgdGhpcy5fZ3JpZE9wdGlvbnMuZ3JpZE1lbnUgJiYgdGhpcy5fZ3JpZE9wdGlvbnMuZ3JpZE1lbnUuY3VzdG9tSXRlbXMpIHtcbiAgICAgIHRoaXMuX2dyaWRPcHRpb25zLmdyaWRNZW51LmN1c3RvbUl0ZW1zLmZvckVhY2goKG1lbnVJdGVtKSA9PiB7XG4gICAgICAgIGlmIChtZW51SXRlbSAmJiB0eXBlb2YgbWVudUl0ZW0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgY29uc3QgbWVudUNvbW1hbmQgPSBtZW51SXRlbS5jb21tYW5kO1xuICAgICAgICAgIGlmIChtZW51Q29tbWFuZCA9PT0gJ2NsZWFyLXNvcnRpbmcnKSB7XG4gICAgICAgICAgICBtZW51SXRlbS5oaWRkZW4gPSBpc0Rpc2FibGluZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBjb2x1bW5EZWZpbml0aW9ucztcbiAgfVxufVxuIl19