import * as tslib_1 from "tslib";
import { Observable } from 'rxjs';
import { first } from 'rxjs/operators';
import * as moment_ from 'moment-mini';
var moment = moment_; // patch to fix rollup "moment has no default export" issue, document here https://github.com/rollup/rollup/issues/670
import { FieldType, OperatorType } from '../models/index';
/**
 * Add an item to an array only when the item does not exists, when the item is an object we will be using their "id" to compare
 * @param inputArray
 * @param inputItem
 * @param itemIdPropName
 */
export function addToArrayWhenNotExists(inputArray, inputItem, itemIdPropName) {
    if (itemIdPropName === void 0) { itemIdPropName = 'id'; }
    var arrayRowIndex = -1;
    if (typeof inputItem === 'object' && inputItem.hasOwnProperty(itemIdPropName)) {
        arrayRowIndex = inputArray.findIndex(function (item) { return item[itemIdPropName] === inputItem[itemIdPropName]; });
    }
    else {
        arrayRowIndex = inputArray.findIndex(function (item) { return item === inputItem; });
    }
    if (arrayRowIndex < 0) {
        inputArray.push(inputItem);
    }
}
/**
 * Simple function to which will loop and create as demanded the number of white spaces,
 * this is used in the CSV export
 * @param int nbSpaces: number of white spaces to create
 */
export function addWhiteSpaces(nbSpaces) {
    var result = '';
    for (var i = 0; i < nbSpaces; i++) {
        result += ' ';
    }
    return result;
}
/**
 * Remove a column from the grid by it's index in the grid
 * @param array input
 * @param index
 */
export function arrayRemoveItemByIndex(array, index) {
    return array.filter(function (_el, i) { return index !== i; });
}
/**
 * Convert a flat array (with "parentId" references) into a hierarchical dataset structure (where children are array(s) inside their parent objects)
 * @param flatArray input array (flat dataset)
 * @param options you can provide the following options:: "parentPropName" (defaults to "parent"), "childrenPropName" (defaults to "children") and "identifierPropName" (defaults to "id")
 * @return roots - hierarchical data view array
 */
export function convertParentChildArrayToHierarchicalView(flatArray, options) {
    var childrenPropName = options && options.childrenPropName || 'children';
    var parentPropName = options && options.parentPropName || '__parentId';
    var identifierPropName = options && options.identifierPropName || 'id';
    var hasChildrenFlagPropName = '__hasChildren';
    var treeLevelPropName = '__treeLevel';
    var inputArray = $.extend(true, [], flatArray);
    var roots = []; // things without parent
    // make them accessible by guid on this map
    var all = {};
    inputArray.forEach(function (item) { return all[item[identifierPropName]] = item; });
    // connect childrens to its parent, and split roots apart
    Object.keys(all).forEach(function (id) {
        var item = all[id];
        if (item[parentPropName] === null || !item.hasOwnProperty(parentPropName)) {
            delete item[parentPropName];
            roots.push(item);
        }
        else if (item[parentPropName] in all) {
            var p = all[item[parentPropName]];
            if (!(childrenPropName in p)) {
                p[childrenPropName] = [];
            }
            delete item[parentPropName];
            p[childrenPropName].push(item);
        }
        // delete any unnecessary properties that were possibly created in the flat array but shouldn't be part of the tree data
        delete item[treeLevelPropName];
        delete item[hasChildrenFlagPropName];
    });
    return roots;
}
/**
 * Convert a hierarchical array (with children) into a flat array structure array (where the children are pushed as next indexed item in the array)
 * @param hierarchicalArray - input hierarchical array
 * @param options - you can provide "childrenPropName" (defaults to "children")
 * @return output - Parent/Child array
 */
export function convertHierarchicalViewToParentChildArray(hierarchicalArray, options) {
    var outputArray = [];
    convertHierarchicalViewToParentChildArrayByReference($.extend(true, [], hierarchicalArray), outputArray, options, 0);
    // the output array is the one passed as reference
    return outputArray;
}
/**
 * Convert a hierarchical array (with children) into a flat array structure array but using the array as the output (the array is the pointer reference)
 * @param hierarchicalArray - input hierarchical array
 * @param outputArrayRef - output array passed (and modified) by reference
 * @param options - you can provide "childrenPropName" (defaults to "children")
 * @param treeLevel - tree level number
 * @param parentId - parent ID
 */
export function convertHierarchicalViewToParentChildArrayByReference(hierarchicalArray, outputArrayRef, options, treeLevel, parentId) {
    var e_1, _a;
    if (treeLevel === void 0) { treeLevel = 0; }
    var childrenPropName = options && options.childrenPropName || 'children';
    var identifierPropName = options && options.identifierPropName || 'id';
    var hasChildrenFlagPropName = options && options.hasChildrenFlagPropName || '__hasChildren';
    var treeLevelPropName = options && options.treeLevelPropName || '__treeLevel';
    var parentPropName = options && options.parentPropName || '__parentId';
    if (Array.isArray(hierarchicalArray)) {
        var _loop_1 = function (item) {
            if (item) {
                var itemExist = outputArrayRef.find(function (itm) { return itm[identifierPropName] === item[identifierPropName]; });
                if (!itemExist) {
                    item[treeLevelPropName] = treeLevel; // save tree level ref
                    item[parentPropName] = parentId || null;
                    outputArrayRef.push(item);
                }
                if (Array.isArray(item[childrenPropName])) {
                    treeLevel++;
                    convertHierarchicalViewToParentChildArrayByReference(item[childrenPropName], outputArrayRef, options, treeLevel, item[identifierPropName]);
                    treeLevel--;
                    item[hasChildrenFlagPropName] = true;
                    delete item[childrenPropName]; // remove the children property
                }
            }
        };
        try {
            for (var hierarchicalArray_1 = tslib_1.__values(hierarchicalArray), hierarchicalArray_1_1 = hierarchicalArray_1.next(); !hierarchicalArray_1_1.done; hierarchicalArray_1_1 = hierarchicalArray_1.next()) {
                var item = hierarchicalArray_1_1.value;
                _loop_1(item);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (hierarchicalArray_1_1 && !hierarchicalArray_1_1.done && (_a = hierarchicalArray_1.return)) _a.call(hierarchicalArray_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
}
/**
 * Create an immutable clone of an array or object
 * (c) 2019 Chris Ferdinandi, MIT License, https://gomakethings.com
 * @param  {Array|Object} obj The array or object to copy
 * @return {Array|Object}     The clone of the array or object
 */
export function deepCopy(obj) {
    /**
     * Create an immutable copy of an object
     * @return {Object}
     */
    var cloneObj = function () {
        // Create new object
        var clone = {};
        // Loop through each item in the original
        // Recursively copy it's value and add to the clone
        for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                clone[key] = deepCopy(obj[key]);
            }
        }
        return clone;
    };
    /**
     * Create an immutable copy of an array
     * @return {Array}
     */
    var cloneArr = function () {
        return obj.map(function (item) { return deepCopy(item); });
    };
    // -- init --//
    // Get object type
    var type = Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();
    // If an object
    if (type === 'object') {
        return cloneObj();
    }
    // If an array
    if (type === 'array') {
        return cloneArr();
    }
    // Otherwise, return it as-is
    return obj;
}
/**
 * Find an item from a hierarchical view structure (a parent that can have children array which themseleves can children and so on)
 * @param hierarchicalArray
 * @param predicate
 * @param childrenPropertyName
 */
export function findItemInHierarchicalStructure(hierarchicalArray, predicate, childrenPropertyName) {
    if (!childrenPropertyName) {
        throw new Error('findRecursive requires parameter "childrenPropertyName"');
    }
    var initialFind = hierarchicalArray.find(predicate);
    var elementsWithChildren = hierarchicalArray.filter(function (x) { return x.hasOwnProperty(childrenPropertyName) && x[childrenPropertyName]; });
    if (initialFind) {
        return initialFind;
    }
    else if (elementsWithChildren.length) {
        var childElements_1 = [];
        elementsWithChildren.forEach(function (item) {
            if (item.hasOwnProperty(childrenPropertyName)) {
                childElements_1.push.apply(childElements_1, tslib_1.__spread(item[childrenPropertyName]));
            }
        });
        return findItemInHierarchicalStructure(childElements_1, predicate, childrenPropertyName);
    }
    return undefined;
}
/**
 * HTML decode using jQuery with a <div>
 * Create a in-memory div, set it's inner text(which jQuery automatically encodes)
 * then grab the encoded contents back out.  The div never exists on the page.
*/
export function htmlDecode(encodedStr) {
    var parser = DOMParser && new DOMParser;
    if (parser && parser.parseFromString) {
        var dom = parser.parseFromString('<!doctype html><body>' + encodedStr, 'text/html');
        return dom && dom.body && dom.body.textContent;
    }
    else {
        // for some browsers that might not support DOMParser, use jQuery instead
        return $('<div/>').html(encodedStr).text();
    }
}
/**
 * HTML encode using jQuery with a <div>
 * Create a in-memory div, set it's inner text(which jQuery automatically encodes)
 * then grab the encoded contents back out.  The div never exists on the page.
*/
export function htmlEncode(inputValue) {
    var entityMap = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        '\'': '&#39;'
    };
    // all symbols::  /[&<>"'`=\/]/g
    return (inputValue || '').toString().replace(/[&<>"']/g, function (s) { return entityMap[s]; });
}
/**
 * Decode text into html entity
 * @param string text: input text
 * @param string text: output text
 */
export function htmlEntityDecode(input) {
    return input.replace(/&#(\d+);/g, function (_match, dec) {
        return String.fromCharCode(dec);
    });
}
/**
 * Decode text into html entity
 * @param string text: input text
 * @param string text: output text
 */
export function htmlEntityEncode(input) {
    var buf = [];
    for (var i = input.length - 1; i >= 0; i--) {
        buf.unshift(['&#', input[i].charCodeAt(), ';'].join(''));
    }
    return buf.join('');
}
/**
 * Compares two arrays of characters to determine if all the items are equal
 * @param a first array
 * @param b second array to compare with a
 * @param [orderMatters=false] flag if the order matters, if not arrays will be sorted before comparison
 * @return boolean true if equal, else false
 */
export function charArraysEqual(a, b, orderMatters) {
    if (orderMatters === void 0) { orderMatters = false; }
    if (!a || !b || !Array.isArray(a) || !Array.isArray(a)) {
        return false;
    }
    if (a.length !== b.length) {
        return false;
    }
    if (!orderMatters && a.sort && b.sort) {
        a.sort();
        b.sort();
    }
    for (var i = 0; i < a.length; ++i) {
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
}
/**
 * Try casting an input of type Promise | Observable into a Promise type.
 * @param object which could be of type Promise or Observable
 * @param fromServiceName string representing the caller service name and will be used if we throw a casting problem error
 */
export function castToPromise(input, fromServiceName) {
    if (fromServiceName === void 0) { fromServiceName = ''; }
    var promise = input;
    if (input instanceof Promise) {
        // if it's already a Promise then return it
        return input;
    }
    else if (input instanceof Observable) {
        promise = input.pipe(first()).toPromise();
    }
    if (!(promise instanceof Promise)) {
        throw new Error("Something went wrong, Angular-Slickgrid " + fromServiceName + " is not able to convert the Observable into a Promise.\n      If you are using Angular HttpClient, you could try converting your http call to a Promise with \".toPromise()\"\n      for example::  this.http.post('graphql', { query: graphqlQuery }).toPromise()\n      ");
    }
    return promise;
}
/**
 * Uses the logic function to find an item in an array or returns the default
 * value provided (empty object by default)
 * @param any[] array the array to filter
 * @param function logic the logic to find the item
 * @param any [defaultVal={}] the default value to return
 * @return object the found object or default value
 */
export function findOrDefault(array, logic, defaultVal) {
    if (defaultVal === void 0) { defaultVal = {}; }
    return array.find(logic) || defaultVal;
}
/**
 * Encode string to html special char and add html space padding defined
 * @param {string} inputStr - input string
 * @param {number} paddingLength - padding to add
 */
export function htmlEncodedStringWithPadding(inputStr, paddingLength) {
    var inputStrLn = inputStr.length;
    var outputStr = htmlEncode(inputStr);
    if (inputStrLn < paddingLength) {
        for (var i = inputStrLn; i < paddingLength; i++) {
            outputStr += "&nbsp;";
        }
    }
    return outputStr;
}
/**
  * Take a number (or a string) and display it as a formatted decimal string with defined minimum and maximum decimals
  * @param input
  * @param minDecimal
  * @param maxDecimal
  */
export function decimalFormatted(input, minDecimal, maxDecimal, decimalSeparator, thousandSeparator) {
    if (decimalSeparator === void 0) { decimalSeparator = '.'; }
    if (thousandSeparator === void 0) { thousandSeparator = ''; }
    if (isNaN(+input)) {
        return input;
    }
    var minDec = (minDecimal === undefined) ? 2 : minDecimal;
    var maxDec = (maxDecimal === undefined) ? 2 : maxDecimal;
    var amount = String(Math.round(+input * Math.pow(10, maxDec)) / Math.pow(10, maxDec));
    if ((amount.indexOf('.') < 0) && (minDec > 0)) {
        amount += '.';
    }
    while ((amount.length - amount.indexOf('.')) <= minDec) {
        amount += '0';
    }
    var decimalSplit = amount.split('.');
    var integerNumber;
    var decimalNumber;
    // do we want to display our number with a custom separator in each thousand position
    if (thousandSeparator) {
        integerNumber = decimalSplit.length >= 1 ? thousandSeparatorFormatted(decimalSplit[0], thousandSeparator) : undefined;
    }
    else {
        integerNumber = decimalSplit.length >= 1 ? decimalSplit[0] : amount;
    }
    // when using a separator that is not a dot, replace it with the new separator
    if (decimalSplit.length > 1) {
        decimalNumber = decimalSplit[1];
    }
    var output = '';
    if (integerNumber !== undefined && decimalNumber !== undefined) {
        output = "" + integerNumber + decimalSeparator + decimalNumber;
    }
    else if (integerNumber !== undefined && integerNumber !== null) {
        output = integerNumber;
    }
    return output;
}
/**
 * Loop through all properties of an object and nullify any properties that are instanceof HTMLElement,
 * if we detect an array then use recursion to go inside it and apply same logic
 * @param obj - object containing 1 or more properties with DOM Elements
 */
export function destroyObjectDomElementProps(obj) {
    var e_2, _a;
    if (obj) {
        try {
            for (var _b = tslib_1.__values(Object.keys(obj)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var key = _c.value;
                if (Array.isArray(obj[key])) {
                    destroyObjectDomElementProps(obj[key]);
                }
                if (obj[key] instanceof HTMLElement) {
                    obj[key] = null;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
}
/**
 * Format a number following options passed as arguments (decimals, separator, ...)
 * @param input
 * @param minDecimal
 * @param maxDecimal
 * @param displayNegativeNumberWithParentheses
 * @param symbolPrefix
 * @param symbolSuffix
 * @param decimalSeparator
 * @param thousandSeparator
 */
export function formatNumber(input, minDecimal, maxDecimal, displayNegativeNumberWithParentheses, symbolPrefix, symbolSuffix, decimalSeparator, thousandSeparator) {
    if (symbolPrefix === void 0) { symbolPrefix = ''; }
    if (symbolSuffix === void 0) { symbolSuffix = ''; }
    if (decimalSeparator === void 0) { decimalSeparator = '.'; }
    if (thousandSeparator === void 0) { thousandSeparator = ''; }
    if (isNaN(+input)) {
        return input;
    }
    var calculatedValue = ((Math.round(parseFloat(input) * 1000000) / 1000000));
    if (calculatedValue < 0) {
        var absValue = Math.abs(calculatedValue);
        if (displayNegativeNumberWithParentheses) {
            if (!isNaN(minDecimal) || !isNaN(maxDecimal)) {
                return "(" + symbolPrefix + decimalFormatted(absValue, minDecimal, maxDecimal, decimalSeparator, thousandSeparator) + symbolSuffix + ")";
            }
            var formattedValue = thousandSeparatorFormatted("" + absValue, thousandSeparator);
            return "(" + symbolPrefix + formattedValue + symbolSuffix + ")";
        }
        else {
            if (!isNaN(minDecimal) || !isNaN(maxDecimal)) {
                return "-" + symbolPrefix + decimalFormatted(absValue, minDecimal, maxDecimal, decimalSeparator, thousandSeparator) + symbolSuffix;
            }
            var formattedValue = thousandSeparatorFormatted("" + absValue, thousandSeparator);
            return "-" + symbolPrefix + formattedValue + symbolSuffix;
        }
    }
    else {
        if (!isNaN(minDecimal) || !isNaN(maxDecimal)) {
            return "" + symbolPrefix + decimalFormatted(input, minDecimal, maxDecimal, decimalSeparator, thousandSeparator) + symbolSuffix;
        }
        var formattedValue = thousandSeparatorFormatted("" + input, thousandSeparator);
        return "" + symbolPrefix + formattedValue + symbolSuffix;
    }
}
/** From a dot (.) notation path, find and return a property within an object given a path */
export function getDescendantProperty(obj, path) {
    return path.split('.').reduce(function (acc, part) { return acc && acc[part]; }, obj);
}
/** Get HTML Element position offset (without jQuery) */
export function getHtmlElementOffset(element) {
    var rect = element.getBoundingClientRect();
    var top = 0;
    var left = 0;
    if (rect && rect.top !== undefined && rect.left !== undefined) {
        top = rect.top + window.pageYOffset;
        left = rect.left + window.pageXOffset;
    }
    return { top: top, left: left };
}
/** Get Translation Prefix, defaults to an empty string */
export function getTranslationPrefix(gridOptions) {
    if (gridOptions && gridOptions.translationNamespace) {
        return gridOptions.translationNamespace + (gridOptions.translationNamespaceSeparator || '');
    }
    return '';
}
/**
 * From a Date FieldType, return it's equivalent moment.js format
 * refer to moment.js for the format standard used: https://momentjs.com/docs/#/parsing/string-format/
 * @param fieldType
 */
export function mapMomentDateFormatWithFieldType(fieldType) {
    var map;
    switch (fieldType) {
        case FieldType.dateTime:
        case FieldType.dateTimeIso:
            map = 'YYYY-MM-DD HH:mm:ss';
            break;
        case FieldType.dateTimeShortIso:
            map = 'YYYY-MM-DD HH:mm';
            break;
        case FieldType.dateTimeIsoAmPm:
            map = 'YYYY-MM-DD hh:mm:ss a';
            break;
        case FieldType.dateTimeIsoAM_PM:
            map = 'YYYY-MM-DD hh:mm:ss A';
            break;
        // all Euro Formats (date/month/year)
        case FieldType.dateEuro:
            map = 'DD/MM/YYYY';
            break;
        case FieldType.dateEuroShort:
            map = 'D/M/YY';
            break;
        case FieldType.dateTimeEuro:
            map = 'DD/MM/YYYY HH:mm:ss';
            break;
        case FieldType.dateTimeShortEuro:
            map = 'DD/MM/YYYY HH:mm';
            break;
        case FieldType.dateTimeEuroAmPm:
            map = 'DD/MM/YYYY hh:mm:ss a';
            break;
        case FieldType.dateTimeEuroAM_PM:
            map = 'DD/MM/YYYY hh:mm:ss A';
            break;
        case FieldType.dateTimeEuroShort:
            map = 'D/M/YY H:m:s';
            break;
        case FieldType.dateTimeEuroShortAmPm:
            map = 'D/M/YY h:m:s a';
            break;
        // all US Formats (month/date/year)
        case FieldType.dateUs:
            map = 'MM/DD/YYYY';
            break;
        case FieldType.dateUsShort:
            map = 'M/D/YY';
            break;
        case FieldType.dateTimeUs:
            map = 'MM/DD/YYYY HH:mm:ss';
            break;
        case FieldType.dateTimeShortUs:
            map = 'MM/DD/YYYY HH:mm';
            break;
        case FieldType.dateTimeUsAmPm:
            map = 'MM/DD/YYYY hh:mm:ss a';
            break;
        case FieldType.dateTimeUsAM_PM:
            map = 'MM/DD/YYYY hh:mm:ss A';
            break;
        case FieldType.dateTimeUsShort:
            map = 'M/D/YY H:m:s';
            break;
        case FieldType.dateTimeUsShortAmPm:
            map = 'M/D/YY h:m:s a';
            break;
        case FieldType.dateUtc:
            map = 'YYYY-MM-DDTHH:mm:ss.SSSZ';
            break;
        case FieldType.date:
        case FieldType.dateIso:
        default:
            map = 'YYYY-MM-DD';
            break;
    }
    return map;
}
/**
 * From a Date FieldType, return it's equivalent Flatpickr format
 * refer to Flatpickr for the format standard used: https://chmln.github.io/flatpickr/formatting/#date-formatting-tokens
 * also note that they seem very similar to PHP format (except for am/pm): http://php.net/manual/en/function.date.php
 * @param fieldType
 */
export function mapFlatpickrDateFormatWithFieldType(fieldType) {
    /*
      d: Day of the month, 2 digits with leading zeros	01 to 31
      D: A textual representation of a day	Mon through Sun
      l: (lowercase 'L')	A full textual representation of the day of the week	Sunday through Saturday
      j: Day of the month without leading zeros	1 to 31
      J: Day of the month without leading zeros and ordinal suffix	1st, 2nd, to 31st
      w: Numeric representation of the day of the week	0 (for Sunday) through 6 (for Saturday)
      F: A full textual representation of a month	January through December
      m: Numeric representation of a month, with leading zero	01 through 12
      n: Numeric representation of a month, without leading zeros	1 through 12
      M: A short textual representation of a month	Jan through Dec
      U: The number of seconds since the Unix Epoch	1413704993
      y: A two digit representation of a year	99 or 03
      Y: A full numeric representation of a year, 4 digits	1999 or 2003
      H: Hours (24 hours)	00 to 23
      h: Hours	1 to 12
      i: Minutes	00 to 59
      S: Seconds, 2 digits	00 to 59
      s: Seconds	0, 1 to 59
      K: AM/PM	AM or PM
    */
    var map;
    switch (fieldType) {
        case FieldType.dateTime:
        case FieldType.dateTimeIso:
            map = 'Y-m-d H:i:S';
            break;
        case FieldType.dateTimeShortIso:
            map = 'Y-m-d H:i';
            break;
        case FieldType.dateTimeIsoAmPm:
        case FieldType.dateTimeIsoAM_PM:
            map = 'Y-m-d h:i:S K'; // there is no lowercase in Flatpickr :(
            break;
        // all Euro Formats (date/month/year)
        case FieldType.dateEuro:
            map = 'd/m/Y';
            break;
        case FieldType.dateEuroShort:
            map = 'd/m/y';
            break;
        case FieldType.dateTimeEuro:
            map = 'd/m/Y H:i:S';
            break;
        case FieldType.dateTimeShortEuro:
            map = 'd/m/y H:i';
            break;
        case FieldType.dateTimeEuroAmPm:
            map = 'd/m/Y h:i:S K'; // there is no lowercase in Flatpickr :(
            break;
        case FieldType.dateTimeEuroAM_PM:
            map = 'd/m/Y h:i:s K';
            break;
        case FieldType.dateTimeEuroShort:
            map = 'd/m/y H:i:s';
            break;
        case FieldType.dateTimeEuroShortAmPm:
            map = 'd/m/y h:i:s K'; // there is no lowercase in Flatpickr :(
            break;
        // all US Formats (month/date/year)
        case FieldType.dateUs:
            map = 'm/d/Y';
            break;
        case FieldType.dateUsShort:
            map = 'm/d/y';
            break;
        case FieldType.dateTimeUs:
            map = 'm/d/Y H:i:S';
            break;
        case FieldType.dateTimeShortUs:
            map = 'm/d/y H:i';
            break;
        case FieldType.dateTimeUsAmPm:
            map = 'm/d/Y h:i:S K'; // there is no lowercase in Flatpickr :(
            break;
        case FieldType.dateTimeUsAM_PM:
            map = 'm/d/Y h:i:s K';
            break;
        case FieldType.dateTimeUsShort:
            map = 'm/d/y H:i:s';
            break;
        case FieldType.dateTimeUsShortAmPm:
            map = 'm/d/y h:i:s K'; // there is no lowercase in Flatpickr :(
            break;
        case FieldType.dateUtc:
            map = 'Z';
            break;
        case FieldType.date:
        case FieldType.dateIso:
        default:
            map = 'Y-m-d';
            break;
    }
    return map;
}
/**
 * Mapper for query operators (ex.: <= is "le", > is "gt")
 * @param string operator
 * @returns string map
 */
export function mapOperatorType(operator) {
    var map;
    switch (operator) {
        case '<':
        case 'LT':
            map = OperatorType.lessThan;
            break;
        case '<=':
        case 'LE':
            map = OperatorType.lessThanOrEqual;
            break;
        case '>':
        case 'GT':
            map = OperatorType.greaterThan;
            break;
        case '>=':
        case 'GE':
            map = OperatorType.greaterThanOrEqual;
            break;
        case '<>':
        case '!=':
        case 'NE':
            map = OperatorType.notEqual;
            break;
        case '*':
        case 'a*':
        case 'StartsWith':
            map = OperatorType.startsWith;
            break;
        case '*z':
        case 'EndsWith':
            map = OperatorType.endsWith;
            break;
        case '=':
        case '==':
        case 'EQ':
            map = OperatorType.equal;
            break;
        case 'IN':
            map = OperatorType.in;
            break;
        case 'NIN':
        case 'NOT_IN':
            map = OperatorType.notIn;
            break;
        case 'Not_Contains':
        case 'NOT_CONTAINS':
            map = OperatorType.notContains;
            break;
        case 'Contains':
        case 'CONTAINS':
        default:
            map = OperatorType.contains;
            break;
    }
    return map;
}
/**
 * Find equivalent short designation of an Operator Type or Operator String.
 * When using a Compound Filter, we use the short designation and so we need the mapped value.
 * For example OperatorType.startsWith short designation is "a*", while OperatorType.greaterThanOrEqual is ">="
 */
export function mapOperatorToShorthandDesignation(operator) {
    var shortOperator = '';
    switch (operator) {
        case OperatorType.greaterThan:
        case '>':
            shortOperator = '>';
            break;
        case OperatorType.greaterThanOrEqual:
        case '>=':
            shortOperator = '>=';
            break;
        case OperatorType.lessThan:
        case '<':
            shortOperator = '<';
            break;
        case OperatorType.lessThanOrEqual:
        case '<=':
            shortOperator = '<=';
            break;
        case OperatorType.notEqual:
        case '<>':
            shortOperator = '<>';
            break;
        case OperatorType.equal:
        case '=':
        case '==':
        case 'EQ':
            shortOperator = '=';
            break;
        case OperatorType.startsWith:
        case 'a*':
        case '*':
            shortOperator = 'a*';
            break;
        case OperatorType.endsWith:
        case '*z':
            shortOperator = '*z';
            break;
        default:
            // any other operator will be considered as already a short expression, so we can return same input operator
            shortOperator = operator;
            break;
    }
    return shortOperator;
}
/**
 * Mapper for query operator by a Filter Type
 * For example a multiple-select typically uses 'IN' operator
 * @param operator
 * @returns string map
 */
export function mapOperatorByFieldType(fieldType) {
    var map;
    switch (fieldType) {
        case FieldType.unknown:
        case FieldType.string:
        case FieldType.text:
        case FieldType.password:
        case FieldType.readonly:
            map = OperatorType.contains;
            break;
        case FieldType.float:
        case FieldType.number:
        case FieldType.date:
        case FieldType.dateIso:
        case FieldType.dateUtc:
        case FieldType.dateTime:
        case FieldType.dateTimeIso:
        case FieldType.dateTimeIsoAmPm:
        case FieldType.dateTimeIsoAM_PM:
        case FieldType.dateEuro:
        case FieldType.dateEuroShort:
        case FieldType.dateTimeEuro:
        case FieldType.dateTimeEuroAmPm:
        case FieldType.dateTimeEuroAM_PM:
        case FieldType.dateTimeEuroShort:
        case FieldType.dateTimeEuroShortAmPm:
        case FieldType.dateTimeEuroShortAM_PM:
        case FieldType.dateUs:
        case FieldType.dateUsShort:
        case FieldType.dateTimeUs:
        case FieldType.dateTimeUsAmPm:
        case FieldType.dateTimeUsAM_PM:
        case FieldType.dateTimeUsShort:
        case FieldType.dateTimeUsShortAmPm:
        case FieldType.dateTimeUsShortAM_PM:
        default:
            map = OperatorType.equal;
            break;
    }
    return map;
}
/** Parse any input (bool, number, string) and return a boolean or False when not possible */
export function parseBoolean(input) {
    return /(true|1)/i.test(input + '');
}
/**
 * Parse a date passed as a string (Date only, without time) and return a Date object (if valid)
 * @param inputDateString
 * @returns string date formatted
 */
export function parseUtcDate(inputDateString, useUtc) {
    var date = null;
    if (/^[0-9\-\/]*$/.test(inputDateString)) {
        // get the UTC datetime with moment.js but we need to decode the value so that it's valid text
        var dateString = decodeURIComponent(inputDateString);
        var dateMoment = moment(new Date(dateString));
        if (dateMoment.isValid() && dateMoment.year().toString().length === 4) {
            date = (useUtc) ? dateMoment.utc().format() : dateMoment.format();
        }
    }
    return date;
}
/**
 * Sanitize, return only the text without HTML tags
 * @input htmlString
 * @return text
 */
export function sanitizeHtmlToText(htmlString) {
    var temp = document.createElement('div');
    temp.innerHTML = htmlString;
    return temp.textContent || temp.innerText || '';
}
/** Set the object value of deeper node from a given dot (.) notation path (e.g.: "user.firstName") */
export function setDeepValue(obj, path, value) {
    if (typeof path === 'string') {
        path = path.split('.');
    }
    if (path.length > 1) {
        var e = path.shift();
        if (obj && e !== undefined) {
            setDeepValue(obj[e] = Object.prototype.toString.call(obj[e]) === '[object Object]' ? obj[e] : {}, path, value);
        }
    }
    else if (obj && path[0]) {
        obj[path[0]] = value;
    }
}
/**
 * Format a number or a string into a string that is separated every thousand,
 * the default separator is a comma but user can optionally pass a different one
 * @param inputValue
 * @param separator default to comma ","
 * @returns string
 */
export function thousandSeparatorFormatted(inputValue, separator) {
    if (separator === void 0) { separator = ','; }
    if (inputValue !== null && inputValue !== undefined) {
        var stringValue = "" + inputValue;
        var decimalSplit = stringValue.split('.');
        if (decimalSplit.length === 2) {
            return decimalSplit[0].replace(/\B(?=(\d{3})+(?!\d))/g, separator) + "." + decimalSplit[1];
        }
        return stringValue.replace(/\B(?=(\d{3})+(?!\d))/g, separator);
    }
    return inputValue;
}
/**
 * Title case (or capitalize) first char of a string, for example "hello world" will become "Hello world"
 * Change the string to be title case on the complete sentence (upper case first char of each word while changing everything else to lower case)
 * @param inputStr
 * @returns string
 */
export function titleCase(inputStr, caseEveryWords) {
    if (caseEveryWords === void 0) { caseEveryWords = false; }
    if (typeof inputStr === 'string') {
        if (caseEveryWords) {
            return inputStr.replace(/\w\S*/g, function (outputStr) {
                return outputStr.charAt(0).toUpperCase() + outputStr.substr(1).toLowerCase();
            });
        }
        return inputStr.charAt(0).toUpperCase() + inputStr.slice(1);
    }
    return inputStr;
}
/**
 * Converts a string to camel case (camelCase), for example "hello-world" (or "hellow world") will become "helloWorld"
 * @param inputStr the string to convert
 * @return the string in camel case
 */
export function toCamelCase(inputStr) {
    if (typeof inputStr === 'string') {
        return inputStr.replace(/(?:^\w|[A-Z]|\b\w|[\s+\-_\/])/g, function (match, offset) {
            // remove white space or hypens or underscores
            if (/[\s+\-_\/]/.test(match)) {
                return '';
            }
            return offset === 0 ? match.toLowerCase() : match.toUpperCase();
        });
    }
    return inputStr;
}
/**
 * Converts a string to kebab (hypen) case, for example "helloWorld" will become "hello-world"
 * @param str the string to convert
 * @return the string in kebab case
 */
export function toKebabCase(inputStr) {
    if (typeof inputStr === 'string') {
        return toCamelCase(inputStr).replace(/([A-Z])/g, '-$1').toLowerCase();
    }
    return inputStr;
}
/**
 * Converts a string from camelCase to snake_case (underscore) case, for example "helloWorld" will become "hello_world"
 * @param str the string to convert
 * @return the string in kebab case
 */
export function toSnakeCase(inputStr) {
    if (typeof inputStr === 'string') {
        return toCamelCase(inputStr).replace(/([A-Z])/g, '_$1').toLowerCase();
    }
    return inputStr;
}
/**
 * Takes an input array and makes sure the array has unique values by removing duplicates
 * @param array input with possible duplicates
 * @param objectProperty optionally provide an object property to compare (example: 'id')
 * @return array output without duplicates
 */
export function uniqueArray(arr) {
    if (Array.isArray(arr) && arr.length > 0) {
        return arr.filter(function (item, index) {
            return arr.indexOf(item) >= index;
        });
    }
    return arr;
}
/**
 * Takes an input array of objects and makes sure the array has unique object values by removing duplicates
 * it will loop through the array using a property name (or "id" when is not provided) to compare uniqueness
 * @param array input with possible duplicates
 * @param propertyName defaults to "id"
 * @return array output without duplicates
 */
export function uniqueObjectArray(arr, propertyName) {
    var e_3, _a;
    if (propertyName === void 0) { propertyName = 'id'; }
    if (Array.isArray(arr) && arr.length > 0) {
        var result = [];
        var map = new Map();
        try {
            for (var arr_1 = tslib_1.__values(arr), arr_1_1 = arr_1.next(); !arr_1_1.done; arr_1_1 = arr_1.next()) {
                var item = arr_1_1.value;
                if (!map.has(item[propertyName])) {
                    map.set(item[propertyName], true); // set any value to Map
                    result.push({
                        id: item[propertyName],
                        name: item.name
                    });
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (arr_1_1 && !arr_1_1.done && (_a = arr_1.return)) _a.call(arr_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return result;
    }
    return arr;
}
/**
 * Unsubscribe all Observables Subscriptions
 * It will return an empty array if it all went well
 * @param subscriptions
 */
export function unsubscribeAllObservables(subscriptions) {
    if (Array.isArray(subscriptions)) {
        subscriptions.forEach(function (subscription) {
            if (subscription && subscription.unsubscribe) {
                subscription.unsubscribe();
            }
        });
        subscriptions = [];
    }
    return subscriptions;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbGl0aWVzLmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci1zbGlja2dyaWQvIiwic291cmNlcyI6WyJhcHAvbW9kdWxlcy9hbmd1bGFyLXNsaWNrZ3JpZC9zZXJ2aWNlcy91dGlsaXRpZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQWdCLE1BQU0sTUFBTSxDQUFDO0FBQ2hELE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUN2QyxPQUFPLEtBQUssT0FBTyxNQUFNLGFBQWEsQ0FBQztBQUN2QyxJQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsQ0FBQyxzSEFBc0g7QUFFOUksT0FBTyxFQUFFLFNBQVMsRUFBOEIsWUFBWSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFLdEY7Ozs7O0dBS0c7QUFDSCxNQUFNLFVBQVUsdUJBQXVCLENBQVUsVUFBZSxFQUFFLFNBQVksRUFBRSxjQUFxQjtJQUFyQiwrQkFBQSxFQUFBLHFCQUFxQjtJQUNuRyxJQUFJLGFBQWEsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUN2QixJQUFJLE9BQU8sU0FBUyxLQUFLLFFBQVEsSUFBSSxTQUFTLENBQUMsY0FBYyxDQUFDLGNBQWMsQ0FBQyxFQUFFO1FBQzdFLGFBQWEsR0FBRyxVQUFVLENBQUMsU0FBUyxDQUFDLFVBQUMsSUFBSSxJQUFLLE9BQUEsSUFBSSxDQUFDLGNBQWMsQ0FBQyxLQUFLLFNBQVMsQ0FBQyxjQUFjLENBQUMsRUFBbEQsQ0FBa0QsQ0FBQyxDQUFDO0tBQ3BHO1NBQU07UUFDTCxhQUFhLEdBQUcsVUFBVSxDQUFDLFNBQVMsQ0FBQyxVQUFDLElBQUksSUFBSyxPQUFBLElBQUksS0FBSyxTQUFTLEVBQWxCLENBQWtCLENBQUMsQ0FBQztLQUNwRTtJQUVELElBQUksYUFBYSxHQUFHLENBQUMsRUFBRTtRQUNyQixVQUFVLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0tBQzVCO0FBQ0gsQ0FBQztB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YSxDQUFDLE9BQU8sQ0FBQyxVQUFDLFlBQTBCO1lBQy9DLElBQUksWUFBWSxJQUFJLFlBQVksQ0FBQyxXQUFXLEVBQUU7Z0JBQzVDLFlBQVksQ0FBQyxXQUFXLEVBQUUsQ0FBQzthQUM1QjtRQUNILENBQUMsQ0FBQyxDQUFDO1FBQ0gsYUFBYSxHQUFHLEVBQUUsQ0FBQztLQUNwQjtJQUVELE9BQU8sYUFBYSxDQUFDO0FBQ3ZCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgZmlyc3QgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcbmltcG9ydCAqIGFzIG1vbWVudF8gZnJvbSAnbW9tZW50LW1pbmknO1xyXG5jb25zdCBtb21lbnQgPSBtb21lbnRfOyAvLyBwYXRjaCB0byBmaXggcm9sbHVwIFwibW9tZW50IGhhcyBubyBkZWZhdWx0IGV4cG9ydFwiIGlzc3VlLCBkb2N1bWVudCBoZXJlIGh0dHBzOi8vZ2l0aHViLmNvbS9yb2xsdXAvcm9sbHVwL2lzc3Vlcy82NzBcclxuXHJcbmltcG9ydCB7IEZpZWxkVHlwZSwgR3JpZE9wdGlvbiwgT3BlcmF0b3JTdHJpbmcsIE9wZXJhdG9yVHlwZSB9IGZyb20gJy4uL21vZGVscy9pbmRleCc7XHJcblxyXG4vLyB1c2luZyBleHRlcm5hbCBub24tdHlwZWQganMgbGlicmFyaWVzXHJcbmRlY2xhcmUgY29uc3QgJDogYW55O1xyXG5cclxuLyoqXHJcbiAqIEFkZCBhbiBpdGVtIHRvIGFuIGFycmF5IG9ubHkgd2hlbiB0aGUgaXRlbSBkb2VzIG5vdCBleGlzdHMsIHdoZW4gdGhlIGl0ZW0gaXMgYW4gb2JqZWN0IHdlIHdpbGwgYmUgdXNpbmcgdGhlaXIgXCJpZFwiIHRvIGNvbXBhcmVcclxuICogQHBhcmFtIGlucHV0QXJyYXlcclxuICogQHBhcmFtIGlucHV0SXRlbVxyXG4gKiBAcGFyYW0gaXRlbUlkUHJvcE5hbWVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhZGRUb0FycmF5V2hlbk5vdEV4aXN0czxUID0gYW55PihpbnB1dEFycmF5OiBUW10sIGlucHV0SXRlbTogVCwgaXRlbUlkUHJvcE5hbWUgPSAnaWQnKSB7XHJcbiAgbGV0IGFycmF5Um93SW5kZXggPSAtMTtcclxuICBpZiAodHlwZW9mIGlucHV0SXRlbSA9PT0gJ29iamVjdCcgJiYgaW5wdXRJdGVtLmhhc093blByb3BlcnR5KGl0ZW1JZFByb3BOYW1lKSkge1xyXG4gICAgYXJyYXlSb3dJbmRleCA9IGlucHV0QXJyYXkuZmluZEluZGV4KChpdGVtKSA9PiBpdGVtW2l0ZW1JZFByb3BOYW1lXSA9PT0gaW5wdXRJdGVtW2l0ZW1JZFByb3BOYW1lXSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGFycmF5Um93SW5kZXggPSBpbnB1dEFycmF5LmZpbmRJbmRleCgoaXRlbSkgPT4gaXRlbSA9PT0gaW5wdXRJdGVtKTtcclxuICB9XHJcblxyXG4gIGlmIChhcnJheVJvd0luZGV4IDwgMCkge1xyXG4gICAgaW5wdXRBcnJheS5wdXNoKGlucHV0SXRlbSk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogU2ltcGxlIGZ1bmN0aW9uIHRvIHdoaWNoIHdpbGwgbG9vcCBhbmQgY3JlYXRlIGFzIGRlbWFuZGVkIHRoZSBudW1iZXIgb2Ygd2hpdGUgc3BhY2VzLFxyXG4gKiB0aGlzIGlzIHVzZWQgaW4gdGhlIENTViBleHBvcnRcclxuICogQHBhcmFtIGludCBuYlNwYWNlczogbnVtYmVyIG9mIHdoaXRlIHNwYWNlcyB0byBjcmVhdGVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhZGRXaGl0ZVNwYWNlcyhuYlNwYWNlczogbnVtYmVyKTogc3RyaW5nIHtcclxuICBsZXQgcmVzdWx0ID0gJyc7XHJcblxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbmJTcGFjZXM7IGkrKykge1xyXG4gICAgcmVzdWx0ICs9ICcgJztcclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSBhIGNvbHVtbiBmcm9tIHRoZSBncmlkIGJ5IGl0J3MgaW5kZXggaW4gdGhlIGdyaWRcclxuICogQHBhcmFtIGFycmF5IGlucHV0XHJcbiAqIEBwYXJhbSBpbmRleFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5UmVtb3ZlSXRlbUJ5SW5kZXg8VD4oYXJyYXk6IFRbXSwgaW5kZXg6IG51bWJlcik6IFRbXSB7XHJcbiAgcmV0dXJuIGFycmF5LmZpbHRlcigoX2VsOiBULCBpOiBudW1iZXIpID0+IGluZGV4ICE9PSBpKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgYSBmbGF0IGFycmF5ICh3aXRoIFwicGFyZW50SWRcIiByZWZlcmVuY2VzKSBpbnRvIGEgaGllcmFyY2hpY2FsIGRhdGFzZXQgc3RydWN0dXJlICh3aGVyZSBjaGlsZHJlbiBhcmUgYXJyYXkocykgaW5zaWRlIHRoZWlyIHBhcmVudCBvYmplY3RzKVxyXG4gKiBAcGFyYW0gZmxhdEFycmF5IGlucHV0IGFycmF5IChmbGF0IGRhdGFzZXQpXHJcbiAqIEBwYXJhbSBvcHRpb25zIHlvdSBjYW4gcHJvdmlkZSB0aGUgZm9sbG93aW5nIG9wdGlvbnM6OiBcInBhcmVudFByb3BOYW1lXCIgKGRlZmF1bHRzIHRvIFwicGFyZW50XCIpLCBcImNoaWxkcmVuUHJvcE5hbWVcIiAoZGVmYXVsdHMgdG8gXCJjaGlsZHJlblwiKSBhbmQgXCJpZGVudGlmaWVyUHJvcE5hbWVcIiAoZGVmYXVsdHMgdG8gXCJpZFwiKVxyXG4gKiBAcmV0dXJuIHJvb3RzIC0gaGllcmFyY2hpY2FsIGRhdGEgdmlldyBhcnJheVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRQYXJlbnRDaGlsZEFycmF5VG9IaWVyYXJjaGljYWxWaWV3PFQgPSBhbnk+KGZsYXRBcnJheTogVFtdLCBvcHRpb25zPzogeyBwYXJlbnRQcm9wTmFtZT86IHN0cmluZzsgY2hpbGRyZW5Qcm9wTmFtZT86IHN0cmluZzsgaWRlbnRpZmllclByb3BOYW1lPzogc3RyaW5nOyB9KTogVFtdIHtcclxuICBjb25zdCBjaGlsZHJlblByb3BOYW1lID0gb3B0aW9ucyAmJiBvcHRpb25zLmNoaWxkcmVuUHJvcE5hbWUgfHwgJ2NoaWxkcmVuJztcclxuICBjb25zdCBwYXJlbnRQcm9wTmFtZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5wYXJlbnRQcm9wTmFtZSB8fCAnX19wYXJlbnRJZCc7XHJcbiAgY29uc3QgaWRlbnRpZmllclByb3BOYW1lID0gb3B0aW9ucyAmJiBvcHRpb25zLmlkZW50aWZpZXJQcm9wTmFtZSB8fCAnaWQnO1xyXG4gIGNvbnN0IGhhc0NoaWxkcmVuRmxhZ1Byb3BOYW1lID0gJ19faGFzQ2hpbGRyZW4nO1xyXG4gIGNvbnN0IHRyZWVMZXZlbFByb3BOYW1lID0gJ19fdHJlZUxldmVsJztcclxuICBjb25zdCBpbnB1dEFycmF5OiBUW10gPSAkLmV4dGVuZCh0cnVlLCBbXSwgZmxhdEFycmF5KTtcclxuXHJcbiAgY29uc3Qgcm9vdHM6IFRbXSA9IFtdOyAvLyB0aGluZ3Mgd2l0aG91dCBwYXJlbnRcclxuXHJcbiAgLy8gbWFrZSB0aGVtIGFjY2Vzc2libGUgYnkgZ3VpZCBvbiB0aGlzIG1hcFxyXG4gIGNvbnN0IGFsbCA9IHt9O1xyXG5cclxuICBpbnB1dEFycmF5LmZvckVhY2goKGl0ZW0pID0+IGFsbFtpdGVtW2lkZW50aWZpZXJQcm9wTmFtZV1dID0gaXRlbSk7XHJcblxyXG4gIC8vIGNvbm5lY3QgY2hpbGRyZW5zIHRvIGl0cyBwYXJlbnQsIGFuZCBzcGxpdCByb290cyBhcGFydFxyXG4gIE9iamVjdC5rZXlzKGFsbCkuZm9yRWFjaCgoaWQpID0+IHtcclxuICAgIGNvbnN0IGl0ZW0gPSBhbGxbaWRdO1xyXG4gICAgaWYgKGl0ZW1bcGFyZW50UHJvcE5hbWVdID09PSBudWxsIHx8ICFpdGVtLmhhc093blByb3BlcnR5KHBhcmVudFByb3BOYW1lKSkge1xyXG4gICAgICBkZWxldGUgaXRlbVtwYXJlbnRQcm9wTmFtZV07XHJcbiAgICAgIHJvb3RzLnB1c2goaXRlbSk7XHJcbiAgICB9IGVsc2UgaWYgKGl0ZW1bcGFyZW50UHJvcE5hbWVdIGluIGFsbCkge1xyXG4gICAgICBjb25zdCBwID0gYWxsW2l0ZW1bcGFyZW50UHJvcE5hbWVdXTtcclxuICAgICAgaWYgKCEoY2hpbGRyZW5Qcm9wTmFtZSBpbiBwKSkge1xyXG4gICAgICAgIHBbY2hpbGRyZW5Qcm9wTmFtZV0gPSBbXTtcclxuICAgICAgfVxyXG4gICAgICBkZWxldGUgaXRlbVtwYXJlbnRQcm9wTmFtZV07XHJcbiAgICAgIHBbY2hpbGRyZW5Qcm9wTmFtZV0ucHVzaChpdGVtKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBkZWxldGUgYW55IHVubmVjZXNzYXJ5IHByb3BlcnRpZXMgdGhhdCB3ZXJlIHBvc3NpYmx5IGNyZWF0ZWQgaW4gdGhlIGZsYXQgYXJyYXkgYnV0IHNob3VsZG4ndCBiZSBwYXJ0IG9mIHRoZSB0cmVlIGRhdGFcclxuICAgIGRlbGV0ZSBpdGVtW3RyZWVMZXZlbFByb3BOYW1lXTtcclxuICAgIGRlbGV0ZSBpdGVtW2hhc0NoaWxkcmVuRmxhZ1Byb3BOYW1lXTtcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIHJvb3RzO1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydCBhIGhpZXJhcmNoaWNhbCBhcnJheSAod2l0aCBjaGlsZHJlbikgaW50byBhIGZsYXQgYXJyYXkgc3RydWN0dXJlIGFycmF5ICh3aGVyZSB0aGUgY2hpbGRyZW4gYXJlIHB1c2hlZCBhcyBuZXh0IGluZGV4ZWQgaXRlbSBpbiB0aGUgYXJyYXkpXHJcbiAqIEBwYXJhbSBoaWVyYXJjaGljYWxBcnJheSAtIGlucHV0IGhpZXJhcmNoaWNhbCBhcnJheVxyXG4gKiBAcGFyYW0gb3B0aW9ucyAtIHlvdSBjYW4gcHJvdmlkZSBcImNoaWxkcmVuUHJvcE5hbWVcIiAoZGVmYXVsdHMgdG8gXCJjaGlsZHJlblwiKVxyXG4gKiBAcmV0dXJuIG91dHB1dCAtIFBhcmVudC9DaGlsZCBhcnJheVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRIaWVyYXJjaGljYWxWaWV3VG9QYXJlbnRDaGlsZEFycmF5PFQgPSBhbnk+KGhpZXJhcmNoaWNhbEFycmF5OiBUW10sIG9wdGlvbnM/OiB7IHBhcmVudFByb3BOYW1lPzogc3RyaW5nOyBjaGlsZHJlblByb3BOYW1lPzogc3RyaW5nOyBpZGVudGlmaWVyUHJvcE5hbWU/OiBzdHJpbmc7IH0pOiBUW10ge1xyXG4gIGNvbnN0IG91dHB1dEFycmF5OiBUW10gPSBbXTtcclxuICBjb252ZXJ0SGllcmFyY2hpY2FsVmlld1RvUGFyZW50Q2hpbGRBcnJheUJ5UmVmZXJlbmNlKCQuZXh0ZW5kKHRydWUsIFtdLCBoaWVyYXJjaGljYWxBcnJheSksIG91dHB1dEFycmF5LCBvcHRpb25zLCAwKTtcclxuXHJcbiAgLy8gdGhlIG91dHB1dCBhcnJheSBpcyB0aGUgb25lIHBhc3NlZCBhcyByZWZlcmVuY2VcclxuICByZXR1cm4gb3V0cHV0QXJyYXk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0IGEgaGllcmFyY2hpY2FsIGFycmF5ICh3aXRoIGNoaWxkcmVuKSBpbnRvIGEgZmxhdCBhcnJheSBzdHJ1Y3R1cmUgYXJyYXkgYnV0IHVzaW5nIHRoZSBhcnJheSBhcyB0aGUgb3V0cHV0ICh0aGUgYXJyYXkgaXMgdGhlIHBvaW50ZXIgcmVmZXJlbmNlKVxyXG4gKiBAcGFyYW0gaGllcmFyY2hpY2FsQXJyYXkgLSBpbnB1dCBoaWVyYXJjaGljYWwgYXJyYXlcclxuICogQHBhcmFtIG91dHB1dEFycmF5UmVmIC0gb3V0cHV0IGFycmF5IHBhc3NlZCAoYW5kIG1vZGlmaWVkKSBieSByZWZlcmVuY2VcclxuICogQHBhcmFtIG9wdGlvbnMgLSB5b3UgY2FuIHByb3ZpZGUgXCJjaGlsZHJlblByb3BOYW1lXCIgKGRlZmF1bHRzIHRvIFwiY2hpbGRyZW5cIilcclxuICogQHBhcmFtIHRyZWVMZXZlbCAtIHRyZWUgbGV2ZWwgbnVtYmVyXHJcbiAqIEBwYXJhbSBwYXJlbnRJZCAtIHBhcmVudCBJRFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRIaWVyYXJjaGljYWxWaWV3VG9QYXJlbnRDaGlsZEFycmF5QnlSZWZlcmVuY2U8VCA9IGFueT4oaGllcmFyY2hpY2FsQXJyYXk6IFRbXSwgb3V0cHV0QXJyYXlSZWY6IFRbXSwgb3B0aW9ucz86IHsgY2hpbGRyZW5Qcm9wTmFtZT86IHN0cmluZzsgcGFyZW50UHJvcE5hbWU/OiBzdHJpbmc7IGhhc0NoaWxkcmVuRmxhZ1Byb3BOYW1lPzogc3RyaW5nOyB0cmVlTGV2ZWxQcm9wTmFtZT86IHN0cmluZzsgaWRlbnRpZmllclByb3BOYW1lPzogc3RyaW5nOyB9LCB0cmVlTGV2ZWwgPSAwLCBwYXJlbnRJZD86IHN0cmluZykge1xyXG4gIGNvbnN0IGNoaWxkcmVuUHJvcE5hbWUgPSBvcHRpb25zICYmIG9wdGlvbnMuY2hpbGRyZW5Qcm9wTmFtZSB8fCAnY2hpbGRyZW4nO1xyXG4gIGNvbnN0IGlkZW50aWZpZXJQcm9wTmFtZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5pZGVudGlmaWVyUHJvcE5hbWUgfHwgJ2lkJztcclxuICBjb25zdCBoYXNDaGlsZHJlbkZsYWdQcm9wTmFtZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5oYXNDaGlsZHJlbkZsYWdQcm9wTmFtZSB8fCAnX19oYXNDaGlsZHJlbic7XHJcbiAgY29uc3QgdHJlZUxldmVsUHJvcE5hbWUgPSBvcHRpb25zICYmIG9wdGlvbnMudHJlZUxldmVsUHJvcE5hbWUgfHwgJ19fdHJlZUxldmVsJztcclxuICBjb25zdCBwYXJlbnRQcm9wTmFtZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5wYXJlbnRQcm9wTmFtZSB8fCAnX19wYXJlbnRJZCc7XHJcblxyXG4gIGlmIChBcnJheS5pc0FycmF5KGhpZXJhcmNoaWNhbEFycmF5KSkge1xyXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGhpZXJhcmNoaWNhbEFycmF5KSB7XHJcbiAgICAgIGlmIChpdGVtKSB7XHJcbiAgICAgICAgY29uc3QgaXRlbUV4aXN0ID0gb3V0cHV0QXJyYXlSZWYuZmluZCgoaXRtOiBUKSA9PiBpdG1baWRlbnRpZmllclByb3BOYW1lXSA9PT0gaXRlbVtpZGVudGlmaWVyUHJvcE5hbWVdKTtcclxuICAgICAgICBpZiAoIWl0ZW1FeGlzdCkge1xyXG4gICAgICAgICAgaXRlbVt0cmVlTGV2ZWxQcm9wTmFtZV0gPSB0cmVlTGV2ZWw7IC8vIHNhdmUgdHJlZSBsZXZlbCByZWZcclxuICAgICAgICAgIGl0ZW1bcGFyZW50UHJvcE5hbWVdID0gcGFyZW50SWQgfHwgbnVsbDtcclxuICAgICAgICAgIG91dHB1dEFycmF5UmVmLnB1c2goaXRlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW1bY2hpbGRyZW5Qcm9wTmFtZV0pKSB7XHJcbiAgICAgICAgICB0cmVlTGV2ZWwrKztcclxuICAgICAgICAgIGNvbnZlcnRIaWVyYXJjaGljYWxWaWV3VG9QYXJlbnRDaGlsZEFycmF5QnlSZWZlcmVuY2UoaXRlbVtjaGlsZHJlblByb3BOYW1lXSwgb3V0cHV0QXJyYXlSZWYsIG9wdGlvbnMsIHRyZWVMZXZlbCwgaXRlbVtpZGVudGlmaWVyUHJvcE5hbWVdKTtcclxuICAgICAgICAgIHRyZWVMZXZlbC0tO1xyXG4gICAgICAgICAgaXRlbVtoYXNDaGlsZHJlbkZsYWdQcm9wTmFtZV0gPSB0cnVlO1xyXG4gICAgICAgICAgZGVsZXRlIGl0ZW1bY2hpbGRyZW5Qcm9wTmFtZV07IC8vIHJlbW92ZSB0aGUgY2hpbGRyZW4gcHJvcGVydHlcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogQ3JlYXRlIGFuIGltbXV0YWJsZSBjbG9uZSBvZiBhbiBhcnJheSBvciBvYmplY3RcclxuICogKGMpIDIwMTkgQ2hyaXMgRmVyZGluYW5kaSwgTUlUIExpY2Vuc2UsIGh0dHBzOi8vZ29tYWtldGhpbmdzLmNvbVxyXG4gKiBAcGFyYW0gIHtBcnJheXxPYmplY3R9IG9iaiBUaGUgYXJyYXkgb3Igb2JqZWN0IHRvIGNvcHlcclxuICogQHJldHVybiB7QXJyYXl8T2JqZWN0fSAgICAgVGhlIGNsb25lIG9mIHRoZSBhcnJheSBvciBvYmplY3RcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWVwQ29weShvYmo6IGFueSkge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhbiBpbW11dGFibGUgY29weSBvZiBhbiBvYmplY3RcclxuICAgKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAgICovXHJcbiAgY29uc3QgY2xvbmVPYmogPSAoKSA9PiB7XHJcbiAgICAvLyBDcmVhdGUgbmV3IG9iamVjdFxyXG4gICAgY29uc3QgY2xvbmUgPSB7fTtcclxuXHJcbiAgICAvLyBMb29wIHRocm91Z2ggZWFjaCBpdGVtIGluIHRoZSBvcmlnaW5hbFxyXG4gICAgLy8gUmVjdXJzaXZlbHkgY29weSBpdCdzIHZhbHVlIGFuZCBhZGQgdG8gdGhlIGNsb25lXHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcclxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcclxuICAgICAgICBjbG9uZVtrZXldID0gZGVlcENvcHkob2JqW2tleV0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2xvbmU7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGFuIGltbXV0YWJsZSBjb3B5IG9mIGFuIGFycmF5XHJcbiAgICogQHJldHVybiB7QXJyYXl9XHJcbiAgICovXHJcbiAgY29uc3QgY2xvbmVBcnIgPSAoKSA9PiB7XHJcbiAgICByZXR1cm4gb2JqLm1hcCgoaXRlbTogYW55KSA9PiBkZWVwQ29weShpdGVtKSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gLS0gaW5pdCAtLS8vXHJcbiAgLy8gR2V0IG9iamVjdCB0eXBlXHJcbiAgY29uc3QgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopLnNsaWNlKDgsIC0xKS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuICAvLyBJZiBhbiBvYmplY3RcclxuICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcclxuICAgIHJldHVybiBjbG9uZU9iaigpO1xyXG4gIH1cclxuICAvLyBJZiBhbiBhcnJheVxyXG4gIGlmICh0eXBlID09PSAnYXJyYXknKSB7XHJcbiAgICByZXR1cm4gY2xvbmVBcnIoKTtcclxuICB9XHJcbiAgLy8gT3RoZXJ3aXNlLCByZXR1cm4gaXQgYXMtaXNcclxuICByZXR1cm4gb2JqO1xyXG59XHJcblxyXG4vKipcclxuICogRmluZCBhbiBpdGVtIGZyb20gYSBoaWVyYXJjaGljYWwgdmlldyBzdHJ1Y3R1cmUgKGEgcGFyZW50IHRoYXQgY2FuIGhhdmUgY2hpbGRyZW4gYXJyYXkgd2hpY2ggdGhlbXNlbGV2ZXMgY2FuIGNoaWxkcmVuIGFuZCBzbyBvbilcclxuICogQHBhcmFtIGhpZXJhcmNoaWNhbEFycmF5XHJcbiAqIEBwYXJhbSBwcmVkaWNhdGVcclxuICogQHBhcmFtIGNoaWxkcmVuUHJvcGVydHlOYW1lXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZmluZEl0ZW1JbkhpZXJhcmNoaWNhbFN0cnVjdHVyZTxUID0gYW55PihoaWVyYXJjaGljYWxBcnJheTogVFtdLCBwcmVkaWNhdGU6IChpdGVtOiBUKSA9PiBib29sZWFuLCBjaGlsZHJlblByb3BlcnR5TmFtZTogc3RyaW5nKTogVCB7XHJcbiAgaWYgKCFjaGlsZHJlblByb3BlcnR5TmFtZSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdmaW5kUmVjdXJzaXZlIHJlcXVpcmVzIHBhcmFtZXRlciBcImNoaWxkcmVuUHJvcGVydHlOYW1lXCInKTtcclxuICB9XHJcbiAgY29uc3QgaW5pdGlhbEZpbmQgPSBoaWVyYXJjaGljYWxBcnJheS5maW5kKHByZWRpY2F0ZSk7XHJcbiAgY29uc3QgZWxlbWVudHNXaXRoQ2hpbGRyZW4gPSBoaWVyYXJjaGljYWxBcnJheS5maWx0ZXIoKHg6IFQpID0+IHguaGFzT3duUHJvcGVydHkoY2hpbGRyZW5Qcm9wZXJ0eU5hbWUpICYmIHhbY2hpbGRyZW5Qcm9wZXJ0eU5hbWVdKTtcclxuICBpZiAoaW5pdGlhbEZpbmQpIHtcclxuICAgIHJldHVybiBpbml0aWFsRmluZDtcclxuICB9IGVsc2UgaWYgKGVsZW1lbnRzV2l0aENoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgY29uc3QgY2hpbGRFbGVtZW50czogVFtdID0gW107XHJcbiAgICBlbGVtZW50c1dpdGhDaGlsZHJlbi5mb3JFYWNoKChpdGVtOiBUKSA9PiB7XHJcbiAgICAgIGlmIChpdGVtLmhhc093blByb3BlcnR5KGNoaWxkcmVuUHJvcGVydHlOYW1lKSkge1xyXG4gICAgICAgIGNoaWxkRWxlbWVudHMucHVzaCguLi5pdGVtW2NoaWxkcmVuUHJvcGVydHlOYW1lXSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGZpbmRJdGVtSW5IaWVyYXJjaGljYWxTdHJ1Y3R1cmU8VD4oY2hpbGRFbGVtZW50cywgcHJlZGljYXRlLCBjaGlsZHJlblByb3BlcnR5TmFtZSk7XHJcbiAgfVxyXG4gIHJldHVybiB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBIVE1MIGRlY29kZSB1c2luZyBqUXVlcnkgd2l0aCBhIDxkaXY+XHJcbiAqIENyZWF0ZSBhIGluLW1lbW9yeSBkaXYsIHNldCBpdCdzIGlubmVyIHRleHQod2hpY2ggalF1ZXJ5IGF1dG9tYXRpY2FsbHkgZW5jb2RlcylcclxuICogdGhlbiBncmFiIHRoZSBlbmNvZGVkIGNvbnRlbnRzIGJhY2sgb3V0LiAgVGhlIGRpdiBuZXZlciBleGlzdHMgb24gdGhlIHBhZ2UuXHJcbiovXHJcbmV4cG9ydCBmdW5jdGlvbiBodG1sRGVjb2RlKGVuY29kZWRTdHI6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgY29uc3QgcGFyc2VyID0gRE9NUGFyc2VyICYmIG5ldyBET01QYXJzZXI7XHJcbiAgaWYgKHBhcnNlciAmJiBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKSB7XHJcbiAgICBjb25zdCBkb20gPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKFxyXG4gICAgICAnPCFkb2N0eXBlIGh0bWw+PGJvZHk+JyArIGVuY29kZWRTdHIsXHJcbiAgICAgICd0ZXh0L2h0bWwnKTtcclxuICAgIHJldHVybiBkb20gJiYgZG9tLmJvZHkgJiYgZG9tLmJvZHkudGV4dENvbnRlbnQ7XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIGZvciBzb21lIGJyb3dzZXJzIHRoYXQgbWlnaHQgbm90IHN1cHBvcnQgRE9NUGFyc2VyLCB1c2UgalF1ZXJ5IGluc3RlYWRcclxuICAgIHJldHVybiAkKCc8ZGl2Lz4nKS5odG1sKGVuY29kZWRTdHIpLnRleHQoKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBIVE1MIGVuY29kZSB1c2luZyBqUXVlcnkgd2l0aCBhIDxkaXY+XHJcbiAqIENyZWF0ZSBhIGluLW1lbW9yeSBkaXYsIHNldCBpdCdzIGlubmVyIHRleHQod2hpY2ggalF1ZXJ5IGF1dG9tYXRpY2FsbHkgZW5jb2RlcylcclxuICogdGhlbiBncmFiIHRoZSBlbmNvZGVkIGNvbnRlbnRzIGJhY2sgb3V0LiAgVGhlIGRpdiBuZXZlciBleGlzdHMgb24gdGhlIHBhZ2UuXHJcbiovXHJcbmV4cG9ydCBmdW5jdGlvbiBodG1sRW5jb2RlKGlucHV0VmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgY29uc3QgZW50aXR5TWFwID0ge1xyXG4gICAgJyYnOiAnJmFtcDsnLFxyXG4gICAgJzwnOiAnJmx0OycsXHJcbiAgICAnPic6ICcmZ3Q7JyxcclxuICAgICdcIic6ICcmcXVvdDsnLFxyXG4gICAgJ1xcJyc6ICcmIzM5OydcclxuICB9O1xyXG4gIC8vIGFsbCBzeW1ib2xzOjogIC9bJjw+XCInYD1cXC9dL2dcclxuICByZXR1cm4gKGlucHV0VmFsdWUgfHwgJycpLnRvU3RyaW5nKCkucmVwbGFjZSgvWyY8PlwiJ10vZywgKHMpID0+IGVudGl0eU1hcFtzXSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZWNvZGUgdGV4dCBpbnRvIGh0bWwgZW50aXR5XHJcbiAqIEBwYXJhbSBzdHJpbmcgdGV4dDogaW5wdXQgdGV4dFxyXG4gKiBAcGFyYW0gc3RyaW5nIHRleHQ6IG91dHB1dCB0ZXh0XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaHRtbEVudGl0eURlY29kZShpbnB1dDogc3RyaW5nKTogc3RyaW5nIHtcclxuICByZXR1cm4gaW5wdXQucmVwbGFjZSgvJiMoXFxkKyk7L2csIGZ1bmN0aW9uIChfbWF0Y2gsIGRlYykge1xyXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoZGVjKTtcclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIERlY29kZSB0ZXh0IGludG8gaHRtbCBlbnRpdHlcclxuICogQHBhcmFtIHN0cmluZyB0ZXh0OiBpbnB1dCB0ZXh0XHJcbiAqIEBwYXJhbSBzdHJpbmcgdGV4dDogb3V0cHV0IHRleHRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBodG1sRW50aXR5RW5jb2RlKGlucHV0OiBhbnkpOiBzdHJpbmcge1xyXG4gIGNvbnN0IGJ1ZiA9IFtdO1xyXG4gIGZvciAobGV0IGkgPSBpbnB1dC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgYnVmLnVuc2hpZnQoWycmIycsIGlucHV0W2ldLmNoYXJDb2RlQXQoKSwgJzsnXS5qb2luKCcnKSk7XHJcbiAgfVxyXG4gIHJldHVybiBidWYuam9pbignJyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb21wYXJlcyB0d28gYXJyYXlzIG9mIGNoYXJhY3RlcnMgdG8gZGV0ZXJtaW5lIGlmIGFsbCB0aGUgaXRlbXMgYXJlIGVxdWFsXHJcbiAqIEBwYXJhbSBhIGZpcnN0IGFycmF5XHJcbiAqIEBwYXJhbSBiIHNlY29uZCBhcnJheSB0byBjb21wYXJlIHdpdGggYVxyXG4gKiBAcGFyYW0gW29yZGVyTWF0dGVycz1mYWxzZV0gZmxhZyBpZiB0aGUgb3JkZXIgbWF0dGVycywgaWYgbm90IGFycmF5cyB3aWxsIGJlIHNvcnRlZCBiZWZvcmUgY29tcGFyaXNvblxyXG4gKiBAcmV0dXJuIGJvb2xlYW4gdHJ1ZSBpZiBlcXVhbCwgZWxzZSBmYWxzZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNoYXJBcnJheXNFcXVhbDxUID0gYW55PihhOiBUW10sIGI6IFRbXSwgb3JkZXJNYXR0ZXJzOiBib29sZWFuID0gZmFsc2UpOiBib29sZWFuIHtcclxuICBpZiAoIWEgfHwgIWIgfHwgIUFycmF5LmlzQXJyYXkoYSkgfHwgIUFycmF5LmlzQXJyYXkoYSkpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGlmICghb3JkZXJNYXR0ZXJzICYmIGEuc29ydCAmJiBiLnNvcnQpIHtcclxuICAgIGEuc29ydCgpO1xyXG4gICAgYi5zb3J0KCk7XHJcbiAgfVxyXG5cclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHtcclxuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB0cnVlO1xyXG59XHJcblxyXG4vKipcclxuICogVHJ5IGNhc3RpbmcgYW4gaW5wdXQgb2YgdHlwZSBQcm9taXNlIHwgT2JzZXJ2YWJsZSBpbnRvIGEgUHJvbWlzZSB0eXBlLlxyXG4gKiBAcGFyYW0gb2JqZWN0IHdoaWNoIGNvdWxkIGJlIG9mIHR5cGUgUHJvbWlzZSBvciBPYnNlcnZhYmxlXHJcbiAqIEBwYXJhbSBmcm9tU2VydmljZU5hbWUgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY2FsbGVyIHNlcnZpY2UgbmFtZSBhbmQgd2lsbCBiZSB1c2VkIGlmIHdlIHRocm93IGEgY2FzdGluZyBwcm9ibGVtIGVycm9yXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2FzdFRvUHJvbWlzZTxUPihpbnB1dDogUHJvbWlzZTxUPiB8IE9ic2VydmFibGU8VD4sIGZyb21TZXJ2aWNlTmFtZTogc3RyaW5nID0gJycpOiBQcm9taXNlPFQ+IHtcclxuICBsZXQgcHJvbWlzZTogYW55ID0gaW5wdXQ7XHJcblxyXG4gIGlmIChpbnB1dCBpbnN0YW5jZW9mIFByb21pc2UpIHtcclxuICAgIC8vIGlmIGl0J3MgYWxyZWFkeSBhIFByb21pc2UgdGhlbiByZXR1cm4gaXRcclxuICAgIHJldHVybiBpbnB1dDtcclxuICB9IGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgT2JzZXJ2YWJsZSkge1xyXG4gICAgcHJvbWlzZSA9IGlucHV0LnBpcGUoZmlyc3QoKSkudG9Qcm9taXNlKCk7XHJcbiAgfVxyXG5cclxuICBpZiAoIShwcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgYFNvbWV0aGluZyB3ZW50IHdyb25nLCBBbmd1bGFyLVNsaWNrZ3JpZCAke2Zyb21TZXJ2aWNlTmFtZX0gaXMgbm90IGFibGUgdG8gY29udmVydCB0aGUgT2JzZXJ2YWJsZSBpbnRvIGEgUHJvbWlzZS5cclxuICAgICAgSWYgeW91IGFyZSB1c2luZyBBbmd1bGFyIEh0dHBDbGllbnQsIHlvdSBjb3VsZCB0cnkgY29udmVydGluZyB5b3VyIGh0dHAgY2FsbCB0byBhIFByb21pc2Ugd2l0aCBcIi50b1Byb21pc2UoKVwiXHJcbiAgICAgIGZvciBleGFtcGxlOjogIHRoaXMuaHR0cC5wb3N0KCdncmFwaHFsJywgeyBxdWVyeTogZ3JhcGhxbFF1ZXJ5IH0pLnRvUHJvbWlzZSgpXHJcbiAgICAgIGApO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHByb21pc2U7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBVc2VzIHRoZSBsb2dpYyBmdW5jdGlvbiB0byBmaW5kIGFuIGl0ZW0gaW4gYW4gYXJyYXkgb3IgcmV0dXJucyB0aGUgZGVmYXVsdFxyXG4gKiB2YWx1ZSBwcm92aWRlZCAoZW1wdHkgb2JqZWN0IGJ5IGRlZmF1bHQpXHJcbiAqIEBwYXJhbSBhbnlbXSBhcnJheSB0aGUgYXJyYXkgdG8gZmlsdGVyXHJcbiAqIEBwYXJhbSBmdW5jdGlvbiBsb2dpYyB0aGUgbG9naWMgdG8gZmluZCB0aGUgaXRlbVxyXG4gKiBAcGFyYW0gYW55IFtkZWZhdWx0VmFsPXt9XSB0aGUgZGVmYXVsdCB2YWx1ZSB0byByZXR1cm5cclxuICogQHJldHVybiBvYmplY3QgdGhlIGZvdW5kIG9iamVjdCBvciBkZWZhdWx0IHZhbHVlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZmluZE9yRGVmYXVsdDxUID0gYW55PihhcnJheTogYW55W10sIGxvZ2ljOiAoaXRlbTogYW55KSA9PiBib29sZWFuLCBkZWZhdWx0VmFsID0ge30pOiBhbnkge1xyXG4gIHJldHVybiBhcnJheS5maW5kKGxvZ2ljKSB8fCBkZWZhdWx0VmFsO1xyXG59XHJcblxyXG4vKipcclxuICogRW5jb2RlIHN0cmluZyB0byBodG1sIHNwZWNpYWwgY2hhciBhbmQgYWRkIGh0bWwgc3BhY2UgcGFkZGluZyBkZWZpbmVkXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFN0ciAtIGlucHV0IHN0cmluZ1xyXG4gKiBAcGFyYW0ge251bWJlcn0gcGFkZGluZ0xlbmd0aCAtIHBhZGRpbmcgdG8gYWRkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaHRtbEVuY29kZWRTdHJpbmdXaXRoUGFkZGluZyhpbnB1dFN0cjogc3RyaW5nLCBwYWRkaW5nTGVuZ3RoOiBudW1iZXIpOiBzdHJpbmcge1xyXG4gIGNvbnN0IGlucHV0U3RyTG4gPSBpbnB1dFN0ci5sZW5ndGg7XHJcbiAgbGV0IG91dHB1dFN0ciA9IGh0bWxFbmNvZGUoaW5wdXRTdHIpO1xyXG5cclxuICBpZiAoaW5wdXRTdHJMbiA8IHBhZGRpbmdMZW5ndGgpIHtcclxuICAgIGZvciAobGV0IGkgPSBpbnB1dFN0ckxuOyBpIDwgcGFkZGluZ0xlbmd0aDsgaSsrKSB7XHJcbiAgICAgIG91dHB1dFN0ciArPSBgJm5ic3A7YDtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIG91dHB1dFN0cjtcclxufVxyXG5cclxuLyoqXHJcbiAgKiBUYWtlIGEgbnVtYmVyIChvciBhIHN0cmluZykgYW5kIGRpc3BsYXkgaXQgYXMgYSBmb3JtYXR0ZWQgZGVjaW1hbCBzdHJpbmcgd2l0aCBkZWZpbmVkIG1pbmltdW0gYW5kIG1heGltdW0gZGVjaW1hbHNcclxuICAqIEBwYXJhbSBpbnB1dFxyXG4gICogQHBhcmFtIG1pbkRlY2ltYWxcclxuICAqIEBwYXJhbSBtYXhEZWNpbWFsXHJcbiAgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRlY2ltYWxGb3JtYXR0ZWQoaW5wdXQ6IG51bWJlciB8IHN0cmluZywgbWluRGVjaW1hbD86IG51bWJlciwgbWF4RGVjaW1hbD86IG51bWJlciwgZGVjaW1hbFNlcGFyYXRvcjogJy4nIHwgJywnID0gJy4nLCB0aG91c2FuZFNlcGFyYXRvcjogJywnIHwgJ18nIHwgJy4nIHwgJyAnIHwgJycgPSAnJyk6IHN0cmluZyB7XHJcbiAgaWYgKGlzTmFOKCtpbnB1dCkpIHtcclxuICAgIHJldHVybiBpbnB1dCBhcyBzdHJpbmc7XHJcbiAgfVxyXG5cclxuICBjb25zdCBtaW5EZWMgPSAobWluRGVjaW1hbCA9PT0gdW5kZWZpbmVkKSA/IDIgOiBtaW5EZWNpbWFsO1xyXG4gIGNvbnN0IG1heERlYyA9IChtYXhEZWNpbWFsID09PSB1bmRlZmluZWQpID8gMiA6IG1heERlY2ltYWw7XHJcbiAgbGV0IGFtb3VudCA9IFN0cmluZyhNYXRoLnJvdW5kKCtpbnB1dCAqIE1hdGgucG93KDEwLCBtYXhEZWMpKSAvIE1hdGgucG93KDEwLCBtYXhEZWMpKTtcclxuXHJcbiAgaWYgKChhbW91bnQuaW5kZXhPZignLicpIDwgMCkgJiYgKG1pbkRlYyA+IDApKSB7XHJcbiAgICBhbW91bnQgKz0gJy4nO1xyXG4gIH1cclxuICB3aGlsZSAoKGFtb3VudC5sZW5ndGggLSBhbW91bnQuaW5kZXhPZignLicpKSA8PSBtaW5EZWMpIHtcclxuICAgIGFtb3VudCArPSAnMCc7XHJcbiAgfVxyXG5cclxuICBjb25zdCBkZWNpbWFsU3BsaXQgPSBhbW91bnQuc3BsaXQoJy4nKTtcclxuICBsZXQgaW50ZWdlck51bWJlcjtcclxuICBsZXQgZGVjaW1hbE51bWJlcjtcclxuXHJcbiAgLy8gZG8gd2Ugd2FudCB0byBkaXNwbGF5IG91ciBudW1iZXIgd2l0aCBhIGN1c3RvbSBzZXBhcmF0b3IgaW4gZWFjaCB0aG91c2FuZCBwb3NpdGlvblxyXG4gIGlmICh0aG91c2FuZFNlcGFyYXRvcikge1xyXG4gICAgaW50ZWdlck51bWJlciA9IGRlY2ltYWxTcGxpdC5sZW5ndGggPj0gMSA/IHRob3VzYW5kU2VwYXJhdG9yRm9ybWF0dGVkKGRlY2ltYWxTcGxpdFswXSwgdGhvdXNhbmRTZXBhcmF0b3IpIDogdW5kZWZpbmVkO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBpbnRlZ2VyTnVtYmVyID0gZGVjaW1hbFNwbGl0Lmxlbmd0aCA+PSAxID8gZGVjaW1hbFNwbGl0WzBdIDogYW1vdW50O1xyXG4gIH1cclxuXHJcbiAgLy8gd2hlbiB1c2luZyBhIHNlcGFyYXRvciB0aGF0IGlzIG5vdCBhIGRvdCwgcmVwbGFjZSBpdCB3aXRoIHRoZSBuZXcgc2VwYXJhdG9yXHJcbiAgaWYgKGRlY2ltYWxTcGxpdC5sZW5ndGggPiAxKSB7XHJcbiAgICBkZWNpbWFsTnVtYmVyID0gZGVjaW1hbFNwbGl0WzFdO1xyXG4gIH1cclxuXHJcbiAgbGV0IG91dHB1dCA9ICcnO1xyXG4gIGlmIChpbnRlZ2VyTnVtYmVyICE9PSB1bmRlZmluZWQgJiYgZGVjaW1hbE51bWJlciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICBvdXRwdXQgPSBgJHtpbnRlZ2VyTnVtYmVyfSR7ZGVjaW1hbFNlcGFyYXRvcn0ke2RlY2ltYWxOdW1iZXJ9YDtcclxuICB9IGVsc2UgaWYgKGludGVnZXJOdW1iZXIgIT09IHVuZGVmaW5lZCAmJiBpbnRlZ2VyTnVtYmVyICE9PSBudWxsKSB7XHJcbiAgICBvdXRwdXQgPSBpbnRlZ2VyTnVtYmVyO1xyXG4gIH1cclxuICByZXR1cm4gb3V0cHV0O1xyXG59XHJcblxyXG4vKipcclxuICogTG9vcCB0aHJvdWdoIGFsbCBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdCBhbmQgbnVsbGlmeSBhbnkgcHJvcGVydGllcyB0aGF0IGFyZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50LFxyXG4gKiBpZiB3ZSBkZXRlY3QgYW4gYXJyYXkgdGhlbiB1c2UgcmVjdXJzaW9uIHRvIGdvIGluc2lkZSBpdCBhbmQgYXBwbHkgc2FtZSBsb2dpY1xyXG4gKiBAcGFyYW0gb2JqIC0gb2JqZWN0IGNvbnRhaW5pbmcgMSBvciBtb3JlIHByb3BlcnRpZXMgd2l0aCBET00gRWxlbWVudHNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkZXN0cm95T2JqZWN0RG9tRWxlbWVudFByb3BzKG9iajogYW55KSB7XHJcbiAgaWYgKG9iaikge1xyXG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob2JqKSkge1xyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpba2V5XSkpIHtcclxuICAgICAgICBkZXN0cm95T2JqZWN0RG9tRWxlbWVudFByb3BzKG9ialtrZXldKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAob2JqW2tleV0gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xyXG4gICAgICAgIG9ialtrZXldID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEZvcm1hdCBhIG51bWJlciBmb2xsb3dpbmcgb3B0aW9ucyBwYXNzZWQgYXMgYXJndW1lbnRzIChkZWNpbWFscywgc2VwYXJhdG9yLCAuLi4pXHJcbiAqIEBwYXJhbSBpbnB1dFxyXG4gKiBAcGFyYW0gbWluRGVjaW1hbFxyXG4gKiBAcGFyYW0gbWF4RGVjaW1hbFxyXG4gKiBAcGFyYW0gZGlzcGxheU5lZ2F0aXZlTnVtYmVyV2l0aFBhcmVudGhlc2VzXHJcbiAqIEBwYXJhbSBzeW1ib2xQcmVmaXhcclxuICogQHBhcmFtIHN5bWJvbFN1ZmZpeFxyXG4gKiBAcGFyYW0gZGVjaW1hbFNlcGFyYXRvclxyXG4gKiBAcGFyYW0gdGhvdXNhbmRTZXBhcmF0b3JcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXROdW1iZXIoaW5wdXQ6IG51bWJlciB8IHN0cmluZywgbWluRGVjaW1hbD86IG51bWJlciwgbWF4RGVjaW1hbD86IG51bWJlciwgZGlzcGxheU5lZ2F0aXZlTnVtYmVyV2l0aFBhcmVudGhlc2VzPzogYm9vbGVhbiwgc3ltYm9sUHJlZml4ID0gJycsIHN5bWJvbFN1ZmZpeCA9ICcnLCBkZWNpbWFsU2VwYXJhdG9yOiAnLicgfCAnLCcgPSAnLicsIHRob3VzYW5kU2VwYXJhdG9yOiAnLCcgfCAnXycgfCAnLicgfCAnICcgfCAnJyA9ICcnKTogc3RyaW5nIHtcclxuICBpZiAoaXNOYU4oK2lucHV0KSkge1xyXG4gICAgcmV0dXJuIGlucHV0IGFzIHN0cmluZztcclxuICB9XHJcblxyXG4gIGNvbnN0IGNhbGN1bGF0ZWRWYWx1ZSA9ICgoTWF0aC5yb3VuZChwYXJzZUZsb2F0KGlucHV0IGFzIHN0cmluZykgKiAxMDAwMDAwKSAvIDEwMDAwMDApKTtcclxuXHJcbiAgaWYgKGNhbGN1bGF0ZWRWYWx1ZSA8IDApIHtcclxuICAgIGNvbnN0IGFic1ZhbHVlID0gTWF0aC5hYnMoY2FsY3VsYXRlZFZhbHVlKTtcclxuICAgIGlmIChkaXNwbGF5TmVnYXRpdmVOdW1iZXJXaXRoUGFyZW50aGVzZXMpIHtcclxuICAgICAgaWYgKCFpc05hTihtaW5EZWNpbWFsKSB8fCAhaXNOYU4obWF4RGVjaW1hbCkpIHtcclxuICAgICAgICByZXR1cm4gYCgke3N5bWJvbFByZWZpeH0ke2RlY2ltYWxGb3JtYXR0ZWQoYWJzVmFsdWUsIG1pbkRlY2ltYWwsIG1heERlY2ltYWwsIGRlY2ltYWxTZXBhcmF0b3IsIHRob3VzYW5kU2VwYXJhdG9yKX0ke3N5bWJvbFN1ZmZpeH0pYDtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBmb3JtYXR0ZWRWYWx1ZSA9IHRob3VzYW5kU2VwYXJhdG9yRm9ybWF0dGVkKGAke2Fic1ZhbHVlfWAsIHRob3VzYW5kU2VwYXJhdG9yKTtcclxuICAgICAgcmV0dXJuIGAoJHtzeW1ib2xQcmVmaXh9JHtmb3JtYXR0ZWRWYWx1ZX0ke3N5bWJvbFN1ZmZpeH0pYDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmICghaXNOYU4obWluRGVjaW1hbCkgfHwgIWlzTmFOKG1heERlY2ltYWwpKSB7XHJcbiAgICAgICAgcmV0dXJuIGAtJHtzeW1ib2xQcmVmaXh9JHtkZWNpbWFsRm9ybWF0dGVkKGFic1ZhbHVlLCBtaW5EZWNpbWFsLCBtYXhEZWNpbWFsLCBkZWNpbWFsU2VwYXJhdG9yLCB0aG91c2FuZFNlcGFyYXRvcil9JHtzeW1ib2xTdWZmaXh9YDtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBmb3JtYXR0ZWRWYWx1ZSA9IHRob3VzYW5kU2VwYXJhdG9yRm9ybWF0dGVkKGAke2Fic1ZhbHVlfWAsIHRob3VzYW5kU2VwYXJhdG9yKTtcclxuICAgICAgcmV0dXJuIGAtJHtzeW1ib2xQcmVmaXh9JHtmb3JtYXR0ZWRWYWx1ZX0ke3N5bWJvbFN1ZmZpeH1gO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAoIWlzTmFOKG1pbkRlY2ltYWwpIHx8ICFpc05hTihtYXhEZWNpbWFsKSkge1xyXG4gICAgICByZXR1cm4gYCR7c3ltYm9sUHJlZml4fSR7ZGVjaW1hbEZvcm1hdHRlZChpbnB1dCwgbWluRGVjaW1hbCwgbWF4RGVjaW1hbCwgZGVjaW1hbFNlcGFyYXRvciwgdGhvdXNhbmRTZXBhcmF0b3IpfSR7c3ltYm9sU3VmZml4fWA7XHJcbiAgICB9XHJcbiAgICBjb25zdCBmb3JtYXR0ZWRWYWx1ZSA9IHRob3VzYW5kU2VwYXJhdG9yRm9ybWF0dGVkKGAke2lucHV0fWAsIHRob3VzYW5kU2VwYXJhdG9yKTtcclxuICAgIHJldHVybiBgJHtzeW1ib2xQcmVmaXh9JHtmb3JtYXR0ZWRWYWx1ZX0ke3N5bWJvbFN1ZmZpeH1gO1xyXG4gIH1cclxufVxyXG5cclxuLyoqIEZyb20gYSBkb3QgKC4pIG5vdGF0aW9uIHBhdGgsIGZpbmQgYW5kIHJldHVybiBhIHByb3BlcnR5IHdpdGhpbiBhbiBvYmplY3QgZ2l2ZW4gYSBwYXRoICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXREZXNjZW5kYW50UHJvcGVydHk8VCA9IGFueT4ob2JqOiBULCBwYXRoOiBzdHJpbmcpOiBhbnkge1xyXG4gIHJldHVybiBwYXRoLnNwbGl0KCcuJykucmVkdWNlKChhY2MsIHBhcnQpID0+IGFjYyAmJiBhY2NbcGFydF0sIG9iaik7XHJcbn1cclxuXHJcbi8qKiBHZXQgSFRNTCBFbGVtZW50IHBvc2l0aW9uIG9mZnNldCAod2l0aG91dCBqUXVlcnkpICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRIdG1sRWxlbWVudE9mZnNldChlbGVtZW50OiBIVE1MRWxlbWVudCk6IHsgdG9wOiBudW1iZXI7IGxlZnQ6IG51bWJlcjsgfSB7XHJcbiAgY29uc3QgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgbGV0IHRvcCA9IDA7XHJcbiAgbGV0IGxlZnQgPSAwO1xyXG5cclxuICBpZiAocmVjdCAmJiByZWN0LnRvcCAhPT0gdW5kZWZpbmVkICYmIHJlY3QubGVmdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICB0b3AgPSByZWN0LnRvcCArIHdpbmRvdy5wYWdlWU9mZnNldDtcclxuICAgIGxlZnQgPSByZWN0LmxlZnQgKyB3aW5kb3cucGFnZVhPZmZzZXQ7XHJcbiAgfVxyXG4gIHJldHVybiB7IHRvcCwgbGVmdCB9O1xyXG59XHJcblxyXG4vKiogR2V0IFRyYW5zbGF0aW9uIFByZWZpeCwgZGVmYXVsdHMgdG8gYW4gZW1wdHkgc3RyaW5nICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRUcmFuc2xhdGlvblByZWZpeChncmlkT3B0aW9ucz86IEdyaWRPcHRpb24pOiBzdHJpbmcge1xyXG4gIGlmIChncmlkT3B0aW9ucyAmJiBncmlkT3B0aW9ucy50cmFuc2xhdGlvbk5hbWVzcGFjZSkge1xyXG4gICAgcmV0dXJuIGdyaWRPcHRpb25zLnRyYW5zbGF0aW9uTmFtZXNwYWNlICsgKGdyaWRPcHRpb25zLnRyYW5zbGF0aW9uTmFtZXNwYWNlU2VwYXJhdG9yIHx8ICcnKTtcclxuICB9XHJcbiAgcmV0dXJuICcnO1xyXG59XHJcblxyXG4vKipcclxuICogRnJvbSBhIERhdGUgRmllbGRUeXBlLCByZXR1cm4gaXQncyBlcXVpdmFsZW50IG1vbWVudC5qcyBmb3JtYXRcclxuICogcmVmZXIgdG8gbW9tZW50LmpzIGZvciB0aGUgZm9ybWF0IHN0YW5kYXJkIHVzZWQ6IGh0dHBzOi8vbW9tZW50anMuY29tL2RvY3MvIy9wYXJzaW5nL3N0cmluZy1mb3JtYXQvXHJcbiAqIEBwYXJhbSBmaWVsZFR5cGVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBtYXBNb21lbnREYXRlRm9ybWF0V2l0aEZpZWxkVHlwZShmaWVsZFR5cGU6IEZpZWxkVHlwZSk6IHN0cmluZyB7XHJcbiAgbGV0IG1hcDogc3RyaW5nO1xyXG4gIHN3aXRjaCAoZmllbGRUeXBlKSB7XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZTpcclxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lSXNvOlxyXG4gICAgICBtYXAgPSAnWVlZWS1NTS1ERCBISDptbTpzcyc7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVTaG9ydElzbzpcclxuICAgICAgbWFwID0gJ1lZWVktTU0tREQgSEg6bW0nO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lSXNvQW1QbTpcclxuICAgICAgbWFwID0gJ1lZWVktTU0tREQgaGg6bW06c3MgYSc7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVJc29BTV9QTTpcclxuICAgICAgbWFwID0gJ1lZWVktTU0tREQgaGg6bW06c3MgQSc7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgLy8gYWxsIEV1cm8gRm9ybWF0cyAoZGF0ZS9tb250aC95ZWFyKVxyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZUV1cm86XHJcbiAgICAgIG1hcCA9ICdERC9NTS9ZWVlZJztcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlRXVyb1Nob3J0OlxyXG4gICAgICBtYXAgPSAnRC9NL1lZJztcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZUV1cm86XHJcbiAgICAgIG1hcCA9ICdERC9NTS9ZWVlZIEhIOm1tOnNzJztcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZVNob3J0RXVybzpcclxuICAgICAgbWFwID0gJ0REL01NL1lZWVkgSEg6bW0nO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lRXVyb0FtUG06XHJcbiAgICAgIG1hcCA9ICdERC9NTS9ZWVlZIGhoOm1tOnNzIGEnO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lRXVyb0FNX1BNOlxyXG4gICAgICBtYXAgPSAnREQvTU0vWVlZWSBoaDptbTpzcyBBJztcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZUV1cm9TaG9ydDpcclxuICAgICAgbWFwID0gJ0QvTS9ZWSBIOm06cyc7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVFdXJvU2hvcnRBbVBtOlxyXG4gICAgICBtYXAgPSAnRC9NL1lZIGg6bTpzIGEnO1xyXG4gICAgICBicmVhaztcclxuICAgIC8vIGFsbCBVUyBGb3JtYXRzIChtb250aC9kYXRlL3llYXIpXHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVXM6XHJcbiAgICAgIG1hcCA9ICdNTS9ERC9ZWVlZJztcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVXNTaG9ydDpcclxuICAgICAgbWFwID0gJ00vRC9ZWSc7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVVczpcclxuICAgICAgbWFwID0gJ01NL0REL1lZWVkgSEg6bW06c3MnO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lU2hvcnRVczpcclxuICAgICAgbWFwID0gJ01NL0REL1lZWVkgSEg6bW0nO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lVXNBbVBtOlxyXG4gICAgICBtYXAgPSAnTU0vREQvWVlZWSBoaDptbTpzcyBhJztcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZVVzQU1fUE06XHJcbiAgICAgIG1hcCA9ICdNTS9ERC9ZWVlZIGhoOm1tOnNzIEEnO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lVXNTaG9ydDpcclxuICAgICAgbWFwID0gJ00vRC9ZWSBIOm06cyc7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVVc1Nob3J0QW1QbTpcclxuICAgICAgbWFwID0gJ00vRC9ZWSBoOm06cyBhJztcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVXRjOlxyXG4gICAgICBtYXAgPSAnWVlZWS1NTS1ERFRISDptbTpzcy5TU1NaJztcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlOlxyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZUlzbzpcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIG1hcCA9ICdZWVlZLU1NLUREJztcclxuICAgICAgYnJlYWs7XHJcbiAgfVxyXG4gIHJldHVybiBtYXA7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGcm9tIGEgRGF0ZSBGaWVsZFR5cGUsIHJldHVybiBpdCdzIGVxdWl2YWxlbnQgRmxhdHBpY2tyIGZvcm1hdFxyXG4gKiByZWZlciB0byBGbGF0cGlja3IgZm9yIHRoZSBmb3JtYXQgc3RhbmRhcmQgdXNlZDogaHR0cHM6Ly9jaG1sbi5naXRodWIuaW8vZmxhdHBpY2tyL2Zvcm1hdHRpbmcvI2RhdGUtZm9ybWF0dGluZy10b2tlbnNcclxuICogYWxzbyBub3RlIHRoYXQgdGhleSBzZWVtIHZlcnkgc2ltaWxhciB0byBQSFAgZm9ybWF0IChleGNlcHQgZm9yIGFtL3BtKTogaHR0cDovL3BocC5uZXQvbWFudWFsL2VuL2Z1bmN0aW9uLmRhdGUucGhwXHJcbiAqIEBwYXJhbSBmaWVsZFR5cGVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBtYXBGbGF0cGlja3JEYXRlRm9ybWF0V2l0aEZpZWxkVHlwZShmaWVsZFR5cGU6IEZpZWxkVHlwZSk6IHN0cmluZyB7XHJcbiAgLypcclxuICAgIGQ6IERheSBvZiB0aGUgbW9udGgsIDIgZGlnaXRzIHdpdGggbGVhZGluZyB6ZXJvc1x0MDEgdG8gMzFcclxuICAgIEQ6IEEgdGV4dHVhbCByZXByZXNlbnRhdGlvbiBvZiBhIGRheVx0TW9uIHRocm91Z2ggU3VuXHJcbiAgICBsOiAobG93ZXJjYXNlICdMJylcdEEgZnVsbCB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBkYXkgb2YgdGhlIHdlZWtcdFN1bmRheSB0aHJvdWdoIFNhdHVyZGF5XHJcbiAgICBqOiBEYXkgb2YgdGhlIG1vbnRoIHdpdGhvdXQgbGVhZGluZyB6ZXJvc1x0MSB0byAzMVxyXG4gICAgSjogRGF5IG9mIHRoZSBtb250aCB3aXRob3V0IGxlYWRpbmcgemVyb3MgYW5kIG9yZGluYWwgc3VmZml4XHQxc3QsIDJuZCwgdG8gMzFzdFxyXG4gICAgdzogTnVtZXJpYyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZGF5IG9mIHRoZSB3ZWVrXHQwIChmb3IgU3VuZGF5KSB0aHJvdWdoIDYgKGZvciBTYXR1cmRheSlcclxuICAgIEY6IEEgZnVsbCB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIGEgbW9udGhcdEphbnVhcnkgdGhyb3VnaCBEZWNlbWJlclxyXG4gICAgbTogTnVtZXJpYyByZXByZXNlbnRhdGlvbiBvZiBhIG1vbnRoLCB3aXRoIGxlYWRpbmcgemVyb1x0MDEgdGhyb3VnaCAxMlxyXG4gICAgbjogTnVtZXJpYyByZXByZXNlbnRhdGlvbiBvZiBhIG1vbnRoLCB3aXRob3V0IGxlYWRpbmcgemVyb3NcdDEgdGhyb3VnaCAxMlxyXG4gICAgTTogQSBzaG9ydCB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIGEgbW9udGhcdEphbiB0aHJvdWdoIERlY1xyXG4gICAgVTogVGhlIG51bWJlciBvZiBzZWNvbmRzIHNpbmNlIHRoZSBVbml4IEVwb2NoXHQxNDEzNzA0OTkzXHJcbiAgICB5OiBBIHR3byBkaWdpdCByZXByZXNlbnRhdGlvbiBvZiBhIHllYXJcdDk5IG9yIDAzXHJcbiAgICBZOiBBIGZ1bGwgbnVtZXJpYyByZXByZXNlbnRhdGlvbiBvZiBhIHllYXIsIDQgZGlnaXRzXHQxOTk5IG9yIDIwMDNcclxuICAgIEg6IEhvdXJzICgyNCBob3VycylcdDAwIHRvIDIzXHJcbiAgICBoOiBIb3Vyc1x0MSB0byAxMlxyXG4gICAgaTogTWludXRlc1x0MDAgdG8gNTlcclxuICAgIFM6IFNlY29uZHMsIDIgZGlnaXRzXHQwMCB0byA1OVxyXG4gICAgczogU2Vjb25kc1x0MCwgMSB0byA1OVxyXG4gICAgSzogQU0vUE1cdEFNIG9yIFBNXHJcbiAgKi9cclxuICBsZXQgbWFwOiBzdHJpbmc7XHJcbiAgc3dpdGNoIChmaWVsZFR5cGUpIHtcclxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lOlxyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVJc286XHJcbiAgICAgIG1hcCA9ICdZLW0tZCBIOmk6Uyc7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVTaG9ydElzbzpcclxuICAgICAgbWFwID0gJ1ktbS1kIEg6aSc7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVJc29BbVBtOlxyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVJc29BTV9QTTpcclxuICAgICAgbWFwID0gJ1ktbS1kIGg6aTpTIEsnOyAvLyB0aGVyZSBpcyBubyBsb3dlcmNhc2UgaW4gRmxhdHBpY2tyIDooXHJcbiAgICAgIGJyZWFrO1xyXG4gICAgLy8gYWxsIEV1cm8gRm9ybWF0cyAoZGF0ZS9tb250aC95ZWFyKVxyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZUV1cm86XHJcbiAgICAgIG1hcCA9ICdkL20vWSc7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZUV1cm9TaG9ydDpcclxuICAgICAgbWFwID0gJ2QvbS95JztcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZUV1cm86XHJcbiAgICAgIG1hcCA9ICdkL20vWSBIOmk6Uyc7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVTaG9ydEV1cm86XHJcbiAgICAgIG1hcCA9ICdkL20veSBIOmknO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lRXVyb0FtUG06XHJcbiAgICAgIG1hcCA9ICdkL20vWSBoOmk6UyBLJzsgLy8gdGhlcmUgaXMgbm8gbG93ZXJjYXNlIGluIEZsYXRwaWNrciA6KFxyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lRXVyb0FNX1BNOlxyXG4gICAgICBtYXAgPSAnZC9tL1kgaDppOnMgSyc7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVFdXJvU2hvcnQ6XHJcbiAgICAgIG1hcCA9ICdkL20veSBIOmk6cyc7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVFdXJvU2hvcnRBbVBtOlxyXG4gICAgICBtYXAgPSAnZC9tL3kgaDppOnMgSyc7IC8vIHRoZXJlIGlzIG5vIGxvd2VyY2FzZSBpbiBGbGF0cGlja3IgOihcclxuICAgICAgYnJlYWs7XHJcbiAgICAvLyBhbGwgVVMgRm9ybWF0cyAobW9udGgvZGF0ZS95ZWFyKVxyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVVzOlxyXG4gICAgICBtYXAgPSAnbS9kL1knO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVVc1Nob3J0OlxyXG4gICAgICBtYXAgPSAnbS9kL3knO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lVXM6XHJcbiAgICAgIG1hcCA9ICdtL2QvWSBIOmk6Uyc7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVTaG9ydFVzOlxyXG4gICAgICBtYXAgPSAnbS9kL3kgSDppJztcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZVVzQW1QbTpcclxuICAgICAgbWFwID0gJ20vZC9ZIGg6aTpTIEsnOyAvLyB0aGVyZSBpcyBubyBsb3dlcmNhc2UgaW4gRmxhdHBpY2tyIDooXHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVVc0FNX1BNOlxyXG4gICAgICBtYXAgPSAnbS9kL1kgaDppOnMgSyc7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVVc1Nob3J0OlxyXG4gICAgICBtYXAgPSAnbS9kL3kgSDppOnMnO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lVXNTaG9ydEFtUG06XHJcbiAgICAgIG1hcCA9ICdtL2QveSBoOmk6cyBLJzsgLy8gdGhlcmUgaXMgbm8gbG93ZXJjYXNlIGluIEZsYXRwaWNrciA6KFxyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVVdGM6XHJcbiAgICAgIG1hcCA9ICdaJztcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlOlxyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZUlzbzpcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIG1hcCA9ICdZLW0tZCc7XHJcbiAgICAgIGJyZWFrO1xyXG4gIH1cclxuICByZXR1cm4gbWFwO1xyXG59XHJcblxyXG4vKipcclxuICogTWFwcGVyIGZvciBxdWVyeSBvcGVyYXRvcnMgKGV4LjogPD0gaXMgXCJsZVwiLCA+IGlzIFwiZ3RcIilcclxuICogQHBhcmFtIHN0cmluZyBvcGVyYXRvclxyXG4gKiBAcmV0dXJucyBzdHJpbmcgbWFwXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbWFwT3BlcmF0b3JUeXBlKG9wZXJhdG9yOiBPcGVyYXRvclR5cGUgfCBPcGVyYXRvclN0cmluZyk6IE9wZXJhdG9yVHlwZSB7XHJcbiAgbGV0IG1hcDogT3BlcmF0b3JUeXBlO1xyXG5cclxuICBzd2l0Y2ggKG9wZXJhdG9yKSB7XHJcbiAgICBjYXNlICc8JzpcclxuICAgIGNhc2UgJ0xUJzpcclxuICAgICAgbWFwID0gT3BlcmF0b3JUeXBlLmxlc3NUaGFuO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgJzw9JzpcclxuICAgIGNhc2UgJ0xFJzpcclxuICAgICAgbWFwID0gT3BlcmF0b3JUeXBlLmxlc3NUaGFuT3JFcXVhbDtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlICc+JzpcclxuICAgIGNhc2UgJ0dUJzpcclxuICAgICAgbWFwID0gT3BlcmF0b3JUeXBlLmdyZWF0ZXJUaGFuO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgJz49JzpcclxuICAgIGNhc2UgJ0dFJzpcclxuICAgICAgbWFwID0gT3BlcmF0b3JUeXBlLmdyZWF0ZXJUaGFuT3JFcXVhbDtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlICc8Pic6XHJcbiAgICBjYXNlICchPSc6XHJcbiAgICBjYXNlICdORSc6XHJcbiAgICAgIG1hcCA9IE9wZXJhdG9yVHlwZS5ub3RFcXVhbDtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlICcqJzpcclxuICAgIGNhc2UgJ2EqJzpcclxuICAgIGNhc2UgJ1N0YXJ0c1dpdGgnOlxyXG4gICAgICBtYXAgPSBPcGVyYXRvclR5cGUuc3RhcnRzV2l0aDtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlICcqeic6XHJcbiAgICBjYXNlICdFbmRzV2l0aCc6XHJcbiAgICAgIG1hcCA9IE9wZXJhdG9yVHlwZS5lbmRzV2l0aDtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlICc9JzpcclxuICAgIGNhc2UgJz09JzpcclxuICAgIGNhc2UgJ0VRJzpcclxuICAgICAgbWFwID0gT3BlcmF0b3JUeXBlLmVxdWFsO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgJ0lOJzpcclxuICAgICAgbWFwID0gT3BlcmF0b3JUeXBlLmluO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgJ05JTic6XHJcbiAgICBjYXNlICdOT1RfSU4nOlxyXG4gICAgICBtYXAgPSBPcGVyYXRvclR5cGUubm90SW47XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAnTm90X0NvbnRhaW5zJzpcclxuICAgIGNhc2UgJ05PVF9DT05UQUlOUyc6XHJcbiAgICAgIG1hcCA9IE9wZXJhdG9yVHlwZS5ub3RDb250YWlucztcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlICdDb250YWlucyc6XHJcbiAgICBjYXNlICdDT05UQUlOUyc6XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICBtYXAgPSBPcGVyYXRvclR5cGUuY29udGFpbnM7XHJcbiAgICAgIGJyZWFrO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG1hcDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEZpbmQgZXF1aXZhbGVudCBzaG9ydCBkZXNpZ25hdGlvbiBvZiBhbiBPcGVyYXRvciBUeXBlIG9yIE9wZXJhdG9yIFN0cmluZy5cclxuICogV2hlbiB1c2luZyBhIENvbXBvdW5kIEZpbHRlciwgd2UgdXNlIHRoZSBzaG9ydCBkZXNpZ25hdGlvbiBhbmQgc28gd2UgbmVlZCB0aGUgbWFwcGVkIHZhbHVlLlxyXG4gKiBGb3IgZXhhbXBsZSBPcGVyYXRvclR5cGUuc3RhcnRzV2l0aCBzaG9ydCBkZXNpZ25hdGlvbiBpcyBcImEqXCIsIHdoaWxlIE9wZXJhdG9yVHlwZS5ncmVhdGVyVGhhbk9yRXF1YWwgaXMgXCI+PVwiXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbWFwT3BlcmF0b3JUb1Nob3J0aGFuZERlc2lnbmF0aW9uKG9wZXJhdG9yOiBPcGVyYXRvclR5cGUgfCBPcGVyYXRvclN0cmluZyk6IE9wZXJhdG9yU3RyaW5nIHtcclxuICBsZXQgc2hvcnRPcGVyYXRvcjogT3BlcmF0b3JTdHJpbmcgPSAnJztcclxuXHJcbiAgc3dpdGNoIChvcGVyYXRvcikge1xyXG4gICAgY2FzZSBPcGVyYXRvclR5cGUuZ3JlYXRlclRoYW46XHJcbiAgICBjYXNlICc+JzpcclxuICAgICAgc2hvcnRPcGVyYXRvciA9ICc+JztcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIE9wZXJhdG9yVHlwZS5ncmVhdGVyVGhhbk9yRXF1YWw6XHJcbiAgICBjYXNlICc+PSc6XHJcbiAgICAgIHNob3J0T3BlcmF0b3IgPSAnPj0nO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgT3BlcmF0b3JUeXBlLmxlc3NUaGFuOlxyXG4gICAgY2FzZSAnPCc6XHJcbiAgICAgIHNob3J0T3BlcmF0b3IgPSAnPCc7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBPcGVyYXRvclR5cGUubGVzc1RoYW5PckVxdWFsOlxyXG4gICAgY2FzZSAnPD0nOlxyXG4gICAgICBzaG9ydE9wZXJhdG9yID0gJzw9JztcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIE9wZXJhdG9yVHlwZS5ub3RFcXVhbDpcclxuICAgIGNhc2UgJzw+JzpcclxuICAgICAgc2hvcnRPcGVyYXRvciA9ICc8Pic7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBPcGVyYXRvclR5cGUuZXF1YWw6XHJcbiAgICBjYXNlICc9JzpcclxuICAgIGNhc2UgJz09JzpcclxuICAgIGNhc2UgJ0VRJzpcclxuICAgICAgc2hvcnRPcGVyYXRvciA9ICc9JztcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIE9wZXJhdG9yVHlwZS5zdGFydHNXaXRoOlxyXG4gICAgY2FzZSAnYSonOlxyXG4gICAgY2FzZSAnKic6XHJcbiAgICAgIHNob3J0T3BlcmF0b3IgPSAnYSonO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgT3BlcmF0b3JUeXBlLmVuZHNXaXRoOlxyXG4gICAgY2FzZSAnKnonOlxyXG4gICAgICBzaG9ydE9wZXJhdG9yID0gJyp6JztcclxuICAgICAgYnJlYWs7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICAvLyBhbnkgb3RoZXIgb3BlcmF0b3Igd2lsbCBiZSBjb25zaWRlcmVkIGFzIGFscmVhZHkgYSBzaG9ydCBleHByZXNzaW9uLCBzbyB3ZSBjYW4gcmV0dXJuIHNhbWUgaW5wdXQgb3BlcmF0b3JcclxuICAgICAgc2hvcnRPcGVyYXRvciA9IG9wZXJhdG9yO1xyXG4gICAgICBicmVhaztcclxuICB9XHJcblxyXG4gIHJldHVybiBzaG9ydE9wZXJhdG9yO1xyXG59XHJcblxyXG4vKipcclxuICogTWFwcGVyIGZvciBxdWVyeSBvcGVyYXRvciBieSBhIEZpbHRlciBUeXBlXHJcbiAqIEZvciBleGFtcGxlIGEgbXVsdGlwbGUtc2VsZWN0IHR5cGljYWxseSB1c2VzICdJTicgb3BlcmF0b3JcclxuICogQHBhcmFtIG9wZXJhdG9yXHJcbiAqIEByZXR1cm5zIHN0cmluZyBtYXBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBtYXBPcGVyYXRvckJ5RmllbGRUeXBlKGZpZWxkVHlwZTogRmllbGRUeXBlIHwgc3RyaW5nKTogT3BlcmF0b3JUeXBlIHtcclxuICBsZXQgbWFwOiBPcGVyYXRvclR5cGU7XHJcblxyXG4gIHN3aXRjaCAoZmllbGRUeXBlKSB7XHJcbiAgICBjYXNlIEZpZWxkVHlwZS51bmtub3duOlxyXG4gICAgY2FzZSBGaWVsZFR5cGUuc3RyaW5nOlxyXG4gICAgY2FzZSBGaWVsZFR5cGUudGV4dDpcclxuICAgIGNhc2UgRmllbGRUeXBlLnBhc3N3b3JkOlxyXG4gICAgY2FzZSBGaWVsZFR5cGUucmVhZG9ubHk6XHJcbiAgICAgIG1hcCA9IE9wZXJhdG9yVHlwZS5jb250YWlucztcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5mbG9hdDpcclxuICAgIGNhc2UgRmllbGRUeXBlLm51bWJlcjpcclxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGU6XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlSXNvOlxyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVV0YzpcclxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lOlxyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVJc286XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZUlzb0FtUG06XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZUlzb0FNX1BNOlxyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZUV1cm86XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlRXVyb1Nob3J0OlxyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVFdXJvOlxyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVFdXJvQW1QbTpcclxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lRXVyb0FNX1BNOlxyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVFdXJvU2hvcnQ6XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZUV1cm9TaG9ydEFtUG06XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZUV1cm9TaG9ydEFNX1BNOlxyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVVzOlxyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVVzU2hvcnQ6XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZVVzOlxyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVVc0FtUG06XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZVVzQU1fUE06XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZVVzU2hvcnQ6XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZVVzU2hvcnRBbVBtOlxyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVVc1Nob3J0QU1fUE06XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICBtYXAgPSBPcGVyYXRvclR5cGUuZXF1YWw7XHJcbiAgICAgIGJyZWFrO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG1hcDtcclxufVxyXG5cclxuLyoqIFBhcnNlIGFueSBpbnB1dCAoYm9vbCwgbnVtYmVyLCBzdHJpbmcpIGFuZCByZXR1cm4gYSBib29sZWFuIG9yIEZhbHNlIHdoZW4gbm90IHBvc3NpYmxlICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUJvb2xlYW4oaW5wdXQ6IGFueSk6IGJvb2xlYW4ge1xyXG4gIHJldHVybiAvKHRydWV8MSkvaS50ZXN0KGlucHV0ICsgJycpO1xyXG59XHJcblxyXG4vKipcclxuICogUGFyc2UgYSBkYXRlIHBhc3NlZCBhcyBhIHN0cmluZyAoRGF0ZSBvbmx5LCB3aXRob3V0IHRpbWUpIGFuZCByZXR1cm4gYSBEYXRlIG9iamVjdCAoaWYgdmFsaWQpXHJcbiAqIEBwYXJhbSBpbnB1dERhdGVTdHJpbmdcclxuICogQHJldHVybnMgc3RyaW5nIGRhdGUgZm9ybWF0dGVkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VVdGNEYXRlKGlucHV0RGF0ZVN0cmluZzogc3RyaW5nLCB1c2VVdGM/OiBib29sZWFuKTogc3RyaW5nIHwgbnVsbCB7XHJcbiAgbGV0IGRhdGUgPSBudWxsO1xyXG5cclxuICBpZiAoL15bMC05XFwtXFwvXSokLy50ZXN0KGlucHV0RGF0ZVN0cmluZykpIHtcclxuICAgIC8vIGdldCB0aGUgVVRDIGRhdGV0aW1lIHdpdGggbW9tZW50LmpzIGJ1dCB3ZSBuZWVkIHRvIGRlY29kZSB0aGUgdmFsdWUgc28gdGhhdCBpdCdzIHZhbGlkIHRleHRcclxuICAgIGNvbnN0IGRhdGVTdHJpbmcgPSBkZWNvZGVVUklDb21wb25lbnQoaW5wdXREYXRlU3RyaW5nKTtcclxuICAgIGNvbnN0IGRhdGVNb21lbnQgPSBtb21lbnQobmV3IERhdGUoZGF0ZVN0cmluZykpO1xyXG4gICAgaWYgKGRhdGVNb21lbnQuaXNWYWxpZCgpICYmIGRhdGVNb21lbnQueWVhcigpLnRvU3RyaW5nKCkubGVuZ3RoID09PSA0KSB7XHJcbiAgICAgIGRhdGUgPSAodXNlVXRjKSA/IGRhdGVNb21lbnQudXRjKCkuZm9ybWF0KCkgOiBkYXRlTW9tZW50LmZvcm1hdCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGRhdGU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTYW5pdGl6ZSwgcmV0dXJuIG9ubHkgdGhlIHRleHQgd2l0aG91dCBIVE1MIHRhZ3NcclxuICogQGlucHV0IGh0bWxTdHJpbmdcclxuICogQHJldHVybiB0ZXh0XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2FuaXRpemVIdG1sVG9UZXh0KGh0bWxTdHJpbmc6IHN0cmluZykge1xyXG4gIGNvbnN0IHRlbXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICB0ZW1wLmlubmVySFRNTCA9IGh0bWxTdHJpbmc7XHJcbiAgcmV0dXJuIHRlbXAudGV4dENvbnRlbnQgfHwgdGVtcC5pbm5lclRleHQgfHwgJyc7XHJcbn1cclxuXHJcbi8qKiBTZXQgdGhlIG9iamVjdCB2YWx1ZSBvZiBkZWVwZXIgbm9kZSBmcm9tIGEgZ2l2ZW4gZG90ICguKSBub3RhdGlvbiBwYXRoIChlLmcuOiBcInVzZXIuZmlyc3ROYW1lXCIpICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXREZWVwVmFsdWU8VCA9IGFueT4ob2JqOiBULCBwYXRoOiBzdHJpbmcgfCBzdHJpbmdbXSwgdmFsdWU6IGFueSkge1xyXG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcclxuICAgIHBhdGggPSBwYXRoLnNwbGl0KCcuJyk7XHJcbiAgfVxyXG5cclxuICBpZiAocGF0aC5sZW5ndGggPiAxKSB7XHJcbiAgICBjb25zdCBlID0gcGF0aC5zaGlmdCgpO1xyXG4gICAgaWYgKG9iaiAmJiBlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgc2V0RGVlcFZhbHVlKFxyXG4gICAgICAgIG9ialtlXSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmpbZV0pID09PSAnW29iamVjdCBPYmplY3RdJyA/IG9ialtlXSA6IHt9LFxyXG4gICAgICAgIHBhdGgsXHJcbiAgICAgICAgdmFsdWVcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKG9iaiAmJiBwYXRoWzBdKSB7XHJcbiAgICBvYmpbcGF0aFswXV0gPSB2YWx1ZTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGb3JtYXQgYSBudW1iZXIgb3IgYSBzdHJpbmcgaW50byBhIHN0cmluZyB0aGF0IGlzIHNlcGFyYXRlZCBldmVyeSB0aG91c2FuZCxcclxuICogdGhlIGRlZmF1bHQgc2VwYXJhdG9yIGlzIGEgY29tbWEgYnV0IHVzZXIgY2FuIG9wdGlvbmFsbHkgcGFzcyBhIGRpZmZlcmVudCBvbmVcclxuICogQHBhcmFtIGlucHV0VmFsdWVcclxuICogQHBhcmFtIHNlcGFyYXRvciBkZWZhdWx0IHRvIGNvbW1hIFwiLFwiXHJcbiAqIEByZXR1cm5zIHN0cmluZ1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRob3VzYW5kU2VwYXJhdG9yRm9ybWF0dGVkKGlucHV0VmFsdWU6IHN0cmluZyB8IG51bWJlciB8IG51bGwsIHNlcGFyYXRvcjogJywnIHwgJ18nIHwgJy4nIHwgJyAnIHwgJycgPSAnLCcpOiBzdHJpbmcgfCBudWxsIHtcclxuICBpZiAoaW5wdXRWYWx1ZSAhPT0gbnVsbCAmJiBpbnB1dFZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgIGNvbnN0IHN0cmluZ1ZhbHVlID0gYCR7aW5wdXRWYWx1ZX1gO1xyXG4gICAgY29uc3QgZGVjaW1hbFNwbGl0ID0gc3RyaW5nVmFsdWUuc3BsaXQoJy4nKTtcclxuICAgIGlmIChkZWNpbWFsU3BsaXQubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgIHJldHVybiBgJHtkZWNpbWFsU3BsaXRbMF0ucmVwbGFjZSgvXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZywgc2VwYXJhdG9yKX0uJHtkZWNpbWFsU3BsaXRbMV19YDtcclxuICAgIH1cclxuICAgIHJldHVybiBzdHJpbmdWYWx1ZS5yZXBsYWNlKC9cXEIoPz0oXFxkezN9KSsoPyFcXGQpKS9nLCBzZXBhcmF0b3IpO1xyXG4gIH1cclxuICByZXR1cm4gaW5wdXRWYWx1ZSBhcyBudWxsO1xyXG59XHJcblxyXG4vKipcclxuICogVGl0bGUgY2FzZSAob3IgY2FwaXRhbGl6ZSkgZmlyc3QgY2hhciBvZiBhIHN0cmluZywgZm9yIGV4YW1wbGUgXCJoZWxsbyB3b3JsZFwiIHdpbGwgYmVjb21lIFwiSGVsbG8gd29ybGRcIlxyXG4gKiBDaGFuZ2UgdGhlIHN0cmluZyB0byBiZSB0aXRsZSBjYXNlIG9uIHRoZSBjb21wbGV0ZSBzZW50ZW5jZSAodXBwZXIgY2FzZSBmaXJzdCBjaGFyIG9mIGVhY2ggd29yZCB3aGlsZSBjaGFuZ2luZyBldmVyeXRoaW5nIGVsc2UgdG8gbG93ZXIgY2FzZSlcclxuICogQHBhcmFtIGlucHV0U3RyXHJcbiAqIEByZXR1cm5zIHN0cmluZ1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRpdGxlQ2FzZShpbnB1dFN0cjogc3RyaW5nLCBjYXNlRXZlcnlXb3JkcyA9IGZhbHNlKTogc3RyaW5nIHtcclxuICBpZiAodHlwZW9mIGlucHV0U3RyID09PSAnc3RyaW5nJykge1xyXG4gICAgaWYgKGNhc2VFdmVyeVdvcmRzKSB7XHJcbiAgICAgIHJldHVybiBpbnB1dFN0ci5yZXBsYWNlKC9cXHdcXFMqL2csIChvdXRwdXRTdHIpID0+IHtcclxuICAgICAgICByZXR1cm4gb3V0cHV0U3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgb3V0cHV0U3RyLnN1YnN0cigxKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBpbnB1dFN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGlucHV0U3RyLnNsaWNlKDEpO1xyXG4gIH1cclxuICByZXR1cm4gaW5wdXRTdHI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBhIHN0cmluZyB0byBjYW1lbCBjYXNlIChjYW1lbENhc2UpLCBmb3IgZXhhbXBsZSBcImhlbGxvLXdvcmxkXCIgKG9yIFwiaGVsbG93IHdvcmxkXCIpIHdpbGwgYmVjb21lIFwiaGVsbG9Xb3JsZFwiXHJcbiAqIEBwYXJhbSBpbnB1dFN0ciB0aGUgc3RyaW5nIHRvIGNvbnZlcnRcclxuICogQHJldHVybiB0aGUgc3RyaW5nIGluIGNhbWVsIGNhc2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB0b0NhbWVsQ2FzZShpbnB1dFN0cjogc3RyaW5nKTogc3RyaW5nIHtcclxuICBpZiAodHlwZW9mIGlucHV0U3RyID09PSAnc3RyaW5nJykge1xyXG4gICAgcmV0dXJuIGlucHV0U3RyLnJlcGxhY2UoLyg/Ol5cXHd8W0EtWl18XFxiXFx3fFtcXHMrXFwtX1xcL10pL2csIChtYXRjaDogc3RyaW5nLCBvZmZzZXQ6IG51bWJlcikgPT4ge1xyXG4gICAgICAvLyByZW1vdmUgd2hpdGUgc3BhY2Ugb3IgaHlwZW5zIG9yIHVuZGVyc2NvcmVzXHJcbiAgICAgIGlmICgvW1xccytcXC1fXFwvXS8udGVzdChtYXRjaCkpIHtcclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBvZmZzZXQgPT09IDAgPyBtYXRjaC50b0xvd2VyQ2FzZSgpIDogbWF0Y2gudG9VcHBlckNhc2UoKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICByZXR1cm4gaW5wdXRTdHI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBhIHN0cmluZyB0byBrZWJhYiAoaHlwZW4pIGNhc2UsIGZvciBleGFtcGxlIFwiaGVsbG9Xb3JsZFwiIHdpbGwgYmVjb21lIFwiaGVsbG8td29ybGRcIlxyXG4gKiBAcGFyYW0gc3RyIHRoZSBzdHJpbmcgdG8gY29udmVydFxyXG4gKiBAcmV0dXJuIHRoZSBzdHJpbmcgaW4ga2ViYWIgY2FzZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRvS2ViYWJDYXNlKGlucHV0U3RyOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gIGlmICh0eXBlb2YgaW5wdXRTdHIgPT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm4gdG9DYW1lbENhc2UoaW5wdXRTdHIpLnJlcGxhY2UoLyhbQS1aXSkvZywgJy0kMScpLnRvTG93ZXJDYXNlKCk7XHJcbiAgfVxyXG4gIHJldHVybiBpbnB1dFN0cjtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIGEgc3RyaW5nIGZyb20gY2FtZWxDYXNlIHRvIHNuYWtlX2Nhc2UgKHVuZGVyc2NvcmUpIGNhc2UsIGZvciBleGFtcGxlIFwiaGVsbG9Xb3JsZFwiIHdpbGwgYmVjb21lIFwiaGVsbG9fd29ybGRcIlxyXG4gKiBAcGFyYW0gc3RyIHRoZSBzdHJpbmcgdG8gY29udmVydFxyXG4gKiBAcmV0dXJuIHRoZSBzdHJpbmcgaW4ga2ViYWIgY2FzZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRvU25ha2VDYXNlKGlucHV0U3RyOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gIGlmICh0eXBlb2YgaW5wdXRTdHIgPT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm4gdG9DYW1lbENhc2UoaW5wdXRTdHIpLnJlcGxhY2UoLyhbQS1aXSkvZywgJ18kMScpLnRvTG93ZXJDYXNlKCk7XHJcbiAgfVxyXG4gIHJldHVybiBpbnB1dFN0cjtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRha2VzIGFuIGlucHV0IGFycmF5IGFuZCBtYWtlcyBzdXJlIHRoZSBhcnJheSBoYXMgdW5pcXVlIHZhbHVlcyBieSByZW1vdmluZyBkdXBsaWNhdGVzXHJcbiAqIEBwYXJhbSBhcnJheSBpbnB1dCB3aXRoIHBvc3NpYmxlIGR1cGxpY2F0ZXNcclxuICogQHBhcmFtIG9iamVjdFByb3BlcnR5IG9wdGlvbmFsbHkgcHJvdmlkZSBhbiBvYmplY3QgcHJvcGVydHkgdG8gY29tcGFyZSAoZXhhbXBsZTogJ2lkJylcclxuICogQHJldHVybiBhcnJheSBvdXRwdXQgd2l0aG91dCBkdXBsaWNhdGVzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdW5pcXVlQXJyYXk8VCA9IGFueT4oYXJyOiBUW10pOiBUW10ge1xyXG4gIGlmIChBcnJheS5pc0FycmF5KGFycikgJiYgYXJyLmxlbmd0aCA+IDApIHtcclxuICAgIHJldHVybiBhcnIuZmlsdGVyKChpdGVtOiBULCBpbmRleDogbnVtYmVyKSA9PiB7XHJcbiAgICAgIHJldHVybiBhcnIuaW5kZXhPZihpdGVtKSA+PSBpbmRleDtcclxuICAgIH0pO1xyXG4gIH1cclxuICByZXR1cm4gYXJyO1xyXG59XHJcblxyXG4vKipcclxuICogVGFrZXMgYW4gaW5wdXQgYXJyYXkgb2Ygb2JqZWN0cyBhbmQgbWFrZXMgc3VyZSB0aGUgYXJyYXkgaGFzIHVuaXF1ZSBvYmplY3QgdmFsdWVzIGJ5IHJlbW92aW5nIGR1cGxpY2F0ZXNcclxuICogaXQgd2lsbCBsb29wIHRocm91Z2ggdGhlIGFycmF5IHVzaW5nIGEgcHJvcGVydHkgbmFtZSAob3IgXCJpZFwiIHdoZW4gaXMgbm90IHByb3ZpZGVkKSB0byBjb21wYXJlIHVuaXF1ZW5lc3NcclxuICogQHBhcmFtIGFycmF5IGlucHV0IHdpdGggcG9zc2libGUgZHVwbGljYXRlc1xyXG4gKiBAcGFyYW0gcHJvcGVydHlOYW1lIGRlZmF1bHRzIHRvIFwiaWRcIlxyXG4gKiBAcmV0dXJuIGFycmF5IG91dHB1dCB3aXRob3V0IGR1cGxpY2F0ZXNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1bmlxdWVPYmplY3RBcnJheShhcnI6IGFueVtdLCBwcm9wZXJ0eU5hbWUgPSAnaWQnKTogYW55W10ge1xyXG4gIGlmIChBcnJheS5pc0FycmF5KGFycikgJiYgYXJyLmxlbmd0aCA+IDApIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgY29uc3QgbWFwID0gbmV3IE1hcCgpO1xyXG5cclxuICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnIpIHtcclxuICAgICAgaWYgKCFtYXAuaGFzKGl0ZW1bcHJvcGVydHlOYW1lXSkpIHtcclxuICAgICAgICBtYXAuc2V0KGl0ZW1bcHJvcGVydHlOYW1lXSwgdHJ1ZSk7ICAgIC8vIHNldCBhbnkgdmFsdWUgdG8gTWFwXHJcbiAgICAgICAgcmVzdWx0LnB1c2goe1xyXG4gICAgICAgICAgaWQ6IGl0ZW1bcHJvcGVydHlOYW1lXSxcclxuICAgICAgICAgIG5hbWU6IGl0ZW0ubmFtZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuICByZXR1cm4gYXJyO1xyXG59XHJcblxyXG4vKipcclxuICogVW5zdWJzY3JpYmUgYWxsIE9ic2VydmFibGVzIFN1YnNjcmlwdGlvbnNcclxuICogSXQgd2lsbCByZXR1cm4gYW4gZW1wdHkgYXJyYXkgaWYgaXQgYWxsIHdlbnQgd2VsbFxyXG4gKiBAcGFyYW0gc3Vic2NyaXB0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVuc3Vic2NyaWJlQWxsT2JzZXJ2YWJsZXMoc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10pOiBTdWJzY3JpcHRpb25bXSB7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3Vic2NyaXB0aW9ucykpIHtcclxuICAgIHN1YnNjcmlwdGlvbnMuZm9yRWFjaCgoc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb24pID0+IHtcclxuICAgICAgaWYgKHN1YnNjcmlwdGlvbiAmJiBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUpIHtcclxuICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBzdWJzY3JpcHRpb25zID0gW107XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3Vic2NyaXB0aW9ucztcclxufVxyXG4iXX0=