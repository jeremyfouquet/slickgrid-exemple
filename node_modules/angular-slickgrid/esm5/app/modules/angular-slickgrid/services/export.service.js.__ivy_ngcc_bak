import * as tslib_1 from "tslib";
import { Injectable, Optional } from '@angular/core';
import { TranslateService } from '@ngx-translate/core';
import { TextEncoder } from 'text-encoding-utf-8';
import { Subject } from 'rxjs';
import { FileType, } from './../models/index';
import { Constants } from './../constants';
import { exportWithFormatterWhenDefined } from './export-utilities';
import { addWhiteSpaces, getTranslationPrefix, htmlEntityDecode, sanitizeHtmlToText, titleCase } from './../services/utilities';
var ExportService = /** @class */ (function () {
    function ExportService(translate) {
        this.translate = translate;
        this._delimiter = ',';
        this._fileFormat = FileType.csv;
        this._lineCarriageReturn = '\n';
        this._exportQuoteWrapper = '';
        this._hasGroupedItems = false;
        this.onGridBeforeExportToFile = new Subject();
        this.onGridAfterExportToFile = new Subject();
    }
    Object.defineProperty(ExportService.prototype, "datasetIdName", {
        get: function () {
            return this._gridOptions && this._gridOptions.datasetIdPropertyName || 'id';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExportService.prototype, "_gridOptions", {
        /** Getter for the Grid Options pulled through the Grid Object */
        get: function () {
            return (this._grid && this._grid.getOptions) ? this._grid.getOptions() : {};
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Initialize the Export Service
     * @param grid
     * @param gridOptions
     * @param dataView
     */
    ExportService.prototype.init = function (grid, dataView) {
        this._grid = grid;
        this._dataView = dataView;
        // get locales provided by user in forRoot or else use default English locales via the Constants
        this._locales = this._gridOptions && this._gridOptions.locales || Constants.locales;
        if (this._gridOptions.enableTranslate && (!this.translate || !this.translate.instant)) {
            throw new Error('[Angular-Slickgrid] requires "ngx-translate" to be installed and configured when the grid option "enableTranslate" is enabled.');
        }
    };
    /**
     * Function to export the Grid result to an Excel CSV format using javascript for it to produce the CSV file.
     * This is a WYSIWYG export to file output (What You See is What You Get)
     *
     * NOTES: The column position needs to match perfectly the JSON Object position because of the way we are pulling the data,
     * which means that if any column(s) got moved in the UI, it has to be reflected in the JSON array output as well
     *
     * Example: exportToFile({ format: FileType.csv, delimiter: DelimiterType.comma })
     */
    ExportService.prototype.exportToFile = function (options) {
        var _this = this;
        if (!this._grid || !this._dataView) {
            throw new Error('[Angular-Slickgrid] it seems that the SlickGrid & DataView objects are not initialized did you forget to enable the grid option flag "enableExcelExport"?');
        }
        return new Promise(function (resolve, reject) {
            _this.onGridBeforeExportToFile.next(true);
            _this._exportOptions = $.extend(true, {}, _this._gridOptions.exportOptions, options);
            _this._delimiter = _this._exportOptions.delimiterOverride || _this._exportOptions.delimiter || '';
            _this._fileFormat = _this._exportOptions.format || FileType.csv;
            // get the CSV output from the grid data
            var dataOutput = _this.getDataOutput();
            // trigger a download file
            // wrap it into a setTimeout so that the EventAggregator has enough time to start a pre-process like showing a spinner
            setTimeout(function () {
                try {
                    var downloadOptions = {
                        filename: _this._exportOptions.filename + "." + _this._fileFormat,
                        format: _this._fileFormat,
                        useUtf8WithBom: _this._exportOptions.hasOwnProperty('useUtf8WithBom') ? _this._exportOptions.useUtf8WithBom : true
                    };
                    // start downloading but add the content property only on the start download not on the event itself
                    _this.startDownloadFile(tslib_1.__assign({}, downloadOptions, { content: dataOutput })); // add content property
                    _this.onGridAfterExportToFile.next(downloadOptions);
                    resolve(true);
                }
                catch (error) {
                    reject(error);
                }
            }, 0);
        });
    };
    /**
     * Triggers download file with file format.
     * IE(6-10) are not supported
     * All other browsers will use plain javascript on client side to produce a file download.
     * @param options
     */
    ExportService.prototype.startDownloadFile = function (options) {
        // IE(6-10) don't support javascript download and our service doesn't support either so throw an error, we have to make a round trip to the Web Server for exporting
        if (navigator.appName === 'Microsoft Internet Explorer') {
            throw new Error('Microsoft Internet Explorer 6 to 10 do not support javascript export to CSV. Please upgrade your browser.');
        }
        // set the correct MIME type
        var mimeType = (options.format === FileType.csv) ? 'text/csv' : 'text/plain';
        // make sure no html entities exist in the data
        var dataContent = htmlEntityDecode(options.content);
        // dealing with Excel CSV export and UTF-8 is a little tricky.. We will use Option #2 to cover older Excel versions
        // Option #1: we need to make Excel knowing that it's dealing with an UTF-8, A correctly formatted UTF8 file can have a Byte Order Mark as its first three octets
        // reference: http://stackoverflow.com/questions/155097/microsoft-excel-mangles-diacritics-in-csv-files
        // Option#2: use a 3rd party extension to javascript encode into UTF-16
        var outputData;
        if (options.format === FileType.csv) {
            outputData = new TextEncoder('utf-8').encode(dataContent);
        }
        else {
            outputData = dataContent;
        }
        // create a Blob object for the download
        var blob = new Blob([options.useUtf8WithBom ? '\uFEFF' : '', outputData], {
            type: mimeType + ";charset=utf-8;"
        });
        // when using IE/Edge, then use different download call
        if (typeof navigator.msSaveOrOpenBlob === 'function') {
            navigator.msSaveOrOpenBlob(blob, options.filename);
        }
        else {
            // this trick will generate a temp <a /> tag
            // the code will then trigger a hidden click for it to start downloading
            var link = document.createElement('a');
            var csvUrl = URL.createObjectURL(blob);
            link.textContent = 'download';
            link.href = csvUrl;
            link.setAttribute('download', options.filename);
            // set the visibility to hidden so there is no effect on your web-layout
            link.style.visibility = 'hidden';
            // this part will append the anchor tag, trigger a click (for download to start) and finally remove the tag once completed
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
    };
    // -----------------------
    // Private functions
    // -----------------------
    ExportService.prototype.getDataOutput = function () {
        var _this = this;
        var columns = this._grid.getColumns() || [];
        // Group By text, it could be set in the export options or from translation or if nothing is found then use the English constant text
        var groupByColumnHeader = this._exportOptions.groupingColumnHeaderTitle;
        if (!groupByColumnHeader && this._gridOptions.enableTranslate && this.translate && this.translate.currentLang && this.translate.instant) {
            groupByColumnHeader = this.translate.instant(getTranslationPrefix(this._gridOptions) + "GROUP_BY");
        }
        else if (!groupByColumnHeader) {
            groupByColumnHeader = this._locales && this._locales.TEXT_GROUP_BY;
        }
        // a CSV needs double quotes wrapper, the other types do not need any wrapper
        this._exportQuoteWrapper = (this._fileFormat === FileType.csv) ? '"' : '';
        // data variable which will hold all the fields data of a row
        var outputDataString = '';
        // get grouped column titles and if found, we will add a "Group by" column at the first column index
        // if it's a CSV format, we'll escape the text in double quotes
        var grouping = this._dataView.getGrouping();
        if (grouping && Array.isArray(grouping) && grouping.length > 0) {
            this._hasGroupedItems = true;
            outputDataString += (this._fileFormat === FileType.csv) ? "\"" + groupByColumnHeader + "\"" + this._delimiter : "" + groupByColumnHeader + this._delimiter;
        }
        else {
            this._hasGroupedItems = false;
        }
        // get all Grouped Column Header Titles when defined (from pre-header row)
        if (this._gridOptions.createPreHeaderPanel && this._gridOptions.showPreHeaderPanel && !this._gridOptions.enableDraggableGrouping) {
            this._groupedColumnHeaders = this.getColumnGroupedHeaderTitles(columns) || [];
            if (this._groupedColumnHeaders && Array.isArray(this._groupedColumnHeaders) && this._groupedColumnHeaders.length > 0) {
                // add the header row + add a new line at the end of the row
                var outputGroupedHeaderTitles = this._groupedColumnHeaders.map(function (header) { return "" + _this._exportQuoteWrapper + header.title + _this._exportQuoteWrapper; });
                outputDataString += (outputGroupedHeaderTitles.join(this._delimiter) + this._lineCarriageReturn);
            }
        }
        // get all Column Header Titles
        this._columnHeaders = this.getColumnHeaders(columns) || [];
        if (this._columnHeaders && Array.isArray(this._columnHeaders) && this._columnHeaders.length > 0) {
            // add the header row + add a new line at the end of the row
            var outputHeaderTitles = this._columnHeaders.map(function (header) { return "" + _this._exportQuoteWrapper + header.title + _this._exportQuoteWrapper; });
            outputDataString += (outputHeaderTitles.join(this._delimiter) + this._lineCarriageReturn);
        }
        // Populate the rest of the Grid Data
        outputDataString += this.getAllGridRowData(columns, this._lineCarriageReturn);
        return outputDataString;
    };
    /**
     * Get all the grid row data and return that as an output string
     */
    ExportService.prototype.getAllGridRowData = function (columns, lineCarriageReturn) {
        var outputDataStrings = [];
        var lineCount = this._dataView.getLength();
        // loop through all the grid rows of data
        for (var rowNumber = 0; rowNumber < lineCount; rowNumber++) {
            var itemObj = this._dataView.getItem(rowNumber);
            if (itemObj) {
                // Normal row (not grouped by anything) would have an ID which was predefined in the Grid Columns definition
                if (itemObj[this.datasetIdName] !== null && itemObj[this.datasetIdName] !== undefined) {
                    // get regular row item data
                    outputDataStrings.push(this.readRegularRowData(columns, rowNumber, itemObj));
                }
                else if (this._hasGroupedItems && itemObj.__groupTotals === undefined) {
                    // get the group row
                    outputDataStrings.push(this.readGroupedTitleRow(itemObj));
                }
                else if (itemObj.__groupTotals) {
                    // else if the row is a Group By and we have agreggators, then a property of '__groupTotals' would exist under that object
                    outputDataStrings.push(this.readGroupedTotalRow(columns, itemObj));
                }
            }
        }
        return outputDataStrings.join(lineCarriageReturn);
    };
    /**
   * Get all Grouped Header Titles and their keys, translate the title when required.
   * @param {Array<object>} columns of the grid
   */
    ExportService.prototype.getColumnGroupedHeaderTitles = function (columns) {
        var _this = this;
        var groupedColumnHeaders = [];
        if (columns && Array.isArray(columns)) {
            // Populate the Grouped Column Header, pull the columnGroup(Key) defined
            columns.forEach(function (columnDef) {
                var groupedHeaderTitle = '';
                if ((columnDef.columnGroupKey || columnDef.columnGroupKey) && _this._gridOptions.enableTranslate && _this.translate && _this.translate.currentLang && _this.translate.instant) {
                    groupedHeaderTitle = _this.translate.instant((columnDef.columnGroupKey || columnDef.columnGroupKey));
                }
                else {
                    groupedHeaderTitle = columnDef.columnGroup || '';
                }
                var skippedField = columnDef.excludeFromExport || false;
                // if column width is 0px, then we consider that field as a hidden field and should not be part of the export
                if ((columnDef.width === undefined || columnDef.width > 0) && !skippedField) {
                    groupedColumnHeaders.push({
                        key: (columnDef.field || columnDef.id),
                        title: groupedHeaderTitle || ''
                    });
                }
            });
        }
        return groupedColumnHeaders;
    };
    /**
     * Get all header titles and their keys, translate the title when required.
     * @param {Array<object>} columns of the grid
     */
    ExportService.prototype.getColumnHeaders = function (columns) {
        var _this = this;
        var columnHeaders = [];
        if (columns && Array.isArray(columns)) {
            // Populate the Column Header, pull the name defined
            columns.forEach(function (columnDef) {
                var headerTitle = '';
                if ((columnDef.headerKey || columnDef.nameKey) && _this._gridOptions.enableTranslate && _this.translate && _this.translate.currentLang && _this.translate.instant) {
                    headerTitle = _this.translate.instant((columnDef.headerKey || columnDef.nameKey));
                }
                else {
                    headerTitle = columnDef.name || titleCase(columnDef.field);
                }
                var skippedField = columnDef.excludeFromExport || false;
                // if column width is 0, then we consider that field as a hidden field and should not be part of the export
                if ((columnDef.width === undefined || columnDef.width > 0) && !skippedField) {
                    columnHeaders.push({
                        key: columnDef.field || columnDef.id,
                        title: headerTitle
                    });
                }
            });
        }
        return columnHeaders;
    };
    /**
     * Get the data of a regular row (a row without grouping)
     * @param row
     * @param itemObj
     */
    ExportService.prototype.readRegularRowData = function (columns, row, itemObj) {
        var idx = 0;
        var rowOutputStrings = [];
        var exportQuoteWrapper = this._exportQuoteWrapper;
        for (var col = 0, ln = columns.length; col < ln; col++) {
            var columnDef = columns[col];
            // skip excluded column
            if (columnDef.excludeFromExport) {
                continue;
            }
            // if we are grouping and are on 1st column index, we need to skip this column since it will be used later by the grouping text:: Group by [columnX]
            if (this._hasGroupedItems && idx === 0) {
                var emptyValue = this._fileFormat === FileType.csv ? "\"\"" : '';
                rowOutputStrings.push(emptyValue);
            }
            // get the output by analyzing if we'll pull the value from the cell or from a formatter
            var itemData = exportWithFormatterWhenDefined(row, col, itemObj, columnDef, this._grid, this._exportOptions);
            // does the user want to sanitize the output data (remove HTML tags)?
            if (columnDef.sanitizeDataExport || this._exportOptions.sanitizeDataExport) {
                itemData = sanitizeHtmlToText(itemData);
            }
            // when CSV we also need to escape double quotes twice, so " becomes ""
            if (this._fileFormat === FileType.csv && itemData) {
                itemData = itemData.toString().replace(/"/gi, "\"\"");
            }
            // do we have a wrapper to keep as a string? in certain cases like "1E06", we don't want excel to transform it into exponential (1.0E06)
            // to cancel that effect we can had = in front, ex: ="1E06"
            var keepAsStringWrapper = (columnDef && columnDef.exportCsvForceToKeepAsString) ? '=' : '';
            rowOutputStrings.push(keepAsStringWrapper + exportQuoteWrapper + itemData + exportQuoteWrapper);
            idx++;
        }
        return rowOutputStrings.join(this._delimiter);
    };
    /**
     * Get the grouped title(s) and its group title formatter, for example if we grouped by salesRep, the returned result would be:: 'Sales Rep: John Dow (2 items)'
     * @param itemObj
     */
    ExportService.prototype.readGroupedTitleRow = function (itemObj) {
        var groupName = sanitizeHtmlToText(itemObj.title);
        var exportQuoteWrapper = this._exportQuoteWrapper;
        groupName = addWhiteSpaces(5 * itemObj.level) + groupName;
        if (this._fileFormat === FileType.csv) {
            // when CSV we also need to escape double quotes twice, so " becomes ""
            groupName = groupName.toString().replace(/"/gi, "\"\"");
        }
        return exportQuoteWrapper + groupName + exportQuoteWrapper;
    };
    /**
     * Get the grouped totals (below the regular rows), these are set by Slick Aggregators.
     * For example if we grouped by "salesRep" and we have a Sum Aggregator on "sales", then the returned output would be:: ["Sum 123$"]
     * @param itemObj
     */
    ExportService.prototype.readGroupedTotalRow = function (columns, itemObj) {
        var _this = this;
        var delimiter = this._exportOptions.delimiter;
        var format = this._exportOptions.format;
        var groupingAggregatorRowText = this._exportOptions.groupingAggregatorRowText || '';
        var exportQuoteWrapper = this._exportQuoteWrapper;
        var outputStrings = ["" + exportQuoteWrapper + groupingAggregatorRowText + exportQuoteWrapper];
        columns.forEach(function (columnDef) {
            var itemData = '';
            var skippedField = columnDef.excludeFromExport || false;
            // if there's a groupTotalsFormatter, we will re-run it to get the exact same output as what is shown in UI
            if (columnDef.groupTotalsFormatter) {
                itemData = columnDef.groupTotalsFormatter(itemObj, columnDef);
            }
            // does the user want to sanitize the output data (remove HTML tags)?
            if (columnDef.sanitizeDataExport || _this._exportOptions.sanitizeDataExport) {
                itemData = sanitizeHtmlToText(itemData);
            }
            if (format === FileType.csv) {
                // when CSV we also need to escape double quotes twice, so a double quote " becomes 2x double quotes ""
                itemData = itemData.toString().replace(/"/gi, "\"\"");
            }
            // add the column (unless user wants to skip it)
            if ((columnDef.width === undefined || columnDef.width > 0) && !skippedField) {
                outputStrings.push(exportQuoteWrapper + itemData + exportQuoteWrapper);
            }
        });
        return outputStrings.join(delimiter);
    };
    ExportService.ctorParameters = function () { return [
        { type: TranslateService, decorators: [{ type: Optional }] }
    ]; };
    ExportService = tslib_1.__decorate([
        Injectable(),
        tslib_1.__param(0, Optional())
    ], ExportService);
    return ExportService;
}());
export { ExportService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhwb3J0LnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9hbmd1bGFyLXNsaWNrZ3JpZC8iLCJzb3VyY2VzIjpbImFwcC9tb2R1bGVzL2FuZ3VsYXItc2xpY2tncmlkL3NlcnZpY2VzL2V4cG9ydC5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNyRCxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUN2RCxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDbEQsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUUvQixPQUFPLEVBR0wsUUFBUSxHQUlULE1BQU0sbUJBQW1CLENBQUM7QUFDM0IsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzNDLE9BQU8sRUFBRSw4QkFBOEIsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQ3BFLE9BQU8sRUFBRSxjQUFjLEVBQUUsb0JBQW9CLEVBQUUsZ0JBQWdCLEVBQUUsa0JBQWtCLEVBQUUsU0FBUyxFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFNaEk7SUFlRSx1QkFBZ0MsU0FBMkI7UUFBM0IsY0FBUyxHQUFULFNBQVMsQ0FBa0I7UUFkbkQsZUFBVSxHQUFHLEdBQUcsQ0FBQztRQUNqQixnQkFBVyxHQUFHLFFBQVEsQ0FBQyxHQUFHLENBQUM7UUFDM0Isd0JBQW1CLEdBQUcsSUFBSSxDQUFDO1FBSTNCLHdCQUFtQixHQUFHLEVBQUUsQ0FBQztRQUd6QixxQkFBZ0IsR0FBRyxLQUFLLENBQUM7UUFFakMsNkJBQXdCLEdBQUcsSUFBSSxPQUFPLEVBQVcsQ0FBQztRQUNsRCw0QkFBdUIsR0FBRyxJQUFJLE9BQU8sRUFBb0YsQ0FBQztJQUUzRCxDQUFDO0lBRWhFLHNCQUFZLHdDQUFhO2FBQXpCO1lBQ0UsT0FBTyxJQUFJLENB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QUM7YUFDekM7WUFFRCxJQUFJLE1BQU0sS0FBSyxRQUFRLENBQUMsR0FBRyxFQUFFO2dCQUMzQix1R0FBdUc7Z0JBQ3ZHLFFBQVEsR0FBRyxRQUFRLENBQUMsUUFBUSxFQUFFLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxNQUFJLENBQUMsQ0FBQzthQUNyRDtZQUVELGdEQUFnRDtZQUNoRCxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssS0FBSyxTQUFTLElBQUksU0FBUyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRTtnQkFDM0UsYUFBYSxDQUFDLElBQUksQ0FBQyxrQkFBa0IsR0FBRyxRQUFRLEdBQUcsa0JBQWtCLENBQUMsQ0FBQzthQUN4RTtRQUNILENBQUMsQ0FBQyxDQUFDO1FBRUgsT0FBTyxhQUFhLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ3ZDLENBQUM7O2dCQTFYMEMsZ0JBQWdCLHVCQUE5QyxRQUFROztJQWZWLGFBQWE7UUFEekIsVUFBVSxFQUFFO1FBZ0JFLG1CQUFBLFFBQVEsRUFBRSxDQUFBO09BZlosYUFBYSxDQTBZekI7SUFBRCxvQkFBQztDQUFBLEFBMVlELElBMFlDO1NBMVlZLGFBQWEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVHJhbnNsYXRlU2VydmljZSB9IGZyb20gJ0BuZ3gtdHJhbnNsYXRlL2NvcmUnO1xuaW1wb3J0IHsgVGV4dEVuY29kZXIgfSBmcm9tICd0ZXh0LWVuY29kaW5nLXV0Zi04JztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHtcbiAgQ29sdW1uLFxuICBFeHBvcnRPcHRpb24sXG4gIEZpbGVUeXBlLFxuICBHcmlkT3B0aW9uLFxuICBLZXlUaXRsZVBhaXIsXG4gIExvY2FsZSxcbn0gZnJvbSAnLi8uLi9tb2RlbHMvaW5kZXgnO1xuaW1wb3J0IHsgQ29uc3RhbnRzIH0gZnJvbSAnLi8uLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgZXhwb3J0V2l0aEZvcm1hdHRlcldoZW5EZWZpbmVkIH0gZnJvbSAnLi9leHBvcnQtdXRpbGl0aWVzJztcbmltcG9ydCB7IGFkZFdoaXRlU3BhY2VzLCBnZXRUcmFuc2xhdGlvblByZWZpeCwgaHRtbEVudGl0eURlY29kZSwgc2FuaXRpemVIdG1sVG9UZXh0LCB0aXRsZUNhc2UgfSBmcm9tICcuLy4uL3NlcnZpY2VzL3V0aWxpdGllcyc7XG5cbi8vIHVzaW5nIGV4dGVybmFsIG5vbi10eXBlZCBqcyBsaWJyYXJpZXNcbmRlY2xhcmUgbGV0ICQ6IGFueTtcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEV4cG9ydFNlcnZpY2Uge1xuICBwcml2YXRlIF9kZWxpbWl0ZXIgPSAnLCc7XG4gIHByaXZhdGUgX2ZpbGVGb3JtYXQgPSBGaWxlVHlwZS5jc3Y7XG4gIHByaXZhdGUgX2xpbmVDYXJyaWFnZVJldHVybiA9ICdcXG4nO1xuICBwcml2YXRlIF9kYXRhVmlldzogYW55O1xuICBwcml2YXRlIF9ncmlkOiBhbnk7XG4gIHByaXZhdGUgX2xvY2FsZXM6IExvY2FsZTtcbiAgcHJpdmF0ZSBfZXhwb3J0UXVvdGVXcmFwcGVyID0gJyc7XG4gIHByaXZhdGUgX2NvbHVtbkhlYWRlcnM6IEtleVRpdGxlUGFpcltdO1xuICBwcml2YXRlIF9ncm91cGVkQ29sdW1uSGVhZGVyczogS2V5VGl0bGVQYWlyW107XG4gIHByaXZhdGUgX2hhc0dyb3VwZWRJdGVtcyA9IGZhbHNlO1xuICBwcml2YXRlIF9leHBvcnRPcHRpb25zOiBFeHBvcnRPcHRpb247XG4gIG9uR3JpZEJlZm9yZUV4cG9ydFRvRmlsZSA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG4gIG9uR3JpZEFmdGVyRXhwb3J0VG9GaWxlID0gbmV3IFN1YmplY3Q8eyBjb250ZW50Pzogc3RyaW5nOyBmaWxlbmFtZTogc3RyaW5nOyBmb3JtYXQ6IHN0cmluZzsgdXNlVXRmOFdpdGhCb206IGJvb2xlYW47IH0+KCk7XG5cbiAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgcHJpdmF0ZSB0cmFuc2xhdGU6IFRyYW5zbGF0ZVNlcnZpY2UpIHsgfVxuXG4gIHByaXZhdGUgZ2V0IGRhdGFzZXRJZE5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fZ3JpZE9wdGlvbnMgJiYgdGhpcy5fZ3JpZE9wdGlvbnMuZGF0YXNldElkUHJvcGVydHlOYW1lIHx8ICdpZCc7XG4gIH1cblxuICAvKiogR2V0dGVyIGZvciB0aGUgR3JpZCBPcHRpb25zIHB1bGxlZCB0aHJvdWdoIHRoZSBHcmlkIE9iamVjdCAqL1xuICBwcml2YXRlIGdldCBfZ3JpZE9wdGlvbnMoKTogR3JpZE9wdGlvbiB7XG4gICAgcmV0dXJuICh0aGlzLl9ncmlkICYmIHRoaXMuX2dyaWQuZ2V0T3B0aW9ucykgPyB0aGlzLl9ncmlkLmdldE9wdGlvbnMoKSA6IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIEV4cG9ydCBTZXJ2aWNlXG4gICAqIEBwYXJhbSBncmlkXG4gICAqIEBwYXJhbSBncmlkT3B0aW9uc1xuICAgKiBAcGFyYW0gZGF0YVZpZXdcbiAgICovXG4gIGluaXQoZ3JpZDogYW55LCBkYXRhVmlldzogYW55KTogdm9pZCB7XG4gICAgdGhpcy5fZ3JpZCA9IGdyaWQ7XG4gICAgdGhpcy5fZGF0YVZpZXcgPSBkYXRhVmlldztcblxuICAgIC8vIGdldCBsb2NhbGVzIHByb3ZpZGVkIGJ5IHVzZXIgaW4gZm9yUm9vdCBvciBlbHNlIHVzZSBkZWZhdWx0IEVuZ2xpc2ggbG9jYWxlcyB2aWEgdGhlIENvbnN0YW50c1xuICAgIHRoaXMuX2xvY2FsZXMgPSB0aGlzLl9ncmlkT3B0aW9ucyAmJiB0aGlzLl9ncmlkT3B0aW9ucy5sb2NhbGVzIHx8IENvbnN0YW50cy5sb2NhbGVzO1xuXG4gICAgaWYgKHRoaXMuX2dyaWRPcHRpb25zLmVuYWJsZVRyYW5zbGF0ZSAmJiAoIXRoaXMudHJhbnNsYXRlIHx8ICF0aGlzLnRyYW5zbGF0ZS5pbnN0YW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdbQW5ndWxhci1TbGlja2dyaWRdIHJlcXVpcmVzIFwibmd4LXRyYW5zbGF0ZVwiIHRvIGJlIGluc3RhbGxlZCBhbmQgY29uZmlndXJlZCB3aGVuIHRoZSBncmlkIG9wdGlvbiBcImVuYWJsZVRyYW5zbGF0ZVwiIGlzIGVuYWJsZWQuJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIHRvIGV4cG9ydCB0aGUgR3JpZCByZXN1bHQgdG8gYW4gRXhjZWwgQ1NWIGZvcm1hdCB1c2luZyBqYXZhc2NyaXB0IGZvciBpdCB0byBwcm9kdWNlIHRoZSBDU1YgZmlsZS5cbiAgICogVGhpcyBpcyBhIFdZU0lXWUcgZXhwb3J0IHRvIGZpbGUgb3V0cHV0IChXaGF0IFlvdSBTZWUgaXMgV2hhdCBZb3UgR2V0KVxuICAgKlxuICAgKiBOT1RFUzogVGhlIGNvbHVtbiBwb3NpdGlvbiBuZWVkcyB0byBtYXRjaCBwZXJmZWN0bHkgdGhlIEpTT04gT2JqZWN0IHBvc2l0aW9uIGJlY2F1c2Ugb2YgdGhlIHdheSB3ZSBhcmUgcHVsbGluZyB0aGUgZGF0YSxcbiAgICogd2hpY2ggbWVhbnMgdGhhdCBpZiBhbnkgY29sdW1uKHMpIGdvdCBtb3ZlZCBpbiB0aGUgVUksIGl0IGhhcyB0byBiZSByZWZsZWN0ZWQgaW4gdGhlIEpTT04gYXJyYXkgb3V0cHV0IGFzIHdlbGxcbiAgICpcbiAgICogRXhhbXBsZTogZXhwb3J0VG9GaWxlKHsgZm9ybWF0OiBGaWxlVHlwZS5jc3YsIGRlbGltaXRlcjogRGVsaW1pdGVyVHlwZS5jb21tYSB9KVxuICAgKi9cbiAgZXhwb3J0VG9GaWxlKG9wdGlvbnM6IEV4cG9ydE9wdGlvbik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmICghdGhpcy5fZ3JpZCB8fCAhdGhpcy5fZGF0YVZpZXcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignW0FuZ3VsYXItU2xpY2tncmlkXSBpdCBzZWVtcyB0aGF0IHRoZSBTbGlja0dyaWQgJiBEYXRhVmlldyBvYmplY3RzIGFyZSBub3QgaW5pdGlhbGl6ZWQgZGlkIHlvdSBmb3JnZXQgdG8gZW5hYmxlIHRoZSBncmlkIG9wdGlvbiBmbGFnIFwiZW5hYmxlRXhjZWxFeHBvcnRcIj8nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5vbkdyaWRCZWZvcmVFeHBvcnRUb0ZpbGUubmV4dCh0cnVlKTtcbiAgICAgIHRoaXMuX2V4cG9ydE9wdGlvbnMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgdGhpcy5fZ3JpZE9wdGlvbnMuZXhwb3J0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICB0aGlzLl9kZWxpbWl0ZXIgPSB0aGlzLl9leHBvcnRPcHRpb25zLmRlbGltaXRlck92ZXJyaWRlIHx8IHRoaXMuX2V4cG9ydE9wdGlvbnMuZGVsaW1pdGVyIHx8ICcnO1xuICAgICAgdGhpcy5fZmlsZUZvcm1hdCA9IHRoaXMuX2V4cG9ydE9wdGlvbnMuZm9ybWF0IHx8IEZpbGVUeXBlLmNzdjtcblxuICAgICAgLy8gZ2V0IHRoZSBDU1Ygb3V0cHV0IGZyb20gdGhlIGdyaWQgZGF0YVxuICAgICAgY29uc3QgZGF0YU91dHB1dCA9IHRoaXMuZ2V0RGF0YU91dHB1dCgpO1xuXG4gICAgICAvLyB0cmlnZ2VyIGEgZG93bmxvYWQgZmlsZVxuICAgICAgLy8gd3JhcCBpdCBpbnRvIGEgc2V0VGltZW91dCBzbyB0aGF0IHRoZSBFdmVudEFnZ3JlZ2F0b3IgaGFzIGVub3VnaCB0aW1lIHRvIHN0YXJ0IGEgcHJlLXByb2Nlc3MgbGlrZSBzaG93aW5nIGEgc3Bpbm5lclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgZG93bmxvYWRPcHRpb25zID0ge1xuICAgICAgICAgICAgZmlsZW5hbWU6IGAke3RoaXMuX2V4cG9ydE9wdGlvbnMuZmlsZW5hbWV9LiR7dGhpcy5fZmlsZUZvcm1hdH1gLFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLl9maWxlRm9ybWF0LFxuICAgICAgICAgICAgdXNlVXRmOFdpdGhCb206IHRoaXMuX2V4cG9ydE9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ3VzZVV0ZjhXaXRoQm9tJykgPyB0aGlzLl9leHBvcnRPcHRpb25zLnVzZVV0ZjhXaXRoQm9tIDogdHJ1ZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBzdGFydCBkb3dubG9hZGluZyBidXQgYWRkIHRoZSBjb250ZW50IHByb3BlcnR5IG9ubHkgb24gdGhlIHN0YXJ0IGRvd25sb2FkIG5vdCBvbiB0aGUgZXZlbnQgaXRzZWxmXG4gICAgICAgICAgdGhpcy5zdGFydERvd25sb2FkRmlsZSh7IC4uLmRvd25sb2FkT3B0aW9ucywgY29udGVudDogZGF0YU91dHB1dCB9KTsgLy8gYWRkIGNvbnRlbnQgcHJvcGVydHlcbiAgICAgICAgICB0aGlzLm9uR3JpZEFmdGVyRXhwb3J0VG9GaWxlLm5leHQoZG93bmxvYWRPcHRpb25zKTtcbiAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0sIDApO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyaWdnZXJzIGRvd25sb2FkIGZpbGUgd2l0aCBmaWxlIGZvcm1hdC5cbiAgICogSUUoNi0xMCkgYXJlIG5vdCBzdXBwb3J0ZWRcbiAgICogQWxsIG90aGVyIGJyb3dzZXJzIHdpbGwgdXNlIHBsYWluIGphdmFzY3JpcHQgb24gY2xpZW50IHNpZGUgdG8gcHJvZHVjZSBhIGZpbGUgZG93bmxvYWQuXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqL1xuICBzdGFydERvd25sb2FkRmlsZShvcHRpb25zOiB7IGZpbGVuYW1lOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZywgZm9ybWF0OiBGaWxlVHlwZSB8IHN0cmluZywgdXNlVXRmOFdpdGhCb206IGJvb2xlYW4gfSkge1xuICAgIC8vIElFKDYtMTApIGRvbid0IHN1cHBvcnQgamF2YXNjcmlwdCBkb3dubG9hZCBhbmQgb3VyIHNlcnZpY2UgZG9lc24ndCBzdXBwb3J0IGVpdGhlciBzbyB0aHJvdyBhbiBlcnJvciwgd2UgaGF2ZSB0byBtYWtlIGEgcm91bmQgdHJpcCB0byB0aGUgV2ViIFNlcnZlciBmb3IgZXhwb3J0aW5nXG4gICAgaWYgKG5hdmlnYXRvci5hcHBOYW1lID09PSAnTWljcm9zb2Z0IEludGVybmV0IEV4cGxvcmVyJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaWNyb3NvZnQgSW50ZXJuZXQgRXhwbG9yZXIgNiB0byAxMCBkbyBub3Qgc3VwcG9ydCBqYXZhc2NyaXB0IGV4cG9ydCB0byBDU1YuIFBsZWFzZSB1cGdyYWRlIHlvdXIgYnJvd3Nlci4nKTtcbiAgICB9XG5cbiAgICAvLyBzZXQgdGhlIGNvcnJlY3QgTUlNRSB0eXBlXG4gICAgY29uc3QgbWltZVR5cGUgPSAob3B0aW9ucy5mb3JtYXQgPT09IEZpbGVUeXBlLmNzdikgPyAndGV4dC9jc3YnIDogJ3RleHQvcGxhaW4nO1xuXG4gICAgLy8gbWFrZSBzdXJlIG5vIGh0bWwgZW50aXRpZXMgZXhpc3QgaW4gdGhlIGRhdGFcbiAgICBjb25zdCBkYXRhQ29udGVudCA9IGh0bWxFbnRpdHlEZWNvZGUob3B0aW9ucy5jb250ZW50KTtcblxuICAgIC8vIGRlYWxpbmcgd2l0aCBFeGNlbCBDU1YgZXhwb3J0IGFuZCBVVEYtOCBpcyBhIGxpdHRsZSB0cmlja3kuLiBXZSB3aWxsIHVzZSBPcHRpb24gIzIgdG8gY292ZXIgb2xkZXIgRXhjZWwgdmVyc2lvbnNcbiAgICAvLyBPcHRpb24gIzE6IHdlIG5lZWQgdG8gbWFrZSBFeGNlbCBrbm93aW5nIHRoYXQgaXQncyBkZWFsaW5nIHdpdGggYW4gVVRGLTgsIEEgY29ycmVjdGx5IGZvcm1hdHRlZCBVVEY4IGZpbGUgY2FuIGhhdmUgYSBCeXRlIE9yZGVyIE1hcmsgYXMgaXRzIGZpcnN0IHRocmVlIG9jdGV0c1xuICAgIC8vIHJlZmVyZW5jZTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNTUwOTcvbWljcm9zb2Z0LWV4Y2VsLW1hbmdsZXMtZGlhY3JpdGljcy1pbi1jc3YtZmlsZXNcbiAgICAvLyBPcHRpb24jMjogdXNlIGEgM3JkIHBhcnR5IGV4dGVuc2lvbiB0byBqYXZhc2NyaXB0IGVuY29kZSBpbnRvIFVURi0xNlxuICAgIGxldCBvdXRwdXREYXRhOiBVaW50OEFycmF5IHwgc3RyaW5nO1xuICAgIGlmIChvcHRpb25zLmZvcm1hdCA9PT0gRmlsZVR5cGUuY3N2KSB7XG4gICAgICBvdXRwdXREYXRhID0gbmV3IFRleHRFbmNvZGVyKCd1dGYtOCcpLmVuY29kZShkYXRhQ29udGVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dERhdGEgPSBkYXRhQ29udGVudDtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgYSBCbG9iIG9iamVjdCBmb3IgdGhlIGRvd25sb2FkXG4gICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtvcHRpb25zLnVzZVV0ZjhXaXRoQm9tID8gJ1xcdUZFRkYnIDogJycsIG91dHB1dERhdGFdLCB7XG4gICAgICB0eXBlOiBgJHttaW1lVHlwZX07Y2hhcnNldD11dGYtODtgXG4gICAgfSk7XG5cbiAgICAvLyB3aGVuIHVzaW5nIElFL0VkZ2UsIHRoZW4gdXNlIGRpZmZlcmVudCBkb3dubG9hZCBjYWxsXG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbmF2aWdhdG9yLm1zU2F2ZU9yT3BlbkJsb2IoYmxvYiwgb3B0aW9ucy5maWxlbmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRoaXMgdHJpY2sgd2lsbCBnZW5lcmF0ZSBhIHRlbXAgPGEgLz4gdGFnXG4gICAgICAvLyB0aGUgY29kZSB3aWxsIHRoZW4gdHJpZ2dlciBhIGhpZGRlbiBjbGljayBmb3IgaXQgdG8gc3RhcnQgZG93bmxvYWRpbmdcbiAgICAgIGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICBjb25zdCBjc3ZVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXG4gICAgICBsaW5rLnRleHRDb250ZW50ID0gJ2Rvd25sb2FkJztcbiAgICAgIGxpbmsuaHJlZiA9IGNzdlVybDtcbiAgICAgIGxpbmsuc2V0QXR0cmlidXRlKCdkb3dubG9hZCcsIG9wdGlvbnMuZmlsZW5hbWUpO1xuXG4gICAgICAvLyBzZXQgdGhlIHZpc2liaWxpdHkgdG8gaGlkZGVuIHNvIHRoZXJlIGlzIG5vIGVmZmVjdCBvbiB5b3VyIHdlYi1sYXlvdXRcbiAgICAgIGxpbmsuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuXG4gICAgICAvLyB0aGlzIHBhcnQgd2lsbCBhcHBlbmQgdGhlIGFuY2hvciB0YWcsIHRyaWdnZXIgYSBjbGljayAoZm9yIGRvd25sb2FkIHRvIHN0YXJ0KSBhbmQgZmluYWxseSByZW1vdmUgdGhlIHRhZyBvbmNlIGNvbXBsZXRlZFxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChsaW5rKTtcbiAgICAgIGxpbmsuY2xpY2soKTtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQobGluayk7XG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gUHJpdmF0ZSBmdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBwcml2YXRlIGdldERhdGFPdXRwdXQoKTogc3RyaW5nIHtcbiAgICBjb25zdCBjb2x1bW5zID0gdGhpcy5fZ3JpZC5nZXRDb2x1bW5zKCkgfHwgW107XG5cbiAgICAvLyBHcm91cCBCeSB0ZXh0LCBpdCBjb3VsZCBiZSBzZXQgaW4gdGhlIGV4cG9ydCBvcHRpb25zIG9yIGZyb20gdHJhbnNsYXRpb24gb3IgaWYgbm90aGluZyBpcyBmb3VuZCB0aGVuIHVzZSB0aGUgRW5nbGlzaCBjb25zdGFudCB0ZXh0XG4gICAgbGV0IGdyb3VwQnlDb2x1bW5IZWFkZXIgPSB0aGlzLl9leHBvcnRPcHRpb25zLmdyb3VwaW5nQ29sdW1uSGVhZGVyVGl0bGU7XG4gICAgaWYgKCFncm91cEJ5Q29sdW1uSGVhZGVyICYmIHRoaXMuX2dyaWRPcHRpb25zLmVuYWJsZVRyYW5zbGF0ZSAmJiB0aGlzLnRyYW5zbGF0ZSAmJiB0aGlzLnRyYW5zbGF0ZS5jdXJyZW50TGFuZyAmJiB0aGlzLnRyYW5zbGF0ZS5pbnN0YW50KSB7XG4gICAgICBncm91cEJ5Q29sdW1uSGVhZGVyID0gdGhpcy50cmFuc2xhdGUuaW5zdGFudChgJHtnZXRUcmFuc2xhdGlvblByZWZpeCh0aGlzLl9ncmlkT3B0aW9ucyl9R1JPVVBfQllgKTtcbiAgICB9IGVsc2UgaWYgKCFncm91cEJ5Q29sdW1uSGVhZGVyKSB7XG4gICAgICBncm91cEJ5Q29sdW1uSGVhZGVyID0gdGhpcy5fbG9jYWxlcyAmJiB0aGlzLl9sb2NhbGVzLlRFWFRfR1JPVVBfQlk7XG4gICAgfVxuXG4gICAgLy8gYSBDU1YgbmVlZHMgZG91YmxlIHF1b3RlcyB3cmFwcGVyLCB0aGUgb3RoZXIgdHlwZXMgZG8gbm90IG5lZWQgYW55IHdyYXBwZXJcbiAgICB0aGlzLl9leHBvcnRRdW90ZVdyYXBwZXIgPSAodGhpcy5fZmlsZUZvcm1hdCA9PT0gRmlsZVR5cGUuY3N2KSA/ICdcIicgOiAnJztcblxuICAgIC8vIGRhdGEgdmFyaWFibGUgd2hpY2ggd2lsbCBob2xkIGFsbCB0aGUgZmllbGRzIGRhdGEgb2YgYSByb3dcbiAgICBsZXQgb3V0cHV0RGF0YVN0cmluZyA9ICcnO1xuXG4gICAgLy8gZ2V0IGdyb3VwZWQgY29sdW1uIHRpdGxlcyBhbmQgaWYgZm91bmQsIHdlIHdpbGwgYWRkIGEgXCJHcm91cCBieVwiIGNvbHVtbiBhdCB0aGUgZmlyc3QgY29sdW1uIGluZGV4XG4gICAgLy8gaWYgaXQncyBhIENTViBmb3JtYXQsIHdlJ2xsIGVzY2FwZSB0aGUgdGV4dCBpbiBkb3VibGUgcXVvdGVzXG4gICAgY29uc3QgZ3JvdXBpbmcgPSB0aGlzLl9kYXRhVmlldy5nZXRHcm91cGluZygpO1xuICAgIGlmIChncm91cGluZyAmJiBBcnJheS5pc0FycmF5KGdyb3VwaW5nKSAmJiBncm91cGluZy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLl9oYXNHcm91cGVkSXRlbXMgPSB0cnVlO1xuICAgICAgb3V0cHV0RGF0YVN0cmluZyArPSAodGhpcy5fZmlsZUZvcm1hdCA9PT0gRmlsZVR5cGUuY3N2KSA/IGBcIiR7Z3JvdXBCeUNvbHVtbkhlYWRlcn1cIiR7dGhpcy5fZGVsaW1pdGVyfWAgOiBgJHtncm91cEJ5Q29sdW1uSGVhZGVyfSR7dGhpcy5fZGVsaW1pdGVyfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2hhc0dyb3VwZWRJdGVtcyA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGdldCBhbGwgR3JvdXBlZCBDb2x1bW4gSGVhZGVyIFRpdGxlcyB3aGVuIGRlZmluZWQgKGZyb20gcHJlLWhlYWRlciByb3cpXG4gICAgaWYgKHRoaXMuX2dyaWRPcHRpb25zLmNyZWF0ZVByZUhlYWRlclBhbmVsICYmIHRoaXMuX2dyaWRPcHRpb25zLnNob3dQcmVIZWFkZXJQYW5lbCAmJiAhdGhpcy5fZ3JpZE9wdGlvbnMuZW5hYmxlRHJhZ2dhYmxlR3JvdXBpbmcpIHtcbiAgICAgIHRoaXMuX2dyb3VwZWRDb2x1bW5IZWFkZXJzID0gdGhpcy5nZXRDb2x1bW5Hcm91cGVkSGVhZGVyVGl0bGVzKGNvbHVtbnMpIHx8IFtdO1xuICAgICAgaWYgKHRoaXMuX2dyb3VwZWRDb2x1bW5IZWFkZXJzICYmIEFycmF5LmlzQXJyYXkodGhpcy5fZ3JvdXBlZENvbHVtbkhlYWRlcnMpICYmIHRoaXMuX2dyb3VwZWRDb2x1bW5IZWFkZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gYWRkIHRoZSBoZWFkZXIgcm93ICsgYWRkIGEgbmV3IGxpbmUgYXQgdGhlIGVuZCBvZiB0aGUgcm93XG4gICAgICAgIGNvbnN0IG91dHB1dEdyb3VwZWRIZWFkZXJUaXRsZXMgPSB0aGlzLl9ncm91cGVkQ29sdW1uSGVhZGVycy5tYXAoKGhlYWRlcikgPT4gYCR7dGhpcy5fZXhwb3J0UXVvdGVXcmFwcGVyfSR7aGVhZGVyLnRpdGxlfSR7dGhpcy5fZXhwb3J0UXVvdGVXcmFwcGVyfWApO1xuICAgICAgICBvdXRwdXREYXRhU3RyaW5nICs9IChvdXRwdXRHcm91cGVkSGVhZGVyVGl0bGVzLmpvaW4odGhpcy5fZGVsaW1pdGVyKSArIHRoaXMuX2xpbmVDYXJyaWFnZVJldHVybik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZ2V0IGFsbCBDb2x1bW4gSGVhZGVyIFRpdGxlc1xuICAgIHRoaXMuX2NvbHVtbkhlYWRlcnMgPSB0aGlzLmdldENvbHVtbkhlYWRlcnMoY29sdW1ucykgfHwgW107XG4gICAgaWYgKHRoaXMuX2NvbHVtbkhlYWRlcnMgJiYgQXJyYXkuaXNBcnJheSh0aGlzLl9jb2x1bW5IZWFkZXJzKSAmJiB0aGlzLl9jb2x1bW5IZWFkZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIGFkZCB0aGUgaGVhZGVyIHJvdyArIGFkZCBhIG5ldyBsaW5lIGF0IHRoZSBlbmQgb2YgdGhlIHJvd1xuICAgICAgY29uc3Qgb3V0cHV0SGVhZGVyVGl0bGVzID0gdGhpcy5fY29sdW1uSGVhZGVycy5tYXAoKGhlYWRlcikgPT4gYCR7dGhpcy5fZXhwb3J0UXVvdGVXcmFwcGVyfSR7aGVhZGVyLnRpdGxlfSR7dGhpcy5fZXhwb3J0UXVvdGVXcmFwcGVyfWApO1xuICAgICAgb3V0cHV0RGF0YVN0cmluZyArPSAob3V0cHV0SGVhZGVyVGl0bGVzLmpvaW4odGhpcy5fZGVsaW1pdGVyKSArIHRoaXMuX2xpbmVDYXJyaWFnZVJldHVybik7XG4gICAgfVxuXG4gICAgLy8gUG9wdWxhdGUgdGhlIHJlc3Qgb2YgdGhlIEdyaWQgRGF0YVxuICAgIG91dHB1dERhdGFTdHJpbmcgKz0gdGhpcy5nZXRBbGxHcmlkUm93RGF0YShjb2x1bW5zLCB0aGlzLl9saW5lQ2FycmlhZ2VSZXR1cm4pO1xuXG4gICAgcmV0dXJuIG91dHB1dERhdGFTdHJpbmc7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCB0aGUgZ3JpZCByb3cgZGF0YSBhbmQgcmV0dXJuIHRoYXQgYXMgYW4gb3V0cHV0IHN0cmluZ1xuICAgKi9cbiAgcHJpdmF0ZSBnZXRBbGxHcmlkUm93RGF0YShjb2x1bW5zOiBDb2x1bW5bXSwgbGluZUNhcnJpYWdlUmV0dXJuOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IG91dHB1dERhdGFTdHJpbmdzID0gW107XG4gICAgY29uc3QgbGluZUNvdW50ID0gdGhpcy5fZGF0YVZpZXcuZ2V0TGVuZ3RoKCk7XG5cbiAgICAvLyBsb29wIHRocm91Z2ggYWxsIHRoZSBncmlkIHJvd3Mgb2YgZGF0YVxuICAgIGZvciAobGV0IHJvd051bWJlciA9IDA7IHJvd051bWJlciA8IGxpbmVDb3VudDsgcm93TnVtYmVyKyspIHtcbiAgICAgIGNvbnN0IGl0ZW1PYmogPSB0aGlzLl9kYXRhVmlldy5nZXRJdGVtKHJvd051bWJlcik7XG4gICAgICBpZiAoaXRlbU9iaikge1xuICAgICAgICAvLyBOb3JtYWwgcm93IChub3QgZ3JvdXBlZCBieSBhbnl0aGluZykgd291bGQgaGF2ZSBhbiBJRCB3aGljaCB3YXMgcHJlZGVmaW5lZCBpbiB0aGUgR3JpZCBDb2x1bW5zIGRlZmluaXRpb25cbiAgICAgICAgaWYgKGl0ZW1PYmpbdGhpcy5kYXRhc2V0SWROYW1lXSAhPT0gbnVsbCAmJiBpdGVtT2JqW3RoaXMuZGF0YXNldElkTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIGdldCByZWd1bGFyIHJvdyBpdGVtIGRhdGFcbiAgICAgICAgICBvdXRwdXREYXRhU3RyaW5ncy5wdXNoKHRoaXMucmVhZFJlZ3VsYXJSb3dEYXRhKGNvbHVtbnMsIHJvd051bWJlciwgaXRlbU9iaikpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2hhc0dyb3VwZWRJdGVtcyAmJiBpdGVtT2JqLl9fZ3JvdXBUb3RhbHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIGdldCB0aGUgZ3JvdXAgcm93XG4gICAgICAgICAgb3V0cHV0RGF0YVN0cmluZ3MucHVzaCh0aGlzLnJlYWRHcm91cGVkVGl0bGVSb3coaXRlbU9iaikpO1xuICAgICAgICB9IGVsc2UgaWYgKGl0ZW1PYmouX19ncm91cFRvdGFscykge1xuICAgICAgICAgIC8vIGVsc2UgaWYgdGhlIHJvdyBpcyBhIEdyb3VwIEJ5IGFuZCB3ZSBoYXZlIGFncmVnZ2F0b3JzLCB0aGVuIGEgcHJvcGVydHkgb2YgJ19fZ3JvdXBUb3RhbHMnIHdvdWxkIGV4aXN0IHVuZGVyIHRoYXQgb2JqZWN0XG4gICAgICAgICAgb3V0cHV0RGF0YVN0cmluZ3MucHVzaCh0aGlzLnJlYWRHcm91cGVkVG90YWxSb3coY29sdW1ucywgaXRlbU9iaikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dERhdGFTdHJpbmdzLmpvaW4obGluZUNhcnJpYWdlUmV0dXJuKTtcbiAgfVxuXG4gIC8qKlxuICogR2V0IGFsbCBHcm91cGVkIEhlYWRlciBUaXRsZXMgYW5kIHRoZWlyIGtleXMsIHRyYW5zbGF0ZSB0aGUgdGl0bGUgd2hlbiByZXF1aXJlZC5cbiAqIEBwYXJhbSB7QXJyYXk8b2JqZWN0Pn0gY29sdW1ucyBvZiB0aGUgZ3JpZFxuICovXG4gIHByaXZhdGUgZ2V0Q29sdW1uR3JvdXBlZEhlYWRlclRpdGxlcyhjb2x1bW5zOiBDb2x1bW5bXSk6IEtleVRpdGxlUGFpcltdIHtcbiAgICBjb25zdCBncm91cGVkQ29sdW1uSGVhZGVyczogS2V5VGl0bGVQYWlyW10gPSBbXTtcblxuICAgIGlmIChjb2x1bW5zICYmIEFycmF5LmlzQXJyYXkoY29sdW1ucykpIHtcbiAgICAgIC8vIFBvcHVsYXRlIHRoZSBHcm91cGVkIENvbHVtbiBIZWFkZXIsIHB1bGwgdGhlIGNvbHVtbkdyb3VwKEtleSkgZGVmaW5lZFxuICAgICAgY29sdW1ucy5mb3JFYWNoKChjb2x1bW5EZWYpID0+IHtcbiAgICAgICAgbGV0IGdyb3VwZWRIZWFkZXJUaXRsZSA9ICcnO1xuICAgICAgICBpZiAoKGNvbHVtbkRlZi5jb2x1bW5Hcm91cEtleSB8fCBjb2x1bW5EZWYuY29sdW1uR3JvdXBLZXkpICYmIHRoaXMuX2dyaWRPcHRpb25zLmVuYWJsZVRyYW5zbGF0ZSAmJiB0aGlzLnRyYW5zbGF0ZSAmJiB0aGlzLnRyYW5zbGF0ZS5jdXJyZW50TGFuZyAmJiB0aGlzLnRyYW5zbGF0ZS5pbnN0YW50KSB7XG4gICAgICAgICAgZ3JvdXBlZEhlYWRlclRpdGxlID0gdGhpcy50cmFuc2xhdGUuaW5zdGFudCgoY29sdW1uRGVmLmNvbHVtbkdyb3VwS2V5IHx8IGNvbHVtbkRlZi5jb2x1bW5Hcm91cEtleSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdyb3VwZWRIZWFkZXJUaXRsZSA9IGNvbHVtbkRlZi5jb2x1bW5Hcm91cCB8fCAnJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBza2lwcGVkRmllbGQgPSBjb2x1bW5EZWYuZXhjbHVkZUZyb21FeHBvcnQgfHwgZmFsc2U7XG5cbiAgICAgICAgLy8gaWYgY29sdW1uIHdpZHRoIGlzIDBweCwgdGhlbiB3ZSBjb25zaWRlciB0aGF0IGZpZWxkIGFzIGEgaGlkZGVuIGZpZWxkIGFuZCBzaG91bGQgbm90IGJlIHBhcnQgb2YgdGhlIGV4cG9ydFxuICAgICAgICBpZiAoKGNvbHVtbkRlZi53aWR0aCA9PT0gdW5kZWZpbmVkIHx8IGNvbHVtbkRlZi53aWR0aCA+IDApICYmICFza2lwcGVkRmllbGQpIHtcbiAgICAgICAgICBncm91cGVkQ29sdW1uSGVhZGVycy5wdXNoKHtcbiAgICAgICAgICAgIGtleTogKGNvbHVtbkRlZi5maWVsZCB8fCBjb2x1bW5EZWYuaWQpIGFzIHN0cmluZyxcbiAgICAgICAgICAgIHRpdGxlOiBncm91cGVkSGVhZGVyVGl0bGUgfHwgJydcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBncm91cGVkQ29sdW1uSGVhZGVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIGhlYWRlciB0aXRsZXMgYW5kIHRoZWlyIGtleXMsIHRyYW5zbGF0ZSB0aGUgdGl0bGUgd2hlbiByZXF1aXJlZC5cbiAgICogQHBhcmFtIHtBcnJheTxvYmplY3Q+fSBjb2x1bW5zIG9mIHRoZSBncmlkXG4gICAqL1xuICBwcml2YXRlIGdldENvbHVtbkhlYWRlcnMoY29sdW1uczogQ29sdW1uW10pOiBLZXlUaXRsZVBhaXJbXSB7XG4gICAgY29uc3QgY29sdW1uSGVhZGVycyA9IFtdO1xuXG4gICAgaWYgKGNvbHVtbnMgJiYgQXJyYXkuaXNBcnJheShjb2x1bW5zKSkge1xuICAgICAgLy8gUG9wdWxhdGUgdGhlIENvbHVtbiBIZWFkZXIsIHB1bGwgdGhlIG5hbWUgZGVmaW5lZFxuICAgICAgY29sdW1ucy5mb3JFYWNoKChjb2x1bW5EZWYpID0+IHtcbiAgICAgICAgbGV0IGhlYWRlclRpdGxlID0gJyc7XG4gICAgICAgIGlmICgoY29sdW1uRGVmLmhlYWRlcktleSB8fCBjb2x1bW5EZWYubmFtZUtleSkgJiYgdGhpcy5fZ3JpZE9wdGlvbnMuZW5hYmxlVHJhbnNsYXRlICYmIHRoaXMudHJhbnNsYXRlICYmIHRoaXMudHJhbnNsYXRlLmN1cnJlbnRMYW5nICYmIHRoaXMudHJhbnNsYXRlLmluc3RhbnQpIHtcbiAgICAgICAgICBoZWFkZXJUaXRsZSA9IHRoaXMudHJhbnNsYXRlLmluc3RhbnQoKGNvbHVtbkRlZi5oZWFkZXJLZXkgfHwgY29sdW1uRGVmLm5hbWVLZXkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoZWFkZXJUaXRsZSA9IGNvbHVtbkRlZi5uYW1lIHx8IHRpdGxlQ2FzZShjb2x1bW5EZWYuZmllbGQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNraXBwZWRGaWVsZCA9IGNvbHVtbkRlZi5leGNsdWRlRnJvbUV4cG9ydCB8fCBmYWxzZTtcblxuICAgICAgICAvLyBpZiBjb2x1bW4gd2lkdGggaXMgMCwgdGhlbiB3ZSBjb25zaWRlciB0aGF0IGZpZWxkIGFzIGEgaGlkZGVuIGZpZWxkIGFuZCBzaG91bGQgbm90IGJlIHBhcnQgb2YgdGhlIGV4cG9ydFxuICAgICAgICBpZiAoKGNvbHVtbkRlZi53aWR0aCA9PT0gdW5kZWZpbmVkIHx8IGNvbHVtbkRlZi53aWR0aCA+IDApICYmICFza2lwcGVkRmllbGQpIHtcbiAgICAgICAgICBjb2x1bW5IZWFkZXJzLnB1c2goe1xuICAgICAgICAgICAga2V5OiBjb2x1bW5EZWYuZmllbGQgfHwgY29sdW1uRGVmLmlkLFxuICAgICAgICAgICAgdGl0bGU6IGhlYWRlclRpdGxlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBjb2x1bW5IZWFkZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGF0YSBvZiBhIHJlZ3VsYXIgcm93IChhIHJvdyB3aXRob3V0IGdyb3VwaW5nKVxuICAgKiBAcGFyYW0gcm93XG4gICAqIEBwYXJhbSBpdGVtT2JqXG4gICAqL1xuICBwcml2YXRlIHJlYWRSZWd1bGFyUm93RGF0YShjb2x1bW5zOiBDb2x1bW5bXSwgcm93OiBudW1iZXIsIGl0ZW1PYmo6IGFueSkge1xuICAgIGxldCBpZHggPSAwO1xuICAgIGNvbnN0IHJvd091dHB1dFN0cmluZ3MgPSBbXTtcbiAgICBjb25zdCBleHBvcnRRdW90ZVdyYXBwZXIgPSB0aGlzLl9leHBvcnRRdW90ZVdyYXBwZXI7XG5cbiAgICBmb3IgKGxldCBjb2wgPSAwLCBsbiA9IGNvbHVtbnMubGVuZ3RoOyBjb2wgPCBsbjsgY29sKyspIHtcbiAgICAgIGNvbnN0IGNvbHVtbkRlZiA9IGNvbHVtbnNbY29sXTtcblxuICAgICAgLy8gc2tpcCBleGNsdWRlZCBjb2x1bW5cbiAgICAgIGlmIChjb2x1bW5EZWYuZXhjbHVkZUZyb21FeHBvcnQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHdlIGFyZSBncm91cGluZyBhbmQgYXJlIG9uIDFzdCBjb2x1bW4gaW5kZXgsIHdlIG5lZWQgdG8gc2tpcCB0aGlzIGNvbHVtbiBzaW5jZSBpdCB3aWxsIGJlIHVzZWQgbGF0ZXIgYnkgdGhlIGdyb3VwaW5nIHRleHQ6OiBHcm91cCBieSBbY29sdW1uWF1cbiAgICAgIGlmICh0aGlzLl9oYXNHcm91cGVkSXRlbXMgJiYgaWR4ID09PSAwKSB7XG4gICAgICAgIGNvbnN0IGVtcHR5VmFsdWUgPSB0aGlzLl9maWxlRm9ybWF0ID09PSBGaWxlVHlwZS5jc3YgPyBgXCJcImAgOiAnJztcbiAgICAgICAgcm93T3V0cHV0U3RyaW5ncy5wdXNoKGVtcHR5VmFsdWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBnZXQgdGhlIG91dHB1dCBieSBhbmFseXppbmcgaWYgd2UnbGwgcHVsbCB0aGUgdmFsdWUgZnJvbSB0aGUgY2VsbCBvciBmcm9tIGEgZm9ybWF0dGVyXG4gICAgICBsZXQgaXRlbURhdGEgPSBleHBvcnRXaXRoRm9ybWF0dGVyV2hlbkRlZmluZWQocm93LCBjb2wsIGl0ZW1PYmosIGNvbHVtbkRlZiwgdGhpcy5fZ3JpZCwgdGhpcy5fZXhwb3J0T3B0aW9ucyk7XG5cbiAgICAgIC8vIGRvZXMgdGhlIHVzZXIgd2FudCB0byBzYW5pdGl6ZSB0aGUgb3V0cHV0IGRhdGEgKHJlbW92ZSBIVE1MIHRhZ3MpP1xuICAgICAgaWYgKGNvbHVtbkRlZi5zYW5pdGl6ZURhdGFFeHBvcnQgfHwgdGhpcy5fZXhwb3J0T3B0aW9ucy5zYW5pdGl6ZURhdGFFeHBvcnQpIHtcbiAgICAgICAgaXRlbURhdGEgPSBzYW5pdGl6ZUh0bWxUb1RleHQoaXRlbURhdGEpO1xuICAgICAgfVxuXG4gICAgICAvLyB3aGVuIENTViB3ZSBhbHNvIG5lZWQgdG8gZXNjYXBlIGRvdWJsZSBxdW90ZXMgdHdpY2UsIHNvIFwiIGJlY29tZXMgXCJcIlxuICAgICAgaWYgKHRoaXMuX2ZpbGVGb3JtYXQgPT09IEZpbGVUeXBlLmNzdiAmJiBpdGVtRGF0YSkge1xuICAgICAgICBpdGVtRGF0YSA9IGl0ZW1EYXRhLnRvU3RyaW5nKCkucmVwbGFjZSgvXCIvZ2ksIGBcIlwiYCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGRvIHdlIGhhdmUgYSB3cmFwcGVyIHRvIGtlZXAgYXMgYSBzdHJpbmc/IGluIGNlcnRhaW4gY2FzZXMgbGlrZSBcIjFFMDZcIiwgd2UgZG9uJ3Qgd2FudCBleGNlbCB0byB0cmFuc2Zvcm0gaXQgaW50byBleHBvbmVudGlhbCAoMS4wRTA2KVxuICAgICAgLy8gdG8gY2FuY2VsIHRoYXQgZWZmZWN0IHdlIGNhbiBoYWQgPSBpbiBmcm9udCwgZXg6ID1cIjFFMDZcIlxuICAgICAgY29uc3Qga2VlcEFzU3RyaW5nV3JhcHBlciA9IChjb2x1bW5EZWYgJiYgY29sdW1uRGVmLmV4cG9ydENzdkZvcmNlVG9LZWVwQXNTdHJpbmcpID8gJz0nIDogJyc7XG5cbiAgICAgIHJvd091dHB1dFN0cmluZ3MucHVzaChrZWVwQXNTdHJpbmdXcmFwcGVyICsgZXhwb3J0UXVvdGVXcmFwcGVyICsgaXRlbURhdGEgKyBleHBvcnRRdW90ZVdyYXBwZXIpO1xuICAgICAgaWR4Kys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJvd091dHB1dFN0cmluZ3Muam9pbih0aGlzLl9kZWxpbWl0ZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZ3JvdXBlZCB0aXRsZShzKSBhbmQgaXRzIGdyb3VwIHRpdGxlIGZvcm1hdHRlciwgZm9yIGV4YW1wbGUgaWYgd2UgZ3JvdXBlZCBieSBzYWxlc1JlcCwgdGhlIHJldHVybmVkIHJlc3VsdCB3b3VsZCBiZTo6ICdTYWxlcyBSZXA6IEpvaG4gRG93ICgyIGl0ZW1zKSdcbiAgICogQHBhcmFtIGl0ZW1PYmpcbiAgICovXG4gIHByaXZhdGUgcmVhZEdyb3VwZWRUaXRsZVJvdyhpdGVtT2JqOiBhbnkpIHtcbiAgICBsZXQgZ3JvdXBOYW1lID0gc2FuaXRpemVIdG1sVG9UZXh0KGl0ZW1PYmoudGl0bGUpO1xuICAgIGNvbnN0IGV4cG9ydFF1b3RlV3JhcHBlciA9IHRoaXMuX2V4cG9ydFF1b3RlV3JhcHBlcjtcblxuICAgIGdyb3VwTmFtZSA9IGFkZFdoaXRlU3BhY2VzKDUgKiBpdGVtT2JqLmxldmVsKSArIGdyb3VwTmFtZTtcblxuICAgIGlmICh0aGlzLl9maWxlRm9ybWF0ID09PSBGaWxlVHlwZS5jc3YpIHtcbiAgICAgIC8vIHdoZW4gQ1NWIHdlIGFsc28gbmVlZCB0byBlc2NhcGUgZG91YmxlIHF1b3RlcyB0d2ljZSwgc28gXCIgYmVjb21lcyBcIlwiXG4gICAgICBncm91cE5hbWUgPSBncm91cE5hbWUudG9TdHJpbmcoKS5yZXBsYWNlKC9cIi9naSwgYFwiXCJgKTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cG9ydFF1b3RlV3JhcHBlciArIGdyb3VwTmFtZSArIGV4cG9ydFF1b3RlV3JhcHBlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGdyb3VwZWQgdG90YWxzIChiZWxvdyB0aGUgcmVndWxhciByb3dzKSwgdGhlc2UgYXJlIHNldCBieSBTbGljayBBZ2dyZWdhdG9ycy5cbiAgICogRm9yIGV4YW1wbGUgaWYgd2UgZ3JvdXBlZCBieSBcInNhbGVzUmVwXCIgYW5kIHdlIGhhdmUgYSBTdW0gQWdncmVnYXRvciBvbiBcInNhbGVzXCIsIHRoZW4gdGhlIHJldHVybmVkIG91dHB1dCB3b3VsZCBiZTo6IFtcIlN1bSAxMjMkXCJdXG4gICAqIEBwYXJhbSBpdGVtT2JqXG4gICAqL1xuICBwcml2YXRlIHJlYWRHcm91cGVkVG90YWxSb3coY29sdW1uczogQ29sdW1uW10sIGl0ZW1PYmo6IGFueSkge1xuICAgIGNvbnN0IGRlbGltaXRlciA9IHRoaXMuX2V4cG9ydE9wdGlvbnMuZGVsaW1pdGVyO1xuICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuX2V4cG9ydE9wdGlvbnMuZm9ybWF0O1xuICAgIGNvbnN0IGdyb3VwaW5nQWdncmVnYXRvclJvd1RleHQgPSB0aGlzLl9leHBvcnRPcHRpb25zLmdyb3VwaW5nQWdncmVnYXRvclJvd1RleHQgfHwgJyc7XG4gICAgY29uc3QgZXhwb3J0UXVvdGVXcmFwcGVyID0gdGhpcy5fZXhwb3J0UXVvdGVXcmFwcGVyO1xuICAgIGNvbnN0IG91dHB1dFN0cmluZ3MgPSBbYCR7ZXhwb3J0UXVvdGVXcmFwcGVyfSR7Z3JvdXBpbmdBZ2dyZWdhdG9yUm93VGV4dH0ke2V4cG9ydFF1b3RlV3JhcHBlcn1gXTtcblxuICAgIGNvbHVtbnMuZm9yRWFjaCgoY29sdW1uRGVmKSA9PiB7XG4gICAgICBsZXQgaXRlbURhdGEgPSAnJztcblxuICAgICAgY29uc3Qgc2tpcHBlZEZpZWxkID0gY29sdW1uRGVmLmV4Y2x1ZGVGcm9tRXhwb3J0IHx8IGZhbHNlO1xuXG4gICAgICAvLyBpZiB0aGVyZSdzIGEgZ3JvdXBUb3RhbHNGb3JtYXR0ZXIsIHdlIHdpbGwgcmUtcnVuIGl0IHRvIGdldCB0aGUgZXhhY3Qgc2FtZSBvdXRwdXQgYXMgd2hhdCBpcyBzaG93biBpbiBVSVxuICAgICAgaWYgKGNvbHVtbkRlZi5ncm91cFRvdGFsc0Zvcm1hdHRlcikge1xuICAgICAgICBpdGVtRGF0YSA9IGNvbHVtbkRlZi5ncm91cFRvdGFsc0Zvcm1hdHRlcihpdGVtT2JqLCBjb2x1bW5EZWYpO1xuICAgICAgfVxuXG4gICAgICAvLyBkb2VzIHRoZSB1c2VyIHdhbnQgdG8gc2FuaXRpemUgdGhlIG91dHB1dCBkYXRhIChyZW1vdmUgSFRNTCB0YWdzKT9cbiAgICAgIGlmIChjb2x1bW5EZWYuc2FuaXRpemVEYXRhRXhwb3J0IHx8IHRoaXMuX2V4cG9ydE9wdGlvbnMuc2FuaXRpemVEYXRhRXhwb3J0KSB7XG4gICAgICAgIGl0ZW1EYXRhID0gc2FuaXRpemVIdG1sVG9UZXh0KGl0ZW1EYXRhKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZvcm1hdCA9PT0gRmlsZVR5cGUuY3N2KSB7XG4gICAgICAgIC8vIHdoZW4gQ1NWIHdlIGFsc28gbmVlZCB0byBlc2NhcGUgZG91YmxlIHF1b3RlcyB0d2ljZSwgc28gYSBkb3VibGUgcXVvdGUgXCIgYmVjb21lcyAyeCBkb3VibGUgcXVvdGVzIFwiXCJcbiAgICAgICAgaXRlbURhdGEgPSBpdGVtRGF0YS50b1N0cmluZygpLnJlcGxhY2UoL1wiL2dpLCBgXCJcImApO1xuICAgICAgfVxuXG4gICAgICAvLyBhZGQgdGhlIGNvbHVtbiAodW5sZXNzIHVzZXIgd2FudHMgdG8gc2tpcCBpdClcbiAgICAgIGlmICgoY29sdW1uRGVmLndpZHRoID09PSB1bmRlZmluZWQgfHwgY29sdW1uRGVmLndpZHRoID4gMCkgJiYgIXNraXBwZWRGaWVsZCkge1xuICAgICAgICBvdXRwdXRTdHJpbmdzLnB1c2goZXhwb3J0UXVvdGVXcmFwcGVyICsgaXRlbURhdGEgKyBleHBvcnRRdW90ZVdyYXBwZXIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG91dHB1dFN0cmluZ3Muam9pbihkZWxpbWl0ZXIpO1xuICB9XG59XG4iXX0=