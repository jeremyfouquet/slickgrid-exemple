import { FieldType } from '../models/index';
import { getAssociatedDateFormatter } from './formatterUtilities';
import { alignRightFormatter } from './alignRightFormatter';
import { arrayObjectToCsvFormatter } from './arrayObjectToCsvFormatter';
import { arrayToCsvFormatter } from './arrayToCsvFormatter';
import { boldFormatter } from './boldFormatter';
import { centerFormatter } from './centerFormatter';
import { checkboxFormatter } from './checkboxFormatter';
import { checkmarkFormatter } from './checkmarkFormatter';
import { collectionFormatter } from './collectionFormatter';
import { collectionEditorFormatter } from './collectionEditorFormatter';
import { complexObjectFormatter } from './complexObjectFormatter';
import { decimalFormatter } from './decimalFormatter';
import { deleteIconFormatter } from './deleteIconFormatter';
import { dollarColoredBoldFormatter } from './dollarColoredBoldFormatter';
import { dollarColoredFormatter } from './dollarColoredFormatter';
import { dollarFormatter } from './dollarFormatter';
import { editIconFormatter } from './editIconFormatter';
import { fakeHyperlinkFormatter } from './fakeHyperlinkFormatter';
import { hyperlinkFormatter } from './hyperlinkFormatter';
import { iconFormatter } from './iconFormatter';
import { infoIconFormatter } from './infoIconFormatter';
import { italicFormatter } from './italicFormatter';
import { lowercaseFormatter } from './lowercaseFormatter';
import { maskFormatter } from './maskFormatter';
import { multipleFormatter } from './multipleFormatter';
import { percentFormatter } from './percentFormatter';
import { percentCompleteBarFormatter } from './percentCompleteBarFormatter';
import { percentCompleteFormatter } from './percentCompleteFormatter';
import { percentSymbolFormatter } from './percentSymbolFormatter';
import { progressBarFormatter } from './progressBarFormatter';
import { translateFormatter } from './translateFormatter';
import { translateBooleanFormatter } from './translateBooleanFormatter';
import { treeFormatter } from './treeFormatter';
import { uppercaseFormatter } from './uppercaseFormatter';
import { yesNoFormatter } from './yesNoFormatter';
import { bsDropdownFormatter } from './bsDropdownFormatter';
/** Provides a list of different Formatters that will change the cell value displayed in the UI */
export var Formatters = {
    /** Align cell value to the center (alias to Formatters.center)  */
    alignCenter: centerFormatter,
    /** Align cell value to the right */
    alignRight: alignRightFormatter,
    /**
     * Takes an array of complex objects converts it to a comma delimited string.
     * Requires to pass an array of "propertyNames" in the column definition the generic "params" property
     * For example, if we have an array of user objects that have the property of firstName & lastName then we need to pass in your column definition::
     * params: { propertyNames: ['firtName', 'lastName'] } => 'John Doe, Jane Doe'
     */
    arrayObjectToCsv: arrayObjectToCsvFormatter,
    /** Takes an array of string and converts it to a comma delimited string */
    arrayToCsv: arrayToCsvFormatter,
    /** show value in bold font weight */
    bold: boldFormatter,
    /** boostrap dropdown formatter */
    bsDropdown: bsDropdownFormatter,
    /** Center a text value horizontally */
    center: centerFormatter,
    /** When value is filled (true), it will display a checkbox Unicode icon */
    checkbox: checkboxFormatter,
    /**
     * When value is filled, or if the value is a number and is bigger than 0, it will display a Font-Awesome icon (fa-check).
     * The icon will NOT be displayed when the value is any of the following ("false", false, "0", 0, -0.5, null, undefined)
     * Anything else than the condition specified will display the icon, so a text with "00123" will display the icon but "0" will not.
     * Also note that a string ("null", "undefined") will display the icon but (null, undefined) will not, so the typeof is also important
     */
    checkmark: checkmarkFormatter,
    /**
     * Takes a complex data object and return the data under that property (for example: "user.firstName" will return the first name "John")
     * You can pass the complex structure in the "field" or the "params: { complexField: string }" properties.
     * For example::
     * this.columnDefs = [{ id: 'username', field: 'user.firstName', ... }]
     * OR this.columnDefs = [{ id: 'username', field: 'user', params: { complexField: 'user.firstName' }, ... }]
     */
    complex: complexObjectFormatter,
    complexObject: complexObjectFormatter,
    /**
     * Looks up values from the columnDefinition.params.collection property and displays the label in CSV or string format
     * @example
     * // the grid will display 'foo' and 'bar' and not 1 and 2 from your dataset
     * { params: { collection: [{ value: 1, label: 'foo'}, {value: 2, label: 'bar' }] }}
     * const dataset = [1, 2];
     */
    collection: collectionFormatter,
    /**
     * Roughly the same as the "collectionFormatter" except that it
     * looks up values from the columnDefinition.editor.collection (instead of params) property and displays the label in CSV or string format
     * @example
     * // the grid will display 'foo' and 'bar' and not 1 and 2 from your dataset
     * { editor: { collection: [{ value: 1, label: 'foo'}, {value: 2, label: 'bar' }] }}
     * const dataset = [1, 2];
     */
    collectionEditor: collectionEditorFormatter,
    /** Takes a Date object and displays it as an ISO Date format (YYYY-MM-DD) */
    dateIso: getAssociatedDateFormatter(FieldType.dateIso, '-'),
    /** Takes a Date object and displays it as an ISO Date+Time format (YYYY-MM-DD HH:mm:ss) */
    dateTimeIso: getAssociatedDateFormatter(FieldType.dateTimeIso, '-'),
    /** Takes a Date object and displays it as an ISO Date+Time (without seconds) format (YYYY-MM-DD HH:mm) */
    dateTimeShortIso: getAssociatedDateFormatter(FieldType.dateTimeShortIso, '-'),
    /** Takes a Date object and displays it as an ISO Date+Time+(am/pm) format (YYYY-MM-DD h:mm:ss a) */
    dateTimeIsoAmPm: getAssociatedDateFormatter(FieldType.dateTimeIsoAmPm, '-'),
    /** Takes a Date object and displays it as an Euro Date format (DD/MM/YYYY) */
    dateEuro: getAssociatedDateFormatter(FieldType.dateEuro, '/'),
    /** Takes a Date object and displays it as an Euro Date+Time format (DD/MM/YYYY HH:mm:ss) */
    dateTimeEuro: getAssociatedDateFormatter(FieldType.dateTimeEuro, '/'),
    /** Takes a Date object and displays it as an Euro Date+Time (without seconds) format (DD/MM/YYYY HH:mm) */
    dateTimeShortEuro: getAssociatedDateFormatter(FieldType.dateTimeShortEuro, '/'),
    /** Takes a Date object and displays it as an Euro Date+Time+(am/pm) format (DD/MM/YYYY hh:mm:ss a) */
    dateTimeEuroAmPm: getAssociatedDateFormatter(FieldType.dateTimeEuroAmPm, '/'),
    /** Takes a Date object and displays it as an US Date format (MM/DD/YYYY) */
    dateUs: getAssociatedDateFormatter(FieldType.dateUs, '/'),
    /** Takes a Date object and displays it as an US Date+Time format (MM/DD/YYYY HH:mm:ss) */
    dateTimeUs: getAssociatedDateFormatter(FieldType.dateTimeUs, '/'),
    /** Takes a Date object and displays it as an US Date+Time (without seconds) format (MM/DD/YYYY HH:mm:ss) */
    dateTimeShortUs: getAssociatedDateFormatter(FieldType.dateTimeShortUs, '/'),
    /** Takes a Date object and displays it as an US Date+Time+(am/pm) format (MM/DD/YYYY hh:mm:ss a) */
    dateTimeUsAmPm: getAssociatedDateFormatter(FieldType.dateTimeUsAmPm, '/'),
    /** Displays a Font-Awesome delete icon (fa-trash) */
    deleteIcon: deleteIconFormatter,
    /**
     * Display the value as x decimals formatted, defaults to 2 decimals.
     * You can pass "decimalPlaces" or "minDecimalPlaces" and/or "maxDecimalPlaces" to the "params" property.
     * For example:: `{ formatter: Formatters.decimal, params: { decimalPlaces: 3 }}`
     * The property "decimalPlaces" is an alias of "minDecimalPlaces"
     */
    decimal: decimalFormatter,
    /** Display the value as 2 decimals formatted with dollar sign '$' at the end of of the value */
    dollar: dollarFormatter,
    /** Display the value as 2 decimals formatted with dollar sign '$' at the end of of the value, change color of text to red/green on negative/positive value */
    dollarColored: dollarColoredFormatter,
    /** Display the value as 2 decimals formatted with dollar sign '$' at the end of of the value, change color of text to red/green on negative/positive value, show it in bold font weight as well */
    dollarColoredBold: dollarColoredBoldFormatter,
    /** Displays a Font-Awesome edit icon (fa-pencil) */
    editIcon: editIconFormatter,
    /** Takes any text value and display it as a fake a hyperlink (only styled as an hyperlink), this can be used in combo with "onCellClick" event */
    fakeHyperlink: fakeHyperlinkFormatter,
    /**
     * Takes an hyperlink cell value and transforms it into a real hyperlink, given that the value starts with 1 of these (http|ftp|https).
     * The structure will be "<a href="hyperlink">hyperlink</a>"
     *
     * You can optionally change the hyperlink text displayed by using the generic params "hyperlinkText" in the column definition
     * For example: { id: 'link', field: 'link', params: { hyperlinkText: 'Company Website' } } will display "<a href="link">Company Website</a>"
     *
     * You can also optionally provide the hyperlink URL by using the generic params "hyperlinkUrl" in the column definition
     * For example: { id: 'link', field: 'link', params: {  hyperlinkText: 'Company Website', hyperlinkUrl: 'http://www.somewhere.com' } } will display "<a href="http://www.somewhere.com">Company Website</a>"
     */
    hyperlink: hyperlinkFormatter,
    /** Display whichever icon you want (library agnostic, it could be Font-Awesome or any other) */
    icon: iconFormatter,
    /** Displays a Font-Awesome edit icon (fa-info-circle) */
    infoIcon: infoIconFormatter,
    /** show input text value as italic text */
    italic: italicFormatter,
    /** Takes a value and displays it all lowercase */
    lowercase: lowercaseFormatter,
    /**
     * Takes a value display it according to a mask provided
     * e.: 1234567890 with mask "(000) 000-0000" will display "(123) 456-7890"
     */
    mask: maskFormatter,
    /**
     * You can pipe multiple formatters (executed in sequence), use params to pass the list of formatters.
     * Requires to pass an array of "formatters" in the column definition the generic "params" property
     * For example::
     * { field: 'title', formatter: Formatters.multiple, params: { formatters: [ Formatters.lowercase, Formatters.uppercase ] }
     */
    multiple: multipleFormatter,
    /** Takes a cell value number (between 0.0-1.0) and displays a red (<50) or green (>=50) bar */
    percent: percentFormatter,
    /** Takes a cell value number (between 0.0-100) and displays a red (<50) or green (>=50) bar */
    percentComplete: percentCompleteFormatter,
    /** Takes a cell value number (between 0-100) and displays Bootstrap "percent-complete-bar" a red (<30), silver (>30 & <70) or green (>=70) bar */
    percentCompleteBar: percentCompleteBarFormatter,
    /** Takes a cell value number (between 0-100) and add the "%" after the number */
    percentSymbol: percentSymbolFormatter,
    /** Takes a cell value number (between 0-100) and displays Bootstrap "progress-bar" a red (<30), silver (>30 & <70) or green (>=70) bar */
    progressBar: progressBarFormatter,
    /** Takes a cell value and translates it (i18n). Requires an instance of the Translate Service:: `i18n: this.translate */
    translate: translateFormatter,
    /** Takes a boolean value, cast it to upperCase string and finally translates it (i18n). */
    translateBoolean: translateBooleanFormatter,
    /** Formatter that must be use with a Tree Data column */
    tree: treeFormatter,
    /** Takes a value and displays it all uppercase */
    uppercase: uppercaseFormatter,
    /** Takes a boolean value and display a string 'Yes' or 'No' */
    yesNo: yesNoFormatter
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290Ijoibmc6Ly9hbmd1bGFyLXNsaWNrZ3JpZC8iLCJzb3VyY2VzIjpbImFwcC9tb2R1bGVzL2FuZ3VsYXItc2xpY2tncmlkL2Zvcm1hdHRlcnMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQzVDLE9BQU8sRUFBRSwwQkFBMEIsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQ2xFLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQzVELE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBQ3hFLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQzVELE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUNoRCxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDcEQsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDeEQsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDMUQsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDNUQsT0FBTyxFQUFFLHlCQUF5QixFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFDeEUsT0FBTyxFQUFFLHNCQUFzQixFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDbEUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDdEQsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDNUQsT0FBTyxFQUFFLDBCQUEwQixFQUFFLE1BQU0sOEJBQThCLENBQUM7QUFDMUUsT0FBTyxFQUFFLHNCQUFzQixFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDbEUsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFN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a0JBQWtCO0lBRTdCOzs7T0FHRztJQUNILElBQUksRUFBRSxhQUFhO0lBRW5COzs7OztPQUtHO0lBQ0gsUUFBUSxFQUFFLGlCQUFpQjtJQUUzQiwrRkFBK0Y7SUFDL0YsT0FBTyxFQUFFLGdCQUFnQjtJQUV6QiwrRkFBK0Y7SUFDL0YsZUFBZSxFQUFFLHdCQUF3QjtJQUV6QyxrSkFBa0o7SUFDbEosa0JBQWtCLEVBQUUsMkJBQTJCO0lBRS9DLGlGQUFpRjtJQUNqRixhQUFhLEVBQUUsc0JBQXNCO0lBRXJDLDBJQUEwSTtJQUMxSSxXQUFXLEVBQUUsb0JBQW9CO0lBRWpDLHlIQUF5SDtJQUN6SCxTQUFTLEVBQUUsa0JBQWtCO0lBRTdCLDJGQUEyRjtJQUMzRixnQkFBZ0IsRUFBRSx5QkFBeUI7SUFFM0MseURBQXlEO0lBQ3pELElBQUksRUFBRSxhQUFhO0lBRW5CLGtEQUFrRDtJQUNsRCxTQUFTLEVBQUUsa0JBQWtCO0lBRTdCLCtEQUErRDtJQUMvRCxLQUFLLEVBQUUsY0FBYztDQUN0QixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRmllbGRUeXBlIH0gZnJvbSAnLi4vbW9kZWxzL2luZGV4JztcclxuaW1wb3J0IHsgZ2V0QXNzb2NpYXRlZERhdGVGb3JtYXR0ZXIgfSBmcm9tICcuL2Zvcm1hdHRlclV0aWxpdGllcyc7XHJcbmltcG9ydCB7IGFsaWduUmlnaHRGb3JtYXR0ZXIgfSBmcm9tICcuL2FsaWduUmlnaHRGb3JtYXR0ZXInO1xyXG5pbXBvcnQgeyBhcnJheU9iamVjdFRvQ3N2Rm9ybWF0dGVyIH0gZnJvbSAnLi9hcnJheU9iamVjdFRvQ3N2Rm9ybWF0dGVyJztcclxuaW1wb3J0IHsgYXJyYXlUb0NzdkZvcm1hdHRlciB9IGZyb20gJy4vYXJyYXlUb0NzdkZvcm1hdHRlcic7XHJcbmltcG9ydCB7IGJvbGRGb3JtYXR0ZXIgfSBmcm9tICcuL2JvbGRGb3JtYXR0ZXInO1xyXG5pbXBvcnQgeyBjZW50ZXJGb3JtYXR0ZXIgfSBmcm9tICcuL2NlbnRlckZvcm1hdHRlcic7XHJcbmltcG9ydCB7IGNoZWNrYm94Rm9ybWF0dGVyIH0gZnJvbSAnLi9jaGVja2JveEZvcm1hdHRlcic7XHJcbmltcG9ydCB7IGNoZWNrbWFya0Zvcm1hdHRlciB9IGZyb20gJy4vY2hlY2ttYXJrRm9ybWF0dGVyJztcclxuaW1wb3J0IHsgY29sbGVjdGlvbkZvcm1hdHRlciB9IGZyb20gJy4vY29sbGVjdGlvbkZvcm1hdHRlcic7XHJcbmltcG9ydCB7IGNvbGxlY3Rpb25FZGl0b3JGb3JtYXR0ZXIgfSBmcm9tICcuL2NvbGxlY3Rpb25FZGl0b3JGb3JtYXR0ZXInO1xyXG5pbXBvcnQgeyBjb21wbGV4T2JqZWN0Rm9ybWF0dGVyIH0gZnJvbSAnLi9jb21wbGV4T2JqZWN0Rm9ybWF0dGVyJztcclxuaW1wb3J0IHsgZGVjaW1hbEZvcm1hdHRlciB9IGZyb20gJy4vZGVjaW1hbEZvcm1hdHRlcic7XHJcbmltcG9ydCB7IGRlbGV0ZUljb25Gb3JtYXR0ZXIgfSBmcm9tICcuL2RlbGV0ZUljb25Gb3JtYXR0ZXInO1xyXG5pbXBvcnQgeyBkb2xsYXJDb2xvcmVkQm9sZEZvcm1hdHRlciB9IGZyb20gJy4vZG9sbGFyQ29sb3JlZEJvbGRGb3JtYXR0ZXInO1xyXG5pbXBvcnQgeyBkb2xsYXJDb2xvcmVkRm9ybWF0dGVyIH0gZnJvbSAnLi9kb2xsYXJDb2xvcmVkRm9ybWF0dGVyJztcclxuaW1wb3J0IHsgZG9sbGFyRm9ybWF0dGVyIH0gZnJvbSAnLi9kb2xsYXJGb3JtYXR0ZXInO1xyXG5pbXBvcnQgeyBlZGl0SWNvbkZvcm1hdHRlciB9IGZyb20gJy4vZWRpdEljb25Gb3JtYXR0ZXInO1xyXG5pbXBvcnQgeyBmYWtlSHlwZXJsaW5rRm9ybWF0dGVyIH0gZnJvbSAnLi9mYWtlSHlwZXJsaW5rRm9ybWF0dGVyJztcclxuaW1wb3J0IHsgaHlwZXJsaW5rRm9ybWF0dGVyIH0gZnJvbSAnLi9oeXBlcmxpbmtGb3JtYXR0ZXInO1xyXG5pbXBvcnQgeyBpY29uRm9ybWF0dGVyIH0gZnJvbSAnLi9pY29uRm9ybWF0dGVyJztcclxuaW1wb3J0IHsgaW5mb0ljb25Gb3JtYXR0ZXIgfSBmcm9tICcuL2luZm9JY29uRm9ybWF0dGVyJztcclxuaW1wb3J0IHsgaXRhbGljRm9ybWF0dGVyIH0gZnJvbSAnLi9pdGFsaWNGb3JtYXR0ZXInO1xyXG5pbXBvcnQgeyBsb3dlcmNhc2VGb3JtYXR0ZXIgfSBmcm9tICcuL2xvd2VyY2FzZUZvcm1hdHRlcic7XHJcbmltcG9ydCB7IG1hc2tGb3JtYXR0ZXIgfSBmcm9tICcuL21hc2tGb3JtYXR0ZXInO1xyXG5pbXBvcnQgeyBtdWx0aXBsZUZvcm1hdHRlciB9IGZyb20gJy4vbXVsdGlwbGVGb3JtYXR0ZXInO1xyXG5pbXBvcnQgeyBwZXJjZW50Rm9ybWF0dGVyIH0gZnJvbSAnLi9wZXJjZW50Rm9ybWF0dGVyJztcclxuaW1wb3J0IHsgcGVyY2VudENvbXBsZXRlQmFyRm9ybWF0dGVyIH0gZnJvbSAnLi9wZXJjZW50Q29tcGxldGVCYXJGb3JtYXR0ZXInO1xyXG5pbXBvcnQgeyBwZXJjZW50Q29tcGxldGVGb3JtYXR0ZXIgfSBmcm9tICcuL3BlcmNlbnRDb21wbGV0ZUZvcm1hdHRlcic7XHJcbmltcG9ydCB7IHBlcmNlbnRTeW1ib2xGb3JtYXR0ZXIgfSBmcm9tICcuL3BlcmNlbnRTeW1ib2xGb3JtYXR0ZXInO1xyXG5pbXBvcnQgeyBwcm9ncmVzc0JhckZvcm1hdHRlciB9IGZyb20gJy4vcHJvZ3Jlc3NCYXJGb3JtYXR0ZXInO1xyXG5pbXBvcnQgeyB0cmFuc2xhdGVGb3JtYXR0ZXIgfSBmcm9tICcuL3RyYW5zbGF0ZUZvcm1hdHRlcic7XHJcbmltcG9ydCB7IHRyYW5zbGF0ZUJvb2xlYW5Gb3JtYXR0ZXIgfSBmcm9tICcuL3RyYW5zbGF0ZUJvb2xlYW5Gb3JtYXR0ZXInO1xyXG5pbXBvcnQgeyB0cmVlRm9ybWF0dGVyIH0gZnJvbSAnLi90cmVlRm9ybWF0dGVyJztcclxuaW1wb3J0IHsgdXBwZXJjYXNlRm9ybWF0dGVyIH0gZnJvbSAnLi91cHBlcmNhc2VGb3JtYXR0ZXInO1xyXG5pbXBvcnQgeyB5ZXNOb0Zvcm1hdHRlciB9IGZyb20gJy4veWVzTm9Gb3JtYXR0ZXInO1xyXG5pbXBvcnQgeyBic0Ryb3Bkb3duRm9ybWF0dGVyIH0gZnJvbSAnLi9ic0Ryb3Bkb3duRm9ybWF0dGVyJztcclxuXHJcbi8qKiBQcm92aWRlcyBhIGxpc3Qgb2YgZGlmZmVyZW50IEZvcm1hdHRlcnMgdGhhdCB3aWxsIGNoYW5nZSB0aGUgY2VsbCB2YWx1ZSBkaXNwbGF5ZWQgaW4gdGhlIFVJICovXHJcbmV4cG9ydCBjb25zdCBGb3JtYXR0ZXJzID0ge1xyXG4gIC8qKiBBbGlnbiBjZWxsIHZhbHVlIHRvIHRoZSBjZW50ZXIgKGFsaWFzIHRvIEZvcm1hdHRlcnMuY2VudGVyKSAgKi9cclxuICBhbGlnbkNlbnRlcjogY2VudGVyRm9ybWF0dGVyLFxyXG5cclxuICAvKiogQWxpZ24gY2VsbCB2YWx1ZSB0byB0aGUgcmlnaHQgKi9cclxuICBhbGlnblJpZ2h0OiBhbGlnblJpZ2h0Rm9ybWF0dGVyLFxyXG5cclxuICAvKipcclxuICAgKiBUYWtlcyBhbiBhcnJheSBvZiBjb21wbGV4IG9iamVjdHMgY29udmVydHMgaXQgdG8gYSBjb21tYSBkZWxpbWl0ZWQgc3RyaW5nLlxyXG4gICAqIFJlcXVpcmVzIHRvIHBhc3MgYW4gYXJyYXkgb2YgXCJwcm9wZXJ0eU5hbWVzXCIgaW4gdGhlIGNvbHVtbiBkZWZpbml0aW9uIHRoZSBnZW5lcmljIFwicGFyYW1zXCIgcHJvcGVydHlcclxuICAgKiBGb3IgZXhhbXBsZSwgaWYgd2UgaGF2ZSBhbiBhcnJheSBvZiB1c2VyIG9iamVjdHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0eSBvZiBmaXJzdE5hbWUgJiBsYXN0TmFtZSB0aGVuIHdlIG5lZWQgdG8gcGFzcyBpbiB5b3VyIGNvbHVtbiBkZWZpbml0aW9uOjpcclxuICAgKiBwYXJhbXM6IHsgcHJvcGVydHlOYW1lczogWydmaXJ0TmFtZScsICdsYXN0TmFtZSddIH0gPT4gJ0pvaG4gRG9lLCBKYW5lIERvZSdcclxuICAgKi9cclxuICBhcnJheU9iamVjdFRvQ3N2OiBhcnJheU9iamVjdFRvQ3N2Rm9ybWF0dGVyLFxyXG5cclxuICAvKiogVGFrZXMgYW4gYXJyYXkgb2Ygc3RyaW5nIGFuZCBjb252ZXJ0cyBpdCB0byBhIGNvbW1hIGRlbGltaXRlZCBzdHJpbmcgKi9cclxuICBhcnJheVRvQ3N2OiBhcnJheVRvQ3N2Rm9ybWF0dGVyLFxyXG5cclxuICAvKiogc2hvdyB2YWx1ZSBpbiBib2xkIGZvbnQgd2VpZ2h0ICovXHJcbiAgYm9sZDogYm9sZEZvcm1hdHRlcixcclxuXHJcbiAgLyoqIGJvb3N0cmFwIGRyb3Bkb3duIGZvcm1hdHRlciAqL1xyXG4gIGJzRHJvcGRvd246IGJzRHJvcGRvd25Gb3JtYXR0ZXIsXHJcblxyXG4gIC8qKiBDZW50ZXIgYSB0ZXh0IHZhbHVlIGhvcml6b250YWxseSAqL1xyXG4gIGNlbnRlcjogY2VudGVyRm9ybWF0dGVyLFxyXG5cclxuICAvKiogV2hlbiB2YWx1ZSBpcyBmaWxsZWQgKHRydWUpLCBpdCB3aWxsIGRpc3BsYXkgYSBjaGVja2JveCBVbmljb2RlIGljb24gKi9cclxuICBjaGVja2JveDogY2hlY2tib3hGb3JtYXR0ZXIsXHJcblxyXG4gIC8qKlxyXG4gICAqIFdoZW4gdmFsdWUgaXMgZmlsbGVkLCBvciBpZiB0aGUgdmFsdWUgaXMgYSBudW1iZXIgYW5kIGlzIGJpZ2dlciB0aGFuIDAsIGl0IHdpbGwgZGlzcGxheSBhIEZvbnQtQXdlc29tZSBpY29uIChmYS1jaGVjaykuXHJcbiAgICogVGhlIGljb24gd2lsbCBOT1QgYmUgZGlzcGxheWVkIHdoZW4gdGhlIHZhbHVlIGlzIGFueSBvZiB0aGUgZm9sbG93aW5nIChcImZhbHNlXCIsIGZhbHNlLCBcIjBcIiwgMCwgLTAuNSwgbnVsbCwgdW5kZWZpbmVkKVxyXG4gICAqIEFueXRoaW5nIGVsc2UgdGhhbiB0aGUgY29uZGl0aW9uIHNwZWNpZmllZCB3aWxsIGRpc3BsYXkgdGhlIGljb24sIHNvIGEgdGV4dCB3aXRoIFwiMDAxMjNcIiB3aWxsIGRpc3BsYXkgdGhlIGljb24gYnV0IFwiMFwiIHdpbGwgbm90LlxyXG4gICAqIEFsc28gbm90ZSB0aGF0IGEgc3RyaW5nIChcIm51bGxcIiwgXCJ1bmRlZmluZWRcIikgd2lsbCBkaXNwbGF5IHRoZSBpY29uIGJ1dCAobnVsbCwgdW5kZWZpbmVkKSB3aWxsIG5vdCwgc28gdGhlIHR5cGVvZiBpcyBhbHNvIGltcG9ydGFudFxyXG4gICAqL1xyXG4gIGNoZWNrbWFyazogY2hlY2ttYXJrRm9ybWF0dGVyLFxyXG5cclxuICAvKipcclxuICAgKiBUYWtlcyBhIGNvbXBsZXggZGF0YSBvYmplY3QgYW5kIHJldHVybiB0aGUgZGF0YSB1bmRlciB0aGF0IHByb3BlcnR5IChmb3IgZXhhbXBsZTogXCJ1c2VyLmZpcnN0TmFtZVwiIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBuYW1lIFwiSm9oblwiKVxyXG4gICAqIFlvdSBjYW4gcGFzcyB0aGUgY29tcGxleCBzdHJ1Y3R1cmUgaW4gdGhlIFwiZmllbGRcIiBvciB0aGUgXCJwYXJhbXM6IHsgY29tcGxleEZpZWxkOiBzdHJpbmcgfVwiIHByb3BlcnRpZXMuXHJcbiAgICogRm9yIGV4YW1wbGU6OlxyXG4gICAqIHRoaXMuY29sdW1uRGVmcyA9IFt7IGlkOiAndXNlcm5hbWUnLCBmaWVsZDogJ3VzZXIuZmlyc3ROYW1lJywgLi4uIH1dXHJcbiAgICogT1IgdGhpcy5jb2x1bW5EZWZzID0gW3sgaWQ6ICd1c2VybmFtZScsIGZpZWxkOiAndXNlcicsIHBhcmFtczogeyBjb21wbGV4RmllbGQ6ICd1c2VyLmZpcnN0TmFtZScgfSwgLi4uIH1dXHJcbiAgICovXHJcbiAgY29tcGxleDogY29tcGxleE9iamVjdEZvcm1hdHRlcixcclxuICBjb21wbGV4T2JqZWN0OiBjb21wbGV4T2JqZWN0Rm9ybWF0dGVyLFxyXG5cclxuICAvKipcclxuICAgKiBMb29rcyB1cCB2YWx1ZXMgZnJvbSB0aGUgY29sdW1uRGVmaW5pdGlvbi5wYXJhbXMuY29sbGVjdGlvbiBwcm9wZXJ0eSBhbmQgZGlzcGxheXMgdGhlIGxhYmVsIGluIENTViBvciBzdHJpbmcgZm9ybWF0XHJcbiAgICogQGV4YW1wbGVcclxuICAgKiAvLyB0aGUgZ3JpZCB3aWxsIGRpc3BsYXkgJ2ZvbycgYW5kICdiYXInIGFuZCBub3QgMSBhbmQgMiBmcm9tIHlvdXIgZGF0YXNldFxyXG4gICAqIHsgcGFyYW1zOiB7IGNvbGxlY3Rpb246IFt7IHZhbHVlOiAxLCBsYWJlbDogJ2Zvbyd9LCB7dmFsdWU6IDIsIGxhYmVsOiAnYmFyJyB9XSB9fVxyXG4gICAqIGNvbnN0IGRhdGFzZXQgPSBbMSwgMl07XHJcbiAgICovXHJcbiAgY29sbGVjdGlvbjogY29sbGVjdGlvbkZvcm1hdHRlcixcclxuXHJcbiAgLyoqXHJcbiAgICogUm91Z2hseSB0aGUgc2FtZSBhcyB0aGUgXCJjb2xsZWN0aW9uRm9ybWF0dGVyXCIgZXhjZXB0IHRoYXQgaXRcclxuICAgKiBsb29rcyB1cCB2YWx1ZXMgZnJvbSB0aGUgY29sdW1uRGVmaW5pdGlvbi5lZGl0b3IuY29sbGVjdGlvbiAoaW5zdGVhZCBvZiBwYXJhbXMpIHByb3BlcnR5IGFuZCBkaXNwbGF5cyB0aGUgbGFiZWwgaW4gQ1NWIG9yIHN0cmluZyBmb3JtYXRcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIC8vIHRoZSBncmlkIHdpbGwgZGlzcGxheSAnZm9vJyBhbmQgJ2JhcicgYW5kIG5vdCAxIGFuZCAyIGZyb20geW91ciBkYXRhc2V0XHJcbiAgICogeyBlZGl0b3I6IHsgY29sbGVjdGlvbjogW3sgdmFsdWU6IDEsIGxhYmVsOiAnZm9vJ30sIHt2YWx1ZTogMiwgbGFiZWw6ICdiYXInIH1dIH19XHJcbiAgICogY29uc3QgZGF0YXNldCA9IFsxLCAyXTtcclxuICAgKi9cclxuICBjb2xsZWN0aW9uRWRpdG9yOiBjb2xsZWN0aW9uRWRpdG9yRm9ybWF0dGVyLFxyXG5cclxuICAvKiogVGFrZXMgYSBEYXRlIG9iamVjdCBhbmQgZGlzcGxheXMgaXQgYXMgYW4gSVNPIERhdGUgZm9ybWF0IChZWVlZLU1NLUREKSAqL1xyXG4gIGRhdGVJc286IGdldEFzc29jaWF0ZWREYXRlRm9ybWF0dGVyKEZpZWxkVHlwZS5kYXRlSXNvLCAnLScpLFxyXG5cclxuICAvKiogVGFrZXMgYSBEYXRlIG9iamVjdCBhbmQgZGlzcGxheXMgaXQgYXMgYW4gSVNPIERhdGUrVGltZSBmb3JtYXQgKFlZWVktTU0tREQgSEg6bW06c3MpICovXHJcbiAgZGF0ZVRpbWVJc286IGdldEFzc29jaWF0ZWREYXRlRm9ybWF0dGVyKEZpZWxkVHlwZS5kYXRlVGltZUlzbywgJy0nKSxcclxuXHJcbiAgLyoqIFRha2VzIGEgRGF0ZSBvYmplY3QgYW5kIGRpc3BsYXlzIGl0IGFzIGFuIElTTyBEYXRlK1RpbWUgKHdpdGhvdXQgc2Vjb25kcykgZm9ybWF0IChZWVlZLU1NLUREIEhIOm1tKSAqL1xyXG4gIGRhdGVUaW1lU2hvcnRJc286IGdldEFzc29jaWF0ZWREYXRlRm9ybWF0dGVyKEZpZWxkVHlwZS5kYXRlVGltZVNob3J0SXNvLCAnLScpLFxyXG5cclxuICAvKiogVGFrZXMgYSBEYXRlIG9iamVjdCBhbmQgZGlzcGxheXMgaXQgYXMgYW4gSVNPIERhdGUrVGltZSsoYW0vcG0pIGZvcm1hdCAoWVlZWS1NTS1ERCBoOm1tOnNzIGEpICovXHJcbiAgZGF0ZVRpbWVJc29BbVBtOiBnZXRBc3NvY2lhdGVkRGF0ZUZvcm1hdHRlcihGaWVsZFR5cGUuZGF0ZVRpbWVJc29BbVBtLCAnLScpLFxyXG5cclxuICAvKiogVGFrZXMgYSBEYXRlIG9iamVjdCBhbmQgZGlzcGxheXMgaXQgYXMgYW4gRXVybyBEYXRlIGZvcm1hdCAoREQvTU0vWVlZWSkgKi9cclxuICBkYXRlRXVybzogZ2V0QXNzb2NpYXRlZERhdGVGb3JtYXR0ZXIoRmllbGRUeXBlLmRhdGVFdXJvLCAnLycpLFxyXG5cclxuICAvKiogVGFrZXMgYSBEYXRlIG9iamVjdCBhbmQgZGlzcGxheXMgaXQgYXMgYW4gRXVybyBEYXRlK1RpbWUgZm9ybWF0IChERC9NTS9ZWVlZIEhIOm1tOnNzKSAqL1xyXG4gIGRhdGVUaW1lRXVybzogZ2V0QXNzb2NpYXRlZERhdGVGb3JtYXR0ZXIoRmllbGRUeXBlLmRhdGVUaW1lRXVybywgJy8nKSxcclxuXHJcbiAgLyoqIFRha2VzIGEgRGF0ZSBvYmplY3QgYW5kIGRpc3BsYXlzIGl0IGFzIGFuIEV1cm8gRGF0ZStUaW1lICh3aXRob3V0IHNlY29uZHMpIGZvcm1hdCAoREQvTU0vWVlZWSBISDptbSkgKi9cclxuICBkYXRlVGltZVNob3J0RXVybzogZ2V0QXNzb2NpYXRlZERhdGVGb3JtYXR0ZXIoRmllbGRUeXBlLmRhdGVUaW1lU2hvcnRFdXJvLCAnLycpLFxyXG5cclxuICAvKiogVGFrZXMgYSBEYXRlIG9iamVjdCBhbmQgZGlzcGxheXMgaXQgYXMgYW4gRXVybyBEYXRlK1RpbWUrKGFtL3BtKSBmb3JtYXQgKEREL01NL1lZWVkgaGg6bW06c3MgYSkgKi9cclxuICBkYXRlVGltZUV1cm9BbVBtOiBnZXRBc3NvY2lhdGVkRGF0ZUZvcm1hdHRlcihGaWVsZFR5cGUuZGF0ZVRpbWVFdXJvQW1QbSwgJy8nKSxcclxuXHJcbiAgLyoqIFRha2VzIGEgRGF0ZSBvYmplY3QgYW5kIGRpc3BsYXlzIGl0IGFzIGFuIFVTIERhdGUgZm9ybWF0IChNTS9ERC9ZWVlZKSAqL1xyXG4gIGRhdGVVczogZ2V0QXNzb2NpYXRlZERhdGVGb3JtYXR0ZXIoRmllbGRUeXBlLmRhdGVVcywgJy8nKSxcclxuXHJcbiAgLyoqIFRha2VzIGEgRGF0ZSBvYmplY3QgYW5kIGRpc3BsYXlzIGl0IGFzIGFuIFVTIERhdGUrVGltZSBmb3JtYXQgKE1NL0REL1lZWVkgSEg6bW06c3MpICovXHJcbiAgZGF0ZVRpbWVVczogZ2V0QXNzb2NpYXRlZERhdGVGb3JtYXR0ZXIoRmllbGRUeXBlLmRhdGVUaW1lVXMsICcvJyksXHJcblxyXG4gIC8qKiBUYWtlcyBhIERhdGUgb2JqZWN0IGFuZCBkaXNwbGF5cyBpdCBhcyBhbiBVUyBEYXRlK1RpbWUgKHdpdGhvdXQgc2Vjb25kcykgZm9ybWF0IChNTS9ERC9ZWVlZIEhIOm1tOnNzKSAqL1xyXG4gIGRhdGVUaW1lU2hvcnRVczogZ2V0QXNzb2NpYXRlZERhdGVGb3JtYXR0ZXIoRmllbGRUeXBlLmRhdGVUaW1lU2hvcnRVcywgJy8nKSxcclxuXHJcbiAgLyoqIFRha2VzIGEgRGF0ZSBvYmplY3QgYW5kIGRpc3BsYXlzIGl0IGFzIGFuIFVTIERhdGUrVGltZSsoYW0vcG0pIGZvcm1hdCAoTU0vREQvWVlZWSBoaDptbTpzcyBhKSAqL1xyXG4gIGRhdGVUaW1lVXNBbVBtOiBnZXRBc3NvY2lhdGVkRGF0ZUZvcm1hdHRlcihGaWVsZFR5cGUuZGF0ZVRpbWVVc0FtUG0sICcvJyksXHJcblxyXG4gIC8qKiBEaXNwbGF5cyBhIEZvbnQtQXdlc29tZSBkZWxldGUgaWNvbiAoZmEtdHJhc2gpICovXHJcbiAgZGVsZXRlSWNvbjogZGVsZXRlSWNvbkZvcm1hdHRlcixcclxuXHJcbiAgLyoqXHJcbiAgICogRGlzcGxheSB0aGUgdmFsdWUgYXMgeCBkZWNpbWFscyBmb3JtYXR0ZWQsIGRlZmF1bHRzIHRvIDIgZGVjaW1hbHMuXHJcbiAgICogWW91IGNhbiBwYXNzIFwiZGVjaW1hbFBsYWNlc1wiIG9yIFwibWluRGVjaW1hbFBsYWNlc1wiIGFuZC9vciBcIm1heERlY2ltYWxQbGFjZXNcIiB0byB0aGUgXCJwYXJhbXNcIiBwcm9wZXJ0eS5cclxuICAgKiBGb3IgZXhhbXBsZTo6IGB7IGZvcm1hdHRlcjogRm9ybWF0dGVycy5kZWNpbWFsLCBwYXJhbXM6IHsgZGVjaW1hbFBsYWNlczogMyB9fWBcclxuICAgKiBUaGUgcHJvcGVydHkgXCJkZWNpbWFsUGxhY2VzXCIgaXMgYW4gYWxpYXMgb2YgXCJtaW5EZWNpbWFsUGxhY2VzXCJcclxuICAgKi9cclxuICBkZWNpbWFsOiBkZWNpbWFsRm9ybWF0dGVyLFxyXG5cclxuICAvKiogRGlzcGxheSB0aGUgdmFsdWUgYXMgMiBkZWNpbWFscyBmb3JtYXR0ZWQgd2l0aCBkb2xsYXIgc2lnbiAnJCcgYXQgdGhlIGVuZCBvZiBvZiB0aGUgdmFsdWUgKi9cclxuICBkb2xsYXI6IGRvbGxhckZvcm1hdHRlcixcclxuXHJcbiAgLyoqIERpc3BsYXkgdGhlIHZhbHVlIGFzIDIgZGVjaW1hbHMgZm9ybWF0dGVkIHdpdGggZG9sbGFyIHNpZ24gJyQnIGF0IHRoZSBlbmQgb2Ygb2YgdGhlIHZhbHVlLCBjaGFuZ2UgY29sb3Igb2YgdGV4dCB0byByZWQvZ3JlZW4gb24gbmVnYXRpdmUvcG9zaXRpdmUgdmFsdWUgKi9cclxuICBkb2xsYXJDb2xvcmVkOiBkb2xsYXJDb2xvcmVkRm9ybWF0dGVyLFxyXG5cclxuICAvKiogRGlzcGxheSB0aGUgdmFsdWUgYXMgMiBkZWNpbWFscyBmb3JtYXR0ZWQgd2l0aCBkb2xsYXIgc2lnbiAnJCcgYXQgdGhlIGVuZCBvZiBvZiB0aGUgdmFsdWUsIGNoYW5nZSBjb2xvciBvZiB0ZXh0IHRvIHJlZC9ncmVlbiBvbiBuZWdhdGl2ZS9wb3NpdGl2ZSB2YWx1ZSwgc2hvdyBpdCBpbiBib2xkIGZvbnQgd2VpZ2h0IGFzIHdlbGwgKi9cclxuICBkb2xsYXJDb2xvcmVkQm9sZDogZG9sbGFyQ29sb3JlZEJvbGRGb3JtYXR0ZXIsXHJcblxyXG4gIC8qKiBEaXNwbGF5cyBhIEZvbnQtQXdlc29tZSBlZGl0IGljb24gKGZhLXBlbmNpbCkgKi9cclxuICBlZGl0SWNvbjogZWRpdEljb25Gb3JtYXR0ZXIsXHJcblxyXG4gIC8qKiBUYWtlcyBhbnkgdGV4dCB2YWx1ZSBhbmQgZGlzcGxheSBpdCBhcyBhIGZha2UgYSBoeXBlcmxpbmsgKG9ubHkgc3R5bGVkIGFzIGFuIGh5cGVybGluayksIHRoaXMgY2FuIGJlIHVzZWQgaW4gY29tYm8gd2l0aCBcIm9uQ2VsbENsaWNrXCIgZXZlbnQgKi9cclxuICBmYWtlSHlwZXJsaW5rOiBmYWtlSHlwZXJsaW5rRm9ybWF0dGVyLFxyXG5cclxuICAvKipcclxuICAgKiBUYWtlcyBhbiBoeXBlcmxpbmsgY2VsbCB2YWx1ZSBhbmQgdHJhbnNmb3JtcyBpdCBpbnRvIGEgcmVhbCBoeXBlcmxpbmssIGdpdmVuIHRoYXQgdGhlIHZhbHVlIHN0YXJ0cyB3aXRoIDEgb2YgdGhlc2UgKGh0dHB8ZnRwfGh0dHBzKS5cclxuICAgKiBUaGUgc3RydWN0dXJlIHdpbGwgYmUgXCI8YSBocmVmPVwiaHlwZXJsaW5rXCI+aHlwZXJsaW5rPC9hPlwiXHJcbiAgICpcclxuICAgKiBZb3UgY2FuIG9wdGlvbmFsbHkgY2hhbmdlIHRoZSBoeXBlcmxpbmsgdGV4dCBkaXNwbGF5ZWQgYnkgdXNpbmcgdGhlIGdlbmVyaWMgcGFyYW1zIFwiaHlwZXJsaW5rVGV4dFwiIGluIHRoZSBjb2x1bW4gZGVmaW5pdGlvblxyXG4gICAqIEZvciBleGFtcGxlOiB7IGlkOiAnbGluaycsIGZpZWxkOiAnbGluaycsIHBhcmFtczogeyBoeXBlcmxpbmtUZXh0OiAnQ29tcGFueSBXZWJzaXRlJyB9IH0gd2lsbCBkaXNwbGF5IFwiPGEgaHJlZj1cImxpbmtcIj5Db21wYW55IFdlYnNpdGU8L2E+XCJcclxuICAgKlxyXG4gICAqIFlvdSBjYW4gYWxzbyBvcHRpb25hbGx5IHByb3ZpZGUgdGhlIGh5cGVybGluayBVUkwgYnkgdXNpbmcgdGhlIGdlbmVyaWMgcGFyYW1zIFwiaHlwZXJsaW5rVXJsXCIgaW4gdGhlIGNvbHVtbiBkZWZpbml0aW9uXHJcbiAgICogRm9yIGV4YW1wbGU6IHsgaWQ6ICdsaW5rJywgZmllbGQ6ICdsaW5rJywgcGFyYW1zOiB7ICBoeXBlcmxpbmtUZXh0OiAnQ29tcGFueSBXZWJzaXRlJywgaHlwZXJsaW5rVXJsOiAnaHR0cDovL3d3dy5zb21ld2hlcmUuY29tJyB9IH0gd2lsbCBkaXNwbGF5IFwiPGEgaHJlZj1cImh0dHA6Ly93d3cuc29tZXdoZXJlLmNvbVwiPkNvbXBhbnkgV2Vic2l0ZTwvYT5cIlxyXG4gICAqL1xyXG4gIGh5cGVybGluazogaHlwZXJsaW5rRm9ybWF0dGVyLFxyXG5cclxuICAvKiogRGlzcGxheSB3aGljaGV2ZXIgaWNvbiB5b3Ugd2FudCAobGlicmFyeSBhZ25vc3RpYywgaXQgY291bGQgYmUgRm9udC1Bd2Vzb21lIG9yIGFueSBvdGhlcikgKi9cclxuICBpY29uOiBpY29uRm9ybWF0dGVyLFxyXG5cclxuICAvKiogRGlzcGxheXMgYSBGb250LUF3ZXNvbWUgZWRpdCBpY29uIChmYS1pbmZvLWNpcmNsZSkgKi9cclxuICBpbmZvSWNvbjogaW5mb0ljb25Gb3JtYXR0ZXIsXHJcblxyXG4gIC8qKiBzaG93IGlucHV0IHRleHQgdmFsdWUgYXMgaXRhbGljIHRleHQgKi9cclxuICBpdGFsaWM6IGl0YWxpY0Zvcm1hdHRlcixcclxuXHJcbiAgLyoqIFRha2VzIGEgdmFsdWUgYW5kIGRpc3BsYXlzIGl0IGFsbCBsb3dlcmNhc2UgKi9cclxuICBsb3dlcmNhc2U6IGxvd2VyY2FzZUZvcm1hdHRlcixcclxuXHJcbiAgLyoqXHJcbiAgICogVGFrZXMgYSB2YWx1ZSBkaXNwbGF5IGl0IGFjY29yZGluZyB0byBhIG1hc2sgcHJvdmlkZWRcclxuICAgKiBlLjogMTIzNDU2Nzg5MCB3aXRoIG1hc2sgXCIoMDAwKSAwMDAtMDAwMFwiIHdpbGwgZGlzcGxheSBcIigxMjMpIDQ1Ni03ODkwXCJcclxuICAgKi9cclxuICBtYXNrOiBtYXNrRm9ybWF0dGVyLFxyXG5cclxuICAvKipcclxuICAgKiBZb3UgY2FuIHBpcGUgbXVsdGlwbGUgZm9ybWF0dGVycyAoZXhlY3V0ZWQgaW4gc2VxdWVuY2UpLCB1c2UgcGFyYW1zIHRvIHBhc3MgdGhlIGxpc3Qgb2YgZm9ybWF0dGVycy5cclxuICAgKiBSZXF1aXJlcyB0byBwYXNzIGFuIGFycmF5IG9mIFwiZm9ybWF0dGVyc1wiIGluIHRoZSBjb2x1bW4gZGVmaW5pdGlvbiB0aGUgZ2VuZXJpYyBcInBhcmFtc1wiIHByb3BlcnR5XHJcbiAgICogRm9yIGV4YW1wbGU6OlxyXG4gICAqIHsgZmllbGQ6ICd0aXRsZScsIGZvcm1hdHRlcjogRm9ybWF0dGVycy5tdWx0aXBsZSwgcGFyYW1zOiB7IGZvcm1hdHRlcnM6IFsgRm9ybWF0dGVycy5sb3dlcmNhc2UsIEZvcm1hdHRlcnMudXBwZXJjYXNlIF0gfVxyXG4gICAqL1xyXG4gIG11bHRpcGxlOiBtdWx0aXBsZUZvcm1hdHRlcixcclxuXHJcbiAgLyoqIFRha2VzIGEgY2VsbCB2YWx1ZSBudW1iZXIgKGJldHdlZW4gMC4wLTEuMCkgYW5kIGRpc3BsYXlzIGEgcmVkICg8NTApIG9yIGdyZWVuICg+PTUwKSBiYXIgKi9cclxuICBwZXJjZW50OiBwZXJjZW50Rm9ybWF0dGVyLFxyXG5cclxuICAvKiogVGFrZXMgYSBjZWxsIHZhbHVlIG51bWJlciAoYmV0d2VlbiAwLjAtMTAwKSBhbmQgZGlzcGxheXMgYSByZWQgKDw1MCkgb3IgZ3JlZW4gKD49NTApIGJhciAqL1xyXG4gIHBlcmNlbnRDb21wbGV0ZTogcGVyY2VudENvbXBsZXRlRm9ybWF0dGVyLFxyXG5cclxuICAvKiogVGFrZXMgYSBjZWxsIHZhbHVlIG51bWJlciAoYmV0d2VlbiAwLTEwMCkgYW5kIGRpc3BsYXlzIEJvb3RzdHJhcCBcInBlcmNlbnQtY29tcGxldGUtYmFyXCIgYSByZWQgKDwzMCksIHNpbHZlciAoPjMwICYgPDcwKSBvciBncmVlbiAoPj03MCkgYmFyICovXHJcbiAgcGVyY2VudENvbXBsZXRlQmFyOiBwZXJjZW50Q29tcGxldGVCYXJGb3JtYXR0ZXIsXHJcblxyXG4gIC8qKiBUYWtlcyBhIGNlbGwgdmFsdWUgbnVtYmVyIChiZXR3ZWVuIDAtMTAwKSBhbmQgYWRkIHRoZSBcIiVcIiBhZnRlciB0aGUgbnVtYmVyICovXHJcbiAgcGVyY2VudFN5bWJvbDogcGVyY2VudFN5bWJvbEZvcm1hdHRlcixcclxuXHJcbiAgLyoqIFRha2VzIGEgY2VsbCB2YWx1ZSBudW1iZXIgKGJldHdlZW4gMC0xMDApIGFuZCBkaXNwbGF5cyBCb290c3RyYXAgXCJwcm9ncmVzcy1iYXJcIiBhIHJlZCAoPDMwKSwgc2lsdmVyICg+MzAgJiA8NzApIG9yIGdyZWVuICg+PTcwKSBiYXIgKi9cclxuICBwcm9ncmVzc0JhcjogcHJvZ3Jlc3NCYXJGb3JtYXR0ZXIsXHJcblxyXG4gIC8qKiBUYWtlcyBhIGNlbGwgdmFsdWUgYW5kIHRyYW5zbGF0ZXMgaXQgKGkxOG4pLiBSZXF1aXJlcyBhbiBpbnN0YW5jZSBvZiB0aGUgVHJhbnNsYXRlIFNlcnZpY2U6OiBgaTE4bjogdGhpcy50cmFuc2xhdGUgKi9cclxuICB0cmFuc2xhdGU6IHRyYW5zbGF0ZUZvcm1hdHRlcixcclxuXHJcbiAgLyoqIFRha2VzIGEgYm9vbGVhbiB2YWx1ZSwgY2FzdCBpdCB0byB1cHBlckNhc2Ugc3RyaW5nIGFuZCBmaW5hbGx5IHRyYW5zbGF0ZXMgaXQgKGkxOG4pLiAqL1xyXG4gIHRyYW5zbGF0ZUJvb2xlYW46IHRyYW5zbGF0ZUJvb2xlYW5Gb3JtYXR0ZXIsXHJcblxyXG4gIC8qKiBGb3JtYXR0ZXIgdGhhdCBtdXN0IGJlIHVzZSB3aXRoIGEgVHJlZSBEYXRhIGNvbHVtbiAqL1xyXG4gIHRyZWU6IHRyZWVGb3JtYXR0ZXIsXHJcblxyXG4gIC8qKiBUYWtlcyBhIHZhbHVlIGFuZCBkaXNwbGF5cyBpdCBhbGwgdXBwZXJjYXNlICovXHJcbiAgdXBwZXJjYXNlOiB1cHBlcmNhc2VGb3JtYXR0ZXIsXHJcblxyXG4gIC8qKiBUYWtlcyBhIGJvb2xlYW4gdmFsdWUgYW5kIGRpc3BsYXkgYSBzdHJpbmcgJ1llcycgb3IgJ05vJyAqL1xyXG4gIHllc05vOiB5ZXNOb0Zvcm1hdHRlclxyXG59O1xyXG4iXX0=