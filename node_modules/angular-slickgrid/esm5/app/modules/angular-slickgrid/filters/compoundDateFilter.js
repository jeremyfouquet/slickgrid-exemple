import * as tslib_1 from "tslib";
import { Optional } from '@angular/core';
import Flatpickr from 'flatpickr';
import { Constants } from '../constants';
import { FieldType, OperatorType, } from './../models/index';
import { buildSelectOperatorHtmlString } from './filterUtilities';
import { destroyObjectDomElementProps, getTranslationPrefix, mapFlatpickrDateFormatWithFieldType, mapOperatorToShorthandDesignation } from '../services/utilities';
require('flatpickr');
var CompoundDateFilter = /** @class */ (function () {
    function CompoundDateFilter(translate) {
        this.translate = translate;
        this._clearFilterTriggered = false;
        this._shouldTriggerQuery = true;
    }
    Object.defineProperty(CompoundDateFilter.prototype, "gridOptions", {
        /** Getter for the Grid Options pulled through the Grid Object */
        get: function () {
            return (this.grid && this.grid.getOptions) ? this.grid.getOptions() : {};
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompoundDateFilter.prototype, "columnFilter", {
        /** Getter for the Column Filter */
        get: function () {
            return this.columnDef && this.columnDef.filter || {};
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompoundDateFilter.prototype, "currentDate", {
        /** Getter for the Current Dates selected */
        get: function () {
            return this._currentDate;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompoundDateFilter.prototype, "defaultOperator", {
        /** Getter to know what would be the default operator when none is specified */
        get: function () {
            return OperatorType.empty;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompoundDateFilter.prototype, "flatpickrOptions", {
        /** Getter for the Flatpickr Options */
        get: function () {
            return this._flatpickrOptions || {};
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompoundDateFilter.prototype, "locales", {
        /** Getter for the single Locale texts provided by the user in main file or else use default English locales via the Constants */
        get: function () {
            return this.gridOptions.locales || Constants.locales;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompoundDateFilter.prototype, "operator", {
        /** Getter for the Filter Operator */
        get: function () {
            return this._operator || this.columnFilter.operator || this.defaultOperator;
        },
        /** Setter for the Filter Operator */
        set: function (op) {
            this._operator = op;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Initialize the Filter
     */
    CompoundDateFilter.prototype.init = function (args) {
        var _this = this;
        if (!args) {
            throw new Error('[Angular-SlickGrid] A filter must always have an "init()" with valid arguments.');
        }
        this.grid = args.grid;
        this.callback = args.callback;
        this.columnDef = args.columnDef;
        this.operator = args.operator || '';
        this.searchTerms = (args.hasOwnProperty('searchTerms') ? args.searchTerms : []) || [];
        // date input can only have 1 search term, so we will use the 1st array index if it exist
        var searchTerm = (Array.isArray(this.searchTerms) && this.searchTerms.length >= 0) ? this.searchTerms[0] : '';
        // step 1, create the DOM Element of the filter which contain the compound Operator+Input
        // and initialize it if searchTerm is filled
        this.$filterElm = this.createDomElement(searchTerm);
        // step 3, subscribe to the keyup event and run the callback when that happens
        // also add/remove "filled" class for styling purposes
        this.$filterInputElm.keyup(function (e) {
            _this.onTriggerEvent(e);
        });
        this.$selectOperatorElm.change(function (e) {
            _this.onTriggerEvent(e);
        });
    };
    /**
     * Clear the filter value
     */
    CompoundDateFilter.prototype.clear = function (shouldTriggerQuery) {
        if (shouldTriggerQuery === void 0) { shouldTriggerQuery = true; }
        if (this.flatInstance && this.$selectOperatorElm) {
            this._clearFilterTriggered = true;
            this._shouldTriggerQuery = shouldTriggerQuery;
            this.searchTerms = [];
            this.$selectOperatorElm.val(0);
            this.flatInstance.clear();
        }
    };
    /**
     * destroy the filter
     */
    CompoundDateFilter.prototype.destroy = function () {
        if (this.flatInstance && typeof this.flatInstance.destroy === 'function') {
            this.flatInstance.destroy();
            if (this.flatInstance.element) {
                destroyObjectDomElementProps(this.flatInstance);
            }
            this.flatInstance = null;
        }
        if (this.$filterElm) {
            this.$filterElm.off('keyup').remove();
        }
        if (this.$selectOperatorElm) {
            this.$selectOperatorElm.off('change').remove();
        }
        this.$filterElm = null;
        this.callback = null;
        this.onTriggerEvent = null;
    };
    CompoundDateFilter.prototype.hide = function () {
        if (this.flatInstance && typeof this.flatInstance.close === 'function') {
            this.flatInstance.close();
        }
    };
    CompoundDateFilter.prototype.show = function () {
        if (this.flatInstance && typeof this.flatInstance.open === 'function') {
            this.flatInstance.open();
        }
    };
    /** Set value(s) in the DOM element, we can optionally pass an operator and/or trigger a change event */
    CompoundDateFilter.prototype.setValues = function (values, operator) {
        if (this.flatInstance && values) {
            var newValue = Array.isArray(values) ? values[0] : values;
            this._currentDate = newValue;
            this.flatInstance.setDate(newValue);
        }
        // set the operator, in the DOM as well, when defined
        this.operator = operator || this.defaultOperator;
        if (operator && this.$selectOperatorElm) {
            var operatorShorthand = mapOperatorToShorthandDesignation(this.operator);
            this.$selectOperatorElm.val(operatorShorthand);
        }
    };
    //
    // private functions
    // ------------------
    CompoundDateFilter.prototype.buildDatePickerInput = function (searchTerm) {
        var _this = this;
        var inputFormat = mapFlatpickrDateFormatWithFieldType(this.columnFilter.type || this.columnDef.type || FieldType.dateIso);
        var outputFormat = mapFlatpickrDateFormatWithFieldType(this.columnDef.outputType || this.columnFilter.type || this.columnDef.type || FieldType.dateUtc);
        var userFilterOptions = (this.columnFilter && this.columnFilter.filterOptions || {});
        // get current locale, if user defined a custom locale just use or get it the Translate Service if it exist else just use English
        var currentLocale = (userFilterOptions && userFilterOptions.locale) || (this.translate && this.translate.currentLang) || this.gridOptions.locale || 'en';
        if (currentLocale && currentLocale.length > 2) {
            currentLocale = currentLocale.substring(0, 2);
        }
        // if we are preloading searchTerms, we'll keep them for reference
        if (searchTerm) {
            this._currentDate = searchTerm;
        }
        var pickerOptions = {
            defaultDate: searchTerm || '',
            altInput: true,
            altFormat: outputFormat,
            dateFormat: inputFormat,
            wrap: true,
            closeOnSelect: true,
            locale: (currentLocale !== 'en') ? this.loadFlatpickrLocale(currentLocale) : 'en',
            onChange: function (selectedDates, dateStr) {
                _this._currentValue = dateStr;
                _this._currentDate = Array.isArray(selectedDates) && selectedDates[0];
                // when using the time picker, we can simulate a keyup event to avoid multiple backend request
                // since backend request are only executed after user start typing, changing the time should be treated the same way
                var customEvent;
                if (pickerOptions.enableTime) {
                    customEvent = new CustomEvent('keyup');
                }
                _this.onTriggerEvent(customEvent);
            }
        };
        // add the time picker when format is UTC (Z) or has the 'h' (meaning hours)
        if (outputFormat && (outputFormat === 'Z' || outputFormat.toLowerCase().includes('h'))) {
            pickerOptions.enableTime = true;
        }
        // merge options with optional user's custom options
        this._flatpickrOptions = tslib_1.__assign({}, pickerOptions, userFilterOptions);
        var placeholder = (this.gridOptions) ? (this.gridOptions.defaultFilterPlaceholder || '') : '';
        if (this.columnFilter && this.columnFilter.placeholder) {
            placeholder = this.columnFilter.placeholder;
        }
        var $filterInputElm = $("<div class=\"flatpickr\"><input type=\"text\" class=\"form-control\" data-input placeholder=\"" + placeholder + "\"></div>");
        this.flatInstance = ($filterInputElm[0] && typeof $filterInputElm[0].flatpickr === 'function') ? $filterInputElm[0].flatpickr(this._flatpickrOptions) : Flatpickr($filterInputElm, this._flatpickrOptions);
        return $filterInputElm;
    };
    CompoundDateFilter.prototype.getOptionValues = function () {
        return [
            { operator: '', description: '' },
            { operator: '=', description: this.getOutputText('EQUAL_TO', 'TEXT_EQUAL_TO', 'Equal to') },
            { operator: '<', description: this.getOutputText('LESS_THAN', 'TEXT_LESS_THAN', 'Less than') },
            { operator: '<=', description: this.getOutputText('LESS_THAN_OR_EQUAL_TO', 'TEXT_LESS_THAN_OR_EQUAL_TO', 'Less than or equal to') },
            { operator: '>', description: this.getOutputText('GREATER_THAN', 'TEXT_GREATER_THAN', 'Greater than') },
            { operator: '>=', description: this.getOutputText('GREATER_THAN_OR_EQUAL_TO', 'TEXT_GREATER_THAN_OR_EQUAL_TO', 'Greater than or equal to') },
            { operator: '<>', description: this.getOutputText('NOT_EQUAL_TO', 'TEXT_NOT_EQUAL_TO', 'Not equal to') }
        ];
    };
    /** Get Locale, Translated or a Default Text if first two aren't detected */
    CompoundDateFilter.prototype.getOutputText = function (translationKey, localeText, defaultText) {
        if (this.gridOptions && this.gridOptions.enableTranslate && this.translate && this.translate.instant) {
            var translationPrefix = getTranslationPrefix(this.gridOptions);
            return this.translate.instant("" + translationPrefix + translationKey);
        }
        return this.locales && this.locales[localeText] || defaultText;
    };
    /**
     * Create the DOM element
     */
    CompoundDateFilter.prototype.createDomElement = function (searchTerm) {
        var fieldId = this.columnDef && this.columnDef.id;
        var $headerElm = this.grid.getHeaderRowColumn(fieldId);
        $($headerElm).empty();
        // create the DOM Select dropdown for the Operator
        var selectOperatorHtmlString = buildSelectOperatorHtmlString(this.getOptionValues());
        this.$selectOperatorElm = $(selectOperatorHtmlString);
        this.$filterInputElm = this.buildDatePickerInput(searchTerm);
        var $filterContainerElm = $("<div class=\"form-group search-filter filter-" + fieldId + "\"></div>");
        var $containerInputGroup = $("<div class=\"input-group flatpickr\"></div>");
        var $operatorInputGroupAddon = $("<div class=\"input-group-addon input-group-prepend operator\"></div>");
        /* the DOM element final structure will be
          <div class="input-group">
            <div class="input-group-addon input-group-prepend operator">
              <select class="form-control"></select>
            </div>
            <div class=flatpickr>
              <input type="text" class="form-control" data-input>
            </div>
          </div>
        */
        $operatorInputGroupAddon.append(this.$selectOperatorElm);
        $containerInputGroup.append($operatorInputGroupAddon);
        $containerInputGroup.append(this.$filterInputElm);
        // create the DOM element & add an ID and filter class
        $filterContainerElm.append($containerInputGroup);
        this.$filterInputElm.data('columnId', fieldId);
        if (this.operator) {
            var operatorShorthand = mapOperatorToShorthandDesignation(this.operator);
            this.$selectOperatorElm.val(operatorShorthand);
        }
        // if there's a search term, we will add the "filled" class for styling purposes
        if (searchTerm && searchTerm !== '') {
            this.$filterInputElm.addClass('filled');
            this._currentDate = searchTerm;
            this._currentValue = searchTerm;
        }
        // append the new DOM element to the header row
        if ($filterContainerElm && typeof $filterContainerElm.appendTo === 'function') {
            $filterContainerElm.appendTo($headerElm);
        }
        return $filterContainerElm;
    };
    /** Load a different set of locales for Flatpickr to be localized */
    CompoundDateFilter.prototype.loadFlatpickrLocale = function (language) {
        var locales = 'en';
        try {
            if (language !== 'en') {
                // change locale if needed, Flatpickr reference: https://chmln.github.io/flatpickr/localization/
                var localeDefault = require("flatpickr/dist/l10n/" + language + ".js").default;
                locales = (localeDefault && localeDefault[language]) ? localeDefault[language] : 'en';
            }
        }
        catch (e) {
            console.warn("[Angular-Slickgrid - CompoundDate Filter] It seems that \"" + language + "\" is not a locale supported by Flatpickr, we will use \"en\" instead. "
                + "To avoid seeing this message, you can specifically set \"filter: { filterOptions: { locale: 'en' } }\" in your column definition.");
            return 'en';
        }
        return locales;
    };
    CompoundDateFilter.prototype.onTriggerEvent = function (e) {
        if (this._clearFilterTriggered) {
            this.callback(e, { columnDef: this.columnDef, clearFilterTriggered: this._clearFilterTriggered, shouldTriggerQuery: this._shouldTriggerQuery });
            this.$filterElm.removeClass('filled');
        }
        else {
            var selectedOperator = this.$selectOperatorElm.find('option:selected').val();
            (this._currentValue) ? this.$filterElm.addClass('filled') : this.$filterElm.removeClass('filled');
            this.callback(e, { columnDef: this.columnDef, searchTerms: (this._currentValue ? [this._currentValue] : null), operator: selectedOperator || '', shouldTriggerQuery: this._shouldTriggerQuery });
        }
        // reset both flags for next use
        this._clearFilterTriggered = false;
        this._shouldTriggerQuery = true;
    };
    CompoundDateFilter = tslib_1.__decorate([
        tslib_1.__param(0, Optional())
    ], CompoundDateFilter);
    return CompoundDateFilter;
}());
export { CompoundDateFilter };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcG91bmREYXRlRmlsdGVyLmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci1zbGlja2dyaWQvIiwic291cmNlcyI6WyJhcHAvbW9kdWxlcy9hbmd1bGFyLXNsaWNrZ3JpZC9maWx0ZXJzL2NvbXBvdW5kRGF0ZUZpbHRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUV6QyxPQUFPLFNBQVMsTUFBTSxXQUFXLENBQUM7QUFHbEMsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUN6QyxPQUFPLEVBTUwsU0FBUyxFQUtULFlBQVksR0FFYixNQUFNLG1CQUFtQixDQUFDO0FBQzNCLE9BQU8sRUFBRSw2QkFBNkIsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQ2xFLE9BQU8sRUFBRSw0QkFBNEIsRUFBRSxvQkFBb0IsRUFBRSxtQ0FBbUMsRUFBRSxpQ0FBaUMsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBSW5LLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUtyQjtJQWdCRSw0QkFBZ0MsU0FBMkI7UUFBM0IsY0FBUyxHQUFULFNBQVMsQ0FBa0I7UUFmbkQsMEJBQXFCLEdBQUcsS0FBSyxDQUFDO1FBRzlCLHdCQUFtQixHQUFHLElBQUksQ0FBQztJQVk0QixDQUFDO0lBR2hFLHNCQUFZLDJDQUFXO1FBRHZCLGlFQUFpRTthQUNqRTtZQUNFLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUMzRSxDQUFDOzs7T0FBQTtJQUdELHNCQUFJLDRDQUFZO1FBRGhCLG1DQUFtQzthQUNuQztZQUNFLE9BQU8sSUFBSSxDQUFDLFNBQVMsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLE1B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SUFBSSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDbEcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsRUFBRSxTQUFTLEVBQUUsSUFBSSxDQUFDLFNBQVMsRUFBRSxXQUFXLEVBQUUsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsUUFBUSxFQUFFLGdCQUFnQixJQUFJLEVBQUUsRUFBRSxrQkFBa0IsRUFBRSxJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQyxDQUFDO1NBQ2xNO1FBQ0QsZ0NBQWdDO1FBQ2hDLElBQUksQ0FBQyxxQkFBcUIsR0FBRyxLQUFLLENBQUM7UUFDbkMsSUFBSSxDQUFDLG1CQUFtQixHQUFHLElBQUksQ0FBQztJQUNsQyxDQUFDO0lBMVRVLGtCQUFrQjtRQWdCaEIsbUJBQUEsUUFBUSxFQUFFLENBQUE7T0FoQlosa0JBQWtCLENBMlQ5QjtJQUFELHlCQUFDO0NBQUEsQUEzVEQsSUEyVEM7U0EzVFksa0JBQWtCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgVHJhbnNsYXRlU2VydmljZSB9IGZyb20gJ0BuZ3gtdHJhbnNsYXRlL2NvcmUnO1xyXG5pbXBvcnQgRmxhdHBpY2tyIGZyb20gJ2ZsYXRwaWNrcic7XHJcbmltcG9ydCB7IEJhc2VPcHRpb25zIGFzIEZsYXRwaWNrckJhc2VPcHRpb25zIH0gZnJvbSAnZmxhdHBpY2tyL2Rpc3QvdHlwZXMvb3B0aW9ucyc7XHJcblxyXG5pbXBvcnQgeyBDb25zdGFudHMgfSBmcm9tICcuLi9jb25zdGFudHMnO1xyXG5pbXBvcnQge1xyXG4gIENvbHVtbixcclxuICBDb2x1bW5GaWx0ZXIsXHJcbiAgRmlsdGVyLFxyXG4gIEZpbHRlckFyZ3VtZW50cyxcclxuICBGaWx0ZXJDYWxsYmFjayxcclxuICBGaWVsZFR5cGUsXHJcbiAgRmxhdHBpY2tyT3B0aW9uLFxyXG4gIEdyaWRPcHRpb24sXHJcbiAgTG9jYWxlLFxyXG4gIE9wZXJhdG9yU3RyaW5nLFxyXG4gIE9wZXJhdG9yVHlwZSxcclxuICBTZWFyY2hUZXJtLFxyXG59IGZyb20gJy4vLi4vbW9kZWxzL2luZGV4JztcclxuaW1wb3J0IHsgYnVpbGRTZWxlY3RPcGVyYXRvckh0bWxTdHJpbmcgfSBmcm9tICcuL2ZpbHRlclV0aWxpdGllcyc7XHJcbmltcG9ydCB7IGRlc3Ryb3lPYmplY3REb21FbGVtZW50UHJvcHMsIGdldFRyYW5zbGF0aW9uUHJlZml4LCBtYXBGbGF0cGlja3JEYXRlRm9ybWF0V2l0aEZpZWxkVHlwZSwgbWFwT3BlcmF0b3JUb1Nob3J0aGFuZERlc2lnbmF0aW9uIH0gZnJvbSAnLi4vc2VydmljZXMvdXRpbGl0aWVzJztcclxuXHJcbi8vIHVzZSBGbGF0cGlja3IgZnJvbSBpbXBvcnQgb3IgJ3JlcXVpcmUnLCB3aGljaGV2ZXIgd29ya3MgZmlyc3RcclxuZGVjbGFyZSBmdW5jdGlvbiByZXF1aXJlKG5hbWU6IHN0cmluZyk6IGFueTtcclxucmVxdWlyZSgnZmxhdHBpY2tyJyk7XHJcblxyXG4vLyB1c2luZyBleHRlcm5hbCBub24tdHlwZWQganMgbGlicmFyaWVzXHJcbmRlY2xhcmUgY29uc3QgJDogYW55O1xyXG5cclxuZXhwb3J0IGNsYXNzIENvbXBvdW5kRGF0ZUZpbHRlciBpbXBsZW1lbnRzIEZpbHRlciB7XHJcbiAgcHJpdmF0ZSBfY2xlYXJGaWx0ZXJUcmlnZ2VyZWQgPSBmYWxzZTtcclxuICBwcml2YXRlIF9jdXJyZW50RGF0ZTogRGF0ZTtcclxuICBwcml2YXRlIF9mbGF0cGlja3JPcHRpb25zOiBGbGF0cGlja3JPcHRpb247XHJcbiAgcHJpdmF0ZSBfc2hvdWxkVHJpZ2dlclF1ZXJ5ID0gdHJ1ZTtcclxuICBwcml2YXRlICRmaWx0ZXJFbG06IGFueTtcclxuICBwcml2YXRlICRmaWx0ZXJJbnB1dEVsbTogYW55O1xyXG4gIHByaXZhdGUgJHNlbGVjdE9wZXJhdG9yRWxtOiBhbnk7XHJcbiAgcHJpdmF0ZSBfY3VycmVudFZhbHVlOiBzdHJpbmc7XHJcbiAgcHJpdmF0ZSBfb3BlcmF0b3I6IE9wZXJhdG9yVHlwZSB8IE9wZXJhdG9yU3RyaW5nO1xyXG4gIGZsYXRJbnN0YW5jZTogYW55O1xyXG4gIGdyaWQ6IGFueTtcclxuICBzZWFyY2hUZXJtczogU2VhcmNoVGVybVtdO1xyXG4gIGNvbHVtbkRlZjogQ29sdW1uO1xyXG4gIGNhbGxiYWNrOiBGaWx0ZXJDYWxsYmFjaztcclxuXHJcbiAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgcHJpdmF0ZSB0cmFuc2xhdGU6IFRyYW5zbGF0ZVNlcnZpY2UpIHsgfVxyXG5cclxuICAvKiogR2V0dGVyIGZvciB0aGUgR3JpZCBPcHRpb25zIHB1bGxlZCB0aHJvdWdoIHRoZSBHcmlkIE9iamVjdCAqL1xyXG4gIHByaXZhdGUgZ2V0IGdyaWRPcHRpb25zKCk6IEdyaWRPcHRpb24ge1xyXG4gICAgcmV0dXJuICh0aGlzLmdyaWQgJiYgdGhpcy5ncmlkLmdldE9wdGlvbnMpID8gdGhpcy5ncmlkLmdldE9wdGlvbnMoKSA6IHt9O1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldHRlciBmb3IgdGhlIENvbHVtbiBGaWx0ZXIgKi9cclxuICBnZXQgY29sdW1uRmlsdGVyKCk6IENvbHVtbkZpbHRlciB7XHJcbiAgICByZXR1cm4gdGhpcy5jb2x1bW5EZWYgJiYgdGhpcy5jb2x1bW5EZWYuZmlsdGVyIHx8IHt9O1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldHRlciBmb3IgdGhlIEN1cnJlbnQgRGF0ZXMgc2VsZWN0ZWQgKi9cclxuICBnZXQgY3VycmVudERhdGUoKTogRGF0ZSB7XHJcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudERhdGU7XHJcbiAgfVxyXG5cclxuICAvKiogR2V0dGVyIHRvIGtub3cgd2hhdCB3b3VsZCBiZSB0aGUgZGVmYXVsdCBvcGVyYXRvciB3aGVuIG5vbmUgaXMgc3BlY2lmaWVkICovXHJcbiAgZ2V0IGRlZmF1bHRPcGVyYXRvcigpOiBPcGVyYXRvclR5cGUgfCBPcGVyYXRvclN0cmluZyB7XHJcbiAgICByZXR1cm4gT3BlcmF0b3JUeXBlLmVtcHR5O1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldHRlciBmb3IgdGhlIEZsYXRwaWNrciBPcHRpb25zICovXHJcbiAgZ2V0IGZsYXRwaWNrck9wdGlvbnMoKTogRmxhdHBpY2tyT3B0aW9uIHtcclxuICAgIHJldHVybiB0aGlzLl9mbGF0cGlja3JPcHRpb25zIHx8IHt9O1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldHRlciBmb3IgdGhlIHNpbmdsZSBMb2NhbGUgdGV4dHMgcHJvdmlkZWQgYnkgdGhlIHVzZXIgaW4gbWFpbiBmaWxlIG9yIGVsc2UgdXNlIGRlZmF1bHQgRW5nbGlzaCBsb2NhbGVzIHZpYSB0aGUgQ29uc3RhbnRzICovXHJcbiAgZ2V0IGxvY2FsZXMoKTogTG9jYWxlIHtcclxuICAgIHJldHVybiB0aGlzLmdyaWRPcHRpb25zLmxvY2FsZXMgfHwgQ29uc3RhbnRzLmxvY2FsZXM7XHJcbiAgfVxyXG5cclxuICAvKiogR2V0dGVyIGZvciB0aGUgRmlsdGVyIE9wZXJhdG9yICovXHJcbiAgZ2V0IG9wZXJhdG9yKCk6IE9wZXJhdG9yVHlwZSB8IE9wZXJhdG9yU3RyaW5nIHtcclxuICAgIHJldHVybiB0aGlzLl9vcGVyYXRvciB8fCB0aGlzLmNvbHVtbkZpbHRlci5vcGVyYXRvciB8fCB0aGlzLmRlZmF1bHRPcGVyYXRvcjtcclxuICB9XHJcblxyXG4gIC8qKiBTZXR0ZXIgZm9yIHRoZSBGaWx0ZXIgT3BlcmF0b3IgKi9cclxuICBzZXQgb3BlcmF0b3Iob3A6IE9wZXJhdG9yVHlwZSB8IE9wZXJhdG9yU3RyaW5nKSB7XHJcbiAgICB0aGlzLl9vcGVyYXRvciA9IG9wO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZSB0aGUgRmlsdGVyXHJcbiAgICovXHJcbiAgaW5pdChhcmdzOiBGaWx0ZXJBcmd1bWVudHMpIHtcclxuICAgIGlmICghYXJncykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tBbmd1bGFyLVNsaWNrR3JpZF0gQSBmaWx0ZXIgbXVzdCBhbHdheXMgaGF2ZSBhbiBcImluaXQoKVwiIHdpdGggdmFsaWQgYXJndW1lbnRzLicpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5ncmlkID0gYXJncy5ncmlkO1xyXG4gICAgdGhpcy5jYWxsYmFjayA9IGFyZ3MuY2FsbGJhY2s7XHJcbiAgICB0aGlzLmNvbHVtbkRlZiA9IGFyZ3MuY29sdW1uRGVmO1xyXG4gICAgdGhpcy5vcGVyYXRvciA9IGFyZ3Mub3BlcmF0b3IgfHwgJyc7XHJcbiAgICB0aGlzLnNlYXJjaFRlcm1zID0gKGFyZ3MuaGFzT3duUHJvcGVydHkoJ3NlYXJjaFRlcm1zJykgPyBhcmdzLnNlYXJjaFRlcm1zIDogW10pIHx8IFtdO1xyXG5cclxuICAgIC8vIGRhdGUgaW5wdXQgY2FuIG9ubHkgaGF2ZSAxIHNlYXJjaCB0ZXJtLCBzbyB3ZSB3aWxsIHVzZSB0aGUgMXN0IGFycmF5IGluZGV4IGlmIGl0IGV4aXN0XHJcbiAgICBjb25zdCBzZWFyY2hUZXJtID0gKEFycmF5LmlzQXJyYXkodGhpcy5zZWFyY2hUZXJtcykgJiYgdGhpcy5zZWFyY2hUZXJtcy5sZW5ndGggPj0gMCkgPyB0aGlzLnNlYXJjaFRlcm1zWzBdIDogJyc7XHJcblxyXG4gICAgLy8gc3RlcCAxLCBjcmVhdGUgdGhlIERPTSBFbGVtZW50IG9mIHRoZSBmaWx0ZXIgd2hpY2ggY29udGFpbiB0aGUgY29tcG91bmQgT3BlcmF0b3IrSW5wdXRcclxuICAgIC8vIGFuZCBpbml0aWFsaXplIGl0IGlmIHNlYXJjaFRlcm0gaXMgZmlsbGVkXHJcbiAgICB0aGlzLiRmaWx0ZXJFbG0gPSB0aGlzLmNyZWF0ZURvbUVsZW1lbnQoc2VhcmNoVGVybSk7XHJcblxyXG4gICAgLy8gc3RlcCAzLCBzdWJzY3JpYmUgdG8gdGhlIGtleXVwIGV2ZW50IGFuZCBydW4gdGhlIGNhbGxiYWNrIHdoZW4gdGhhdCBoYXBwZW5zXHJcbiAgICAvLyBhbHNvIGFkZC9yZW1vdmUgXCJmaWxsZWRcIiBjbGFzcyBmb3Igc3R5bGluZyBwdXJwb3Nlc1xyXG4gICAgdGhpcy4kZmlsdGVySW5wdXRFbG0ua2V5dXAoKGU6IGFueSkgPT4ge1xyXG4gICAgICB0aGlzLm9uVHJpZ2dlckV2ZW50KGUpO1xyXG4gICAgfSk7XHJcbiAgICB0aGlzLiRzZWxlY3RPcGVyYXRvckVsbS5jaGFuZ2UoKGU6IGFueSkgPT4ge1xyXG4gICAgICB0aGlzLm9uVHJpZ2dlckV2ZW50KGUpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDbGVhciB0aGUgZmlsdGVyIHZhbHVlXHJcbiAgICovXHJcbiAgY2xlYXIoc2hvdWxkVHJpZ2dlclF1ZXJ5ID0gdHJ1ZSkge1xyXG4gICAgaWYgKHRoaXMuZmxhdEluc3RhbmNlICYmIHRoaXMuJHNlbGVjdE9wZXJhdG9yRWxtKSB7XHJcbiAgICAgIHRoaXMuX2NsZWFyRmlsdGVyVHJpZ2dlcmVkID0gdHJ1ZTtcclxuICAgICAgdGhpcy5fc2hvdWxkVHJpZ2dlclF1ZXJ5ID0gc2hvdWxkVHJpZ2dlclF1ZXJ5O1xyXG4gICAgICB0aGlzLnNlYXJjaFRlcm1zID0gW107XHJcbiAgICAgIHRoaXMuJHNlbGVjdE9wZXJhdG9yRWxtLnZhbCgwKTtcclxuICAgICAgdGhpcy5mbGF0SW5zdGFuY2UuY2xlYXIoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIGRlc3Ryb3kgdGhlIGZpbHRlclxyXG4gICAqL1xyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICBpZiAodGhpcy5mbGF0SW5zdGFuY2UgJiYgdHlwZW9mIHRoaXMuZmxhdEluc3RhbmNlLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhpcy5mbGF0SW5zdGFuY2UuZGVzdHJveSgpO1xyXG4gICAgICBpZiAodGhpcy5mbGF0SW5zdGFuY2UuZWxlbWVudCkge1xyXG4gICAgICAgIGRlc3Ryb3lPYmplY3REb21FbGVtZW50UHJvcHModGhpcy5mbGF0SW5zdGFuY2UpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuZmxhdEluc3RhbmNlID0gbnVsbDtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLiRmaWx0ZXJFbG0pIHtcclxuICAgICAgdGhpcy4kZmlsdGVyRWxtLm9mZigna2V5dXAnKS5yZW1vdmUoKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLiRzZWxlY3RPcGVyYXRvckVsbSkge1xyXG4gICAgICB0aGlzLiRzZWxlY3RPcGVyYXRvckVsbS5vZmYoJ2NoYW5nZScpLnJlbW92ZSgpO1xyXG4gICAgfVxyXG4gICAgdGhpcy4kZmlsdGVyRWxtID0gbnVsbDtcclxuICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsO1xyXG4gICAgdGhpcy5vblRyaWdnZXJFdmVudCA9IG51bGw7XHJcbiAgfVxyXG5cclxuICBoaWRlKCkge1xyXG4gICAgaWYgKHRoaXMuZmxhdEluc3RhbmNlICYmIHR5cGVvZiB0aGlzLmZsYXRJbnN0YW5jZS5jbG9zZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aGlzLmZsYXRJbnN0YW5jZS5jbG9zZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc2hvdygpIHtcclxuICAgIGlmICh0aGlzLmZsYXRJbnN0YW5jZSAmJiB0eXBlb2YgdGhpcy5mbGF0SW5zdGFuY2Uub3BlbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aGlzLmZsYXRJbnN0YW5jZS5vcGVuKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogU2V0IHZhbHVlKHMpIGluIHRoZSBET00gZWxlbWVudCwgd2UgY2FuIG9wdGlvbmFsbHkgcGFzcyBhbiBvcGVyYXRvciBhbmQvb3IgdHJpZ2dlciBhIGNoYW5nZSBldmVudCAqL1xyXG4gIHNldFZhbHVlcyh2YWx1ZXM6IFNlYXJjaFRlcm0gfCBTZWFyY2hUZXJtW10sIG9wZXJhdG9yPzogT3BlcmF0b3JUeXBlIHwgT3BlcmF0b3JTdHJpbmcpIHtcclxuICAgIGlmICh0aGlzLmZsYXRJbnN0YW5jZSAmJiB2YWx1ZXMpIHtcclxuICAgICAgY29uc3QgbmV3VmFsdWUgPSBBcnJheS5pc0FycmF5KHZhbHVlcykgPyB2YWx1ZXNbMF0gOiB2YWx1ZXM7XHJcbiAgICAgIHRoaXMuX2N1cnJlbnREYXRlID0gbmV3VmFsdWUgYXMgRGF0ZTtcclxuICAgICAgdGhpcy5mbGF0SW5zdGFuY2Uuc2V0RGF0ZShuZXdWYWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc2V0IHRoZSBvcGVyYXRvciwgaW4gdGhlIERPTSBhcyB3ZWxsLCB3aGVuIGRlZmluZWRcclxuICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvciB8fCB0aGlzLmRlZmF1bHRPcGVyYXRvcjtcclxuICAgIGlmIChvcGVyYXRvciAmJiB0aGlzLiRzZWxlY3RPcGVyYXRvckVsbSkge1xyXG4gICAgICBjb25zdCBvcGVyYXRvclNob3J0aGFuZCA9IG1hcE9wZXJhdG9yVG9TaG9ydGhhbmREZXNpZ25hdGlvbih0aGlzLm9wZXJhdG9yKTtcclxuICAgICAgdGhpcy4kc2VsZWN0T3BlcmF0b3JFbG0udmFsKG9wZXJhdG9yU2hvcnRoYW5kKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vXHJcbiAgLy8gcHJpdmF0ZSBmdW5jdGlvbnNcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cclxuICBwcml2YXRlIGJ1aWxkRGF0ZVBpY2tlcklucHV0KHNlYXJjaFRlcm0/OiBTZWFyY2hUZXJtKSB7XHJcbiAgICBjb25zdCBpbnB1dEZvcm1hdCA9IG1hcEZsYXRwaWNrckRhdGVGb3JtYXRXaXRoRmllbGRUeXBlKHRoaXMuY29sdW1uRmlsdGVyLnR5cGUgfHwgdGhpcy5jb2x1bW5EZWYudHlwZSB8fCBGaWVsZFR5cGUuZGF0ZUlzbyk7XHJcbiAgICBjb25zdCBvdXRwdXRGb3JtYXQgPSBtYXBGbGF0cGlja3JEYXRlRm9ybWF0V2l0aEZpZWxkVHlwZSh0aGlzLmNvbHVtbkRlZi5vdXRwdXRUeXBlIHx8IHRoaXMuY29sdW1uRmlsdGVyLnR5cGUgfHwgdGhpcy5jb2x1bW5EZWYudHlwZSB8fCBGaWVsZFR5cGUuZGF0ZVV0Yyk7XHJcbiAgICBjb25zdCB1c2VyRmlsdGVyT3B0aW9ucyA9ICh0aGlzLmNvbHVtbkZpbHRlciAmJiB0aGlzLmNvbHVtbkZpbHRlci5maWx0ZXJPcHRpb25zIHx8IHt9KSBhcyBGbGF0cGlja3JPcHRpb247XHJcblxyXG4gICAgLy8gZ2V0IGN1cnJlbnQgbG9jYWxlLCBpZiB1c2VyIGRlZmluZWQgYSBjdXN0b20gbG9jYWxlIGp1c3QgdXNlIG9yIGdldCBpdCB0aGUgVHJhbnNsYXRlIFNlcnZpY2UgaWYgaXQgZXhpc3QgZWxzZSBqdXN0IHVzZSBFbmdsaXNoXHJcbiAgICBsZXQgY3VycmVudExvY2FsZSA9ICh1c2VyRmlsdGVyT3B0aW9ucyAmJiB1c2VyRmlsdGVyT3B0aW9ucy5sb2NhbGUpIHx8ICh0aGlzLnRyYW5zbGF0ZSAmJiB0aGlzLnRyYW5zbGF0ZS5jdXJyZW50TGFuZykgfHwgdGhpcy5ncmlkT3B0aW9ucy5sb2NhbGUgfHwgJ2VuJztcclxuICAgIGlmIChjdXJyZW50TG9jYWxlICYmIGN1cnJlbnRMb2NhbGUubGVuZ3RoID4gMikge1xyXG4gICAgICBjdXJyZW50TG9jYWxlID0gY3VycmVudExvY2FsZS5zdWJzdHJpbmcoMCwgMik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaWYgd2UgYXJlIHByZWxvYWRpbmcgc2VhcmNoVGVybXMsIHdlJ2xsIGtlZXAgdGhlbSBmb3IgcmVmZXJlbmNlXHJcbiAgICBpZiAoc2VhcmNoVGVybSkge1xyXG4gICAgICB0aGlzLl9jdXJyZW50RGF0ZSA9IHNlYXJjaFRlcm0gYXMgRGF0ZTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBwaWNrZXJPcHRpb25zOiBGbGF0cGlja3JPcHRpb24gPSB7XHJcbiAgICAgIGRlZmF1bHREYXRlOiAoc2VhcmNoVGVybSBhcyBzdHJpbmcpIHx8ICcnLFxyXG4gICAgICBhbHRJbnB1dDogdHJ1ZSxcclxuICAgICAgYWx0Rm9ybWF0OiBvdXRwdXRGb3JtYXQsXHJcbiAgICAgIGRhdGVGb3JtYXQ6IGlucHV0Rm9ybWF0LFxyXG4gICAgICB3cmFwOiB0cnVlLFxyXG4gICAgICBjbG9zZU9uU2VsZWN0OiB0cnVlLFxyXG4gICAgICBsb2NhbGU6IChjdXJyZW50TG9jYWxlICE9PSAnZW4nKSA/IHRoaXMubG9hZEZsYXRwaWNrckxvY2FsZShjdXJyZW50TG9jYWxlKSA6ICdlbicsXHJcbiAgICAgIG9uQ2hhbmdlOiAoc2VsZWN0ZWREYXRlczogRGF0ZVtdIHwgRGF0ZSwgZGF0ZVN0cjogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudFZhbHVlID0gZGF0ZVN0cjtcclxuICAgICAgICB0aGlzLl9jdXJyZW50RGF0ZSA9IEFycmF5LmlzQXJyYXkoc2VsZWN0ZWREYXRlcykgJiYgc2VsZWN0ZWREYXRlc1swXTtcclxuXHJcbiAgICAgICAgLy8gd2hlbiB1c2luZyB0aGUgdGltZSBwaWNrZXIsIHdlIGNhbiBzaW11bGF0ZSBhIGtleXVwIGV2ZW50IHRvIGF2b2lkIG11bHRpcGxlIGJhY2tlbmQgcmVxdWVzdFxyXG4gICAgICAgIC8vIHNpbmNlIGJhY2tlbmQgcmVxdWVzdCBhcmUgb25seSBleGVjdXRlZCBhZnRlciB1c2VyIHN0YXJ0IHR5cGluZywgY2hhbmdpbmcgdGhlIHRpbWUgc2hvdWxkIGJlIHRyZWF0ZWQgdGhlIHNhbWUgd2F5XHJcbiAgICAgICAgbGV0IGN1c3RvbUV2ZW50OiBDdXN0b21FdmVudCB8IHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAocGlja2VyT3B0aW9ucy5lbmFibGVUaW1lKSB7XHJcbiAgICAgICAgICBjdXN0b21FdmVudCA9IG5ldyBDdXN0b21FdmVudCgna2V5dXAnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5vblRyaWdnZXJFdmVudChjdXN0b21FdmVudCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gYWRkIHRoZSB0aW1lIHBpY2tlciB3aGVuIGZvcm1hdCBpcyBVVEMgKFopIG9yIGhhcyB0aGUgJ2gnIChtZWFuaW5nIGhvdXJzKVxyXG4gICAgaWYgKG91dHB1dEZvcm1hdCAmJiAob3V0cHV0Rm9ybWF0ID09PSAnWicgfHwgb3V0cHV0Rm9ybWF0LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2gnKSkpIHtcclxuICAgICAgcGlja2VyT3B0aW9ucy5lbmFibGVUaW1lID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBtZXJnZSBvcHRpb25zIHdpdGggb3B0aW9uYWwgdXNlcidzIGN1c3RvbSBvcHRpb25zXHJcbiAgICB0aGlzLl9mbGF0cGlja3JPcHRpb25zID0geyAuLi5waWNrZXJPcHRpb25zLCAuLi51c2VyRmlsdGVyT3B0aW9ucyB9O1xyXG5cclxuICAgIGxldCBwbGFjZWhvbGRlciA9ICh0aGlzLmdyaWRPcHRpb25zKSA/ICh0aGlzLmdyaWRPcHRpb25zLmRlZmF1bHRGaWx0ZXJQbGFjZWhvbGRlciB8fCAnJykgOiAnJztcclxuICAgIGlmICh0aGlzLmNvbHVtbkZpbHRlciAmJiB0aGlzLmNvbHVtbkZpbHRlci5wbGFjZWhvbGRlcikge1xyXG4gICAgICBwbGFjZWhvbGRlciA9IHRoaXMuY29sdW1uRmlsdGVyLnBsYWNlaG9sZGVyO1xyXG4gICAgfVxyXG4gICAgY29uc3QgJGZpbHRlcklucHV0RWxtOiBhbnkgPSAkKGA8ZGl2IGNsYXNzPVwiZmxhdHBpY2tyXCI+PGlucHV0IHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBkYXRhLWlucHV0IHBsYWNlaG9sZGVyPVwiJHtwbGFjZWhvbGRlcn1cIj48L2Rpdj5gKTtcclxuICAgIHRoaXMuZmxhdEluc3RhbmNlID0gKCRmaWx0ZXJJbnB1dEVsbVswXSAmJiB0eXBlb2YgJGZpbHRlcklucHV0RWxtWzBdLmZsYXRwaWNrciA9PT0gJ2Z1bmN0aW9uJykgPyAkZmlsdGVySW5wdXRFbG1bMF0uZmxhdHBpY2tyKHRoaXMuX2ZsYXRwaWNrck9wdGlvbnMpIDogRmxhdHBpY2tyKCRmaWx0ZXJJbnB1dEVsbSwgdGhpcy5fZmxhdHBpY2tyT3B0aW9ucyBhcyB1bmtub3duIGFzIFBhcnRpYWw8RmxhdHBpY2tyQmFzZU9wdGlvbnM+KTtcclxuICAgIHJldHVybiAkZmlsdGVySW5wdXRFbG07XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGdldE9wdGlvblZhbHVlcygpOiB7IG9wZXJhdG9yOiBPcGVyYXRvclN0cmluZywgZGVzY3JpcHRpb246IHN0cmluZyB9W10ge1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgeyBvcGVyYXRvcjogJycsIGRlc2NyaXB0aW9uOiAnJyB9LFxyXG4gICAgICB7IG9wZXJhdG9yOiAnPScsIGRlc2NyaXB0aW9uOiB0aGlzLmdldE91dHB1dFRleHQoJ0VRVUFMX1RPJywgJ1RFWFRfRVFVQUxfVE8nLCAnRXF1YWwgdG8nKSB9LFxyXG4gICAgICB7IG9wZXJhdG9yOiAnPCcsIGRlc2NyaXB0aW9uOiB0aGlzLmdldE91dHB1dFRleHQoJ0xFU1NfVEhBTicsICdURVhUX0xFU1NfVEhBTicsICdMZXNzIHRoYW4nKSB9LFxyXG4gICAgICB7IG9wZXJhdG9yOiAnPD0nLCBkZXNjcmlwdGlvbjogdGhpcy5nZXRPdXRwdXRUZXh0KCdMRVNTX1RIQU5fT1JfRVFVQUxfVE8nLCAnVEVYVF9MRVNTX1RIQU5fT1JfRVFVQUxfVE8nLCAnTGVzcyB0aGFuIG9yIGVxdWFsIHRvJykgfSxcclxuICAgICAgeyBvcGVyYXRvcjogJz4nLCBkZXNjcmlwdGlvbjogdGhpcy5nZXRPdXRwdXRUZXh0KCdHUkVBVEVSX1RIQU4nLCAnVEVYVF9HUkVBVEVSX1RIQU4nLCAnR3JlYXRlciB0aGFuJykgfSxcclxuICAgICAgeyBvcGVyYXRvcjogJz49JywgZGVzY3JpcHRpb246IHRoaXMuZ2V0T3V0cHV0VGV4dCgnR1JFQVRFUl9USEFOX09SX0VRVUFMX1RPJywgJ1RFWFRfR1JFQVRFUl9USEFOX09SX0VRVUFMX1RPJywgJ0dyZWF0ZXIgdGhhbiBvciBlcXVhbCB0bycpIH0sXHJcbiAgICAgIHsgb3BlcmF0b3I6ICc8PicsIGRlc2NyaXB0aW9uOiB0aGlzLmdldE91dHB1dFRleHQoJ05PVF9FUVVBTF9UTycsICdURVhUX05PVF9FUVVBTF9UTycsICdOb3QgZXF1YWwgdG8nKSB9XHJcbiAgICBdO1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldCBMb2NhbGUsIFRyYW5zbGF0ZWQgb3IgYSBEZWZhdWx0IFRleHQgaWYgZmlyc3QgdHdvIGFyZW4ndCBkZXRlY3RlZCAqL1xyXG4gIHByaXZhdGUgZ2V0T3V0cHV0VGV4dCh0cmFuc2xhdGlvbktleTogc3RyaW5nLCBsb2NhbGVUZXh0OiBzdHJpbmcsIGRlZmF1bHRUZXh0OiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgaWYgKHRoaXMuZ3JpZE9wdGlvbnMgJiYgdGhpcy5ncmlkT3B0aW9ucy5lbmFibGVUcmFuc2xhdGUgJiYgdGhpcy50cmFuc2xhdGUgJiYgdGhpcy50cmFuc2xhdGUuaW5zdGFudCkge1xyXG4gICAgICBjb25zdCB0cmFuc2xhdGlvblByZWZpeCA9IGdldFRyYW5zbGF0aW9uUHJlZml4KHRoaXMuZ3JpZE9wdGlvbnMpO1xyXG4gICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGUuaW5zdGFudChgJHt0cmFuc2xhdGlvblByZWZpeH0ke3RyYW5zbGF0aW9uS2V5fWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMubG9jYWxlcyAmJiB0aGlzLmxvY2FsZXNbbG9jYWxlVGV4dF0gfHwgZGVmYXVsdFRleHQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgdGhlIERPTSBlbGVtZW50XHJcbiAgICovXHJcbiAgcHJpdmF0ZSBjcmVhdGVEb21FbGVtZW50KHNlYXJjaFRlcm0/OiBTZWFyY2hUZXJtKSB7XHJcbiAgICBjb25zdCBmaWVsZElkID0gdGhpcy5jb2x1bW5EZWYgJiYgdGhpcy5jb2x1bW5EZWYuaWQ7XHJcbiAgICBjb25zdCAkaGVhZGVyRWxtID0gdGhpcy5ncmlkLmdldEhlYWRlclJvd0NvbHVtbihmaWVsZElkKTtcclxuICAgICQoJGhlYWRlckVsbSkuZW1wdHkoKTtcclxuXHJcbiAgICAvLyBjcmVhdGUgdGhlIERPTSBTZWxlY3QgZHJvcGRvd24gZm9yIHRoZSBPcGVyYXRvclxyXG4gICAgY29uc3Qgc2VsZWN0T3BlcmF0b3JIdG1sU3RyaW5nID0gYnVpbGRTZWxlY3RPcGVyYXRvckh0bWxTdHJpbmcodGhpcy5nZXRPcHRpb25WYWx1ZXMoKSk7XHJcbiAgICB0aGlzLiRzZWxlY3RPcGVyYXRvckVsbSA9ICQoc2VsZWN0T3BlcmF0b3JIdG1sU3RyaW5nKTtcclxuICAgIHRoaXMuJGZpbHRlcklucHV0RWxtID0gdGhpcy5idWlsZERhdGVQaWNrZXJJbnB1dChzZWFyY2hUZXJtKTtcclxuICAgIGNvbnN0ICRmaWx0ZXJDb250YWluZXJFbG0gPSAkKGA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCBzZWFyY2gtZmlsdGVyIGZpbHRlci0ke2ZpZWxkSWR9XCI+PC9kaXY+YCk7XHJcbiAgICBjb25zdCAkY29udGFpbmVySW5wdXRHcm91cCA9ICQoYDxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cCBmbGF0cGlja3JcIj48L2Rpdj5gKTtcclxuICAgIGNvbnN0ICRvcGVyYXRvcklucHV0R3JvdXBBZGRvbiA9ICQoYDxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cC1hZGRvbiBpbnB1dC1ncm91cC1wcmVwZW5kIG9wZXJhdG9yXCI+PC9kaXY+YCk7XHJcblxyXG4gICAgLyogdGhlIERPTSBlbGVtZW50IGZpbmFsIHN0cnVjdHVyZSB3aWxsIGJlXHJcbiAgICAgIDxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cFwiPlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cC1hZGRvbiBpbnB1dC1ncm91cC1wcmVwZW5kIG9wZXJhdG9yXCI+XHJcbiAgICAgICAgICA8c2VsZWN0IGNsYXNzPVwiZm9ybS1jb250cm9sXCI+PC9zZWxlY3Q+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1mbGF0cGlja3I+XHJcbiAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIGRhdGEtaW5wdXQ+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgKi9cclxuICAgICRvcGVyYXRvcklucHV0R3JvdXBBZGRvbi5hcHBlbmQodGhpcy4kc2VsZWN0T3BlcmF0b3JFbG0pO1xyXG4gICAgJGNvbnRhaW5lcklucHV0R3JvdXAuYXBwZW5kKCRvcGVyYXRvcklucHV0R3JvdXBBZGRvbik7XHJcbiAgICAkY29udGFpbmVySW5wdXRHcm91cC5hcHBlbmQodGhpcy4kZmlsdGVySW5wdXRFbG0pO1xyXG5cclxuICAgIC8vIGNyZWF0ZSB0aGUgRE9NIGVsZW1lbnQgJiBhZGQgYW4gSUQgYW5kIGZpbHRlciBjbGFzc1xyXG4gICAgJGZpbHRlckNvbnRhaW5lckVsbS5hcHBlbmQoJGNvbnRhaW5lcklucHV0R3JvdXApO1xyXG4gICAgdGhpcy4kZmlsdGVySW5wdXRFbG0uZGF0YSgnY29sdW1uSWQnLCBmaWVsZElkKTtcclxuXHJcbiAgICBpZiAodGhpcy5vcGVyYXRvcikge1xyXG4gICAgICBjb25zdCBvcGVyYXRvclNob3J0aGFuZCA9IG1hcE9wZXJhdG9yVG9TaG9ydGhhbmREZXNpZ25hdGlvbih0aGlzLm9wZXJhdG9yKTtcclxuICAgICAgdGhpcy4kc2VsZWN0T3BlcmF0b3JFbG0udmFsKG9wZXJhdG9yU2hvcnRoYW5kKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBpZiB0aGVyZSdzIGEgc2VhcmNoIHRlcm0sIHdlIHdpbGwgYWRkIHRoZSBcImZpbGxlZFwiIGNsYXNzIGZvciBzdHlsaW5nIHB1cnBvc2VzXHJcbiAgICBpZiAoc2VhcmNoVGVybSAmJiBzZWFyY2hUZXJtICE9PSAnJykge1xyXG4gICAgICB0aGlzLiRmaWx0ZXJJbnB1dEVsbS5hZGRDbGFzcygnZmlsbGVkJyk7XHJcbiAgICAgIHRoaXMuX2N1cnJlbnREYXRlID0gc2VhcmNoVGVybSBhcyBEYXRlO1xyXG4gICAgICB0aGlzLl9jdXJyZW50VmFsdWUgPSBzZWFyY2hUZXJtIGFzIHN0cmluZztcclxuICAgIH1cclxuXHJcbiAgICAvLyBhcHBlbmQgdGhlIG5ldyBET00gZWxlbWVudCB0byB0aGUgaGVhZGVyIHJvd1xyXG4gICAgaWYgKCRmaWx0ZXJDb250YWluZXJFbG0gJiYgdHlwZW9mICRmaWx0ZXJDb250YWluZXJFbG0uYXBwZW5kVG8gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgJGZpbHRlckNvbnRhaW5lckVsbS5hcHBlbmRUbygkaGVhZGVyRWxtKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gJGZpbHRlckNvbnRhaW5lckVsbTtcclxuICB9XHJcblxyXG4gIC8qKiBMb2FkIGEgZGlmZmVyZW50IHNldCBvZiBsb2NhbGVzIGZvciBGbGF0cGlja3IgdG8gYmUgbG9jYWxpemVkICovXHJcbiAgcHJpdmF0ZSBsb2FkRmxhdHBpY2tyTG9jYWxlKGxhbmd1YWdlOiBzdHJpbmcpIHtcclxuICAgIGxldCBsb2NhbGVzID0gJ2VuJztcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAobGFuZ3VhZ2UgIT09ICdlbicpIHtcclxuICAgICAgICAvLyBjaGFuZ2UgbG9jYWxlIGlmIG5lZWRlZCwgRmxhdHBpY2tyIHJlZmVyZW5jZTogaHR0cHM6Ly9jaG1sbi5naXRodWIuaW8vZmxhdHBpY2tyL2xvY2FsaXphdGlvbi9cclxuICAgICAgICBjb25zdCBsb2NhbGVEZWZhdWx0OiBhbnkgPSByZXF1aXJlKGBmbGF0cGlja3IvZGlzdC9sMTBuLyR7bGFuZ3VhZ2V9LmpzYCkuZGVmYXVsdDtcclxuICAgICAgICBsb2NhbGVzID0gKGxvY2FsZURlZmF1bHQgJiYgbG9jYWxlRGVmYXVsdFtsYW5ndWFnZV0pID8gbG9jYWxlRGVmYXVsdFtsYW5ndWFnZV0gOiAnZW4nO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgW0FuZ3VsYXItU2xpY2tncmlkIC0gQ29tcG91bmREYXRlIEZpbHRlcl0gSXQgc2VlbXMgdGhhdCBcIiR7bGFuZ3VhZ2V9XCIgaXMgbm90IGEgbG9jYWxlIHN1cHBvcnRlZCBieSBGbGF0cGlja3IsIHdlIHdpbGwgdXNlIFwiZW5cIiBpbnN0ZWFkLiBgXHJcbiAgICAgICAgKyBgVG8gYXZvaWQgc2VlaW5nIHRoaXMgbWVzc2FnZSwgeW91IGNhbiBzcGVjaWZpY2FsbHkgc2V0IFwiZmlsdGVyOiB7IGZpbHRlck9wdGlvbnM6IHsgbG9jYWxlOiAnZW4nIH0gfVwiIGluIHlvdXIgY29sdW1uIGRlZmluaXRpb24uYCk7XHJcbiAgICAgIHJldHVybiAnZW4nO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxvY2FsZXM7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIG9uVHJpZ2dlckV2ZW50KGU6IEV2ZW50IHwgdW5kZWZpbmVkKSB7XHJcbiAgICBpZiAodGhpcy5fY2xlYXJGaWx0ZXJUcmlnZ2VyZWQpIHtcclxuICAgICAgdGhpcy5jYWxsYmFjayhlLCB7IGNvbHVtbkRlZjogdGhpcy5jb2x1bW5EZWYsIGNsZWFyRmlsdGVyVHJpZ2dlcmVkOiB0aGlzLl9jbGVhckZpbHRlclRyaWdnZXJlZCwgc2hvdWxkVHJpZ2dlclF1ZXJ5OiB0aGlzLl9zaG91bGRUcmlnZ2VyUXVlcnkgfSk7XHJcbiAgICAgIHRoaXMuJGZpbHRlckVsbS5yZW1vdmVDbGFzcygnZmlsbGVkJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBzZWxlY3RlZE9wZXJhdG9yID0gdGhpcy4kc2VsZWN0T3BlcmF0b3JFbG0uZmluZCgnb3B0aW9uOnNlbGVjdGVkJykudmFsKCk7XHJcbiAgICAgICh0aGlzLl9jdXJyZW50VmFsdWUpID8gdGhpcy4kZmlsdGVyRWxtLmFkZENsYXNzKCdmaWxsZWQnKSA6IHRoaXMuJGZpbHRlckVsbS5yZW1vdmVDbGFzcygnZmlsbGVkJyk7XHJcbiAgICAgIHRoaXMuY2FsbGJhY2soZSwgeyBjb2x1bW5EZWY6IHRoaXMuY29sdW1uRGVmLCBzZWFyY2hUZXJtczogKHRoaXMuX2N1cnJlbnRWYWx1ZSA/IFt0aGlzLl9jdXJyZW50VmFsdWVdIDogbnVsbCksIG9wZXJhdG9yOiBzZWxlY3RlZE9wZXJhdG9yIHx8ICcnLCBzaG91bGRUcmlnZ2VyUXVlcnk6IHRoaXMuX3Nob3VsZFRyaWdnZXJRdWVyeSB9KTtcclxuICAgIH1cclxuICAgIC8vIHJlc2V0IGJvdGggZmxhZ3MgZm9yIG5leHQgdXNlXHJcbiAgICB0aGlzLl9jbGVhckZpbHRlclRyaWdnZXJlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5fc2hvdWxkVHJpZ2dlclF1ZXJ5ID0gdHJ1ZTtcclxuICB9XHJcbn1cclxuIl19