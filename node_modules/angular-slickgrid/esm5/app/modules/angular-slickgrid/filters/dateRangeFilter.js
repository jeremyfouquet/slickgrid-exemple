import * as tslib_1 from "tslib";
import { Optional } from '@angular/core';
import { destroyObjectDomElementProps, mapFlatpickrDateFormatWithFieldType, mapMomentDateFormatWithFieldType } from '../services/utilities';
import { FieldType, OperatorType, } from '../models/index';
import Flatpickr from 'flatpickr';
import * as moment_ from 'moment-mini';
var moment = moment_; // patch to fix rollup "moment has no default export" issue, document here https://github.com/rollup/rollup/issues/670
require('flatpickr');
var DateRangeFilter = /** @class */ (function () {
    function DateRangeFilter(translate) {
        this.translate = translate;
        this._clearFilterTriggered = false;
        this._shouldTriggerQuery = true;
    }
    Object.defineProperty(DateRangeFilter.prototype, "gridOptions", {
        /** Getter for the Grid Options pulled through the Grid Object */
        get: function () {
            return (this.grid && this.grid.getOptions) ? this.grid.getOptions() : {};
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateRangeFilter.prototype, "columnFilter", {
        /** Getter for the Column Filter */
        get: function () {
            return this.columnDef && this.columnDef.filter || {};
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateRangeFilter.prototype, "currentDates", {
        /** Getter for the Current Dates selected */
        get: function () {
            return this._currentDates;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateRangeFilter.prototype, "defaultOperator", {
        /** Getter to know what would be the default operator when none is specified */
        get: function () {
            return this.gridOptions.defaultFilterRangeOperator || OperatorType.rangeExclusive;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateRangeFilter.prototype, "flatpickrOptions", {
        /** Getter for the Flatpickr Options */
        get: function () {
            return this._flatpickrOptions || {};
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateRangeFilter.prototype, "operator", {
        /** Getter of the Operator to use when doing the filter comparing */
        get: function () {
            return this.columnFilter && this.columnFilter.operator || this.defaultOperator;
        },
        /** Setter for the filter operator */
        set: function (operator) {
            if (this.columnFilter) {
                this.columnFilter.operator = operator;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Initialize the Filter
     */
    DateRangeFilter.prototype.init = function (args) {
        var _this = this;
        if (!args) {
            throw new Error('[Angular-SlickGrid] A filter must always have an "init()" with valid arguments.');
        }
        this.grid = args.grid;
        this.callback = args.callback;
        this.columnDef = args.columnDef;
        this.searchTerms = (args.hasOwnProperty('searchTerms') ? args.searchTerms : []) || [];
        // step 1, create the DOM Element of the filter which contain the compound Operator+Input
        this.$filterElm = this.createDomElement(this.searchTerms);
        // step 3, subscribe to the keyup event and run the callback when that happens
        // also add/remove "filled" class for styling purposes
        this.$filterInputElm.keyup(function (e) {
            _this.onTriggerEvent(e);
        });
    };
    /**
     * Clear the filter value
     */
    DateRangeFilter.prototype.clear = function (shouldTriggerQuery) {
        if (shouldTriggerQuery === void 0) { shouldTriggerQuery = true; }
        if (this.flatInstance) {
            this._clearFilterTriggered = true;
            this._shouldTriggerQuery = shouldTriggerQuery;
            this.searchTerms = [];
            this.flatInstance.clear();
        }
    };
    /**
     * destroy the filter
     */
    DateRangeFilter.prototype.destroy = function () {
        if (this.flatInstance && typeof this.flatInstance.destroy === 'function') {
            this.flatInstance.destroy();
            if (this.flatInstance.element) {
                destroyObjectDomElementProps(this.flatInstance);
            }
        }
        if (this.$filterElm) {
            this.$filterElm.off('keyup').remove();
        }
        this.flatInstance = null;
        this.$filterElm = null;
        this.callback = null;
        this.onTriggerEvent = null;
    };
    DateRangeFilter.prototype.hide = function () {
        if (this.flatInstance && typeof this.flatInstance.close === 'function') {
            this.flatInstance.close();
        }
    };
    DateRangeFilter.prototype.show = function () {
        if (this.flatInstance && typeof this.flatInstance.open === 'function') {
            this.flatInstance.open();
        }
    };
    /**
     * Set value(s) on the DOM element
     * @params searchTerms
     */
    DateRangeFilter.prototype.setValues = function (searchTerms, operator) {
        var pickerValues = [];
        // get the picker values, if it's a string with the "..", we'll do the split else we'll use the array of search terms
        if (typeof searchTerms === 'string' || (Array.isArray(searchTerms) && typeof searchTerms[0] === 'string') && searchTerms[0].indexOf('..') > 0) {
            pickerValues = (typeof searchTerms === 'string') ? [searchTerms] : searchTerms[0].split('..');
        }
        else if (Array.isArray(searchTerms)) {
            pickerValues = searchTerms;
        }
        if (this.flatInstance && searchTerms) {
            this._currentDates = pickerValues;
            this.flatInstance.setDate(pickerValues);
        }
        // set the operator when defined
        this.operator = operator || this.defaultOperator;
    };
    //
    // private functions
    // ------------------
    DateRangeFilter.prototype.buildDatePickerInput = function (searchTerms) {
        var _this = this;
        var columnId = this.columnDef && this.columnDef.id || '';
        var inputFormat = mapFlatpickrDateFormatWithFieldType(this.columnFilter.type || this.columnDef.type || FieldType.dateIso);
        var outputFormat = mapFlatpickrDateFormatWithFieldType(this.columnDef.outputType || this.columnFilter.type || this.columnDef.type || FieldType.dateUtc);
        var userFilterOptions = (this.columnFilter && this.columnFilter.filterOptions || {});
        // get current locale, if user defined a custom locale just use or get it the Translate Service if it exist else just use English
        var currentLocale = (userFilterOptions && userFilterOptions.locale) || (this.translate && this.translate.currentLang) || this.gridOptions.locale || 'en';
        if (currentLocale.length > 2) {
            currentLocale = currentLocale.substring(0, 2);
        }
        var pickerValues = [];
        // get the picker values, if it's a string with the "..", we'll do the split else we'll use the array of search terms
        if (typeof searchTerms === 'string' || (Array.isArray(searchTerms) && typeof searchTerms[0] === 'string') && searchTerms[0].indexOf('..') > 0) {
            pickerValues = (typeof searchTerms === 'string') ? [searchTerms] : searchTerms[0].split('..');
        }
        else if (Array.isArray(searchTerms)) {
            pickerValues = searchTerms;
        }
        // if we are preloading searchTerms, we'll keep them for reference
        if (pickerValues) {
            this._currentDates = pickerValues;
            var outFormat_1 = mapMomentDateFormatWithFieldType(this.columnFilter.type || this.columnDef.type || FieldType.dateIso);
            this._currentDateStrings = pickerValues.map(function (date) { return moment(date).format(outFormat_1); });
        }
        var pickerOptions = {
            defaultDate: pickerValues || '',
            altInput: true,
            altFormat: outputFormat,
            dateFormat: inputFormat,
            mode: 'range',
            wrap: true,
            closeOnSelect: true,
            locale: (currentLocale !== 'en') ? this.loadFlatpickrLocale(currentLocale) : 'en',
            onChange: function (selectedDates, dateStr, instance) {
                if (Array.isArray(selectedDates)) {
                    _this._currentDates = selectedDates;
                    var outFormat_2 = mapMomentDateFormatWithFieldType(_this.columnDef.outputType || _this.columnFilter.type || _this.columnDef.type || FieldType.dateIso);
                    _this._currentDateStrings = selectedDates.map(function (date) { return moment(date).format(outFormat_2); });
                    _this._currentValue = _this._currentDateStrings.join('..');
                }
                // when using the time picker, we can simulate a keyup event to avoid multiple backend request
                // since backend request are only executed after user start typing, changing the time should be treated the same way
                var newEvent = pickerOptions.enableTime ? new CustomEvent('keyup') : undefined;
                _this.onTriggerEvent(newEvent);
            }
        };
        // add the time picker when format is UTC (Z) or has the 'h' (meaning hours)
        if (outputFormat && (outputFormat === 'Z' || outputFormat.toLowerCase().includes('h'))) {
            pickerOptions.enableTime = true;
        }
        // merge options with optional user's custom options
        this._flatpickrOptions = tslib_1.__assign({}, pickerOptions, userFilterOptions);
        var placeholder = (this.gridOptions) ? (this.gridOptions.defaultFilterPlaceholder || '') : '';
        if (this.columnFilter && this.columnFilter.placeholder) {
            placeholder = this.columnFilter.placeholder;
        }
        var $filterInputElm = $("<div class=\"flatpickr search-filter filter-" + columnId + "\"><input type=\"text\" class=\"form-control\" data-input placeholder=\"" + placeholder + "\"></div>");
        this.flatInstance = ($filterInputElm[0] && typeof $filterInputElm[0].flatpickr === 'function') ? $filterInputElm[0].flatpickr(this._flatpickrOptions) : Flatpickr($filterInputElm, this._flatpickrOptions);
        return $filterInputElm;
    };
    /**
     * Create the DOM element
     * @params searchTerms
     */
    DateRangeFilter.prototype.createDomElement = function (searchTerms) {
        var fieldId = this.columnDef && this.columnDef.id;
        var $headerElm = this.grid.getHeaderRowColumn(fieldId);
        $($headerElm).empty();
        // create the DOM Select dropdown for the Operator
        this.$filterInputElm = this.buildDatePickerInput(searchTerms);
        /* the DOM element final structure will be
          <div class=flatpickr>
            <input type="text" class="form-control" data-input>
          </div>
        */
        // create the DOM element & add an ID and filter class
        this.$filterInputElm.data('columnId', fieldId);
        // if there's a search term, we will add the "filled" class for styling purposes
        if (Array.isArray(searchTerms) && searchTerms.length > 0 && searchTerms[0] !== '') {
            this.$filterInputElm.addClass('filled');
            this._currentDates = searchTerms;
            this._currentValue = searchTerms[0];
        }
        // append the new DOM element to the header row
        if (this.$filterInputElm && typeof this.$filterInputElm.appendTo === 'function') {
            this.$filterInputElm.appendTo($headerElm);
        }
        return this.$filterInputElm;
    };
    /** Load a different set of locales for Flatpickr to be localized */
    DateRangeFilter.prototype.loadFlatpickrLocale = function (language) {
        var locales = 'en';
        try {
            if (language !== 'en') {
                // change locale if needed, Flatpickr reference: https://chmln.github.io/flatpickr/localization/
                var localeDefault = require("flatpickr/dist/l10n/" + language + ".js").default;
                locales = (localeDefault && localeDefault[language]) ? localeDefault[language] : 'en';
            }
        }
        catch (e) {
            console.warn("[Angular-Slickgrid - DateRange Filter] It seems that \"" + language + "\" is not a locale supported by Flatpickr, we will use \"en\" instead. "
                + "To avoid seeing this message, you can specifically set \"filter: { filterOptions: { locale: 'en' } }\" in your column definition.");
            return 'en';
        }
        return locales;
    };
    DateRangeFilter.prototype.onTriggerEvent = function (e) {
        if (this._clearFilterTriggered) {
            this.callback(e, { columnDef: this.columnDef, clearFilterTriggered: this._clearFilterTriggered, shouldTriggerQuery: this._shouldTriggerQuery });
            this.$filterElm.removeClass('filled');
        }
        else {
            (this._currentDateStrings) ? this.$filterElm.addClass('filled') : this.$filterElm.removeClass('filled');
            this.callback(e, { columnDef: this.columnDef, searchTerms: (this._currentDateStrings ? this._currentDateStrings : [this._currentValue]), operator: this.operator || '', shouldTriggerQuery: this._shouldTriggerQuery });
        }
        // reset both flags for next use
        this._clearFilterTriggered = false;
        this._shouldTriggerQuery = true;
    };
    DateRangeFilter = tslib_1.__decorate([
        tslib_1.__param(0, Optional())
    ], DateRangeFilter);
    return DateRangeFilter;
}());
export { DateRangeFilter };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZVJhbmdlRmlsdGVyLmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci1zbGlja2dyaWQvIiwic291cmNlcyI6WyJhcHAvbW9kdWxlcy9hbmd1bGFyLXNsaWNrZ3JpZC9maWx0ZXJzL2RhdGVSYW5nZUZpbHRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUV6QyxPQUFPLEVBQUUsNEJBQTRCLEVBQUUsbUNBQW1DLEVBQUUsZ0NBQWdDLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUM1SSxPQUFPLEVBR0wsU0FBUyxFQU9ULFlBQVksR0FFYixNQUFNLGlCQUFpQixDQUFDO0FBQ3pCLE9BQU8sU0FBUyxNQUFNLFdBQVcsQ0FBQztBQUVsQyxPQUFPLEtBQUssT0FBTyxNQUFNLGFBQWEsQ0FBQztBQUN2QyxJQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsQ0FBQyxzSEFBc0g7QUFJOUksT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBS3JCO0lBZUUseUJBQWdDLFNBQTJCO1FBQTNCLGNBQVMsR0FBVCxTQUFTLENBQWtCO1FBZG5ELDBCQUFxQixHQUFHLEtBQUssQ0FBQztRQUs5Qix3QkFBbUIsR0FBRyxJQUFJLENBQUM7SUFTNEIsQ0FBQztJQUdoRSxzQkFBWSx3Q0FBVztRQUR2QixpRUFBaUU7YUFDakU7WUFDRSxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFDM0UsQ0FBQzs7O09BQUE7SUFHRCxzQkFBSSx5Q0FBWTtRQURoQixtQ0FBbUM7YUFDbkM7WUFDRSxPQUFPLElBQUksQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDO1FBQ3ZELENB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RUFBRSxJQUFJLENBQUMsU0FBUyxFQUFFLFdBQVcsRUFBRSxDQUFDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxFQUFFLFFBQVEsRUFBRSxJQUFJLENBQUMsUUFBUSxJQUFJLEVBQUUsRUFBRSxrQkFBa0IsRUFBRSxJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQyxDQUFDO1NBQ3pOO1FBQ0QsZ0NBQWdDO1FBQ2hDLElBQUksQ0FBQyxxQkFBcUIsR0FBRyxLQUFLLENBQUM7UUFDbkMsSUFBSSxDQUFDLG1CQUFtQixHQUFHLElBQUksQ0FBQztJQUNsQyxDQUFDO0lBeFJVLGVBQWU7UUFlYixtQkFBQSxRQUFRLEVBQUUsQ0FBQTtPQWZaLGVBQWUsQ0F5UjNCO0lBQUQsc0JBQUM7Q0FBQSxBQXpSRCxJQXlSQztTQXpSWSxlQUFlIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgVHJhbnNsYXRlU2VydmljZSB9IGZyb20gJ0BuZ3gtdHJhbnNsYXRlL2NvcmUnO1xyXG5pbXBvcnQgeyBkZXN0cm95T2JqZWN0RG9tRWxlbWVudFByb3BzLCBtYXBGbGF0cGlja3JEYXRlRm9ybWF0V2l0aEZpZWxkVHlwZSwgbWFwTW9tZW50RGF0ZUZvcm1hdFdpdGhGaWVsZFR5cGUgfSBmcm9tICcuLi9zZXJ2aWNlcy91dGlsaXRpZXMnO1xyXG5pbXBvcnQge1xyXG4gIENvbHVtbixcclxuICBDb2x1bW5GaWx0ZXIsXHJcbiAgRmllbGRUeXBlLFxyXG4gIEZpbHRlcixcclxuICBGaWx0ZXJBcmd1bWVudHMsXHJcbiAgRmlsdGVyQ2FsbGJhY2ssXHJcbiAgRmxhdHBpY2tyT3B0aW9uLFxyXG4gIEdyaWRPcHRpb24sXHJcbiAgT3BlcmF0b3JTdHJpbmcsXHJcbiAgT3BlcmF0b3JUeXBlLFxyXG4gIFNlYXJjaFRlcm0sXHJcbn0gZnJvbSAnLi4vbW9kZWxzL2luZGV4JztcclxuaW1wb3J0IEZsYXRwaWNrciBmcm9tICdmbGF0cGlja3InO1xyXG5pbXBvcnQgeyBCYXNlT3B0aW9ucyBhcyBGbGF0cGlja3JCYXNlT3B0aW9ucyB9IGZyb20gJ2ZsYXRwaWNrci9kaXN0L3R5cGVzL29wdGlvbnMnO1xyXG5pbXBvcnQgKiBhcyBtb21lbnRfIGZyb20gJ21vbWVudC1taW5pJztcclxuY29uc3QgbW9tZW50ID0gbW9tZW50XzsgLy8gcGF0Y2ggdG8gZml4IHJvbGx1cCBcIm1vbWVudCBoYXMgbm8gZGVmYXVsdCBleHBvcnRcIiBpc3N1ZSwgZG9jdW1lbnQgaGVyZSBodHRwczovL2dpdGh1Yi5jb20vcm9sbHVwL3JvbGx1cC9pc3N1ZXMvNjcwXHJcblxyXG4vLyB1c2UgRmxhdHBpY2tyIGZyb20gaW1wb3J0IG9yICdyZXF1aXJlJywgd2hpY2hldmVyIHdvcmtzIGZpcnN0XHJcbmRlY2xhcmUgZnVuY3Rpb24gcmVxdWlyZShuYW1lOiBzdHJpbmcpOiBhbnk7XHJcbnJlcXVpcmUoJ2ZsYXRwaWNrcicpO1xyXG5cclxuLy8gdXNpbmcgZXh0ZXJuYWwgbm9uLXR5cGVkIGpzIGxpYnJhcmllc1xyXG5kZWNsYXJlIGNvbnN0ICQ6IGFueTtcclxuXHJcbmV4cG9ydCBjbGFzcyBEYXRlUmFuZ2VGaWx0ZXIgaW1wbGVtZW50cyBGaWx0ZXIge1xyXG4gIHByaXZhdGUgX2NsZWFyRmlsdGVyVHJpZ2dlcmVkID0gZmFsc2U7XHJcbiAgcHJpdmF0ZSBfY3VycmVudFZhbHVlOiBzdHJpbmc7XHJcbiAgcHJpdmF0ZSBfY3VycmVudERhdGVzOiBEYXRlW107XHJcbiAgcHJpdmF0ZSBfY3VycmVudERhdGVTdHJpbmdzOiBzdHJpbmdbXTtcclxuICBwcml2YXRlIF9mbGF0cGlja3JPcHRpb25zOiBGbGF0cGlja3JPcHRpb247XHJcbiAgcHJpdmF0ZSBfc2hvdWxkVHJpZ2dlclF1ZXJ5ID0gdHJ1ZTtcclxuICBwcml2YXRlICRmaWx0ZXJFbG06IGFueTtcclxuICBwcml2YXRlICRmaWx0ZXJJbnB1dEVsbTogYW55O1xyXG4gIGZsYXRJbnN0YW5jZTogYW55O1xyXG4gIGdyaWQ6IGFueTtcclxuICBzZWFyY2hUZXJtczogU2VhcmNoVGVybVtdO1xyXG4gIGNvbHVtbkRlZjogQ29sdW1uO1xyXG4gIGNhbGxiYWNrOiBGaWx0ZXJDYWxsYmFjaztcclxuXHJcbiAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgcHJpdmF0ZSB0cmFuc2xhdGU6IFRyYW5zbGF0ZVNlcnZpY2UpIHsgfVxyXG5cclxuICAvKiogR2V0dGVyIGZvciB0aGUgR3JpZCBPcHRpb25zIHB1bGxlZCB0aHJvdWdoIHRoZSBHcmlkIE9iamVjdCAqL1xyXG4gIHByaXZhdGUgZ2V0IGdyaWRPcHRpb25zKCk6IEdyaWRPcHRpb24ge1xyXG4gICAgcmV0dXJuICh0aGlzLmdyaWQgJiYgdGhpcy5ncmlkLmdldE9wdGlvbnMpID8gdGhpcy5ncmlkLmdldE9wdGlvbnMoKSA6IHt9O1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldHRlciBmb3IgdGhlIENvbHVtbiBGaWx0ZXIgKi9cclxuICBnZXQgY29sdW1uRmlsdGVyKCk6IENvbHVtbkZpbHRlciB7XHJcbiAgICByZXR1cm4gdGhpcy5jb2x1bW5EZWYgJiYgdGhpcy5jb2x1bW5EZWYuZmlsdGVyIHx8IHt9O1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldHRlciBmb3IgdGhlIEN1cnJlbnQgRGF0ZXMgc2VsZWN0ZWQgKi9cclxuICBnZXQgY3VycmVudERhdGVzKCk6IERhdGVbXSB7XHJcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudERhdGVzO1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldHRlciB0byBrbm93IHdoYXQgd291bGQgYmUgdGhlIGRlZmF1bHQgb3BlcmF0b3Igd2hlbiBub25lIGlzIHNwZWNpZmllZCAqL1xyXG4gIGdldCBkZWZhdWx0T3BlcmF0b3IoKTogT3BlcmF0b3JUeXBlIHwgT3BlcmF0b3JTdHJpbmcge1xyXG4gICAgcmV0dXJuIHRoaXMuZ3JpZE9wdGlvbnMuZGVmYXVsdEZpbHRlclJhbmdlT3BlcmF0b3IgfHwgT3BlcmF0b3JUeXBlLnJhbmdlRXhjbHVzaXZlO1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldHRlciBmb3IgdGhlIEZsYXRwaWNrciBPcHRpb25zICovXHJcbiAgZ2V0IGZsYXRwaWNrck9wdGlvbnMoKTogRmxhdHBpY2tyT3B0aW9uIHtcclxuICAgIHJldHVybiB0aGlzLl9mbGF0cGlja3JPcHRpb25zIHx8IHt9O1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldHRlciBvZiB0aGUgT3BlcmF0b3IgdG8gdXNlIHdoZW4gZG9pbmcgdGhlIGZpbHRlciBjb21wYXJpbmcgKi9cclxuICBnZXQgb3BlcmF0b3IoKTogT3BlcmF0b3JUeXBlIHwgT3BlcmF0b3JTdHJpbmcge1xyXG4gICAgcmV0dXJuIHRoaXMuY29sdW1uRmlsdGVyICYmIHRoaXMuY29sdW1uRmlsdGVyLm9wZXJhdG9yIHx8IHRoaXMuZGVmYXVsdE9wZXJhdG9yO1xyXG4gIH1cclxuXHJcbiAgLyoqIFNldHRlciBmb3IgdGhlIGZpbHRlciBvcGVyYXRvciAqL1xyXG4gIHNldCBvcGVyYXRvcihvcGVyYXRvcjogT3BlcmF0b3JUeXBlIHwgT3BlcmF0b3JTdHJpbmcpIHtcclxuICAgIGlmICh0aGlzLmNvbHVtbkZpbHRlcikge1xyXG4gICAgICB0aGlzLmNvbHVtbkZpbHRlci5vcGVyYXRvciA9IG9wZXJhdG9yO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZSB0aGUgRmlsdGVyXHJcbiAgICovXHJcbiAgaW5pdChhcmdzOiBGaWx0ZXJBcmd1bWVudHMpIHtcclxuICAgIGlmICghYXJncykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tBbmd1bGFyLVNsaWNrR3JpZF0gQSBmaWx0ZXIgbXVzdCBhbHdheXMgaGF2ZSBhbiBcImluaXQoKVwiIHdpdGggdmFsaWQgYXJndW1lbnRzLicpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZ3JpZCA9IGFyZ3MuZ3JpZDtcclxuICAgIHRoaXMuY2FsbGJhY2sgPSBhcmdzLmNhbGxiYWNrO1xyXG4gICAgdGhpcy5jb2x1bW5EZWYgPSBhcmdzLmNvbHVtbkRlZjtcclxuICAgIHRoaXMuc2VhcmNoVGVybXMgPSAoYXJncy5oYXNPd25Qcm9wZXJ0eSgnc2VhcmNoVGVybXMnKSA/IGFyZ3Muc2VhcmNoVGVybXMgOiBbXSkgfHwgW107XHJcblxyXG4gICAgLy8gc3RlcCAxLCBjcmVhdGUgdGhlIERPTSBFbGVtZW50IG9mIHRoZSBmaWx0ZXIgd2hpY2ggY29udGFpbiB0aGUgY29tcG91bmQgT3BlcmF0b3IrSW5wdXRcclxuICAgIHRoaXMuJGZpbHRlckVsbSA9IHRoaXMuY3JlYXRlRG9tRWxlbWVudCh0aGlzLnNlYXJjaFRlcm1zKTtcclxuXHJcbiAgICAvLyBzdGVwIDMsIHN1YnNjcmliZSB0byB0aGUga2V5dXAgZXZlbnQgYW5kIHJ1biB0aGUgY2FsbGJhY2sgd2hlbiB0aGF0IGhhcHBlbnNcclxuICAgIC8vIGFsc28gYWRkL3JlbW92ZSBcImZpbGxlZFwiIGNsYXNzIGZvciBzdHlsaW5nIHB1cnBvc2VzXHJcbiAgICB0aGlzLiRmaWx0ZXJJbnB1dEVsbS5rZXl1cCgoZTogYW55KSA9PiB7XHJcbiAgICAgIHRoaXMub25UcmlnZ2VyRXZlbnQoZSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENsZWFyIHRoZSBmaWx0ZXIgdmFsdWVcclxuICAgKi9cclxuICBjbGVhcihzaG91bGRUcmlnZ2VyUXVlcnkgPSB0cnVlKSB7XHJcbiAgICBpZiAodGhpcy5mbGF0SW5zdGFuY2UpIHtcclxuICAgICAgdGhpcy5fY2xlYXJGaWx0ZXJUcmlnZ2VyZWQgPSB0cnVlO1xyXG4gICAgICB0aGlzLl9zaG91bGRUcmlnZ2VyUXVlcnkgPSBzaG91bGRUcmlnZ2VyUXVlcnk7XHJcbiAgICAgIHRoaXMuc2VhcmNoVGVybXMgPSBbXTtcclxuICAgICAgdGhpcy5mbGF0SW5zdGFuY2UuY2xlYXIoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIGRlc3Ryb3kgdGhlIGZpbHRlclxyXG4gICAqL1xyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICBpZiAodGhpcy5mbGF0SW5zdGFuY2UgJiYgdHlwZW9mIHRoaXMuZmxhdEluc3RhbmNlLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhpcy5mbGF0SW5zdGFuY2UuZGVzdHJveSgpO1xyXG4gICAgICBpZiAodGhpcy5mbGF0SW5zdGFuY2UuZWxlbWVudCkge1xyXG4gICAgICAgIGRlc3Ryb3lPYmplY3REb21FbGVtZW50UHJvcHModGhpcy5mbGF0SW5zdGFuY2UpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy4kZmlsdGVyRWxtKSB7XHJcbiAgICAgIHRoaXMuJGZpbHRlckVsbS5vZmYoJ2tleXVwJykucmVtb3ZlKCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmZsYXRJbnN0YW5jZSA9IG51bGw7XHJcbiAgICB0aGlzLiRmaWx0ZXJFbG0gPSBudWxsO1xyXG4gICAgdGhpcy5jYWxsYmFjayA9IG51bGw7XHJcbiAgICB0aGlzLm9uVHJpZ2dlckV2ZW50ID0gbnVsbDtcclxuICB9XHJcblxyXG4gIGhpZGUoKSB7XHJcbiAgICBpZiAodGhpcy5mbGF0SW5zdGFuY2UgJiYgdHlwZW9mIHRoaXMuZmxhdEluc3RhbmNlLmNsb3NlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHRoaXMuZmxhdEluc3RhbmNlLmNsb3NlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzaG93KCkge1xyXG4gICAgaWYgKHRoaXMuZmxhdEluc3RhbmNlICYmIHR5cGVvZiB0aGlzLmZsYXRJbnN0YW5jZS5vcGVuID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHRoaXMuZmxhdEluc3RhbmNlLm9wZW4oKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCB2YWx1ZShzKSBvbiB0aGUgRE9NIGVsZW1lbnRcclxuICAgKiBAcGFyYW1zIHNlYXJjaFRlcm1zXHJcbiAgICovXHJcbiAgc2V0VmFsdWVzKHNlYXJjaFRlcm1zOiBTZWFyY2hUZXJtW10sIG9wZXJhdG9yPzogT3BlcmF0b3JUeXBlIHwgT3BlcmF0b3JTdHJpbmcpIHtcclxuICAgIGxldCBwaWNrZXJWYWx1ZXMgPSBbXTtcclxuXHJcbiAgICAvLyBnZXQgdGhlIHBpY2tlciB2YWx1ZXMsIGlmIGl0J3MgYSBzdHJpbmcgd2l0aCB0aGUgXCIuLlwiLCB3ZSdsbCBkbyB0aGUgc3BsaXQgZWxzZSB3ZSdsbCB1c2UgdGhlIGFycmF5IG9mIHNlYXJjaCB0ZXJtc1xyXG4gICAgaWYgKHR5cGVvZiBzZWFyY2hUZXJtcyA9PT0gJ3N0cmluZycgfHwgKEFycmF5LmlzQXJyYXkoc2VhcmNoVGVybXMpICYmIHR5cGVvZiBzZWFyY2hUZXJtc1swXSA9PT0gJ3N0cmluZycpICYmIChzZWFyY2hUZXJtc1swXSBhcyBzdHJpbmcpLmluZGV4T2YoJy4uJykgPiAwKSB7XHJcbiAgICAgIHBpY2tlclZhbHVlcyA9ICh0eXBlb2Ygc2VhcmNoVGVybXMgPT09ICdzdHJpbmcnKSA/IFsoc2VhcmNoVGVybXMgYXMgc3RyaW5nKV0gOiAoc2VhcmNoVGVybXNbMF0gYXMgc3RyaW5nKS5zcGxpdCgnLi4nKTtcclxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzZWFyY2hUZXJtcykpIHtcclxuICAgICAgcGlja2VyVmFsdWVzID0gc2VhcmNoVGVybXM7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuZmxhdEluc3RhbmNlICYmIHNlYXJjaFRlcm1zKSB7XHJcbiAgICAgIHRoaXMuX2N1cnJlbnREYXRlcyA9IHBpY2tlclZhbHVlcztcclxuICAgICAgdGhpcy5mbGF0SW5zdGFuY2Uuc2V0RGF0ZShwaWNrZXJWYWx1ZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHNldCB0aGUgb3BlcmF0b3Igd2hlbiBkZWZpbmVkXHJcbiAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3IgfHwgdGhpcy5kZWZhdWx0T3BlcmF0b3I7XHJcbiAgfVxyXG5cclxuICAvL1xyXG4gIC8vIHByaXZhdGUgZnVuY3Rpb25zXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgcHJpdmF0ZSBidWlsZERhdGVQaWNrZXJJbnB1dChzZWFyY2hUZXJtcz86IFNlYXJjaFRlcm0gfCBTZWFyY2hUZXJtW10pIHtcclxuICAgIGNvbnN0IGNvbHVtbklkID0gdGhpcy5jb2x1bW5EZWYgJiYgdGhpcy5jb2x1bW5EZWYuaWQgfHwgJyc7XHJcbiAgICBjb25zdCBpbnB1dEZvcm1hdCA9IG1hcEZsYXRwaWNrckRhdGVGb3JtYXRXaXRoRmllbGRUeXBlKHRoaXMuY29sdW1uRmlsdGVyLnR5cGUgfHwgdGhpcy5jb2x1bW5EZWYudHlwZSB8fCBGaWVsZFR5cGUuZGF0ZUlzbyk7XHJcbiAgICBjb25zdCBvdXRwdXRGb3JtYXQgPSBtYXBGbGF0cGlja3JEYXRlRm9ybWF0V2l0aEZpZWxkVHlwZSh0aGlzLmNvbHVtbkRlZi5vdXRwdXRUeXBlIHx8IHRoaXMuY29sdW1uRmlsdGVyLnR5cGUgfHwgdGhpcy5jb2x1bW5EZWYudHlwZSB8fCBGaWVsZFR5cGUuZGF0ZVV0Yyk7XHJcbiAgICBjb25zdCB1c2VyRmlsdGVyT3B0aW9ucyA9ICh0aGlzLmNvbHVtbkZpbHRlciAmJiB0aGlzLmNvbHVtbkZpbHRlci5maWx0ZXJPcHRpb25zIHx8IHt9KSBhcyBGbGF0cGlja3JPcHRpb247XHJcblxyXG4gICAgLy8gZ2V0IGN1cnJlbnQgbG9jYWxlLCBpZiB1c2VyIGRlZmluZWQgYSBjdXN0b20gbG9jYWxlIGp1c3QgdXNlIG9yIGdldCBpdCB0aGUgVHJhbnNsYXRlIFNlcnZpY2UgaWYgaXQgZXhpc3QgZWxzZSBqdXN0IHVzZSBFbmdsaXNoXHJcbiAgICBsZXQgY3VycmVudExvY2FsZSA9ICh1c2VyRmlsdGVyT3B0aW9ucyAmJiB1c2VyRmlsdGVyT3B0aW9ucy5sb2NhbGUpIHx8ICh0aGlzLnRyYW5zbGF0ZSAmJiB0aGlzLnRyYW5zbGF0ZS5jdXJyZW50TGFuZykgfHwgdGhpcy5ncmlkT3B0aW9ucy5sb2NhbGUgfHwgJ2VuJztcclxuICAgIGlmIChjdXJyZW50TG9jYWxlLmxlbmd0aCA+IDIpIHtcclxuICAgICAgY3VycmVudExvY2FsZSA9IGN1cnJlbnRMb2NhbGUuc3Vic3RyaW5nKDAsIDIpO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBwaWNrZXJWYWx1ZXMgPSBbXTtcclxuXHJcbiAgICAvLyBnZXQgdGhlIHBpY2tlciB2YWx1ZXMsIGlmIGl0J3MgYSBzdHJpbmcgd2l0aCB0aGUgXCIuLlwiLCB3ZSdsbCBkbyB0aGUgc3BsaXQgZWxzZSB3ZSdsbCB1c2UgdGhlIGFycmF5IG9mIHNlYXJjaCB0ZXJtc1xyXG4gICAgaWYgKHR5cGVvZiBzZWFyY2hUZXJtcyA9PT0gJ3N0cmluZycgfHwgKEFycmF5LmlzQXJyYXkoc2VhcmNoVGVybXMpICYmIHR5cGVvZiBzZWFyY2hUZXJtc1swXSA9PT0gJ3N0cmluZycpICYmIChzZWFyY2hUZXJtc1swXSBhcyBzdHJpbmcpLmluZGV4T2YoJy4uJykgPiAwKSB7XHJcbiAgICAgIHBpY2tlclZhbHVlcyA9ICh0eXBlb2Ygc2VhcmNoVGVybXMgPT09ICdzdHJpbmcnKSA/IFsoc2VhcmNoVGVybXMgYXMgc3RyaW5nKV0gOiAoc2VhcmNoVGVybXNbMF0gYXMgc3RyaW5nKS5zcGxpdCgnLi4nKTtcclxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzZWFyY2hUZXJtcykpIHtcclxuICAgICAgcGlja2VyVmFsdWVzID0gc2VhcmNoVGVybXM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaWYgd2UgYXJlIHByZWxvYWRpbmcgc2VhcmNoVGVybXMsIHdlJ2xsIGtlZXAgdGhlbSBmb3IgcmVmZXJlbmNlXHJcbiAgICBpZiAocGlja2VyVmFsdWVzKSB7XHJcbiAgICAgIHRoaXMuX2N1cnJlbnREYXRlcyA9IHBpY2tlclZhbHVlcztcclxuICAgICAgY29uc3Qgb3V0Rm9ybWF0ID0gbWFwTW9tZW50RGF0ZUZvcm1hdFdpdGhGaWVsZFR5cGUodGhpcy5jb2x1bW5GaWx0ZXIudHlwZSB8fCB0aGlzLmNvbHVtbkRlZi50eXBlIHx8IEZpZWxkVHlwZS5kYXRlSXNvKTtcclxuICAgICAgdGhpcy5fY3VycmVudERhdGVTdHJpbmdzID0gcGlja2VyVmFsdWVzLm1hcChkYXRlID0+IG1vbWVudChkYXRlKS5mb3JtYXQob3V0Rm9ybWF0KSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcGlja2VyT3B0aW9uczogRmxhdHBpY2tyT3B0aW9uID0ge1xyXG4gICAgICBkZWZhdWx0RGF0ZTogcGlja2VyVmFsdWVzIHx8ICcnLFxyXG4gICAgICBhbHRJbnB1dDogdHJ1ZSxcclxuICAgICAgYWx0Rm9ybWF0OiBvdXRwdXRGb3JtYXQsXHJcbiAgICAgIGRhdGVGb3JtYXQ6IGlucHV0Rm9ybWF0LFxyXG4gICAgICBtb2RlOiAncmFuZ2UnLFxyXG4gICAgICB3cmFwOiB0cnVlLFxyXG4gICAgICBjbG9zZU9uU2VsZWN0OiB0cnVlLFxyXG4gICAgICBsb2NhbGU6IChjdXJyZW50TG9jYWxlICE9PSAnZW4nKSA/IHRoaXMubG9hZEZsYXRwaWNrckxvY2FsZShjdXJyZW50TG9jYWxlKSA6ICdlbicsXHJcbiAgICAgIG9uQ2hhbmdlOiAoc2VsZWN0ZWREYXRlczogRGF0ZVtdIHwgRGF0ZSwgZGF0ZVN0cjogc3RyaW5nLCBpbnN0YW5jZTogYW55KSA9PiB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2VsZWN0ZWREYXRlcykpIHtcclxuICAgICAgICAgIHRoaXMuX2N1cnJlbnREYXRlcyA9IHNlbGVjdGVkRGF0ZXM7XHJcbiAgICAgICAgICBjb25zdCBvdXRGb3JtYXQgPSBtYXBNb21lbnREYXRlRm9ybWF0V2l0aEZpZWxkVHlwZSh0aGlzLmNvbHVtbkRlZi5vdXRwdXRUeXBlIHx8IHRoaXMuY29sdW1uRmlsdGVyLnR5cGUgfHwgdGhpcy5jb2x1bW5EZWYudHlwZSB8fCBGaWVsZFR5cGUuZGF0ZUlzbyk7XHJcbiAgICAgICAgICB0aGlzLl9jdXJyZW50RGF0ZVN0cmluZ3MgPSBzZWxlY3RlZERhdGVzLm1hcChkYXRlID0+IG1vbWVudChkYXRlKS5mb3JtYXQob3V0Rm9ybWF0KSk7XHJcbiAgICAgICAgICB0aGlzLl9jdXJyZW50VmFsdWUgPSB0aGlzLl9jdXJyZW50RGF0ZVN0cmluZ3Muam9pbignLi4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHdoZW4gdXNpbmcgdGhlIHRpbWUgcGlja2VyLCB3ZSBjYW4gc2ltdWxhdGUgYSBrZXl1cCBldmVudCB0byBhdm9pZCBtdWx0aXBsZSBiYWNrZW5kIHJlcXVlc3RcclxuICAgICAgICAvLyBzaW5jZSBiYWNrZW5kIHJlcXVlc3QgYXJlIG9ubHkgZXhlY3V0ZWQgYWZ0ZXIgdXNlciBzdGFydCB0eXBpbmcsIGNoYW5naW5nIHRoZSB0aW1lIHNob3VsZCBiZSB0cmVhdGVkIHRoZSBzYW1lIHdheVxyXG4gICAgICAgIGNvbnN0IG5ld0V2ZW50ID0gcGlja2VyT3B0aW9ucy5lbmFibGVUaW1lID8gbmV3IEN1c3RvbUV2ZW50KCdrZXl1cCcpIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMub25UcmlnZ2VyRXZlbnQobmV3RXZlbnQpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIGFkZCB0aGUgdGltZSBwaWNrZXIgd2hlbiBmb3JtYXQgaXMgVVRDIChaKSBvciBoYXMgdGhlICdoJyAobWVhbmluZyBob3VycylcclxuICAgIGlmIChvdXRwdXRGb3JtYXQgJiYgKG91dHB1dEZvcm1hdCA9PT0gJ1onIHx8IG91dHB1dEZvcm1hdC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdoJykpKSB7XHJcbiAgICAgIHBpY2tlck9wdGlvbnMuZW5hYmxlVGltZSA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gbWVyZ2Ugb3B0aW9ucyB3aXRoIG9wdGlvbmFsIHVzZXIncyBjdXN0b20gb3B0aW9uc1xyXG4gICAgdGhpcy5fZmxhdHBpY2tyT3B0aW9ucyA9IHsgLi4ucGlja2VyT3B0aW9ucywgLi4udXNlckZpbHRlck9wdGlvbnMgfTtcclxuXHJcbiAgICBsZXQgcGxhY2Vob2xkZXIgPSAodGhpcy5ncmlkT3B0aW9ucykgPyAodGhpcy5ncmlkT3B0aW9ucy5kZWZhdWx0RmlsdGVyUGxhY2Vob2xkZXIgfHwgJycpIDogJyc7XHJcbiAgICBpZiAodGhpcy5jb2x1bW5GaWx0ZXIgJiYgdGhpcy5jb2x1bW5GaWx0ZXIucGxhY2Vob2xkZXIpIHtcclxuICAgICAgcGxhY2Vob2xkZXIgPSB0aGlzLmNvbHVtbkZpbHRlci5wbGFjZWhvbGRlcjtcclxuICAgIH1cclxuICAgIGNvbnN0ICRmaWx0ZXJJbnB1dEVsbTogYW55ID0gJChgPGRpdiBjbGFzcz1cImZsYXRwaWNrciBzZWFyY2gtZmlsdGVyIGZpbHRlci0ke2NvbHVtbklkfVwiPjxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgZGF0YS1pbnB1dCBwbGFjZWhvbGRlcj1cIiR7cGxhY2Vob2xkZXJ9XCI+PC9kaXY+YCk7XHJcbiAgICB0aGlzLmZsYXRJbnN0YW5jZSA9ICgkZmlsdGVySW5wdXRFbG1bMF0gJiYgdHlwZW9mICRmaWx0ZXJJbnB1dEVsbVswXS5mbGF0cGlja3IgPT09ICdmdW5jdGlvbicpID8gJGZpbHRlcklucHV0RWxtWzBdLmZsYXRwaWNrcih0aGlzLl9mbGF0cGlja3JPcHRpb25zKSA6IEZsYXRwaWNrcigkZmlsdGVySW5wdXRFbG0sIHRoaXMuX2ZsYXRwaWNrck9wdGlvbnMgYXMgdW5rbm93biBhcyBQYXJ0aWFsPEZsYXRwaWNrckJhc2VPcHRpb25zPik7XHJcbiAgICByZXR1cm4gJGZpbHRlcklucHV0RWxtO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIHRoZSBET00gZWxlbWVudFxyXG4gICAqIEBwYXJhbXMgc2VhcmNoVGVybXNcclxuICAgKi9cclxuICBwcml2YXRlIGNyZWF0ZURvbUVsZW1lbnQoc2VhcmNoVGVybXM/OiBTZWFyY2hUZXJtW10pIHtcclxuICAgIGNvbnN0IGZpZWxkSWQgPSB0aGlzLmNvbHVtbkRlZiAmJiB0aGlzLmNvbHVtbkRlZi5pZDtcclxuICAgIGNvbnN0ICRoZWFkZXJFbG0gPSB0aGlzLmdyaWQuZ2V0SGVhZGVyUm93Q29sdW1uKGZpZWxkSWQpO1xyXG4gICAgJCgkaGVhZGVyRWxtKS5lbXB0eSgpO1xyXG5cclxuICAgIC8vIGNyZWF0ZSB0aGUgRE9NIFNlbGVjdCBkcm9wZG93biBmb3IgdGhlIE9wZXJhdG9yXHJcbiAgICB0aGlzLiRmaWx0ZXJJbnB1dEVsbSA9IHRoaXMuYnVpbGREYXRlUGlja2VySW5wdXQoc2VhcmNoVGVybXMpO1xyXG5cclxuICAgIC8qIHRoZSBET00gZWxlbWVudCBmaW5hbCBzdHJ1Y3R1cmUgd2lsbCBiZVxyXG4gICAgICA8ZGl2IGNsYXNzPWZsYXRwaWNrcj5cclxuICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIGRhdGEtaW5wdXQ+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgKi9cclxuXHJcbiAgICAvLyBjcmVhdGUgdGhlIERPTSBlbGVtZW50ICYgYWRkIGFuIElEIGFuZCBmaWx0ZXIgY2xhc3NcclxuICAgIHRoaXMuJGZpbHRlcklucHV0RWxtLmRhdGEoJ2NvbHVtbklkJywgZmllbGRJZCk7XHJcblxyXG4gICAgLy8gaWYgdGhlcmUncyBhIHNlYXJjaCB0ZXJtLCB3ZSB3aWxsIGFkZCB0aGUgXCJmaWxsZWRcIiBjbGFzcyBmb3Igc3R5bGluZyBwdXJwb3Nlc1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2VhcmNoVGVybXMpICYmIHNlYXJjaFRlcm1zLmxlbmd0aCA+IDAgJiYgc2VhcmNoVGVybXNbMF0gIT09ICcnKSB7XHJcbiAgICAgIHRoaXMuJGZpbHRlcklucHV0RWxtLmFkZENsYXNzKCdmaWxsZWQnKTtcclxuICAgICAgdGhpcy5fY3VycmVudERhdGVzID0gc2VhcmNoVGVybXMgYXMgRGF0ZVtdO1xyXG4gICAgICB0aGlzLl9jdXJyZW50VmFsdWUgPSBzZWFyY2hUZXJtc1swXSBhcyBzdHJpbmc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYXBwZW5kIHRoZSBuZXcgRE9NIGVsZW1lbnQgdG8gdGhlIGhlYWRlciByb3dcclxuICAgIGlmICh0aGlzLiRmaWx0ZXJJbnB1dEVsbSAmJiB0eXBlb2YgdGhpcy4kZmlsdGVySW5wdXRFbG0uYXBwZW5kVG8gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhpcy4kZmlsdGVySW5wdXRFbG0uYXBwZW5kVG8oJGhlYWRlckVsbSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuJGZpbHRlcklucHV0RWxtO1xyXG4gIH1cclxuXHJcbiAgLyoqIExvYWQgYSBkaWZmZXJlbnQgc2V0IG9mIGxvY2FsZXMgZm9yIEZsYXRwaWNrciB0byBiZSBsb2NhbGl6ZWQgKi9cclxuICBwcml2YXRlIGxvYWRGbGF0cGlja3JMb2NhbGUobGFuZ3VhZ2U6IHN0cmluZykge1xyXG4gICAgbGV0IGxvY2FsZXMgPSAnZW4nO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGlmIChsYW5ndWFnZSAhPT0gJ2VuJykge1xyXG4gICAgICAgIC8vIGNoYW5nZSBsb2NhbGUgaWYgbmVlZGVkLCBGbGF0cGlja3IgcmVmZXJlbmNlOiBodHRwczovL2NobWxuLmdpdGh1Yi5pby9mbGF0cGlja3IvbG9jYWxpemF0aW9uL1xyXG4gICAgICAgIGNvbnN0IGxvY2FsZURlZmF1bHQ6IGFueSA9IHJlcXVpcmUoYGZsYXRwaWNrci9kaXN0L2wxMG4vJHtsYW5ndWFnZX0uanNgKS5kZWZhdWx0O1xyXG4gICAgICAgIGxvY2FsZXMgPSAobG9jYWxlRGVmYXVsdCAmJiBsb2NhbGVEZWZhdWx0W2xhbmd1YWdlXSkgPyBsb2NhbGVEZWZhdWx0W2xhbmd1YWdlXSA6ICdlbic7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgY29uc29sZS53YXJuKGBbQW5ndWxhci1TbGlja2dyaWQgLSBEYXRlUmFuZ2UgRmlsdGVyXSBJdCBzZWVtcyB0aGF0IFwiJHtsYW5ndWFnZX1cIiBpcyBub3QgYSBsb2NhbGUgc3VwcG9ydGVkIGJ5IEZsYXRwaWNrciwgd2Ugd2lsbCB1c2UgXCJlblwiIGluc3RlYWQuIGBcclxuICAgICAgICArIGBUbyBhdm9pZCBzZWVpbmcgdGhpcyBtZXNzYWdlLCB5b3UgY2FuIHNwZWNpZmljYWxseSBzZXQgXCJmaWx0ZXI6IHsgZmlsdGVyT3B0aW9uczogeyBsb2NhbGU6ICdlbicgfSB9XCIgaW4geW91ciBjb2x1bW4gZGVmaW5pdGlvbi5gKTtcclxuICAgICAgcmV0dXJuICdlbic7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxlcztcclxuICB9XHJcblxyXG4gIHByaXZhdGUgb25UcmlnZ2VyRXZlbnQoZTogRXZlbnQgfCB1bmRlZmluZWQpIHtcclxuICAgIGlmICh0aGlzLl9jbGVhckZpbHRlclRyaWdnZXJlZCkge1xyXG4gICAgICB0aGlzLmNhbGxiYWNrKGUsIHsgY29sdW1uRGVmOiB0aGlzLmNvbHVtbkRlZiwgY2xlYXJGaWx0ZXJUcmlnZ2VyZWQ6IHRoaXMuX2NsZWFyRmlsdGVyVHJpZ2dlcmVkLCBzaG91bGRUcmlnZ2VyUXVlcnk6IHRoaXMuX3Nob3VsZFRyaWdnZXJRdWVyeSB9KTtcclxuICAgICAgdGhpcy4kZmlsdGVyRWxtLnJlbW92ZUNsYXNzKCdmaWxsZWQnKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICh0aGlzLl9jdXJyZW50RGF0ZVN0cmluZ3MpID8gdGhpcy4kZmlsdGVyRWxtLmFkZENsYXNzKCdmaWxsZWQnKSA6IHRoaXMuJGZpbHRlckVsbS5yZW1vdmVDbGFzcygnZmlsbGVkJyk7XHJcbiAgICAgIHRoaXMuY2FsbGJhY2soZSwgeyBjb2x1bW5EZWY6IHRoaXMuY29sdW1uRGVmLCBzZWFyY2hUZXJtczogKHRoaXMuX2N1cnJlbnREYXRlU3RyaW5ncyA/IHRoaXMuX2N1cnJlbnREYXRlU3RyaW5ncyA6IFt0aGlzLl9jdXJyZW50VmFsdWVdKSwgb3BlcmF0b3I6IHRoaXMub3BlcmF0b3IgfHwgJycsIHNob3VsZFRyaWdnZXJRdWVyeTogdGhpcy5fc2hvdWxkVHJpZ2dlclF1ZXJ5IH0pO1xyXG4gICAgfVxyXG4gICAgLy8gcmVzZXQgYm90aCBmbGFncyBmb3IgbmV4dCB1c2VcclxuICAgIHRoaXMuX2NsZWFyRmlsdGVyVHJpZ2dlcmVkID0gZmFsc2U7XHJcbiAgICB0aGlzLl9zaG91bGRUcmlnZ2VyUXVlcnkgPSB0cnVlO1xyXG4gIH1cclxufVxyXG4iXX0=