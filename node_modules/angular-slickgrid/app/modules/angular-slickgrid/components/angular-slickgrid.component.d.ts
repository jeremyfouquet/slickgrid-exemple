import 'jquery-ui-dist/jquery-ui';
import 'slickgrid/lib/jquery.event.drag-2.3.0';
import 'slickgrid/lib/jquery.mousewheel';
import 'slickgrid/slick.core';
import 'slickgrid/slick.grid';
import 'slickgrid/slick.dataview';
import { AfterViewInit, ChangeDetectorRef, ElementRef, EventEmitter, OnDestroy, OnInit } from '@angular/core';
import { TranslateService } from '@ngx-translate/core';
import { Subscription } from 'rxjs';
import { AngularGridInstance, BackendServiceApi, Column, CustomFooterOption, GridOption, GridStateChange, Locale, Metrics, Pagination, ServicePagination } from './../models/index';
import { ExcelExportService } from '../services/excelExport.service';
import { ExportService } from './../services/export.service';
import { ExtensionService } from '../services/extension.service';
import { ExtensionUtility } from '../extensions/extensionUtility';
import { FilterService } from './../services/filter.service';
import { GridEventService } from './../services/gridEvent.service';
import { GridService } from './../services/grid.service';
import { GridStateService } from './../services/gridState.service';
import { GroupingAndColspanService } from './../services/groupingAndColspan.service';
import { PaginationService } from '../services/pagination.service';
import { ResizerService } from './../services/resizer.service';
import { SharedService } from '../services/shared.service';
import { SortService } from './../services/sort.service';
import { TreeDataService } from './../services/treeData.service';
import * as ɵngcc0 from '@angular/core';
export declare class AngularSlickgridComponent implements AfterViewInit, OnDestroy, OnInit {
    private cd;
    private elm;
    private excelExportService;
    private exportService;
    private extensionService;
    private extensionUtility;
    private filterService;
    private gridEventService;
    private gridService;
    private gridStateService;
    private groupingAndColspanService;
    private paginationService;
    private resizer;
    private sharedService;
    private sortService;
    private treeDataService;
    private translate;
    private forRootConfig;
    private _dataset;
    private _columnDefinitions;
    private _eventHandler;
    private _angularGridInstances;
    private _fixedHeight;
    private _fixedWidth;
    private _hideHeaderRowAfterPageLoad;
    private _isGridInitialized;
    private _isDatasetInitialized;
    private _isPaginationInitialized;
    private _isLocalGrid;
    private _paginationOptions;
    private slickEmptyWarning;
    dataView: any | null;
    grid: any | null;
    gridHeightString: string;
    gridWidthString: string;
    groupingDefinition: any;
    groupItemMetadataProvider: any;
    backendServiceApi: BackendServiceApi;
    customFooterOptions: CustomFooterOption;
    locales: Locale;
    metrics: Metrics;
    showCustomFooter: boolean;
    showPagination: boolean;
    totalItems: number;
    paginationData: {
        gridOptions: GridOption;
    };
    subscriptions: Subscription[];
    onAngularGridCreated: EventEmitter<AngularGridInstance>;
    onDataviewCreated: EventEmitter<any>;
    onGridCreated: EventEmitter<any>;
    onGridInitialized: EventEmitter<any>;
    onBeforeGridCreate: EventEmitter<boolean>;
    onBeforeGridDestroy: EventEmitter<any>;
    onAfterGridDestroyed: EventEmitter<boolean>;
    onGridStateChanged: EventEmitter<GridStateChange>;
    onGridBeforeExportToFile: import("rxjs").Subject<boolean>;
    onGridAfterExportToFile: import("rxjs").Subject<{
        content?: string;
        filename: string;
        format: string;
        useUtf8WithBom: boolean;
    }>;
    onGridBeforeExportToExcel: import("rxjs").Subject<boolean>;
    onGridAfterExportToExcel: import("rxjs").Subject<{
        blob?: Blob;
        filename: string;
        format?: string;
    }>;
    customDataView: any;
    gridId: string;
    gridOptions: GridOption;
    paginationOptions: Pagination | undefined;
    gridHeight: number;
    gridWidth: number;
    columnDefinitions: Column[];
    dataset: any[];
    datasetHierarchical: any[] | null;
    readonly elementRef: ElementRef;
    constructor(cd: ChangeDetectorRef, elm: ElementRef, excelExportService: ExcelExportService, exportService: ExportService, extensionService: ExtensionService, extensionUtility: ExtensionUtility, filterService: FilterService, gridEventService: GridEventService, gridService: GridService, gridStateService: GridStateService, groupingAndColspanService: GroupingAndColspanService, paginationService: PaginationService, resizer: ResizerService, sharedService: SharedService, sortService: SortService, treeDataService: TreeDataService, translate: TranslateService, forRootConfig: GridOption);
    ngAfterViewInit(): void;
    ngOnInit(): void;
    ngOnDestroy(): void;
    destroy(shouldEmptyDomElementContainer?: boolean): void;
    emptyGridContainerElm(): void;
    /** Dispatch of Custom Event, which by default will bubble & is cancelable */
    dispatchCustomEvent(eventName: string, data?: any, isBubbling?: boolean, isCancelable?: boolean): any;
    /**
     * Define our internal Post Process callback, it will execute internally after we get back result from the Process backend call
     * For now, this is GraphQL Service ONLY feature and it will basically refresh the Dataset & Pagination without having the user to create his own PostProcess every time
     */
    createBackendApiInternalPostProcessCallback(gridOptions: GridOption): void;
    /**
     * On a Pagination changed, we will trigger a Grid State changed with the new pagination info
     * Also if we use Row Selection or the Checkbox Selector, we need to reset any selection
     */
    paginationChanged(pagination: ServicePagination): void;
    /**
     * When dataset changes, we need to refresh the entire grid UI & possibly resize it as well
     * @param dataset
     */
    refreshGridData(dataset: any[], totalCount?: number): void;
    /**
     * Check if there's any Pagination Presets defined in the Grid Options,
     * if there are then load them in the paginationOptions object
     */
    setPaginationOptionsWhenPresetDefined(gridOptions: GridOption, paginationOptions: Pagination): Pagination;
    /**
     * Dynamically change or update the column definitions list.
     * We will re-render the grid so that the new header and data shows up correctly.
     * If using i18n, we also need to trigger a re-translate of the column headers
     */
    updateColumnDefinitionsList(newColumnDefinitions: any): void;
    /**
     * Show the filter row displayed on first row, we can optionally pass false to hide it.
     * @param showing
     */
    showHeaderRow(showing?: boolean): boolean;
    private displayEmptyDataWarning;
    private bindDifferentHooks;
    private bindBackendCallbackFunctions;
    private bindResizeHook;
    private executeAfterDataviewCreated;
    private initializePaginationService;
    private initialization;
    /** Load the Editor Collection asynchronously and replace the "collection" property when Observable resolves */
    private loadEditorCollectionAsync;
    private loadPresetsWhenDatasetInitialized;
    /**
     * local grid, check if we need to show the Pagination
     * if so then also check if there's any presets and finally initialize the PaginationService
     * a local grid with Pagination presets will potentially have a different total of items, we'll need to get it from the DataView and update our total
     */
    private loadLocalGridPagination;
    /** Load any Row Selections into the DataView that were presets by the user */
    private loadRowSelectionPresetWhenExists;
    private mergeGridOptions;
    /**
     * We could optionally display a custom footer below the grid to show some metrics (last update, item count with/without filters)
     * It's an opt-in, user has to enable "showCustomFooter" and it cannot be used when there's already a Pagination since they display the same kind of info
     */
    private optionallyShowCustomFooterWithMetrics;
    private treeDataSortComparer;
    /**
     * For convenience to the user, we provide the property "editor" as an Angular-Slickgrid editor complex object
     * however "editor" is used internally by SlickGrid for it's own Editor Factory
     * so in our lib we will swap "editor" and copy it into a new property called "internalColumnEditor"
     * then take back "editor.model" and make it the new "editor" so that SlickGrid Editor Factory still works
     */
    private swapInternalEditorToSlickGridFactoryEditor;
    /** Translate all Custom Footer Texts (footer with metrics) */
    private translateCustomFooterTexts;
    private translateColumnHeaderTitleKeys;
    private translateColumnGroupKeys;
    /**
     * Update the Editor "collection" property from an async call resolved
     * Since this is called after the async call resolves, the pointer will not be the same as the "column" argument passed.
     * Once we found the new pointer, we will reassign the "editor" and "collection" to the "internalColumnEditor" so it has newest collection
     */
    private updateEditorCollection;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<AngularSlickgridComponent, [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, { optional: true; }, null]>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<AngularSlickgridComponent, "angular-slickgrid", never, { "paginationOptions": "paginationOptions"; "gridHeight": "gridHeight"; "gridWidth": "gridWidth"; "columnDefinitions": "columnDefinitions"; "dataset": "dataset"; "datasetHierarchical": "datasetHierarchical"; "gridOptions": "gridOptions"; "customDataView": "customDataView"; "gridId": "gridId"; }, { "onAngularGridCreated": "onAngularGridCreated"; "onDataviewCreated": "onDataviewCreated"; "onGridCreated": "onGridCreated"; "onGridInitialized": "onGridInitialized"; "onBeforeGridCreate": "onBeforeGridCreate"; "onBeforeGridDestroy": "onBeforeGridDestroy"; "onAfterGridDestroyed": "onAfterGridDestroyed"; "onGridStateChanged": "onGridStateChanged"; "onGridBeforeExportToFile": "onGridBeforeExportToFile"; "onGridAfterExportToFile": "onGridAfterExportToFile"; "onGridBeforeExportToExcel": "onGridBeforeExportToExcel"; "onGridAfterExportToExcel": "onGridAfterExportToExcel"; }, never, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhci1zbGlja2dyaWQuY29tcG9uZW50LmQudHMiLCJzb3VyY2VzIjpbImFuZ3VsYXItc2xpY2tncmlkLmNvbXBvbmVudC5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnanF1ZXJ5LXVpLWRpc3QvanF1ZXJ5LXVpJztcclxuaW1wb3J0ICdzbGlja2dyaWQvbGliL2pxdWVyeS5ldmVudC5kcmFnLTIuMy4wJztcclxuaW1wb3J0ICdzbGlja2dyaWQvbGliL2pxdWVyeS5tb3VzZXdoZWVsJztcclxuaW1wb3J0ICdzbGlja2dyaWQvc2xpY2suY29yZSc7XHJcbmltcG9ydCAnc2xpY2tncmlkL3NsaWNrLmdyaWQnO1xyXG5pbXBvcnQgJ3NsaWNrZ3JpZC9zbGljay5kYXRhdmlldyc7XHJcbmltcG9ydCB7IEFmdGVyVmlld0luaXQsIENoYW5nZURldGVjdG9yUmVmLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIE9uRGVzdHJveSwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFRyYW5zbGF0ZVNlcnZpY2UgfSBmcm9tICdAbmd4LXRyYW5zbGF0ZS9jb3JlJztcclxuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IEFuZ3VsYXJHcmlkSW5zdGFuY2UsIEJhY2tlbmRTZXJ2aWNlQXBpLCBDb2x1bW4sIEN1c3RvbUZvb3Rlck9wdGlvbiwgR3JpZE9wdGlvbiwgR3JpZFN0YXRlQ2hhbmdlLCBMb2NhbGUsIE1ldHJpY3MsIFBhZ2luYXRpb24sIFNlcnZpY2VQYWdpbmF0aW9uIH0gZnJvbSAnLi8uLi9tb2RlbHMvaW5kZXgnO1xyXG5pbXBvcnQgeyBFeGNlbEV4cG9ydFNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9leGNlbEV4cG9ydC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgRXhwb3J0U2VydmljZSB9IGZyb20gJy4vLi4vc2VydmljZXMvZXhwb3J0LnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBFeHRlbnNpb25TZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvZXh0ZW5zaW9uLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBFeHRlbnNpb25VdGlsaXR5IH0gZnJvbSAnLi4vZXh0ZW5zaW9ucy9leHRlbnNpb25VdGlsaXR5JztcclxuaW1wb3J0IHsgRmlsdGVyU2VydmljZSB9IGZyb20gJy4vLi4vc2VydmljZXMvZmlsdGVyLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBHcmlkRXZlbnRTZXJ2aWNlIH0gZnJvbSAnLi8uLi9zZXJ2aWNlcy9ncmlkRXZlbnQuc2VydmljZSc7XHJcbmltcG9ydCB7IEdyaWRTZXJ2aWNlIH0gZnJvbSAnLi8uLi9zZXJ2aWNlcy9ncmlkLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBHcmlkU3RhdGVTZXJ2aWNlIH0gZnJvbSAnLi8uLi9zZXJ2aWNlcy9ncmlkU3RhdGUuc2VydmljZSc7XHJcbmltcG9ydCB7IEdyb3VwaW5nQW5kQ29sc3BhblNlcnZpY2UgfSBmcm9tICcuLy4uL3NlcnZpY2VzL2dyb3VwaW5nQW5kQ29sc3Bhbi5zZXJ2aWNlJztcclxuaW1wb3J0IHsgUGFnaW5hdGlvblNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9wYWdpbmF0aW9uLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBSZXNpemVyU2VydmljZSB9IGZyb20gJy4vLi4vc2VydmljZXMvcmVzaXplci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgU2hhcmVkU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL3NoYXJlZC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgU29ydFNlcnZpY2UgfSBmcm9tICcuLy4uL3NlcnZpY2VzL3NvcnQuc2VydmljZSc7XHJcbmltcG9ydCB7IFRyZWVEYXRhU2VydmljZSB9IGZyb20gJy4vLi4vc2VydmljZXMvdHJlZURhdGEuc2VydmljZSc7XHJcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIEFuZ3VsYXJTbGlja2dyaWRDb21wb25lbnQgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3ksIE9uSW5pdCB7XHJcbiAgICBwcml2YXRlIGNkO1xyXG4gICAgcHJpdmF0ZSBlbG07XHJcbiAgICBwcml2YXRlIGV4Y2VsRXhwb3J0U2VydmljZTtcclxuICAgIHByaXZhdGUgZXhwb3J0U2VydmljZTtcclxuICAgIHByaXZhdGUgZXh0ZW5zaW9uU2VydmljZTtcclxuICAgIHByaXZhdGUgZXh0ZW5zaW9uVXRpbGl0eTtcclxuICAgIHByaXZhdGUgZmlsdGVyU2VydmljZTtcclxuICAgIHByaXZhdGUgZ3JpZEV2ZW50U2VydmljZTtcclxuICAgIHByaXZhdGUgZ3JpZFNlcnZpY2U7XHJcbiAgICBwcml2YXRlIGdyaWRTdGF0ZVNlcnZpY2U7XHJcbiAgICBwcml2YXRlIGdyb3VwaW5nQW5kQ29sc3BhblNlcnZpY2U7XHJcbiAgICBwcml2YXRlIHBhZ2luYXRpb25TZXJ2aWNlO1xyXG4gICAgcHJpdmF0ZSByZXNpemVyO1xyXG4gICAgcHJpdmF0ZSBzaGFyZWRTZXJ2aWNlO1xyXG4gICAgcHJpdmF0ZSBzb3J0U2VydmljZTtcclxuICAgIHByaXZhdGUgdHJlZURhdGFTZXJ2aWNlO1xyXG4gICAgcHJpdmF0ZSB0cmFuc2xhdGU7XHJcbiAgICBwcml2YXRlIGZvclJvb3RDb25maWc7XHJcbiAgICBwcml2YXRlIF9kYXRhc2V0O1xyXG4gICAgcHJpdmF0ZSBfY29sdW1uRGVmaW5pdGlvbnM7XHJcbiAgICBwcml2YXRlIF9ldmVudEhhbmRsZXI7XHJcbiAgICBwcml2YXRlIF9hbmd1bGFyR3JpZEluc3RhbmNlcztcclxuICAgIHByaXZhdGUgX2ZpeGVkSGVpZ2h0O1xyXG4gICAgcHJpdmF0ZSBfZml4ZWRXaWR0aDtcclxuICAgIHByaXZhdGUgX2hpZGVIZWFkZXJSb3dBZnRlclBhZ2VMb2FkO1xyXG4gICAgcHJpdmF0ZSBfaXNHcmlkSW5pdGlhbGl6ZWQ7XHJcbiAgICBwcml2YXRlIF9pc0RhdGFzZXRJbml0aWFsaXplZDtcclxuICAgIHByaXZhdGUgX2lzUGFnaW5hdGlvbkluaXRpYWxpemVkO1xyXG4gICAgcHJpdmF0ZSBfaXNMb2NhbEdyaWQ7XHJcbiAgICBwcml2YXRlIF9wYWdpbmF0aW9uT3B0aW9ucztcclxuICAgIHByaXZhdGUgc2xpY2tFbXB0eVdhcm5pbmc7XHJcbiAgICBkYXRhVmlldzogYW55IHwgbnVsbDtcclxuICAgIGdyaWQ6IGFueSB8IG51bGw7XHJcbiAgICBncmlkSGVpZ2h0U3RyaW5nOiBzdHJpbmc7XHJcbiAgICBncmlkV2lkdGhTdHJpbmc6IHN0cmluZztcclxuICAgIGdyb3VwaW5nRGVmaW5pdGlvbjogYW55O1xyXG4gICAgZ3JvdXBJdGVtTWV0YWRhdGFQcm92aWRlcjogYW55O1xyXG4gICAgYmFja2VuZFNlcnZpY2VBcGk6IEJhY2tlbmRTZXJ2aWNlQXBpO1xyXG4gICAgY3VzdG9tRm9vdGVyT3B0aW9uczogQ3VzdG9tRm9vdGVyT3B0aW9uO1xyXG4gICAgbG9jYWxlczogTG9jYWxlO1xyXG4gICAgbWV0cmljczogTWV0cmljcztcclxuICAgIHNob3dDdXN0b21Gb290ZXI6IGJvb2xlYW47XHJcbiAgICBzaG93UGFnaW5hdGlvbjogYm9vbGVhbjtcclxuICAgIHRvdGFsSXRlbXM6IG51bWJlcjtcclxuICAgIHBhZ2luYXRpb25EYXRhOiB7XHJcbiAgICAgICAgZ3JpZE9wdGlvbnM6IEdyaWRPcHRpb247XHJcbiAgICB9O1xyXG4gICAgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW107XHJcbiAgICBvbkFuZ3VsYXJHcmlkQ3JlYXRlZDogRXZlbnRFbWl0dGVyPEFuZ3VsYXJHcmlkSW5zdGFuY2U+O1xyXG4gICAgb25EYXRhdmlld0NyZWF0ZWQ6IEV2ZW50RW1pdHRlcjxhbnk+O1xyXG4gICAgb25HcmlkQ3JlYXRlZDogRXZlbnRFbWl0dGVyPGFueT47XHJcbiAgICBvbkdyaWRJbml0aWFsaXplZDogRXZlbnRFbWl0dGVyPGFueT47XHJcbiAgICBvbkJlZm9yZUdyaWRDcmVhdGU6IEV2ZW50RW1pdHRlcjxib29sZWFuPjtcclxuICAgIG9uQmVmb3JlR3JpZERlc3Ryb3k6IEV2ZW50RW1pdHRlcjxhbnk+O1xyXG4gICAgb25BZnRlckdyaWREZXN0cm95ZWQ6IEV2ZW50RW1pdHRlcjxib29sZWFuPjtcclxuICAgIG9uR3JpZFN0YXRlQ2hhbmdlZDogRXZlbnRFbWl0dGVyPEdyaWRTdGF0ZUNoYW5nZT47XHJcbiAgICBvbkdyaWRCZWZvcmVFeHBvcnRUb0ZpbGU6IGltcG9ydChcInJ4anNcIikuU3ViamVjdDxib29sZWFuPjtcclxuICAgIG9uR3JpZEFmdGVyRXhwb3J0VG9GaWxlOiBpbXBvcnQoXCJyeGpzXCIpLlN1YmplY3Q8e1xyXG4gICAgICAgIGNvbnRlbnQ/OiBzdHJpbmc7XHJcbiAgICAgICAgZmlsZW5hbWU6IHN0cmluZztcclxuICAgICAgICBmb3JtYXQ6IHN0cmluZztcclxuICAgICAgICB1c2VVdGY4V2l0aEJvbTogYm9vbGVhbjtcclxuICAgIH0+O1xyXG4gICAgb25HcmlkQmVmb3JlRXhwb3J0VG9FeGNlbDogaW1wb3J0KFwicnhqc1wiKS5TdWJqZWN0PGJvb2xlYW4+O1xyXG4gICAgb25HcmlkQWZ0ZXJFeHBvcnRUb0V4Y2VsOiBpbXBvcnQoXCJyeGpzXCIpLlN1YmplY3Q8e1xyXG4gICAgICAgIGJsb2I/OiBCbG9iO1xyXG4gICAgICAgIGZpbGVuYW1lOiBzdHJpbmc7XHJcbiAgICAgICAgZm9ybWF0Pzogc3RyaW5nO1xyXG4gICAgfT47XHJcbiAgICBjdXN0b21EYXRhVmlldzogYW55O1xyXG4gICAgZ3JpZElkOiBzdHJpbmc7XHJcbiAgICBncmlkT3B0aW9uczogR3JpZE9wdGlvbjtcclxuICAgIHBhZ2luYXRpb25PcHRpb25zOiBQYWdpbmF0aW9uIHwgdW5kZWZpbmVkO1xyXG4gICAgZ3JpZEhlaWdodDogbnVtYmVyO1xyXG4gICAgZ3JpZFdpZHRoOiBudW1iZXI7XHJcbiAgICBjb2x1bW5EZWZpbml0aW9uczogQ29sdW1uW107XHJcbiAgICBkYXRhc2V0OiBhbnlbXTtcclxuICAgIGRhdGFzZXRIaWVyYXJjaGljYWw6IGFueVtdIHwgbnVsbDtcclxuICAgIHJlYWRvbmx5IGVsZW1lbnRSZWY6IEVsZW1lbnRSZWY7XHJcbiAgICBjb25zdHJ1Y3RvcihjZDogQ2hhbmdlRGV0ZWN0b3JSZWYsIGVsbTogRWxlbWVudFJlZiwgZXhjZWxFeHBvcnRTZXJ2aWNlOiBFeGNlbEV4cG9ydFNlcnZpY2UsIGV4cG9ydFNlcnZpY2U6IEV4cG9ydFNlcnZpY2UsIGV4dGVuc2lvblNlcnZpY2U6IEV4dGVuc2lvblNlcnZpY2UsIGV4dGVuc2lvblV0aWxpdHk6IEV4dGVuc2lvblV0aWxpdHksIGZpbHRlclNlcnZpY2U6IEZpbHRlclNlcnZpY2UsIGdyaWRFdmVudFNlcnZpY2U6IEdyaWRFdmVudFNlcnZpY2UsIGdyaWRTZXJ2aWNlOiBHcmlkU2VydmljZSwgZ3JpZFN0YXRlU2VydmljZTogR3JpZFN0YXRlU2VydmljZSwgZ3JvdXBpbmdBbmRDb2xzcGFuU2VydmljZTogR3JvdXBpbmdBbmRDb2xzcGFuU2VydmljZSwgcGFnaW5hdGlvblNlcnZpY2U6IFBhZ2luYXRpb25TZXJ2aWNlLCByZXNpemVyOiBSZXNpemVyU2VydmljZSwgc2hhcmVkU2VydmljZTogU2hhcmVkU2VydmljZSwgc29ydFNlcnZpY2U6IFNvcnRTZXJ2aWNlLCB0cmVlRGF0YVNlcnZpY2U6IFRyZWVEYXRhU2VydmljZSwgdHJhbnNsYXRlOiBUcmFuc2xhdGVTZXJ2aWNlLCBmb3JSb290Q29uZmlnOiBHcmlkT3B0aW9uKTtcclxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkO1xyXG4gICAgbmdPbkluaXQoKTogdm9pZDtcclxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XHJcbiAgICBkZXN0cm95KHNob3VsZEVtcHR5RG9tRWxlbWVudENvbnRhaW5lcj86IGJvb2xlYW4pOiB2b2lkO1xyXG4gICAgZW1wdHlHcmlkQ29udGFpbmVyRWxtKCk6IHZvaWQ7XHJcbiAgICAvKiogRGlzcGF0Y2ggb2YgQ3VzdG9tIEV2ZW50LCB3aGljaCBieSBkZWZhdWx0IHdpbGwgYnViYmxlICYgaXMgY2FuY2VsYWJsZSAqL1xyXG4gICAgZGlzcGF0Y2hDdXN0b21FdmVudChldmVudE5hbWU6IHN0cmluZywgZGF0YT86IGFueSwgaXNCdWJibGluZz86IGJvb2xlYW4sIGlzQ2FuY2VsYWJsZT86IGJvb2xlYW4pOiBhbnk7XHJcbiAgICAvKipcclxuICAgICAqIERlZmluZSBvdXIgaW50ZXJuYWwgUG9zdCBQcm9jZXNzIGNhbGxiYWNrLCBpdCB3aWxsIGV4ZWN1dGUgaW50ZXJuYWxseSBhZnRlciB3ZSBnZXQgYmFjayByZXN1bHQgZnJvbSB0aGUgUHJvY2VzcyBiYWNrZW5kIGNhbGxcclxuICAgICAqIEZvciBub3csIHRoaXMgaXMgR3JhcGhRTCBTZXJ2aWNlIE9OTFkgZmVhdHVyZSBhbmQgaXQgd2lsbCBiYXNpY2FsbHkgcmVmcmVzaCB0aGUgRGF0YXNldCAmIFBhZ2luYXRpb24gd2l0aG91dCBoYXZpbmcgdGhlIHVzZXIgdG8gY3JlYXRlIGhpcyBvd24gUG9zdFByb2Nlc3MgZXZlcnkgdGltZVxyXG4gICAgICovXHJcbiAgICBjcmVhdGVCYWNrZW5kQXBpSW50ZXJuYWxQb3N0UHJvY2Vzc0NhbGxiYWNrKGdyaWRPcHRpb25zOiBHcmlkT3B0aW9uKTogdm9pZDtcclxuICAgIC8qKlxyXG4gICAgICogT24gYSBQYWdpbmF0aW9uIGNoYW5nZWQsIHdlIHdpbGwgdHJpZ2dlciBhIEdyaWQgU3RhdGUgY2hhbmdlZCB3aXRoIHRoZSBuZXcgcGFnaW5hdGlvbiBpbmZvXHJcbiAgICAgKiBBbHNvIGlmIHdlIHVzZSBSb3cgU2VsZWN0aW9uIG9yIHRoZSBDaGVja2JveCBTZWxlY3Rvciwgd2UgbmVlZCB0byByZXNldCBhbnkgc2VsZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIHBhZ2luYXRpb25DaGFuZ2VkKHBhZ2luYXRpb246IFNlcnZpY2VQYWdpbmF0aW9uKTogdm9pZDtcclxuICAgIC8qKlxyXG4gICAgICogV2hlbiBkYXRhc2V0IGNoYW5nZXMsIHdlIG5lZWQgdG8gcmVmcmVzaCB0aGUgZW50aXJlIGdyaWQgVUkgJiBwb3NzaWJseSByZXNpemUgaXQgYXMgd2VsbFxyXG4gICAgICogQHBhcmFtIGRhdGFzZXRcclxuICAgICAqL1xyXG4gICAgcmVmcmVzaEdyaWREYXRhKGRhdGFzZXQ6IGFueVtdLCB0b3RhbENvdW50PzogbnVtYmVyKTogdm9pZDtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgaWYgdGhlcmUncyBhbnkgUGFnaW5hdGlvbiBQcmVzZXRzIGRlZmluZWQgaW4gdGhlIEdyaWQgT3B0aW9ucyxcclxuICAgICAqIGlmIHRoZXJlIGFyZSB0aGVuIGxvYWQgdGhlbSBpbiB0aGUgcGFnaW5hdGlvbk9wdGlvbnMgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIHNldFBhZ2luYXRpb25PcHRpb25zV2hlblByZXNldERlZmluZWQoZ3JpZE9wdGlvbnM6IEdyaWRPcHRpb24sIHBhZ2luYXRpb25PcHRpb25zOiBQYWdpbmF0aW9uKTogUGFnaW5hdGlvbjtcclxuICAgIC8qKlxyXG4gICAgICogRHluYW1pY2FsbHkgY2hhbmdlIG9yIHVwZGF0ZSB0aGUgY29sdW1uIGRlZmluaXRpb25zIGxpc3QuXHJcbiAgICAgKiBXZSB3aWxsIHJlLXJlbmRlciB0aGUgZ3JpZCBzbyB0aGF0IHRoZSBuZXcgaGVhZGVyIGFuZCBkYXRhIHNob3dzIHVwIGNvcnJlY3RseS5cclxuICAgICAqIElmIHVzaW5nIGkxOG4sIHdlIGFsc28gbmVlZCB0byB0cmlnZ2VyIGEgcmUtdHJhbnNsYXRlIG9mIHRoZSBjb2x1bW4gaGVhZGVyc1xyXG4gICAgICovXHJcbiAgICB1cGRhdGVDb2x1bW5EZWZpbml0aW9uc0xpc3QobmV3Q29sdW1uRGVmaW5pdGlvbnM6IGFueSk6IHZvaWQ7XHJcbiAgICAvKipcclxuICAgICAqIFNob3cgdGhlIGZpbHRlciByb3cgZGlzcGxheWVkIG9uIGZpcnN0IHJvdywgd2UgY2FuIG9wdGlvbmFsbHkgcGFzcyBmYWxzZSB0byBoaWRlIGl0LlxyXG4gICAgICogQHBhcmFtIHNob3dpbmdcclxuICAgICAqL1xyXG4gICAgc2hvd0hlYWRlclJvdyhzaG93aW5nPzogYm9vbGVhbik6IGJvb2xlYW47XHJcbiAgICBwcml2YXRlIGRpc3BsYXlFbXB0eURhdGFXYXJuaW5nO1xyXG4gICAgcHJpdmF0ZSBiaW5kRGlmZmVyZW50SG9va3M7XHJcbiAgICBwcml2YXRlIGJpbmRCYWNrZW5kQ2FsbGJhY2tGdW5jdGlvbnM7XHJcbiAgICBwcml2YXRlIGJpbmRSZXNpemVIb29rO1xyXG4gICAgcHJpdmF0ZSBleGVjdXRlQWZ0ZXJEYXRhdmlld0NyZWF0ZWQ7XHJcbiAgICBwcml2YXRlIGluaXRpYWxpemVQYWdpbmF0aW9uU2VydmljZTtcclxuICAgIHByaXZhdGUgaW5pdGlhbGl6YXRpb247XHJcbiAgICAvKiogTG9hZCB0aGUgRWRpdG9yIENvbGxlY3Rpb24gYXN5bmNocm9ub3VzbHkgYW5kIHJlcGxhY2UgdGhlIFwiY29sbGVjdGlvblwiIHByb3BlcnR5IHdoZW4gT2JzZXJ2YWJsZSByZXNvbHZlcyAqL1xyXG4gICAgcHJpdmF0ZSBsb2FkRWRpdG9yQ29sbGVjdGlvbkFzeW5jO1xyXG4gICAgcHJpdmF0ZSBsb2FkUHJlc2V0c1doZW5EYXRhc2V0SW5pdGlhbGl6ZWQ7XHJcbiAgICAvKipcclxuICAgICAqIGxvY2FsIGdyaWQsIGNoZWNrIGlmIHdlIG5lZWQgdG8gc2hvdyB0aGUgUGFnaW5hdGlvblxyXG4gICAgICogaWYgc28gdGhlbiBhbHNvIGNoZWNrIGlmIHRoZXJlJ3MgYW55IHByZXNldHMgYW5kIGZpbmFsbHkgaW5pdGlhbGl6ZSB0aGUgUGFnaW5hdGlvblNlcnZpY2VcclxuICAgICAqIGEgbG9jYWwgZ3JpZCB3aXRoIFBhZ2luYXRpb24gcHJlc2V0cyB3aWxsIHBvdGVudGlhbGx5IGhhdmUgYSBkaWZmZXJlbnQgdG90YWwgb2YgaXRlbXMsIHdlJ2xsIG5lZWQgdG8gZ2V0IGl0IGZyb20gdGhlIERhdGFWaWV3IGFuZCB1cGRhdGUgb3VyIHRvdGFsXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgbG9hZExvY2FsR3JpZFBhZ2luYXRpb247XHJcbiAgICAvKiogTG9hZCBhbnkgUm93IFNlbGVjdGlvbnMgaW50byB0aGUgRGF0YVZpZXcgdGhhdCB3ZXJlIHByZXNldHMgYnkgdGhlIHVzZXIgKi9cclxuICAgIHByaXZhdGUgbG9hZFJvd1NlbGVjdGlvblByZXNldFdoZW5FeGlzdHM7XHJcbiAgICBwcml2YXRlIG1lcmdlR3JpZE9wdGlvbnM7XHJcbiAgICAvKipcclxuICAgICAqIFdlIGNvdWxkIG9wdGlvbmFsbHkgZGlzcGxheSBhIGN1c3RvbSBmb290ZXIgYmVsb3cgdGhlIGdyaWQgdG8gc2hvdyBzb21lIG1ldHJpY3MgKGxhc3QgdXBkYXRlLCBpdGVtIGNvdW50IHdpdGgvd2l0aG91dCBmaWx0ZXJzKVxyXG4gICAgICogSXQncyBhbiBvcHQtaW4sIHVzZXIgaGFzIHRvIGVuYWJsZSBcInNob3dDdXN0b21Gb290ZXJcIiBhbmQgaXQgY2Fubm90IGJlIHVzZWQgd2hlbiB0aGVyZSdzIGFscmVhZHkgYSBQYWdpbmF0aW9uIHNpbmNlIHRoZXkgZGlzcGxheSB0aGUgc2FtZSBraW5kIG9mIGluZm9cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBvcHRpb25hbGx5U2hvd0N1c3RvbUZvb3RlcldpdGhNZXRyaWNzO1xyXG4gICAgcHJpdmF0ZSB0cmVlRGF0YVNvcnRDb21wYXJlcjtcclxuICAgIC8qKlxyXG4gICAgICogRm9yIGNvbnZlbmllbmNlIHRvIHRoZSB1c2VyLCB3ZSBwcm92aWRlIHRoZSBwcm9wZXJ0eSBcImVkaXRvclwiIGFzIGFuIEFuZ3VsYXItU2xpY2tncmlkIGVkaXRvciBjb21wbGV4IG9iamVjdFxyXG4gICAgICogaG93ZXZlciBcImVkaXRvclwiIGlzIHVzZWQgaW50ZXJuYWxseSBieSBTbGlja0dyaWQgZm9yIGl0J3Mgb3duIEVkaXRvciBGYWN0b3J5XHJcbiAgICAgKiBzbyBpbiBvdXIgbGliIHdlIHdpbGwgc3dhcCBcImVkaXRvclwiIGFuZCBjb3B5IGl0IGludG8gYSBuZXcgcHJvcGVydHkgY2FsbGVkIFwiaW50ZXJuYWxDb2x1bW5FZGl0b3JcIlxyXG4gICAgICogdGhlbiB0YWtlIGJhY2sgXCJlZGl0b3IubW9kZWxcIiBhbmQgbWFrZSBpdCB0aGUgbmV3IFwiZWRpdG9yXCIgc28gdGhhdCBTbGlja0dyaWQgRWRpdG9yIEZhY3Rvcnkgc3RpbGwgd29ya3NcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzd2FwSW50ZXJuYWxFZGl0b3JUb1NsaWNrR3JpZEZhY3RvcnlFZGl0b3I7XHJcbiAgICAvKiogVHJhbnNsYXRlIGFsbCBDdXN0b20gRm9vdGVyIFRleHRzIChmb290ZXIgd2l0aCBtZXRyaWNzKSAqL1xyXG4gICAgcHJpdmF0ZSB0cmFuc2xhdGVDdXN0b21Gb290ZXJUZXh0cztcclxuICAgIHByaXZhdGUgdHJhbnNsYXRlQ29sdW1uSGVhZGVyVGl0bGVLZXlzO1xyXG4gICAgcHJpdmF0ZSB0cmFuc2xhdGVDb2x1bW5Hcm91cEtleXM7XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0aGUgRWRpdG9yIFwiY29sbGVjdGlvblwiIHByb3BlcnR5IGZyb20gYW4gYXN5bmMgY2FsbCByZXNvbHZlZFxyXG4gICAgICogU2luY2UgdGhpcyBpcyBjYWxsZWQgYWZ0ZXIgdGhlIGFzeW5jIGNhbGwgcmVzb2x2ZXMsIHRoZSBwb2ludGVyIHdpbGwgbm90IGJlIHRoZSBzYW1lIGFzIHRoZSBcImNvbHVtblwiIGFyZ3VtZW50IHBhc3NlZC5cclxuICAgICAqIE9uY2Ugd2UgZm91bmQgdGhlIG5ldyBwb2ludGVyLCB3ZSB3aWxsIHJlYXNzaWduIHRoZSBcImVkaXRvclwiIGFuZCBcImNvbGxlY3Rpb25cIiB0byB0aGUgXCJpbnRlcm5hbENvbHVtbkVkaXRvclwiIHNvIGl0IGhhcyBuZXdlc3QgY29sbGVjdGlvblxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHVwZGF0ZUVkaXRvckNvbGxlY3Rpb247XHJcbn1cclxuIl19