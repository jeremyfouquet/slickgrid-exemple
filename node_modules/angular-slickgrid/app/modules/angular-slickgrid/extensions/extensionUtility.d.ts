import { TranslateService } from '@ngx-translate/core';
import { Column, ExtensionName } from '../models/index';
import { SharedService } from '../services/shared.service';
import * as ɵngcc0 from '@angular/core';
export declare class ExtensionUtility {
    private sharedService;
    private translate;
    constructor(sharedService: SharedService, translate: TranslateService);
    /**
     * Load SlickGrid Extension (Control/Plugin) dynamically (on demand)
     * This will basically only load the extension when user enables the feature
     * @param extensionName
     */
    loadExtensionDynamically(extensionName: ExtensionName): any;
    /**
     * From a Grid Menu object property name, we will return the correct title output string following this order
     * 1- if user provided a title, use it as the output title
     * 2- else if user provided a title key, use it to translate the output title
     * 3- else if nothing is provided use text defined as constants
     */
    getPickerTitleOutputString(propName: string, pickerName: 'gridMenu' | 'columnPicker'): string;
    /**
     * Loop through object provided and set to null any property found starting with "onX"
     * @param {Object}: obj
     */
    nullifyFunctionNameStartingWithOn(obj?: any): void;
    /**
     * When using ColumnPicker/GridMenu to show/hide a column, we potentially need to readjust the grid option "frozenColumn" index.
     * That is because SlickGrid freezes by column index and it has no knowledge of the columns themselves and won't change the index, we need to do that ourselves whenever necessary.
     * Note: we call this method right after the visibleColumns array got updated, it won't work properly if we call it before the setting the visibleColumns.
     * @param {String} pickerColumnId - what is the column id triggered by the picker
     * @param {Number} frozenColumnIndex - current frozenColumn index
     * @param {Boolean} showingColumn - is the column being shown or hidden?
     * @param {Array<Object>} allColumns - all columns (including hidden ones)
     * @param {Array<Object>} visibleColumns - only visible columns (excluding hidden ones)
     */
    readjustFrozenColumnIndexWhenNeeded(pickerColumnId: string | number, frozenColumnIndex: number, showingColumn: boolean, allColumns: Column[], visibleColumns: Column[]): void;
    /**
     * Sort items (by pointers) in an array by a property name
     * @params items array
     * @param property name to sort with
     */
    sortItems<T = any>(items: T[], propertyName: string): void;
    /** Translate the an array of items from an input key and assign to the output key */
    translateItems<T = any>(items: T[], inputKey: string, outputKey: string): void;
    /**
     * When "enabledTranslate" is set to True, we will try to translate if the Translate Service exist or use the Locales when not
     * @param translationKey
     * @param localeKey
     */
    translateWhenEnabledAndServiceExist(translationKey: string, localeKey: string): string;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<ExtensionUtility, [null, { optional: true; }]>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<ExtensionUtility>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXh0ZW5zaW9uVXRpbGl0eS5kLnRzIiwic291cmNlcyI6WyJleHRlbnNpb25VdGlsaXR5LmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVHJhbnNsYXRlU2VydmljZSB9IGZyb20gJ0BuZ3gtdHJhbnNsYXRlL2NvcmUnO1xyXG5pbXBvcnQgeyBDb2x1bW4sIEV4dGVuc2lvbk5hbWUgfSBmcm9tICcuLi9tb2RlbHMvaW5kZXgnO1xyXG5pbXBvcnQgeyBTaGFyZWRTZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvc2hhcmVkLnNlcnZpY2UnO1xyXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBFeHRlbnNpb25VdGlsaXR5IHtcclxuICAgIHByaXZhdGUgc2hhcmVkU2VydmljZTtcclxuICAgIHByaXZhdGUgdHJhbnNsYXRlO1xyXG4gICAgY29uc3RydWN0b3Ioc2hhcmVkU2VydmljZTogU2hhcmVkU2VydmljZSwgdHJhbnNsYXRlOiBUcmFuc2xhdGVTZXJ2aWNlKTtcclxuICAgIC8qKlxyXG4gICAgICogTG9hZCBTbGlja0dyaWQgRXh0ZW5zaW9uIChDb250cm9sL1BsdWdpbikgZHluYW1pY2FsbHkgKG9uIGRlbWFuZClcclxuICAgICAqIFRoaXMgd2lsbCBiYXNpY2FsbHkgb25seSBsb2FkIHRoZSBleHRlbnNpb24gd2hlbiB1c2VyIGVuYWJsZXMgdGhlIGZlYXR1cmVcclxuICAgICAqIEBwYXJhbSBleHRlbnNpb25OYW1lXHJcbiAgICAgKi9cclxuICAgIGxvYWRFeHRlbnNpb25EeW5hbWljYWxseShleHRlbnNpb25OYW1lOiBFeHRlbnNpb25OYW1lKTogYW55O1xyXG4gICAgLyoqXHJcbiAgICAgKiBGcm9tIGEgR3JpZCBNZW51IG9iamVjdCBwcm9wZXJ0eSBuYW1lLCB3ZSB3aWxsIHJldHVybiB0aGUgY29ycmVjdCB0aXRsZSBvdXRwdXQgc3RyaW5nIGZvbGxvd2luZyB0aGlzIG9yZGVyXHJcbiAgICAgKiAxLSBpZiB1c2VyIHByb3ZpZGVkIGEgdGl0bGUsIHVzZSBpdCBhcyB0aGUgb3V0cHV0IHRpdGxlXHJcbiAgICAgKiAyLSBlbHNlIGlmIHVzZXIgcHJvdmlkZWQgYSB0aXRsZSBrZXksIHVzZSBpdCB0byB0cmFuc2xhdGUgdGhlIG91dHB1dCB0aXRsZVxyXG4gICAgICogMy0gZWxzZSBpZiBub3RoaW5nIGlzIHByb3ZpZGVkIHVzZSB0ZXh0IGRlZmluZWQgYXMgY29uc3RhbnRzXHJcbiAgICAgKi9cclxuICAgIGdldFBpY2tlclRpdGxlT3V0cHV0U3RyaW5nKHByb3BOYW1lOiBzdHJpbmcsIHBpY2tlck5hbWU6ICdncmlkTWVudScgfCAnY29sdW1uUGlja2VyJyk6IHN0cmluZztcclxuICAgIC8qKlxyXG4gICAgICogTG9vcCB0aHJvdWdoIG9iamVjdCBwcm92aWRlZCBhbmQgc2V0IHRvIG51bGwgYW55IHByb3BlcnR5IGZvdW5kIHN0YXJ0aW5nIHdpdGggXCJvblhcIlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9OiBvYmpcclxuICAgICAqL1xyXG4gICAgbnVsbGlmeUZ1bmN0aW9uTmFtZVN0YXJ0aW5nV2l0aE9uKG9iaj86IGFueSk6IHZvaWQ7XHJcbiAgICAvKipcclxuICAgICAqIFdoZW4gdXNpbmcgQ29sdW1uUGlja2VyL0dyaWRNZW51IHRvIHNob3cvaGlkZSBhIGNvbHVtbiwgd2UgcG90ZW50aWFsbHkgbmVlZCB0byByZWFkanVzdCB0aGUgZ3JpZCBvcHRpb24gXCJmcm96ZW5Db2x1bW5cIiBpbmRleC5cclxuICAgICAqIFRoYXQgaXMgYmVjYXVzZSBTbGlja0dyaWQgZnJlZXplcyBieSBjb2x1bW4gaW5kZXggYW5kIGl0IGhhcyBubyBrbm93bGVkZ2Ugb2YgdGhlIGNvbHVtbnMgdGhlbXNlbHZlcyBhbmQgd29uJ3QgY2hhbmdlIHRoZSBpbmRleCwgd2UgbmVlZCB0byBkbyB0aGF0IG91cnNlbHZlcyB3aGVuZXZlciBuZWNlc3NhcnkuXHJcbiAgICAgKiBOb3RlOiB3ZSBjYWxsIHRoaXMgbWV0aG9kIHJpZ2h0IGFmdGVyIHRoZSB2aXNpYmxlQ29sdW1ucyBhcnJheSBnb3QgdXBkYXRlZCwgaXQgd29uJ3Qgd29yayBwcm9wZXJseSBpZiB3ZSBjYWxsIGl0IGJlZm9yZSB0aGUgc2V0dGluZyB0aGUgdmlzaWJsZUNvbHVtbnMuXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGlja2VyQ29sdW1uSWQgLSB3aGF0IGlzIHRoZSBjb2x1bW4gaWQgdHJpZ2dlcmVkIGJ5IHRoZSBwaWNrZXJcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmcm96ZW5Db2x1bW5JbmRleCAtIGN1cnJlbnQgZnJvemVuQ29sdW1uIGluZGV4XHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNob3dpbmdDb2x1bW4gLSBpcyB0aGUgY29sdW1uIGJlaW5nIHNob3duIG9yIGhpZGRlbj9cclxuICAgICAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gYWxsQ29sdW1ucyAtIGFsbCBjb2x1bW5zIChpbmNsdWRpbmcgaGlkZGVuIG9uZXMpXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IHZpc2libGVDb2x1bW5zIC0gb25seSB2aXNpYmxlIGNvbHVtbnMgKGV4Y2x1ZGluZyBoaWRkZW4gb25lcylcclxuICAgICAqL1xyXG4gICAgcmVhZGp1c3RGcm96ZW5Db2x1bW5JbmRleFdoZW5OZWVkZWQocGlja2VyQ29sdW1uSWQ6IHN0cmluZyB8IG51bWJlciwgZnJvemVuQ29sdW1uSW5kZXg6IG51bWJlciwgc2hvd2luZ0NvbHVtbjogYm9vbGVhbiwgYWxsQ29sdW1uczogQ29sdW1uW10sIHZpc2libGVDb2x1bW5zOiBDb2x1bW5bXSk6IHZvaWQ7XHJcbiAgICAvKipcclxuICAgICAqIFNvcnQgaXRlbXMgKGJ5IHBvaW50ZXJzKSBpbiBhbiBhcnJheSBieSBhIHByb3BlcnR5IG5hbWVcclxuICAgICAqIEBwYXJhbXMgaXRlbXMgYXJyYXlcclxuICAgICAqIEBwYXJhbSBwcm9wZXJ0eSBuYW1lIHRvIHNvcnQgd2l0aFxyXG4gICAgICovXHJcbiAgICBzb3J0SXRlbXM8VCA9IGFueT4oaXRlbXM6IFRbXSwgcHJvcGVydHlOYW1lOiBzdHJpbmcpOiB2b2lkO1xyXG4gICAgLyoqIFRyYW5zbGF0ZSB0aGUgYW4gYXJyYXkgb2YgaXRlbXMgZnJvbSBhbiBpbnB1dCBrZXkgYW5kIGFzc2lnbiB0byB0aGUgb3V0cHV0IGtleSAqL1xyXG4gICAgdHJhbnNsYXRlSXRlbXM8VCA9IGFueT4oaXRlbXM6IFRbXSwgaW5wdXRLZXk6IHN0cmluZywgb3V0cHV0S2V5OiBzdHJpbmcpOiB2b2lkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBXaGVuIFwiZW5hYmxlZFRyYW5zbGF0ZVwiIGlzIHNldCB0byBUcnVlLCB3ZSB3aWxsIHRyeSB0byB0cmFuc2xhdGUgaWYgdGhlIFRyYW5zbGF0ZSBTZXJ2aWNlIGV4aXN0IG9yIHVzZSB0aGUgTG9jYWxlcyB3aGVuIG5vdFxyXG4gICAgICogQHBhcmFtIHRyYW5zbGF0aW9uS2V5XHJcbiAgICAgKiBAcGFyYW0gbG9jYWxlS2V5XHJcbiAgICAgKi9cclxuICAgIHRyYW5zbGF0ZVdoZW5FbmFibGVkQW5kU2VydmljZUV4aXN0KHRyYW5zbGF0aW9uS2V5OiBzdHJpbmcsIGxvY2FsZUtleTogc3RyaW5nKTogc3RyaW5nO1xyXG59XHJcbiJdfQ==