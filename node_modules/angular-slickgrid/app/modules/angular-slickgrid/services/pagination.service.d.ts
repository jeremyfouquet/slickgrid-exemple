import { Subject } from 'rxjs';
import { BackendServiceApi, CurrentPagination, Pagination, ServicePagination } from '../models';
import { FilterService } from './filter.service';
import { GridService } from './grid.service';
import { SharedService } from './shared.service';
import * as ɵngcc0 from '@angular/core';
export declare class PaginationService {
    private filterService;
    private gridService;
    private sharedService;
    private _initialized;
    private _isLocalGrid;
    private _backendServiceApi;
    private _dataFrom;
    private _dataTo;
    private _itemsPerPage;
    private _pageCount;
    private _pageNumber;
    private _totalItems;
    private _availablePageSizes;
    private _eventHandler;
    private _paginationOptions;
    private _subscriptions;
    onPaginationChanged: Subject<ServicePagination>;
    onPaginationVisibilityChanged: Subject<{
        visible: boolean;
    }>;
    dataView: any;
    grid: any;
    /** Constructor */
    constructor(filterService: FilterService, gridService: GridService, sharedService: SharedService);
    paginationOptions: Pagination;
    readonly availablePageSizes: number[];
    readonly dataFrom: number;
    readonly dataTo: number;
    readonly itemsPerPage: number;
    readonly pageCount: number;
    readonly pageNumber: number;
    totalItems: number;
    init(grid: any, dataView: any, paginationOptions: Pagination, backendServiceApi?: BackendServiceApi): void;
    dispose(): void;
    getCurrentPageNumber(): number;
    getCurrentPagination(): CurrentPagination & {
        pageSizes: number[];
    };
    getFullPagination(): ServicePagination;
    getCurrentItemPerPage(): number;
    changeItemPerPage(itemsPerPage: number, event?: any): Promise<any>;
    goToFirstPage(event?: any): Promise<any>;
    goToLastPage(event?: any): Promise<any>;
    goToNextPage(event?: any): Promise<any>;
    goToPageNumber(pageNumber: number, event?: any): Promise<any>;
    goToPreviousPage(event?: any): Promise<any>;
    refreshPagination(isPageNumberReset?: boolean, triggerChangedEvent?: boolean): void;
    processOnPageChanged(pageNumber: number, event?: Event | undefined): Promise<any>;
    recalculateFromToIndexes(): void;
    /** Reset the Pagination to first page and recalculate necessary numbers */
    resetPagination(triggerChangedEvent?: boolean): void;
    /**
     * Toggle the Pagination (show/hide), it will use the visible if defined else it will automatically inverse when called without argument
     *
     * IMPORTANT NOTE:
     * The Pagination must be created on initial page load, then only after can you toggle it.
     * Basically this method WILL NOT WORK to show the Pagination if it was not there from the start.
     */
    togglePaginationVisibility(visible?: boolean): void;
    updateTotalItems(totalItems: number, triggerChangedEvent?: boolean): void;
    /**
     * When item is added or removed, we will refresh the numbers on the pagination however we won't trigger a backend change
     * This will have a side effect though, which is that the "To" count won't be matching the "items per page" count,
     * that is a necessary side effect to avoid triggering a backend query just to refresh the paging,
     * basically we assume that this offset is fine for the time being,
     * until user does an action which will refresh the data hence the pagination which will then become normal again
     */
    private processOnItemAddedOrRemoved;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<PaginationService, never>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<PaginationService>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFnaW5hdGlvbi5zZXJ2aWNlLmQudHMiLCJzb3VyY2VzIjpbInBhZ2luYXRpb24uc2VydmljZS5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgQmFja2VuZFNlcnZpY2VBcGksIEN1cnJlbnRQYWdpbmF0aW9uLCBQYWdpbmF0aW9uLCBTZXJ2aWNlUGFnaW5hdGlvbiB9IGZyb20gJy4uL21vZGVscyc7XHJcbmltcG9ydCB7IEZpbHRlclNlcnZpY2UgfSBmcm9tICcuL2ZpbHRlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgR3JpZFNlcnZpY2UgfSBmcm9tICcuL2dyaWQuc2VydmljZSc7XHJcbmltcG9ydCB7IFNoYXJlZFNlcnZpY2UgfSBmcm9tICcuL3NoYXJlZC5zZXJ2aWNlJztcclxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgUGFnaW5hdGlvblNlcnZpY2Uge1xyXG4gICAgcHJpdmF0ZSBmaWx0ZXJTZXJ2aWNlO1xyXG4gICAgcHJpdmF0ZSBncmlkU2VydmljZTtcclxuICAgIHByaXZhdGUgc2hhcmVkU2VydmljZTtcclxuICAgIHByaXZhdGUgX2luaXRpYWxpemVkO1xyXG4gICAgcHJpdmF0ZSBfaXNMb2NhbEdyaWQ7XHJcbiAgICBwcml2YXRlIF9iYWNrZW5kU2VydmljZUFwaTtcclxuICAgIHByaXZhdGUgX2RhdGFGcm9tO1xyXG4gICAgcHJpdmF0ZSBfZGF0YVRvO1xyXG4gICAgcHJpdmF0ZSBfaXRlbXNQZXJQYWdlO1xyXG4gICAgcHJpdmF0ZSBfcGFnZUNvdW50O1xyXG4gICAgcHJpdmF0ZSBfcGFnZU51bWJlcjtcclxuICAgIHByaXZhdGUgX3RvdGFsSXRlbXM7XHJcbiAgICBwcml2YXRlIF9hdmFpbGFibGVQYWdlU2l6ZXM7XHJcbiAgICBwcml2YXRlIF9ldmVudEhhbmRsZXI7XHJcbiAgICBwcml2YXRlIF9wYWdpbmF0aW9uT3B0aW9ucztcclxuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbnM7XHJcbiAgICBvblBhZ2luYXRpb25DaGFuZ2VkOiBTdWJqZWN0PFNlcnZpY2VQYWdpbmF0aW9uPjtcclxuICAgIG9uUGFnaW5hdGlvblZpc2liaWxpdHlDaGFuZ2VkOiBTdWJqZWN0PHtcclxuICAgICAgICB2aXNpYmxlOiBib29sZWFuO1xyXG4gICAgfT47XHJcbiAgICBkYXRhVmlldzogYW55O1xyXG4gICAgZ3JpZDogYW55O1xyXG4gICAgLyoqIENvbnN0cnVjdG9yICovXHJcbiAgICBjb25zdHJ1Y3RvcihmaWx0ZXJTZXJ2aWNlOiBGaWx0ZXJTZXJ2aWNlLCBncmlkU2VydmljZTogR3JpZFNlcnZpY2UsIHNoYXJlZFNlcnZpY2U6IFNoYXJlZFNlcnZpY2UpO1xyXG4gICAgcGFnaW5hdGlvbk9wdGlvbnM6IFBhZ2luYXRpb247XHJcbiAgICByZWFkb25seSBhdmFpbGFibGVQYWdlU2l6ZXM6IG51bWJlcltdO1xyXG4gICAgcmVhZG9ubHkgZGF0YUZyb206IG51bWJlcjtcclxuICAgIHJlYWRvbmx5IGRhdGFUbzogbnVtYmVyO1xyXG4gICAgcmVhZG9ubHkgaXRlbXNQZXJQYWdlOiBudW1iZXI7XHJcbiAgICByZWFkb25seSBwYWdlQ291bnQ6IG51bWJlcjtcclxuICAgIHJlYWRvbmx5IHBhZ2VOdW1iZXI6IG51bWJlcjtcclxuICAgIHRvdGFsSXRlbXM6IG51bWJlcjtcclxuICAgIGluaXQoZ3JpZDogYW55LCBkYXRhVmlldzogYW55LCBwYWdpbmF0aW9uT3B0aW9uczogUGFnaW5hdGlvbiwgYmFja2VuZFNlcnZpY2VBcGk/OiBCYWNrZW5kU2VydmljZUFwaSk6IHZvaWQ7XHJcbiAgICBkaXNwb3NlKCk6IHZvaWQ7XHJcbiAgICBnZXRDdXJyZW50UGFnZU51bWJlcigpOiBudW1iZXI7XHJcbiAgICBnZXRDdXJyZW50UGFnaW5hdGlvbigpOiBDdXJyZW50UGFnaW5hdGlvbiAmIHtcclxuICAgICAgICBwYWdlU2l6ZXM6IG51bWJlcltdO1xyXG4gICAgfTtcclxuICAgIGdldEZ1bGxQYWdpbmF0aW9uKCk6IFNlcnZpY2VQYWdpbmF0aW9uO1xyXG4gICAgZ2V0Q3VycmVudEl0ZW1QZXJQYWdlKCk6IG51bWJlcjtcclxuICAgIGNoYW5nZUl0ZW1QZXJQYWdlKGl0ZW1zUGVyUGFnZTogbnVtYmVyLCBldmVudD86IGFueSk6IFByb21pc2U8YW55PjtcclxuICAgIGdvVG9GaXJzdFBhZ2UoZXZlbnQ/OiBhbnkpOiBQcm9taXNlPGFueT47XHJcbiAgICBnb1RvTGFzdFBhZ2UoZXZlbnQ/OiBhbnkpOiBQcm9taXNlPGFueT47XHJcbiAgICBnb1RvTmV4dFBhZ2UoZXZlbnQ/OiBhbnkpOiBQcm9taXNlPGFueT47XHJcbiAgICBnb1RvUGFnZU51bWJlcihwYWdlTnVtYmVyOiBudW1iZXIsIGV2ZW50PzogYW55KTogUHJvbWlzZTxhbnk+O1xyXG4gICAgZ29Ub1ByZXZpb3VzUGFnZShldmVudD86IGFueSk6IFByb21pc2U8YW55PjtcclxuICAgIHJlZnJlc2hQYWdpbmF0aW9uKGlzUGFnZU51bWJlclJlc2V0PzogYm9vbGVhbiwgdHJpZ2dlckNoYW5nZWRFdmVudD86IGJvb2xlYW4pOiB2b2lkO1xyXG4gICAgcHJvY2Vzc09uUGFnZUNoYW5nZWQocGFnZU51bWJlcjogbnVtYmVyLCBldmVudD86IEV2ZW50IHwgdW5kZWZpbmVkKTogUHJvbWlzZTxhbnk+O1xyXG4gICAgcmVjYWxjdWxhdGVGcm9tVG9JbmRleGVzKCk6IHZvaWQ7XHJcbiAgICAvKiogUmVzZXQgdGhlIFBhZ2luYXRpb24gdG8gZmlyc3QgcGFnZSBhbmQgcmVjYWxjdWxhdGUgbmVjZXNzYXJ5IG51bWJlcnMgKi9cclxuICAgIHJlc2V0UGFnaW5hdGlvbih0cmlnZ2VyQ2hhbmdlZEV2ZW50PzogYm9vbGVhbik6IHZvaWQ7XHJcbiAgICAvKipcclxuICAgICAqIFRvZ2dsZSB0aGUgUGFnaW5hdGlvbiAoc2hvdy9oaWRlKSwgaXQgd2lsbCB1c2UgdGhlIHZpc2libGUgaWYgZGVmaW5lZCBlbHNlIGl0IHdpbGwgYXV0b21hdGljYWxseSBpbnZlcnNlIHdoZW4gY2FsbGVkIHdpdGhvdXQgYXJndW1lbnRcclxuICAgICAqXHJcbiAgICAgKiBJTVBPUlRBTlQgTk9URTpcclxuICAgICAqIFRoZSBQYWdpbmF0aW9uIG11c3QgYmUgY3JlYXRlZCBvbiBpbml0aWFsIHBhZ2UgbG9hZCwgdGhlbiBvbmx5IGFmdGVyIGNhbiB5b3UgdG9nZ2xlIGl0LlxyXG4gICAgICogQmFzaWNhbGx5IHRoaXMgbWV0aG9kIFdJTEwgTk9UIFdPUksgdG8gc2hvdyB0aGUgUGFnaW5hdGlvbiBpZiBpdCB3YXMgbm90IHRoZXJlIGZyb20gdGhlIHN0YXJ0LlxyXG4gICAgICovXHJcbiAgICB0b2dnbGVQYWdpbmF0aW9uVmlzaWJpbGl0eSh2aXNpYmxlPzogYm9vbGVhbik6IHZvaWQ7XHJcbiAgICB1cGRhdGVUb3RhbEl0ZW1zKHRvdGFsSXRlbXM6IG51bWJlciwgdHJpZ2dlckNoYW5nZWRFdmVudD86IGJvb2xlYW4pOiB2b2lkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBXaGVuIGl0ZW0gaXMgYWRkZWQgb3IgcmVtb3ZlZCwgd2Ugd2lsbCByZWZyZXNoIHRoZSBudW1iZXJzIG9uIHRoZSBwYWdpbmF0aW9uIGhvd2V2ZXIgd2Ugd29uJ3QgdHJpZ2dlciBhIGJhY2tlbmQgY2hhbmdlXHJcbiAgICAgKiBUaGlzIHdpbGwgaGF2ZSBhIHNpZGUgZWZmZWN0IHRob3VnaCwgd2hpY2ggaXMgdGhhdCB0aGUgXCJUb1wiIGNvdW50IHdvbid0IGJlIG1hdGNoaW5nIHRoZSBcIml0ZW1zIHBlciBwYWdlXCIgY291bnQsXHJcbiAgICAgKiB0aGF0IGlzIGEgbmVjZXNzYXJ5IHNpZGUgZWZmZWN0IHRvIGF2b2lkIHRyaWdnZXJpbmcgYSBiYWNrZW5kIHF1ZXJ5IGp1c3QgdG8gcmVmcmVzaCB0aGUgcGFnaW5nLFxyXG4gICAgICogYmFzaWNhbGx5IHdlIGFzc3VtZSB0aGF0IHRoaXMgb2Zmc2V0IGlzIGZpbmUgZm9yIHRoZSB0aW1lIGJlaW5nLFxyXG4gICAgICogdW50aWwgdXNlciBkb2VzIGFuIGFjdGlvbiB3aGljaCB3aWxsIHJlZnJlc2ggdGhlIGRhdGEgaGVuY2UgdGhlIHBhZ2luYXRpb24gd2hpY2ggd2lsbCB0aGVuIGJlY29tZSBub3JtYWwgYWdhaW5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBwcm9jZXNzT25JdGVtQWRkZWRPclJlbW92ZWQ7XHJcbn1cclxuIl19