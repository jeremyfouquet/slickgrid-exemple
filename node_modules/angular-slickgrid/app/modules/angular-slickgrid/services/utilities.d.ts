import { Observable, Subscription } from 'rxjs';
import { FieldType, GridOption, OperatorString, OperatorType } from '../models/index';
/**
 * Add an item to an array only when the item does not exists, when the item is an object we will be using their "id" to compare
 * @param inputArray
 * @param inputItem
 * @param itemIdPropName
 */
export declare function addToArrayWhenNotExists<T = any>(inputArray: T[], inputItem: T, itemIdPropName?: string): void;
/**
 * Simple function to which will loop and create as demanded the number of white spaces,
 * this is used in the CSV export
 * @param int nbSpaces: number of white spaces to create
 */
export declare function addWhiteSpaces(nbSpaces: number): string;
/**
 * Remove a column from the grid by it's index in the grid
 * @param array input
 * @param index
 */
export declare function arrayRemoveItemByIndex<T>(array: T[], index: number): T[];
/**
 * Convert a flat array (with "parentId" references) into a hierarchical dataset structure (where children are array(s) inside their parent objects)
 * @param flatArray input array (flat dataset)
 * @param options you can provide the following options:: "parentPropName" (defaults to "parent"), "childrenPropName" (defaults to "children") and "identifierPropName" (defaults to "id")
 * @return roots - hierarchical data view array
 */
export declare function convertParentChildArrayToHierarchicalView<T = any>(flatArray: T[], options?: {
    parentPropName?: string;
    childrenPropName?: string;
    identifierPropName?: string;
}): T[];
/**
 * Convert a hierarchical array (with children) into a flat array structure array (where the children are pushed as next indexed item in the array)
 * @param hierarchicalArray - input hierarchical array
 * @param options - you can provide "childrenPropName" (defaults to "children")
 * @return output - Parent/Child array
 */
export declare function convertHierarchicalViewToParentChildArray<T = any>(hierarchicalArray: T[], options?: {
    parentPropName?: string;
    childrenPropName?: string;
    identifierPropName?: string;
}): T[];
/**
 * Convert a hierarchical array (with children) into a flat array structure array but using the array as the output (the array is the pointer reference)
 * @param hierarchicalArray - input hierarchical array
 * @param outputArrayRef - output array passed (and modified) by reference
 * @param options - you can provide "childrenPropName" (defaults to "children")
 * @param treeLevel - tree level number
 * @param parentId - parent ID
 */
export declare function convertHierarchicalViewToParentChildArrayByReference<T = any>(hierarchicalArray: T[], outputArrayRef: T[], options?: {
    childrenPropName?: string;
    parentPropName?: string;
    hasChildrenFlagPropName?: string;
    treeLevelPropName?: string;
    identifierPropName?: string;
}, treeLevel?: number, parentId?: string): void;
/**
 * Create an immutable clone of an array or object
 * (c) 2019 Chris Ferdinandi, MIT License, https://gomakethings.com
 * @param  {Array|Object} obj The array or object to copy
 * @return {Array|Object}     The clone of the array or object
 */
export declare function deepCopy(obj: any): any;
/**
 * Find an item from a hierarchical view structure (a parent that can have children array which themseleves can children and so on)
 * @param hierarchicalArray
 * @param predicate
 * @param childrenPropertyName
 */
export declare function findItemInHierarchicalStructure<T = any>(hierarchicalArray: T[], predicate: (item: T) => boolean, childrenPropertyName: string): T;
/**
 * HTML decode using jQuery with a <div>
 * Create a in-memory div, set it's inner text(which jQuery automatically encodes)
 * then grab the encoded contents back out.  The div never exists on the page.
*/
export declare function htmlDecode(encodedStr: string): string;
/**
 * HTML encode using jQuery with a <div>
 * Create a in-memory div, set it's inner text(which jQuery automatically encodes)
 * then grab the encoded contents back out.  The div never exists on the page.
*/
export declare function htmlEncode(inputValue: string): string;
/**
 * Decode text into html entity
 * @param string text: input text
 * @param string text: output text
 */
export declare function htmlEntityDecode(input: string): string;
/**
 * Decode text into html entity
 * @param string text: input text
 * @param string text: output text
 */
export declare function htmlEntityEncode(input: any): string;
/**
 * Compares two arrays of characters to determine if all the items are equal
 * @param a first array
 * @param b second array to compare with a
 * @param [orderMatters=false] flag if the order matters, if not arrays will be sorted before comparison
 * @return boolean true if equal, else false
 */
export declare function charArraysEqual<T = any>(a: T[], b: T[], orderMatters?: boolean): boolean;
/**
 * Try casting an input of type Promise | Observable into a Promise type.
 * @param object which could be of type Promise or Observable
 * @param fromServiceName string representing the caller service name and will be used if we throw a casting problem error
 */
export declare function castToPromise<T>(input: Promise<T> | Observable<T>, fromServiceName?: string): Promise<T>;
/**
 * Uses the logic function to find an item in an array or returns the default
 * value provided (empty object by default)
 * @param any[] array the array to filter
 * @param function logic the logic to find the item
 * @param any [defaultVal={}] the default value to return
 * @return object the found object or default value
 */
export declare function findOrDefault<T = any>(array: any[], logic: (item: any) => boolean, defaultVal?: {}): any;
/**
 * Encode string to html special char and add html space padding defined
 * @param {string} inputStr - input string
 * @param {number} paddingLength - padding to add
 */
export declare function htmlEncodedStringWithPadding(inputStr: string, paddingLength: number): string;
/**
  * Take a number (or a string) and display it as a formatted decimal string with defined minimum and maximum decimals
  * @param input
  * @param minDecimal
  * @param maxDecimal
  */
export declare function decimalFormatted(input: number | string, minDecimal?: number, maxDecimal?: number, decimalSeparator?: '.' | ',', thousandSeparator?: ',' | '_' | '.' | ' ' | ''): string;
/**
 * Loop through all properties of an object and nullify any properties that are instanceof HTMLElement,
 * if we detect an array then use recursion to go inside it and apply same logic
 * @param obj - object containing 1 or more properties with DOM Elements
 */
export declare function destroyObjectDomElementProps(obj: any): void;
/**
 * Format a number following options passed as arguments (decimals, separator, ...)
 * @param input
 * @param minDecimal
 * @param maxDecimal
 * @param displayNegativeNumberWithParentheses
 * @param symbolPrefix
 * @param symbolSuffix
 * @param decimalSeparator
 * @param thousandSeparator
 */
export declare function formatNumber(input: number | string, minDecimal?: number, maxDecimal?: number, displayNegativeNumberWithParentheses?: boolean, symbolPrefix?: string, symbolSuffix?: string, decimalSeparator?: '.' | ',', thousandSeparator?: ',' | '_' | '.' | ' ' | ''): string;
/** From a dot (.) notation path, find and return a property within an object given a path */
export declare function getDescendantProperty<T = any>(obj: T, path: string): any;
/** Get HTML Element position offset (without jQuery) */
export declare function getHtmlElementOffset(element: HTMLElement): {
    top: number;
    left: number;
};
/** Get Translation Prefix, defaults to an empty string */
export declare function getTranslationPrefix(gridOptions?: GridOption): string;
/**
 * From a Date FieldType, return it's equivalent moment.js format
 * refer to moment.js for the format standard used: https://momentjs.com/docs/#/parsing/string-format/
 * @param fieldType
 */
export declare function mapMomentDateFormatWithFieldType(fieldType: FieldType): string;
/**
 * From a Date FieldType, return it's equivalent Flatpickr format
 * refer to Flatpickr for the format standard used: https://chmln.github.io/flatpickr/formatting/#date-formatting-tokens
 * also note that they seem very similar to PHP format (except for am/pm): http://php.net/manual/en/function.date.php
 * @param fieldType
 */
export declare function mapFlatpickrDateFormatWithFieldType(fieldType: FieldType): string;
/**
 * Mapper for query operators (ex.: <= is "le", > is "gt")
 * @param string operator
 * @returns string map
 */
export declare function mapOperatorType(operator: OperatorType | OperatorString): OperatorType;
/**
 * Find equivalent short designation of an Operator Type or Operator String.
 * When using a Compound Filter, we use the short designation and so we need the mapped value.
 * For example OperatorType.startsWith short designation is "a*", while OperatorType.greaterThanOrEqual is ">="
 */
export declare function mapOperatorToShorthandDesignation(operator: OperatorType | OperatorString): OperatorString;
/**
 * Mapper for query operator by a Filter Type
 * For example a multiple-select typically uses 'IN' operator
 * @param operator
 * @returns string map
 */
export declare function mapOperatorByFieldType(fieldType: FieldType | string): OperatorType;
/** Parse any input (bool, number, string) and return a boolean or False when not possible */
export declare function parseBoolean(input: any): boolean;
/**
 * Parse a date passed as a string (Date only, without time) and return a Date object (if valid)
 * @param inputDateString
 * @returns string date formatted
 */
export declare function parseUtcDate(inputDateString: string, useUtc?: boolean): string | null;
/**
 * Sanitize, return only the text without HTML tags
 * @input htmlString
 * @return text
 */
export declare function sanitizeHtmlToText(htmlString: string): string;
/** Set the object value of deeper node from a given dot (.) notation path (e.g.: "user.firstName") */
export declare function setDeepValue<T = any>(obj: T, path: string | string[], value: any): void;
/**
 * Format a number or a string into a string that is separated every thousand,
 * the default separator is a comma but user can optionally pass a different one
 * @param inputValue
 * @param separator default to comma ","
 * @returns string
 */
export declare function thousandSeparatorFormatted(inputValue: string | number | null, separator?: ',' | '_' | '.' | ' ' | ''): string | null;
/**
 * Title case (or capitalize) first char of a string, for example "hello world" will become "Hello world"
 * Change the string to be title case on the complete sentence (upper case first char of each word while changing everything else to lower case)
 * @param inputStr
 * @returns string
 */
export declare function titleCase(inputStr: string, caseEveryWords?: boolean): string;
/**
 * Converts a string to camel case (camelCase), for example "hello-world" (or "hellow world") will become "helloWorld"
 * @param inputStr the string to convert
 * @return the string in camel case
 */
export declare function toCamelCase(inputStr: string): string;
/**
 * Converts a string to kebab (hypen) case, for example "helloWorld" will become "hello-world"
 * @param str the string to convert
 * @return the string in kebab case
 */
export declare function toKebabCase(inputStr: string): string;
/**
 * Converts a string from camelCase to snake_case (underscore) case, for example "helloWorld" will become "hello_world"
 * @param str the string to convert
 * @return the string in kebab case
 */
export declare function toSnakeCase(inputStr: string): string;
/**
 * Takes an input array and makes sure the array has unique values by removing duplicates
 * @param array input with possible duplicates
 * @param objectProperty optionally provide an object property to compare (example: 'id')
 * @return array output without duplicates
 */
export declare function uniqueArray<T = any>(arr: T[]): T[];
/**
 * Takes an input array of objects and makes sure the array has unique object values by removing duplicates
 * it will loop through the array using a property name (or "id" when is not provided) to compare uniqueness
 * @param array input with possible duplicates
 * @param propertyName defaults to "id"
 * @return array output without duplicates
 */
export declare function uniqueObjectArray(arr: any[], propertyName?: string): any[];
/**
 * Unsubscribe all Observables Subscriptions
 * It will return an empty array if it all went well
 * @param subscriptions
 */
export declare function unsubscribeAllObservables(subscriptions: Subscription[]): Subscription[];
