import { TranslateService } from '@ngx-translate/core';
import { Subject } from 'rxjs';
import * as moment_ from 'moment-mini';
import { ExcelCellFormat, ExcelExportOption, FieldType } from '../models/index';
import * as ɵngcc0 from '@angular/core';
export declare class ExcelExportService {
    private translate;
    private _fileFormat;
    private _dataView;
    private _grid;
    private _locales;
    private _columnHeaders;
    private _groupedColumnHeaders;
    private _hasGroupedItems;
    private _excelExportOptions;
    private _sheet;
    private _stylesheet;
    private _stylesheetFormats;
    private _workbook;
    onGridBeforeExportToExcel: Subject<boolean>;
    onGridAfterExportToExcel: Subject<{
        blob?: Blob;
        filename: string;
        format?: string;
    }>;
    constructor(translate: TranslateService);
    private readonly datasetIdName;
    /** Getter for the Grid Options pulled through the Grid Object */
    private readonly _gridOptions;
    /**
     * Initialize the Export Service
     * @param grid
     * @param dataView
     */
    init(grid: any, dataView: any): void;
    /**
     * Function to export the Grid result to an Excel CSV format using javascript for it to produce the CSV file.
     * This is a WYSIWYG export to file output (What You See is What You Get)
     *
     * NOTES: The column position needs to match perfectly the JSON Object position because of the way we are pulling the data,
     * which means that if any column(s) got moved in the UI, it has to be reflected in the JSON array output as well
     *
     * Example: exportToExcel({ format: FileType.csv, delimiter: DelimiterType.comma })
     */
    exportToExcel(options: ExcelExportOption): Promise<boolean>;
    /**
     * Triggers download file with file format.
     * IE(6-10) are not supported
     * All other browsers will use plain javascript on client side to produce a file download.
     * @param options
     */
    startDownloadFile(options: {
        filename: string;
        blob: Blob;
        data: any[];
    }): void;
    /** use different Excel Stylesheet Format as per the Field Type */
    useCellFormatByFieldType(data: string | Date | moment_.Moment, fieldType: FieldType): ExcelCellFormat | string;
    private getDataOutput;
    /** Get each column style including a style for the width of each column */
    private getColumnStyles;
    /**
     * Get all Grouped Header Titles and their keys, translate the title when required, and format them in Bold
     * @param {Array<object>} columns of the grid
     */
    private getColumnGroupedHeaderTitlesData;
    /** Get all column headers and format them in Bold */
    private getColumnHeaderData;
    private getGroupColumnTitle;
    /**
     * Get all Grouped Header Titles and their keys, translate the title when required.
     * @param {Array<object>} columns of the grid
     */
    private getColumnGroupedHeaderTitles;
    /**
     * Get all header titles and their keys, translate the title when required.
     * @param columns of the grid
     */
    private getColumnHeaders;
    /**
     * Get all the grid row data and return that as an output string
     */
    private pushAllGridRowDataToArray;
    /**
     * Get the data of a regular row (a row without grouping)
     * @param row
     * @param itemObj
     */
    private readRegularRowData;
    /**
     * Get the grouped title(s) and its group title formatter, for example if we grouped by salesRep, the returned result would be:: 'Sales Rep: John Dow (2 items)'
     * @param itemObj
     */
    private readGroupedTitleRow;
    /**
     * Get the grouped totals (below the regular rows), these are set by Slick Aggregators.
     * For example if we grouped by "salesRep" and we have a Sum Aggregator on "sales", then the returned output would be:: ["Sum 123$"]
     * @param itemObj
     */
    private readGroupedTotalRow;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<ExcelExportService, [{ optional: true; }]>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<ExcelExportService>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhjZWxFeHBvcnQuc2VydmljZS5kLnRzIiwic291cmNlcyI6WyJleGNlbEV4cG9ydC5zZXJ2aWNlLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUcmFuc2xhdGVTZXJ2aWNlIH0gZnJvbSAnQG5neC10cmFuc2xhdGUvY29yZSc7XHJcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0ICogYXMgbW9tZW50XyBmcm9tICdtb21lbnQtbWluaSc7XHJcbmltcG9ydCB7IEV4Y2VsQ2VsbEZvcm1hdCwgRXhjZWxFeHBvcnRPcHRpb24sIEZpZWxkVHlwZSB9IGZyb20gJy4uL21vZGVscy9pbmRleCc7XHJcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIEV4Y2VsRXhwb3J0U2VydmljZSB7XHJcbiAgICBwcml2YXRlIHRyYW5zbGF0ZTtcclxuICAgIHByaXZhdGUgX2ZpbGVGb3JtYXQ7XHJcbiAgICBwcml2YXRlIF9kYXRhVmlldztcclxuICAgIHByaXZhdGUgX2dyaWQ7XHJcbiAgICBwcml2YXRlIF9sb2NhbGVzO1xyXG4gICAgcHJpdmF0ZSBfY29sdW1uSGVhZGVycztcclxuICAgIHByaXZhdGUgX2dyb3VwZWRDb2x1bW5IZWFkZXJzO1xyXG4gICAgcHJpdmF0ZSBfaGFzR3JvdXBlZEl0ZW1zO1xyXG4gICAgcHJpdmF0ZSBfZXhjZWxFeHBvcnRPcHRpb25zO1xyXG4gICAgcHJpdmF0ZSBfc2hlZXQ7XHJcbiAgICBwcml2YXRlIF9zdHlsZXNoZWV0O1xyXG4gICAgcHJpdmF0ZSBfc3R5bGVzaGVldEZvcm1hdHM7XHJcbiAgICBwcml2YXRlIF93b3JrYm9vaztcclxuICAgIG9uR3JpZEJlZm9yZUV4cG9ydFRvRXhjZWw6IFN1YmplY3Q8Ym9vbGVhbj47XHJcbiAgICBvbkdyaWRBZnRlckV4cG9ydFRvRXhjZWw6IFN1YmplY3Q8e1xyXG4gICAgICAgIGJsb2I/OiBCbG9iO1xyXG4gICAgICAgIGZpbGVuYW1lOiBzdHJpbmc7XHJcbiAgICAgICAgZm9ybWF0Pzogc3RyaW5nO1xyXG4gICAgfT47XHJcbiAgICBjb25zdHJ1Y3Rvcih0cmFuc2xhdGU6IFRyYW5zbGF0ZVNlcnZpY2UpO1xyXG4gICAgcHJpdmF0ZSByZWFkb25seSBkYXRhc2V0SWROYW1lO1xyXG4gICAgLyoqIEdldHRlciBmb3IgdGhlIEdyaWQgT3B0aW9ucyBwdWxsZWQgdGhyb3VnaCB0aGUgR3JpZCBPYmplY3QgKi9cclxuICAgIHByaXZhdGUgcmVhZG9ubHkgX2dyaWRPcHRpb25zO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplIHRoZSBFeHBvcnQgU2VydmljZVxyXG4gICAgICogQHBhcmFtIGdyaWRcclxuICAgICAqIEBwYXJhbSBkYXRhVmlld1xyXG4gICAgICovXHJcbiAgICBpbml0KGdyaWQ6IGFueSwgZGF0YVZpZXc6IGFueSk6IHZvaWQ7XHJcbiAgICAvKipcclxuICAgICAqIEZ1bmN0aW9uIHRvIGV4cG9ydCB0aGUgR3JpZCByZXN1bHQgdG8gYW4gRXhjZWwgQ1NWIGZvcm1hdCB1c2luZyBqYXZhc2NyaXB0IGZvciBpdCB0byBwcm9kdWNlIHRoZSBDU1YgZmlsZS5cclxuICAgICAqIFRoaXMgaXMgYSBXWVNJV1lHIGV4cG9ydCB0byBmaWxlIG91dHB1dCAoV2hhdCBZb3UgU2VlIGlzIFdoYXQgWW91IEdldClcclxuICAgICAqXHJcbiAgICAgKiBOT1RFUzogVGhlIGNvbHVtbiBwb3NpdGlvbiBuZWVkcyB0byBtYXRjaCBwZXJmZWN0bHkgdGhlIEpTT04gT2JqZWN0IHBvc2l0aW9uIGJlY2F1c2Ugb2YgdGhlIHdheSB3ZSBhcmUgcHVsbGluZyB0aGUgZGF0YSxcclxuICAgICAqIHdoaWNoIG1lYW5zIHRoYXQgaWYgYW55IGNvbHVtbihzKSBnb3QgbW92ZWQgaW4gdGhlIFVJLCBpdCBoYXMgdG8gYmUgcmVmbGVjdGVkIGluIHRoZSBKU09OIGFycmF5IG91dHB1dCBhcyB3ZWxsXHJcbiAgICAgKlxyXG4gICAgICogRXhhbXBsZTogZXhwb3J0VG9FeGNlbCh7IGZvcm1hdDogRmlsZVR5cGUuY3N2LCBkZWxpbWl0ZXI6IERlbGltaXRlclR5cGUuY29tbWEgfSlcclxuICAgICAqL1xyXG4gICAgZXhwb3J0VG9FeGNlbChvcHRpb25zOiBFeGNlbEV4cG9ydE9wdGlvbik6IFByb21pc2U8Ym9vbGVhbj47XHJcbiAgICAvKipcclxuICAgICAqIFRyaWdnZXJzIGRvd25sb2FkIGZpbGUgd2l0aCBmaWxlIGZvcm1hdC5cclxuICAgICAqIElFKDYtMTApIGFyZSBub3Qgc3VwcG9ydGVkXHJcbiAgICAgKiBBbGwgb3RoZXIgYnJvd3NlcnMgd2lsbCB1c2UgcGxhaW4gamF2YXNjcmlwdCBvbiBjbGllbnQgc2lkZSB0byBwcm9kdWNlIGEgZmlsZSBkb3dubG9hZC5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zXHJcbiAgICAgKi9cclxuICAgIHN0YXJ0RG93bmxvYWRGaWxlKG9wdGlvbnM6IHtcclxuICAgICAgICBmaWxlbmFtZTogc3RyaW5nO1xyXG4gICAgICAgIGJsb2I6IEJsb2I7XHJcbiAgICAgICAgZGF0YTogYW55W107XHJcbiAgICB9KTogdm9pZDtcclxuICAgIC8qKiB1c2UgZGlmZmVyZW50IEV4Y2VsIFN0eWxlc2hlZXQgRm9ybWF0IGFzIHBlciB0aGUgRmllbGQgVHlwZSAqL1xyXG4gICAgdXNlQ2VsbEZvcm1hdEJ5RmllbGRUeXBlKGRhdGE6IHN0cmluZyB8IERhdGUgfCBtb21lbnRfLk1vbWVudCwgZmllbGRUeXBlOiBGaWVsZFR5cGUpOiBFeGNlbENlbGxGb3JtYXQgfCBzdHJpbmc7XHJcbiAgICBwcml2YXRlIGdldERhdGFPdXRwdXQ7XHJcbiAgICAvKiogR2V0IGVhY2ggY29sdW1uIHN0eWxlIGluY2x1ZGluZyBhIHN0eWxlIGZvciB0aGUgd2lkdGggb2YgZWFjaCBjb2x1bW4gKi9cclxuICAgIHByaXZhdGUgZ2V0Q29sdW1uU3R5bGVzO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYWxsIEdyb3VwZWQgSGVhZGVyIFRpdGxlcyBhbmQgdGhlaXIga2V5cywgdHJhbnNsYXRlIHRoZSB0aXRsZSB3aGVuIHJlcXVpcmVkLCBhbmQgZm9ybWF0IHRoZW0gaW4gQm9sZFxyXG4gICAgICogQHBhcmFtIHtBcnJheTxvYmplY3Q+fSBjb2x1bW5zIG9mIHRoZSBncmlkXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZ2V0Q29sdW1uR3JvdXBlZEhlYWRlclRpdGxlc0RhdGE7XHJcbiAgICAvKiogR2V0IGFsbCBjb2x1bW4gaGVhZGVycyBhbmQgZm9ybWF0IHRoZW0gaW4gQm9sZCAqL1xyXG4gICAgcHJpdmF0ZSBnZXRDb2x1bW5IZWFkZXJEYXRhO1xyXG4gICAgcHJpdmF0ZSBnZXRHcm91cENvbHVtblRpdGxlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYWxsIEdyb3VwZWQgSGVhZGVyIFRpdGxlcyBhbmQgdGhlaXIga2V5cywgdHJhbnNsYXRlIHRoZSB0aXRsZSB3aGVuIHJlcXVpcmVkLlxyXG4gICAgICogQHBhcmFtIHtBcnJheTxvYmplY3Q+fSBjb2x1bW5zIG9mIHRoZSBncmlkXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZ2V0Q29sdW1uR3JvdXBlZEhlYWRlclRpdGxlcztcclxuICAgIC8qKlxyXG4gICAgICogR2V0IGFsbCBoZWFkZXIgdGl0bGVzIGFuZCB0aGVpciBrZXlzLCB0cmFuc2xhdGUgdGhlIHRpdGxlIHdoZW4gcmVxdWlyZWQuXHJcbiAgICAgKiBAcGFyYW0gY29sdW1ucyBvZiB0aGUgZ3JpZFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGdldENvbHVtbkhlYWRlcnM7XHJcbiAgICAvKipcclxuICAgICAqIEdldCBhbGwgdGhlIGdyaWQgcm93IGRhdGEgYW5kIHJldHVybiB0aGF0IGFzIGFuIG91dHB1dCBzdHJpbmdcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBwdXNoQWxsR3JpZFJvd0RhdGFUb0FycmF5O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGRhdGEgb2YgYSByZWd1bGFyIHJvdyAoYSByb3cgd2l0aG91dCBncm91cGluZylcclxuICAgICAqIEBwYXJhbSByb3dcclxuICAgICAqIEBwYXJhbSBpdGVtT2JqXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcmVhZFJlZ3VsYXJSb3dEYXRhO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGdyb3VwZWQgdGl0bGUocykgYW5kIGl0cyBncm91cCB0aXRsZSBmb3JtYXR0ZXIsIGZvciBleGFtcGxlIGlmIHdlIGdyb3VwZWQgYnkgc2FsZXNSZXAsIHRoZSByZXR1cm5lZCByZXN1bHQgd291bGQgYmU6OiAnU2FsZXMgUmVwOiBKb2huIERvdyAoMiBpdGVtcyknXHJcbiAgICAgKiBAcGFyYW0gaXRlbU9ialxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHJlYWRHcm91cGVkVGl0bGVSb3c7XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgZ3JvdXBlZCB0b3RhbHMgKGJlbG93IHRoZSByZWd1bGFyIHJvd3MpLCB0aGVzZSBhcmUgc2V0IGJ5IFNsaWNrIEFnZ3JlZ2F0b3JzLlxyXG4gICAgICogRm9yIGV4YW1wbGUgaWYgd2UgZ3JvdXBlZCBieSBcInNhbGVzUmVwXCIgYW5kIHdlIGhhdmUgYSBTdW0gQWdncmVnYXRvciBvbiBcInNhbGVzXCIsIHRoZW4gdGhlIHJldHVybmVkIG91dHB1dCB3b3VsZCBiZTo6IFtcIlN1bSAxMjMkXCJdXHJcbiAgICAgKiBAcGFyYW0gaXRlbU9ialxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHJlYWRHcm91cGVkVG90YWxSb3c7XHJcbn1cclxuIl19