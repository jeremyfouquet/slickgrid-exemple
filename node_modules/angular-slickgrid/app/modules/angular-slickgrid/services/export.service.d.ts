import { TranslateService } from '@ngx-translate/core';
import { Subject } from 'rxjs';
import { ExportOption, FileType } from './../models/index';
import * as ɵngcc0 from '@angular/core';
export declare class ExportService {
    private translate;
    private _delimiter;
    private _fileFormat;
    private _lineCarriageReturn;
    private _dataView;
    private _grid;
    private _locales;
    private _exportQuoteWrapper;
    private _columnHeaders;
    private _groupedColumnHeaders;
    private _hasGroupedItems;
    private _exportOptions;
    onGridBeforeExportToFile: Subject<boolean>;
    onGridAfterExportToFile: Subject<{
        content?: string;
        filename: string;
        format: string;
        useUtf8WithBom: boolean;
    }>;
    constructor(translate: TranslateService);
    private readonly datasetIdName;
    /** Getter for the Grid Options pulled through the Grid Object */
    private readonly _gridOptions;
    /**
     * Initialize the Export Service
     * @param grid
     * @param gridOptions
     * @param dataView
     */
    init(grid: any, dataView: any): void;
    /**
     * Function to export the Grid result to an Excel CSV format using javascript for it to produce the CSV file.
     * This is a WYSIWYG export to file output (What You See is What You Get)
     *
     * NOTES: The column position needs to match perfectly the JSON Object position because of the way we are pulling the data,
     * which means that if any column(s) got moved in the UI, it has to be reflected in the JSON array output as well
     *
     * Example: exportToFile({ format: FileType.csv, delimiter: DelimiterType.comma })
     */
    exportToFile(options: ExportOption): Promise<boolean>;
    /**
     * Triggers download file with file format.
     * IE(6-10) are not supported
     * All other browsers will use plain javascript on client side to produce a file download.
     * @param options
     */
    startDownloadFile(options: {
        filename: string;
        content: string;
        format: FileType | string;
        useUtf8WithBom: boolean;
    }): void;
    private getDataOutput;
    /**
     * Get all the grid row data and return that as an output string
     */
    private getAllGridRowData;
    /**
   * Get all Grouped Header Titles and their keys, translate the title when required.
   * @param {Array<object>} columns of the grid
   */
    private getColumnGroupedHeaderTitles;
    /**
     * Get all header titles and their keys, translate the title when required.
     * @param {Array<object>} columns of the grid
     */
    private getColumnHeaders;
    /**
     * Get the data of a regular row (a row without grouping)
     * @param row
     * @param itemObj
     */
    private readRegularRowData;
    /**
     * Get the grouped title(s) and its group title formatter, for example if we grouped by salesRep, the returned result would be:: 'Sales Rep: John Dow (2 items)'
     * @param itemObj
     */
    private readGroupedTitleRow;
    /**
     * Get the grouped totals (below the regular rows), these are set by Slick Aggregators.
     * For example if we grouped by "salesRep" and we have a Sum Aggregator on "sales", then the returned output would be:: ["Sum 123$"]
     * @param itemObj
     */
    private readGroupedTotalRow;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<ExportService, [{ optional: true; }]>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<ExportService>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhwb3J0LnNlcnZpY2UuZC50cyIsInNvdXJjZXMiOlsiZXhwb3J0LnNlcnZpY2UuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVHJhbnNsYXRlU2VydmljZSB9IGZyb20gJ0BuZ3gtdHJhbnNsYXRlL2NvcmUnO1xyXG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IEV4cG9ydE9wdGlvbiwgRmlsZVR5cGUgfSBmcm9tICcuLy4uL21vZGVscy9pbmRleCc7XHJcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIEV4cG9ydFNlcnZpY2Uge1xyXG4gICAgcHJpdmF0ZSB0cmFuc2xhdGU7XHJcbiAgICBwcml2YXRlIF9kZWxpbWl0ZXI7XHJcbiAgICBwcml2YXRlIF9maWxlRm9ybWF0O1xyXG4gICAgcHJpdmF0ZSBfbGluZUNhcnJpYWdlUmV0dXJuO1xyXG4gICAgcHJpdmF0ZSBfZGF0YVZpZXc7XHJcbiAgICBwcml2YXRlIF9ncmlkO1xyXG4gICAgcHJpdmF0ZSBfbG9jYWxlcztcclxuICAgIHByaXZhdGUgX2V4cG9ydFF1b3RlV3JhcHBlcjtcclxuICAgIHByaXZhdGUgX2NvbHVtbkhlYWRlcnM7XHJcbiAgICBwcml2YXRlIF9ncm91cGVkQ29sdW1uSGVhZGVycztcclxuICAgIHByaXZhdGUgX2hhc0dyb3VwZWRJdGVtcztcclxuICAgIHByaXZhdGUgX2V4cG9ydE9wdGlvbnM7XHJcbiAgICBvbkdyaWRCZWZvcmVFeHBvcnRUb0ZpbGU6IFN1YmplY3Q8Ym9vbGVhbj47XHJcbiAgICBvbkdyaWRBZnRlckV4cG9ydFRvRmlsZTogU3ViamVjdDx7XHJcbiAgICAgICAgY29udGVudD86IHN0cmluZztcclxuICAgICAgICBmaWxlbmFtZTogc3RyaW5nO1xyXG4gICAgICAgIGZvcm1hdDogc3RyaW5nO1xyXG4gICAgICAgIHVzZVV0ZjhXaXRoQm9tOiBib29sZWFuO1xyXG4gICAgfT47XHJcbiAgICBjb25zdHJ1Y3Rvcih0cmFuc2xhdGU6IFRyYW5zbGF0ZVNlcnZpY2UpO1xyXG4gICAgcHJpdmF0ZSByZWFkb25seSBkYXRhc2V0SWROYW1lO1xyXG4gICAgLyoqIEdldHRlciBmb3IgdGhlIEdyaWQgT3B0aW9ucyBwdWxsZWQgdGhyb3VnaCB0aGUgR3JpZCBPYmplY3QgKi9cclxuICAgIHByaXZhdGUgcmVhZG9ubHkgX2dyaWRPcHRpb25zO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplIHRoZSBFeHBvcnQgU2VydmljZVxyXG4gICAgICogQHBhcmFtIGdyaWRcclxuICAgICAqIEBwYXJhbSBncmlkT3B0aW9uc1xyXG4gICAgICogQHBhcmFtIGRhdGFWaWV3XHJcbiAgICAgKi9cclxuICAgIGluaXQoZ3JpZDogYW55LCBkYXRhVmlldzogYW55KTogdm9pZDtcclxuICAgIC8qKlxyXG4gICAgICogRnVuY3Rpb24gdG8gZXhwb3J0IHRoZSBHcmlkIHJlc3VsdCB0byBhbiBFeGNlbCBDU1YgZm9ybWF0IHVzaW5nIGphdmFzY3JpcHQgZm9yIGl0IHRvIHByb2R1Y2UgdGhlIENTViBmaWxlLlxyXG4gICAgICogVGhpcyBpcyBhIFdZU0lXWUcgZXhwb3J0IHRvIGZpbGUgb3V0cHV0IChXaGF0IFlvdSBTZWUgaXMgV2hhdCBZb3UgR2V0KVxyXG4gICAgICpcclxuICAgICAqIE5PVEVTOiBUaGUgY29sdW1uIHBvc2l0aW9uIG5lZWRzIHRvIG1hdGNoIHBlcmZlY3RseSB0aGUgSlNPTiBPYmplY3QgcG9zaXRpb24gYmVjYXVzZSBvZiB0aGUgd2F5IHdlIGFyZSBwdWxsaW5nIHRoZSBkYXRhLFxyXG4gICAgICogd2hpY2ggbWVhbnMgdGhhdCBpZiBhbnkgY29sdW1uKHMpIGdvdCBtb3ZlZCBpbiB0aGUgVUksIGl0IGhhcyB0byBiZSByZWZsZWN0ZWQgaW4gdGhlIEpTT04gYXJyYXkgb3V0cHV0IGFzIHdlbGxcclxuICAgICAqXHJcbiAgICAgKiBFeGFtcGxlOiBleHBvcnRUb0ZpbGUoeyBmb3JtYXQ6IEZpbGVUeXBlLmNzdiwgZGVsaW1pdGVyOiBEZWxpbWl0ZXJUeXBlLmNvbW1hIH0pXHJcbiAgICAgKi9cclxuICAgIGV4cG9ydFRvRmlsZShvcHRpb25zOiBFeHBvcnRPcHRpb24pOiBQcm9taXNlPGJvb2xlYW4+O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUcmlnZ2VycyBkb3dubG9hZCBmaWxlIHdpdGggZmlsZSBmb3JtYXQuXHJcbiAgICAgKiBJRSg2LTEwKSBhcmUgbm90IHN1cHBvcnRlZFxyXG4gICAgICogQWxsIG90aGVyIGJyb3dzZXJzIHdpbGwgdXNlIHBsYWluIGphdmFzY3JpcHQgb24gY2xpZW50IHNpZGUgdG8gcHJvZHVjZSBhIGZpbGUgZG93bmxvYWQuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xyXG4gICAgICovXHJcbiAgICBzdGFydERvd25sb2FkRmlsZShvcHRpb25zOiB7XHJcbiAgICAgICAgZmlsZW5hbWU6IHN0cmluZztcclxuICAgICAgICBjb250ZW50OiBzdHJpbmc7XHJcbiAgICAgICAgZm9ybWF0OiBGaWxlVHlwZSB8IHN0cmluZztcclxuICAgICAgICB1c2VVdGY4V2l0aEJvbTogYm9vbGVhbjtcclxuICAgIH0pOiB2b2lkO1xyXG4gICAgcHJpdmF0ZSBnZXREYXRhT3V0cHV0O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYWxsIHRoZSBncmlkIHJvdyBkYXRhIGFuZCByZXR1cm4gdGhhdCBhcyBhbiBvdXRwdXQgc3RyaW5nXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZ2V0QWxsR3JpZFJvd0RhdGE7XHJcbiAgICAvKipcclxuICAgKiBHZXQgYWxsIEdyb3VwZWQgSGVhZGVyIFRpdGxlcyBhbmQgdGhlaXIga2V5cywgdHJhbnNsYXRlIHRoZSB0aXRsZSB3aGVuIHJlcXVpcmVkLlxyXG4gICAqIEBwYXJhbSB7QXJyYXk8b2JqZWN0Pn0gY29sdW1ucyBvZiB0aGUgZ3JpZFxyXG4gICAqL1xyXG4gICAgcHJpdmF0ZSBnZXRDb2x1bW5Hcm91cGVkSGVhZGVyVGl0bGVzO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYWxsIGhlYWRlciB0aXRsZXMgYW5kIHRoZWlyIGtleXMsIHRyYW5zbGF0ZSB0aGUgdGl0bGUgd2hlbiByZXF1aXJlZC5cclxuICAgICAqIEBwYXJhbSB7QXJyYXk8b2JqZWN0Pn0gY29sdW1ucyBvZiB0aGUgZ3JpZFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGdldENvbHVtbkhlYWRlcnM7XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgZGF0YSBvZiBhIHJlZ3VsYXIgcm93IChhIHJvdyB3aXRob3V0IGdyb3VwaW5nKVxyXG4gICAgICogQHBhcmFtIHJvd1xyXG4gICAgICogQHBhcmFtIGl0ZW1PYmpcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSByZWFkUmVndWxhclJvd0RhdGE7XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgZ3JvdXBlZCB0aXRsZShzKSBhbmQgaXRzIGdyb3VwIHRpdGxlIGZvcm1hdHRlciwgZm9yIGV4YW1wbGUgaWYgd2UgZ3JvdXBlZCBieSBzYWxlc1JlcCwgdGhlIHJldHVybmVkIHJlc3VsdCB3b3VsZCBiZTo6ICdTYWxlcyBSZXA6IEpvaG4gRG93ICgyIGl0ZW1zKSdcclxuICAgICAqIEBwYXJhbSBpdGVtT2JqXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcmVhZEdyb3VwZWRUaXRsZVJvdztcclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBncm91cGVkIHRvdGFscyAoYmVsb3cgdGhlIHJlZ3VsYXIgcm93cyksIHRoZXNlIGFyZSBzZXQgYnkgU2xpY2sgQWdncmVnYXRvcnMuXHJcbiAgICAgKiBGb3IgZXhhbXBsZSBpZiB3ZSBncm91cGVkIGJ5IFwic2FsZXNSZXBcIiBhbmQgd2UgaGF2ZSBhIFN1bSBBZ2dyZWdhdG9yIG9uIFwic2FsZXNcIiwgdGhlbiB0aGUgcmV0dXJuZWQgb3V0cHV0IHdvdWxkIGJlOjogW1wiU3VtIDEyMyRcIl1cclxuICAgICAqIEBwYXJhbSBpdGVtT2JqXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcmVhZEdyb3VwZWRUb3RhbFJvdztcclxufVxyXG4iXX0=