import { Subject } from 'rxjs';
import { CellArgs, Column, GridServiceDeleteOption, GridServiceInsertOption, GridServiceUpdateOption, HideColumnOption, OnEventArgs } from './../models/index';
import { ExtensionService } from './extension.service';
import { FilterService } from './filter.service';
import { GridStateService } from './gridState.service';
import { SharedService } from './shared.service';
import { SortService } from './sort.service';
import * as ɵngcc0 from '@angular/core';
export declare class GridService {
    private extensionService;
    private filterService;
    private gridStateService;
    private sharedService;
    private sortService;
    private _grid;
    private _dataView;
    private _rowSelectionPlugin;
    onItemAdded: Subject<any>;
    onItemDeleted: Subject<any>;
    onItemUpdated: Subject<any>;
    onItemUpserted: Subject<any>;
    onColumnsChanged: Subject<Column<any>[]>;
    constructor(extensionService: ExtensionService, filterService: FilterService, gridStateService: GridStateService, sharedService: SharedService, sortService: SortService);
    /** Getter for the Grid Options pulled through the Grid Object */
    private readonly _gridOptions;
    dispose(): void;
    init(grid: any, dataView: any): void;
    /** Clear all Filters & Sorts */
    clearAllFiltersAndSorts(): void;
    /**
     * Get all column set in the grid, that is all visible/hidden columns
     * and also include any extra columns used by some plugins (like Row Selection, Row Detail, ...)
     */
    getAllColumnDefinitions(): Column<any>[];
    /** Get only visible column definitions and also include any extra columns by some plugins (like Row Selection, Row Detail, ...) */
    getVisibleColumnDefinitions(): Column[];
    /**
     * From a SlickGrid Event triggered get the Column Definition and Item Data Context
     *
     * For example the SlickGrid onClick will return cell arguments when subscribing to it.
     * From these cellArgs, we want to get the Column Definition and Item Data
     * @param cell event args
     * @return object with columnDef and dataContext
     */
    getColumnFromEventArguments(args: CellArgs): OnEventArgs;
    /** Get data item by it's row index number */
    getDataItemByRowNumber<T = any>(rowNumber: number): T;
    /** Chain the item Metadata with our implementation of Metadata at given row index */
    getItemRowMetadataToHighlight(previousItemMetadata: any): (rowNumber: number) => {
        cssClasses: string;
    };
    /**
       * @deprecated Hide a Column from the Grid (the column will just become hidden and will still show up in columnPicker/gridMenu)
       * @see hideColumnById
       * @param column
       */
    hideColumn(column: Column): void;
    /**
     * @deprecated Hide a Column from the Grid by its column definition index (the column will just become hidden and will still show up in columnPicker/gridMenu)
     * @see hideColumnById Please use "hideColumnById(id)" or "hideColumnByIds([ids])" instead since it has a lot more options
     * @param columnIndex - column definition index
     * @param triggerEvent - do we want to trigger an event (onHeaderMenuColumnsChanged) when column becomes hidden? Defaults to true.
     */
    hideColumnByIndex(columnIndex: number, triggerEvent?: boolean): void;
    /**
     * Hide a Column from the Grid by its column definition id, the column will just become hidden and will still show up in columnPicker/gridMenu
     * @param {string | number} columnId - column definition id
     * @param {boolean} triggerEvent - do we want to trigger an event (onHeaderMenuColumnsChanged) when column becomes hidden? Defaults to true.
     * @return {number} columnIndex - column index position when found or -1
     */
    hideColumnById(columnId: string | number, options?: HideColumnOption): number;
    /**
     * Hide a Column from the Grid by its column definition id(s), the column will just become hidden and will still show up in columnPicker/gridMenu
     * @param {Array<string | number>} columnIds - column definition ids, can be a single string and an array of strings
     * @param {boolean} triggerEvent - do we want to trigger an event (onHeaderMenuColumnsChanged) when column becomes hidden? Defaults to true.
     */
    hideColumnByIds(columnIds: Array<string | number>, options?: HideColumnOption): void;
    /**
     * Highlight then fade a row for x seconds.
     * The implementation follows this SO answer: https://stackoverflow.com/a/19985148/1212166
     * @param rowNumber
     * @param fadeDelay
     */
    highlightRow(rowNumber: number | number[], fadeDelay?: number, fadeOutDelay?: number): void;
    highlightRowByMetadata(rowNumber: number, fadeDelay?: number, fadeOutDelay?: number): void;
    /** Get the Data Item from a grid row index */
    getDataItemByRowIndex<T = any>(index: number): T;
    /** Get the Data Item from an array of grid row indexes */
    getDataItemByRowIndexes<T = any>(indexes: number[]): T[];
    /** Get the currently selected row indexes */
    getSelectedRows(): number[];
    /** Get the currently selected rows item data */
    getSelectedRowsDataItem<T = any>(): T[];
    /** Select the selected row by a row index */
    setSelectedRow(rowIndex: number): void;
    /** Set selected rows with provided array of row indexes */
    setSelectedRows(rowIndexes: number[]): void;
    /** Re-Render the Grid */
    renderGrid(): void;
    /**
     * Reset the grid to it's original state (clear any filters, sorting & pagination if exists) .
     * The column definitions could be passed as argument to reset (this can be used after a Grid State reset)
     * The reset will clear the Filters & Sort, then will reset the Columns to their original state
     */
    resetGrid(columnDefinitions?: Column[]): void;
    /** @deprecated please use "addItem" method instead */
    addItemToDatagrid(item: any, shouldHighlightRow?: boolean, shouldResortGrid?: boolean, shouldTriggerEvent?: boolean, shouldSelectRow?: boolean): number;
    /** @deprecated please use "addItems" method instead */
    addItemsToDatagrid(items: any[], shouldHighlightRow?: boolean, shouldResortGrid?: boolean, shouldTriggerEvent?: boolean, shouldSelectRow?: boolean): number[];
    /**
     * Add an item (data item) to the datagrid, by default it will highlight (flashing) the inserted row but we can disable it too
     * @param item object which must contain a unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, resortGrid, selectRow, triggerEvent)
     * @return rowIndex: typically index 0 when adding to position "top" or a different number when adding to the "bottom"
     */
    addItem<T = any>(item: T, options?: GridServiceInsertOption): number;
    /**
     * Add item array (data item) to the datagrid, by default it will highlight (flashing) the inserted row but we can disable it too
     * @param item object arrays, which must contain unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, resortGrid, selectRow, triggerEvent)
     */
    addItems<T = any>(items: T | T[], options?: GridServiceInsertOption): number[];
    /** @deprecated please use "deleteItem" method instead */
    deleteDataGridItem(item: any, shouldTriggerEvent?: boolean): void;
    /** @deprecated please use "deleteItems" method instead */
    deleteDataGridItems(items: any[], shouldTriggerEvent?: boolean): void;
    /** @deprecated please use "deleteItemById" method instead */
    deleteDataGridItemById(itemId: string | number, shouldTriggerEvent?: boolean): void;
    /** @deprecated please use "deleteItemByIds" method instead */
    deleteDataGridItemByIds(itemIds: number[] | string[], shouldTriggerEvent?: boolean): void;
    /**
     * Delete an existing item from the datagrid (dataView)
     * @param item object which must contain a unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (triggerEvent)
     * @return item id deleted
     */
    deleteItem<T = any>(item: T, options?: GridServiceDeleteOption): number | string;
    /**
     * Delete an array of existing items from the datagrid
     * @param item object which must contain a unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (triggerEvent)
     * @return item id deleted
     */
    deleteItems<T = any>(items: T | T[], options?: GridServiceDeleteOption): number[] | string[];
    /**
     * Delete an existing item from the datagrid (dataView) by it's id
     * @param itemId: item unique id
     * @param options: provide the possibility to do certain actions after or during the upsert (triggerEvent)
     * @return item id deleted
     */
    deleteItemById(itemId: string | number, options?: GridServiceDeleteOption): number | string;
    /**
     * Delete an array of existing items from the datagrid
     * @param itemIds array of item unique IDs
     * @param options: provide the possibility to do certain actions after or during the upsert (triggerEvent)
     */
    deleteItemByIds(itemIds: number[] | string[], options?: GridServiceDeleteOption): number[] | string[];
    /** @deprecated please use "updateItem" method instead */
    updateDataGridItem(item: any, shouldHighlightRow?: boolean, shouldTriggerEvent?: boolean, shouldSelectRow?: boolean): number;
    /** @deprecated please use "updateItems" method instead */
    updateDataGridItems(items: any | any[], shouldHighlightRow?: boolean, shouldTriggerEvent?: boolean, shouldSelectRow?: boolean): number[];
    /** @deprecated please use "updateItemById" method instead */
    updateDataGridItemById(itemId: number | string, item: any, shouldHighlightRow?: boolean, shouldTriggerEvent?: boolean, shouldSelectRow?: boolean): number;
    /**
     * Update an existing item with new properties inside the datagrid
     * @param item object which must contain a unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, selectRow, triggerEvent)
     * @return grid row index
     */
    updateItem<T = any>(item: T, options?: GridServiceUpdateOption): number;
    /**
     * Update an array of existing items with new properties inside the datagrid
     * @param item object arrays, which must contain unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, selectRow, triggerEvent)
     * @return grid row indexes
     */
    updateItems<T = any>(items: T | T[], options?: GridServiceUpdateOption): number[];
    /**
     * Update an existing item in the datagrid by it's id and new properties
     * @param itemId: item unique id
     * @param item object which must contain a unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, selectRow, triggerEvent)
     * @return grid row number
     */
    updateItemById<T = any>(itemId: number | string, item: T, options?: GridServiceUpdateOption): number;
    /**
     * Insert a row into the grid if it doesn't already exist or update if it does.
     * @param item object which must contain a unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, resortGrid, selectRow, triggerEvent)
     */
    upsertItem<T = any>(item: T, options?: GridServiceInsertOption): {
        added: number;
        updated: number;
    };
    /**
     * Update an array of existing items with new properties inside the datagrid
     * @param item object arrays, which must contain unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, resortGrid, selectRow, triggerEvent)
     * @return row numbers in the grid
     */
    upsertItems<T = any>(items: T | T[], options?: GridServiceInsertOption): {
        added: number;
        updated: number;
    }[];
    /**
     * Update an existing item in the datagrid by it's id and new properties
     * @param itemId: item unique id
     * @param item object which must contain a unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, resortGrid, selectRow, triggerEvent)
     * @return grid row number in the grid
     */
    upsertItemById<T = any>(itemId: number | string, item: T, options?: GridServiceInsertOption): {
        added: number;
        updated: number;
    };
    static ɵfac: ɵngcc0.ɵɵFactoryDef<GridService, never>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<GridService>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JpZC5zZXJ2aWNlLmQudHMiLCJzb3VyY2VzIjpbImdyaWQuc2VydmljZS5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IENlbGxBcmdzLCBDb2x1bW4sIEdyaWRTZXJ2aWNlRGVsZXRlT3B0aW9uLCBHcmlkU2VydmljZUluc2VydE9wdGlvbiwgR3JpZFNlcnZpY2VVcGRhdGVPcHRpb24sIEhpZGVDb2x1bW5PcHRpb24sIE9uRXZlbnRBcmdzIH0gZnJvbSAnLi8uLi9tb2RlbHMvaW5kZXgnO1xyXG5pbXBvcnQgeyBFeHRlbnNpb25TZXJ2aWNlIH0gZnJvbSAnLi9leHRlbnNpb24uc2VydmljZSc7XHJcbmltcG9ydCB7IEZpbHRlclNlcnZpY2UgfSBmcm9tICcuL2ZpbHRlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgR3JpZFN0YXRlU2VydmljZSB9IGZyb20gJy4vZ3JpZFN0YXRlLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBTaGFyZWRTZXJ2aWNlIH0gZnJvbSAnLi9zaGFyZWQuc2VydmljZSc7XHJcbmltcG9ydCB7IFNvcnRTZXJ2aWNlIH0gZnJvbSAnLi9zb3J0LnNlcnZpY2UnO1xyXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBHcmlkU2VydmljZSB7XHJcbiAgICBwcml2YXRlIGV4dGVuc2lvblNlcnZpY2U7XHJcbiAgICBwcml2YXRlIGZpbHRlclNlcnZpY2U7XHJcbiAgICBwcml2YXRlIGdyaWRTdGF0ZVNlcnZpY2U7XHJcbiAgICBwcml2YXRlIHNoYXJlZFNlcnZpY2U7XHJcbiAgICBwcml2YXRlIHNvcnRTZXJ2aWNlO1xyXG4gICAgcHJpdmF0ZSBfZ3JpZDtcclxuICAgIHByaXZhdGUgX2RhdGFWaWV3O1xyXG4gICAgcHJpdmF0ZSBfcm93U2VsZWN0aW9uUGx1Z2luO1xyXG4gICAgb25JdGVtQWRkZWQ6IFN1YmplY3Q8YW55PjtcclxuICAgIG9uSXRlbURlbGV0ZWQ6IFN1YmplY3Q8YW55PjtcclxuICAgIG9uSXRlbVVwZGF0ZWQ6IFN1YmplY3Q8YW55PjtcclxuICAgIG9uSXRlbVVwc2VydGVkOiBTdWJqZWN0PGFueT47XHJcbiAgICBvbkNvbHVtbnNDaGFuZ2VkOiBTdWJqZWN0PENvbHVtbjxhbnk+W10+O1xyXG4gICAgY29uc3RydWN0b3IoZXh0ZW5zaW9uU2VydmljZTogRXh0ZW5zaW9uU2VydmljZSwgZmlsdGVyU2VydmljZTogRmlsdGVyU2VydmljZSwgZ3JpZFN0YXRlU2VydmljZTogR3JpZFN0YXRlU2VydmljZSwgc2hhcmVkU2VydmljZTogU2hhcmVkU2VydmljZSwgc29ydFNlcnZpY2U6IFNvcnRTZXJ2aWNlKTtcclxuICAgIC8qKiBHZXR0ZXIgZm9yIHRoZSBHcmlkIE9wdGlvbnMgcHVsbGVkIHRocm91Z2ggdGhlIEdyaWQgT2JqZWN0ICovXHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9ncmlkT3B0aW9ucztcclxuICAgIGRpc3Bvc2UoKTogdm9pZDtcclxuICAgIGluaXQoZ3JpZDogYW55LCBkYXRhVmlldzogYW55KTogdm9pZDtcclxuICAgIC8qKiBDbGVhciBhbGwgRmlsdGVycyAmIFNvcnRzICovXHJcbiAgICBjbGVhckFsbEZpbHRlcnNBbmRTb3J0cygpOiB2b2lkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYWxsIGNvbHVtbiBzZXQgaW4gdGhlIGdyaWQsIHRoYXQgaXMgYWxsIHZpc2libGUvaGlkZGVuIGNvbHVtbnNcclxuICAgICAqIGFuZCBhbHNvIGluY2x1ZGUgYW55IGV4dHJhIGNvbHVtbnMgdXNlZCBieSBzb21lIHBsdWdpbnMgKGxpa2UgUm93IFNlbGVjdGlvbiwgUm93IERldGFpbCwgLi4uKVxyXG4gICAgICovXHJcbiAgICBnZXRBbGxDb2x1bW5EZWZpbml0aW9ucygpOiBDb2x1bW48YW55PltdO1xyXG4gICAgLyoqIEdldCBvbmx5IHZpc2libGUgY29sdW1uIGRlZmluaXRpb25zIGFuZCBhbHNvIGluY2x1ZGUgYW55IGV4dHJhIGNvbHVtbnMgYnkgc29tZSBwbHVnaW5zIChsaWtlIFJvdyBTZWxlY3Rpb24sIFJvdyBEZXRhaWwsIC4uLikgKi9cclxuICAgIGdldFZpc2libGVDb2x1bW5EZWZpbml0aW9ucygpOiBDb2x1bW5bXTtcclxuICAgIC8qKlxyXG4gICAgICogRnJvbSBhIFNsaWNrR3JpZCBFdmVudCB0cmlnZ2VyZWQgZ2V0IHRoZSBDb2x1bW4gRGVmaW5pdGlvbiBhbmQgSXRlbSBEYXRhIENvbnRleHRcclxuICAgICAqXHJcbiAgICAgKiBGb3IgZXhhbXBsZSB0aGUgU2xpY2tHcmlkIG9uQ2xpY2sgd2lsbCByZXR1cm4gY2VsbCBhcmd1bWVudHMgd2hlbiBzdWJzY3JpYmluZyB0byBpdC5cclxuICAgICAqIEZyb20gdGhlc2UgY2VsbEFyZ3MsIHdlIHdhbnQgdG8gZ2V0IHRoZSBDb2x1bW4gRGVmaW5pdGlvbiBhbmQgSXRlbSBEYXRhXHJcbiAgICAgKiBAcGFyYW0gY2VsbCBldmVudCBhcmdzXHJcbiAgICAgKiBAcmV0dXJuIG9iamVjdCB3aXRoIGNvbHVtbkRlZiBhbmQgZGF0YUNvbnRleHRcclxuICAgICAqL1xyXG4gICAgZ2V0Q29sdW1uRnJvbUV2ZW50QXJndW1lbnRzKGFyZ3M6IENlbGxBcmdzKTogT25FdmVudEFyZ3M7XHJcbiAgICAvKiogR2V0IGRhdGEgaXRlbSBieSBpdCdzIHJvdyBpbmRleCBudW1iZXIgKi9cclxuICAgIGdldERhdGFJdGVtQnlSb3dOdW1iZXI8VCA9IGFueT4ocm93TnVtYmVyOiBudW1iZXIpOiBUO1xyXG4gICAgLyoqIENoYWluIHRoZSBpdGVtIE1ldGFkYXRhIHdpdGggb3VyIGltcGxlbWVudGF0aW9uIG9mIE1ldGFkYXRhIGF0IGdpdmVuIHJvdyBpbmRleCAqL1xyXG4gICAgZ2V0SXRlbVJvd01ldGFkYXRhVG9IaWdobGlnaHQocHJldmlvdXNJdGVtTWV0YWRhdGE6IGFueSk6IChyb3dOdW1iZXI6IG51bWJlcikgPT4ge1xyXG4gICAgICAgIGNzc0NsYXNzZXM6IHN0cmluZztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAgICogQGRlcHJlY2F0ZWQgSGlkZSBhIENvbHVtbiBmcm9tIHRoZSBHcmlkICh0aGUgY29sdW1uIHdpbGwganVzdCBiZWNvbWUgaGlkZGVuIGFuZCB3aWxsIHN0aWxsIHNob3cgdXAgaW4gY29sdW1uUGlja2VyL2dyaWRNZW51KVxyXG4gICAgICAgKiBAc2VlIGhpZGVDb2x1bW5CeUlkXHJcbiAgICAgICAqIEBwYXJhbSBjb2x1bW5cclxuICAgICAgICovXHJcbiAgICBoaWRlQ29sdW1uKGNvbHVtbjogQ29sdW1uKTogdm9pZDtcclxuICAgIC8qKlxyXG4gICAgICogQGRlcHJlY2F0ZWQgSGlkZSBhIENvbHVtbiBmcm9tIHRoZSBHcmlkIGJ5IGl0cyBjb2x1bW4gZGVmaW5pdGlvbiBpbmRleCAodGhlIGNvbHVtbiB3aWxsIGp1c3QgYmVjb21lIGhpZGRlbiBhbmQgd2lsbCBzdGlsbCBzaG93IHVwIGluIGNvbHVtblBpY2tlci9ncmlkTWVudSlcclxuICAgICAqIEBzZWUgaGlkZUNvbHVtbkJ5SWQgUGxlYXNlIHVzZSBcImhpZGVDb2x1bW5CeUlkKGlkKVwiIG9yIFwiaGlkZUNvbHVtbkJ5SWRzKFtpZHNdKVwiIGluc3RlYWQgc2luY2UgaXQgaGFzIGEgbG90IG1vcmUgb3B0aW9uc1xyXG4gICAgICogQHBhcmFtIGNvbHVtbkluZGV4IC0gY29sdW1uIGRlZmluaXRpb24gaW5kZXhcclxuICAgICAqIEBwYXJhbSB0cmlnZ2VyRXZlbnQgLSBkbyB3ZSB3YW50IHRvIHRyaWdnZXIgYW4gZXZlbnQgKG9uSGVhZGVyTWVudUNvbHVtbnNDaGFuZ2VkKSB3aGVuIGNvbHVtbiBiZWNvbWVzIGhpZGRlbj8gRGVmYXVsdHMgdG8gdHJ1ZS5cclxuICAgICAqL1xyXG4gICAgaGlkZUNvbHVtbkJ5SW5kZXgoY29sdW1uSW5kZXg6IG51bWJlciwgdHJpZ2dlckV2ZW50PzogYm9vbGVhbik6IHZvaWQ7XHJcbiAgICAvKipcclxuICAgICAqIEhpZGUgYSBDb2x1bW4gZnJvbSB0aGUgR3JpZCBieSBpdHMgY29sdW1uIGRlZmluaXRpb24gaWQsIHRoZSBjb2x1bW4gd2lsbCBqdXN0IGJlY29tZSBoaWRkZW4gYW5kIHdpbGwgc3RpbGwgc2hvdyB1cCBpbiBjb2x1bW5QaWNrZXIvZ3JpZE1lbnVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSBjb2x1bW5JZCAtIGNvbHVtbiBkZWZpbml0aW9uIGlkXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHRyaWdnZXJFdmVudCAtIGRvIHdlIHdhbnQgdG8gdHJpZ2dlciBhbiBldmVudCAob25IZWFkZXJNZW51Q29sdW1uc0NoYW5nZWQpIHdoZW4gY29sdW1uIGJlY29tZXMgaGlkZGVuPyBEZWZhdWx0cyB0byB0cnVlLlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBjb2x1bW5JbmRleCAtIGNvbHVtbiBpbmRleCBwb3NpdGlvbiB3aGVuIGZvdW5kIG9yIC0xXHJcbiAgICAgKi9cclxuICAgIGhpZGVDb2x1bW5CeUlkKGNvbHVtbklkOiBzdHJpbmcgfCBudW1iZXIsIG9wdGlvbnM/OiBIaWRlQ29sdW1uT3B0aW9uKTogbnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBIaWRlIGEgQ29sdW1uIGZyb20gdGhlIEdyaWQgYnkgaXRzIGNvbHVtbiBkZWZpbml0aW9uIGlkKHMpLCB0aGUgY29sdW1uIHdpbGwganVzdCBiZWNvbWUgaGlkZGVuIGFuZCB3aWxsIHN0aWxsIHNob3cgdXAgaW4gY29sdW1uUGlja2VyL2dyaWRNZW51XHJcbiAgICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZyB8IG51bWJlcj59IGNvbHVtbklkcyAtIGNvbHVtbiBkZWZpbml0aW9uIGlkcywgY2FuIGJlIGEgc2luZ2xlIHN0cmluZyBhbmQgYW4gYXJyYXkgb2Ygc3RyaW5nc1xyXG4gICAgICogQHBhcmFtIHtib29sZWFufSB0cmlnZ2VyRXZlbnQgLSBkbyB3ZSB3YW50IHRvIHRyaWdnZXIgYW4gZXZlbnQgKG9uSGVhZGVyTWVudUNvbHVtbnNDaGFuZ2VkKSB3aGVuIGNvbHVtbiBiZWNvbWVzIGhpZGRlbj8gRGVmYXVsdHMgdG8gdHJ1ZS5cclxuICAgICAqL1xyXG4gICAgaGlkZUNvbHVtbkJ5SWRzKGNvbHVtbklkczogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPiwgb3B0aW9ucz86IEhpZGVDb2x1bW5PcHRpb24pOiB2b2lkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBIaWdobGlnaHQgdGhlbiBmYWRlIGEgcm93IGZvciB4IHNlY29uZHMuXHJcbiAgICAgKiBUaGUgaW1wbGVtZW50YXRpb24gZm9sbG93cyB0aGlzIFNPIGFuc3dlcjogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE5OTg1MTQ4LzEyMTIxNjZcclxuICAgICAqIEBwYXJhbSByb3dOdW1iZXJcclxuICAgICAqIEBwYXJhbSBmYWRlRGVsYXlcclxuICAgICAqL1xyXG4gICAgaGlnaGxpZ2h0Um93KHJvd051bWJlcjogbnVtYmVyIHwgbnVtYmVyW10sIGZhZGVEZWxheT86IG51bWJlciwgZmFkZU91dERlbGF5PzogbnVtYmVyKTogdm9pZDtcclxuICAgIGhpZ2hsaWdodFJvd0J5TWV0YWRhdGEocm93TnVtYmVyOiBudW1iZXIsIGZhZGVEZWxheT86IG51bWJlciwgZmFkZU91dERlbGF5PzogbnVtYmVyKTogdm9pZDtcclxuICAgIC8qKiBHZXQgdGhlIERhdGEgSXRlbSBmcm9tIGEgZ3JpZCByb3cgaW5kZXggKi9cclxuICAgIGdldERhdGFJdGVtQnlSb3dJbmRleDxUID0gYW55PihpbmRleDogbnVtYmVyKTogVDtcclxuICAgIC8qKiBHZXQgdGhlIERhdGEgSXRlbSBmcm9tIGFuIGFycmF5IG9mIGdyaWQgcm93IGluZGV4ZXMgKi9cclxuICAgIGdldERhdGFJdGVtQnlSb3dJbmRleGVzPFQgPSBhbnk+KGluZGV4ZXM6IG51bWJlcltdKTogVFtdO1xyXG4gICAgLyoqIEdldCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHJvdyBpbmRleGVzICovXHJcbiAgICBnZXRTZWxlY3RlZFJvd3MoKTogbnVtYmVyW107XHJcbiAgICAvKiogR2V0IHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgcm93cyBpdGVtIGRhdGEgKi9cclxuICAgIGdldFNlbGVjdGVkUm93c0RhdGFJdGVtPFQgPSBhbnk+KCk6IFRbXTtcclxuICAgIC8qKiBTZWxlY3QgdGhlIHNlbGVjdGVkIHJvdyBieSBhIHJvdyBpbmRleCAqL1xyXG4gICAgc2V0U2VsZWN0ZWRSb3cocm93SW5kZXg6IG51bWJlcik6IHZvaWQ7XHJcbiAgICAvKiogU2V0IHNlbGVjdGVkIHJvd3Mgd2l0aCBwcm92aWRlZCBhcnJheSBvZiByb3cgaW5kZXhlcyAqL1xyXG4gICAgc2V0U2VsZWN0ZWRSb3dzKHJvd0luZGV4ZXM6IG51bWJlcltdKTogdm9pZDtcclxuICAgIC8qKiBSZS1SZW5kZXIgdGhlIEdyaWQgKi9cclxuICAgIHJlbmRlckdyaWQoKTogdm9pZDtcclxuICAgIC8qKlxyXG4gICAgICogUmVzZXQgdGhlIGdyaWQgdG8gaXQncyBvcmlnaW5hbCBzdGF0ZSAoY2xlYXIgYW55IGZpbHRlcnMsIHNvcnRpbmcgJiBwYWdpbmF0aW9uIGlmIGV4aXN0cykgLlxyXG4gICAgICogVGhlIGNvbHVtbiBkZWZpbml0aW9ucyBjb3VsZCBiZSBwYXNzZWQgYXMgYXJndW1lbnQgdG8gcmVzZXQgKHRoaXMgY2FuIGJlIHVzZWQgYWZ0ZXIgYSBHcmlkIFN0YXRlIHJlc2V0KVxyXG4gICAgICogVGhlIHJlc2V0IHdpbGwgY2xlYXIgdGhlIEZpbHRlcnMgJiBTb3J0LCB0aGVuIHdpbGwgcmVzZXQgdGhlIENvbHVtbnMgdG8gdGhlaXIgb3JpZ2luYWwgc3RhdGVcclxuICAgICAqL1xyXG4gICAgcmVzZXRHcmlkKGNvbHVtbkRlZmluaXRpb25zPzogQ29sdW1uW10pOiB2b2lkO1xyXG4gICAgLyoqIEBkZXByZWNhdGVkIHBsZWFzZSB1c2UgXCJhZGRJdGVtXCIgbWV0aG9kIGluc3RlYWQgKi9cclxuICAgIGFkZEl0ZW1Ub0RhdGFncmlkKGl0ZW06IGFueSwgc2hvdWxkSGlnaGxpZ2h0Um93PzogYm9vbGVhbiwgc2hvdWxkUmVzb3J0R3JpZD86IGJvb2xlYW4sIHNob3VsZFRyaWdnZXJFdmVudD86IGJvb2xlYW4sIHNob3VsZFNlbGVjdFJvdz86IGJvb2xlYW4pOiBudW1iZXI7XHJcbiAgICAvKiogQGRlcHJlY2F0ZWQgcGxlYXNlIHVzZSBcImFkZEl0ZW1zXCIgbWV0aG9kIGluc3RlYWQgKi9cclxuICAgIGFkZEl0ZW1zVG9EYXRhZ3JpZChpdGVtczogYW55W10sIHNob3VsZEhpZ2hsaWdodFJvdz86IGJvb2xlYW4sIHNob3VsZFJlc29ydEdyaWQ/OiBib29sZWFuLCBzaG91bGRUcmlnZ2VyRXZlbnQ/OiBib29sZWFuLCBzaG91bGRTZWxlY3RSb3c/OiBib29sZWFuKTogbnVtYmVyW107XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhbiBpdGVtIChkYXRhIGl0ZW0pIHRvIHRoZSBkYXRhZ3JpZCwgYnkgZGVmYXVsdCBpdCB3aWxsIGhpZ2hsaWdodCAoZmxhc2hpbmcpIHRoZSBpbnNlcnRlZCByb3cgYnV0IHdlIGNhbiBkaXNhYmxlIGl0IHRvb1xyXG4gICAgICogQHBhcmFtIGl0ZW0gb2JqZWN0IHdoaWNoIG11c3QgY29udGFpbiBhIHVuaXF1ZSBcImlkXCIgcHJvcGVydHkgYW5kIGFueSBvdGhlciBzdWl0YWJsZSBwcm9wZXJ0aWVzXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uczogcHJvdmlkZSB0aGUgcG9zc2liaWxpdHkgdG8gZG8gY2VydGFpbiBhY3Rpb25zIGFmdGVyIG9yIGR1cmluZyB0aGUgdXBzZXJ0IChoaWdobGlnaHRSb3csIHJlc29ydEdyaWQsIHNlbGVjdFJvdywgdHJpZ2dlckV2ZW50KVxyXG4gICAgICogQHJldHVybiByb3dJbmRleDogdHlwaWNhbGx5IGluZGV4IDAgd2hlbiBhZGRpbmcgdG8gcG9zaXRpb24gXCJ0b3BcIiBvciBhIGRpZmZlcmVudCBudW1iZXIgd2hlbiBhZGRpbmcgdG8gdGhlIFwiYm90dG9tXCJcclxuICAgICAqL1xyXG4gICAgYWRkSXRlbTxUID0gYW55PihpdGVtOiBULCBvcHRpb25zPzogR3JpZFNlcnZpY2VJbnNlcnRPcHRpb24pOiBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBpdGVtIGFycmF5IChkYXRhIGl0ZW0pIHRvIHRoZSBkYXRhZ3JpZCwgYnkgZGVmYXVsdCBpdCB3aWxsIGhpZ2hsaWdodCAoZmxhc2hpbmcpIHRoZSBpbnNlcnRlZCByb3cgYnV0IHdlIGNhbiBkaXNhYmxlIGl0IHRvb1xyXG4gICAgICogQHBhcmFtIGl0ZW0gb2JqZWN0IGFycmF5cywgd2hpY2ggbXVzdCBjb250YWluIHVuaXF1ZSBcImlkXCIgcHJvcGVydHkgYW5kIGFueSBvdGhlciBzdWl0YWJsZSBwcm9wZXJ0aWVzXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uczogcHJvdmlkZSB0aGUgcG9zc2liaWxpdHkgdG8gZG8gY2VydGFpbiBhY3Rpb25zIGFmdGVyIG9yIGR1cmluZyB0aGUgdXBzZXJ0IChoaWdobGlnaHRSb3csIHJlc29ydEdyaWQsIHNlbGVjdFJvdywgdHJpZ2dlckV2ZW50KVxyXG4gICAgICovXHJcbiAgICBhZGRJdGVtczxUID0gYW55PihpdGVtczogVCB8IFRbXSwgb3B0aW9ucz86IEdyaWRTZXJ2aWNlSW5zZXJ0T3B0aW9uKTogbnVtYmVyW107XHJcbiAgICAvKiogQGRlcHJlY2F0ZWQgcGxlYXNlIHVzZSBcImRlbGV0ZUl0ZW1cIiBtZXRob2QgaW5zdGVhZCAqL1xyXG4gICAgZGVsZXRlRGF0YUdyaWRJdGVtKGl0ZW06IGFueSwgc2hvdWxkVHJpZ2dlckV2ZW50PzogYm9vbGVhbik6IHZvaWQ7XHJcbiAgICAvKiogQGRlcHJlY2F0ZWQgcGxlYXNlIHVzZSBcImRlbGV0ZUl0ZW1zXCIgbWV0aG9kIGluc3RlYWQgKi9cclxuICAgIGRlbGV0ZURhdGFHcmlkSXRlbXMoaXRlbXM6IGFueVtdLCBzaG91bGRUcmlnZ2VyRXZlbnQ/OiBib29sZWFuKTogdm9pZDtcclxuICAgIC8qKiBAZGVwcmVjYXRlZCBwbGVhc2UgdXNlIFwiZGVsZXRlSXRlbUJ5SWRcIiBtZXRob2QgaW5zdGVhZCAqL1xyXG4gICAgZGVsZXRlRGF0YUdyaWRJdGVtQnlJZChpdGVtSWQ6IHN0cmluZyB8IG51bWJlciwgc2hvdWxkVHJpZ2dlckV2ZW50PzogYm9vbGVhbik6IHZvaWQ7XHJcbiAgICAvKiogQGRlcHJlY2F0ZWQgcGxlYXNlIHVzZSBcImRlbGV0ZUl0ZW1CeUlkc1wiIG1ldGhvZCBpbnN0ZWFkICovXHJcbiAgICBkZWxldGVEYXRhR3JpZEl0ZW1CeUlkcyhpdGVtSWRzOiBudW1iZXJbXSB8IHN0cmluZ1tdLCBzaG91bGRUcmlnZ2VyRXZlbnQ/OiBib29sZWFuKTogdm9pZDtcclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlIGFuIGV4aXN0aW5nIGl0ZW0gZnJvbSB0aGUgZGF0YWdyaWQgKGRhdGFWaWV3KVxyXG4gICAgICogQHBhcmFtIGl0ZW0gb2JqZWN0IHdoaWNoIG11c3QgY29udGFpbiBhIHVuaXF1ZSBcImlkXCIgcHJvcGVydHkgYW5kIGFueSBvdGhlciBzdWl0YWJsZSBwcm9wZXJ0aWVzXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uczogcHJvdmlkZSB0aGUgcG9zc2liaWxpdHkgdG8gZG8gY2VydGFpbiBhY3Rpb25zIGFmdGVyIG9yIGR1cmluZyB0aGUgdXBzZXJ0ICh0cmlnZ2VyRXZlbnQpXHJcbiAgICAgKiBAcmV0dXJuIGl0ZW0gaWQgZGVsZXRlZFxyXG4gICAgICovXHJcbiAgICBkZWxldGVJdGVtPFQgPSBhbnk+KGl0ZW06IFQsIG9wdGlvbnM/OiBHcmlkU2VydmljZURlbGV0ZU9wdGlvbik6IG51bWJlciB8IHN0cmluZztcclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlIGFuIGFycmF5IG9mIGV4aXN0aW5nIGl0ZW1zIGZyb20gdGhlIGRhdGFncmlkXHJcbiAgICAgKiBAcGFyYW0gaXRlbSBvYmplY3Qgd2hpY2ggbXVzdCBjb250YWluIGEgdW5pcXVlIFwiaWRcIiBwcm9wZXJ0eSBhbmQgYW55IG90aGVyIHN1aXRhYmxlIHByb3BlcnRpZXNcclxuICAgICAqIEBwYXJhbSBvcHRpb25zOiBwcm92aWRlIHRoZSBwb3NzaWJpbGl0eSB0byBkbyBjZXJ0YWluIGFjdGlvbnMgYWZ0ZXIgb3IgZHVyaW5nIHRoZSB1cHNlcnQgKHRyaWdnZXJFdmVudClcclxuICAgICAqIEByZXR1cm4gaXRlbSBpZCBkZWxldGVkXHJcbiAgICAgKi9cclxuICAgIGRlbGV0ZUl0ZW1zPFQgPSBhbnk+KGl0ZW1zOiBUIHwgVFtdLCBvcHRpb25zPzogR3JpZFNlcnZpY2VEZWxldGVPcHRpb24pOiBudW1iZXJbXSB8IHN0cmluZ1tdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGUgYW4gZXhpc3RpbmcgaXRlbSBmcm9tIHRoZSBkYXRhZ3JpZCAoZGF0YVZpZXcpIGJ5IGl0J3MgaWRcclxuICAgICAqIEBwYXJhbSBpdGVtSWQ6IGl0ZW0gdW5pcXVlIGlkXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uczogcHJvdmlkZSB0aGUgcG9zc2liaWxpdHkgdG8gZG8gY2VydGFpbiBhY3Rpb25zIGFmdGVyIG9yIGR1cmluZyB0aGUgdXBzZXJ0ICh0cmlnZ2VyRXZlbnQpXHJcbiAgICAgKiBAcmV0dXJuIGl0ZW0gaWQgZGVsZXRlZFxyXG4gICAgICovXHJcbiAgICBkZWxldGVJdGVtQnlJZChpdGVtSWQ6IHN0cmluZyB8IG51bWJlciwgb3B0aW9ucz86IEdyaWRTZXJ2aWNlRGVsZXRlT3B0aW9uKTogbnVtYmVyIHwgc3RyaW5nO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGUgYW4gYXJyYXkgb2YgZXhpc3RpbmcgaXRlbXMgZnJvbSB0aGUgZGF0YWdyaWRcclxuICAgICAqIEBwYXJhbSBpdGVtSWRzIGFycmF5IG9mIGl0ZW0gdW5pcXVlIElEc1xyXG4gICAgICogQHBhcmFtIG9wdGlvbnM6IHByb3ZpZGUgdGhlIHBvc3NpYmlsaXR5IHRvIGRvIGNlcnRhaW4gYWN0aW9ucyBhZnRlciBvciBkdXJpbmcgdGhlIHVwc2VydCAodHJpZ2dlckV2ZW50KVxyXG4gICAgICovXHJcbiAgICBkZWxldGVJdGVtQnlJZHMoaXRlbUlkczogbnVtYmVyW10gfCBzdHJpbmdbXSwgb3B0aW9ucz86IEdyaWRTZXJ2aWNlRGVsZXRlT3B0aW9uKTogbnVtYmVyW10gfCBzdHJpbmdbXTtcclxuICAgIC8qKiBAZGVwcmVjYXRlZCBwbGVhc2UgdXNlIFwidXBkYXRlSXRlbVwiIG1ldGhvZCBpbnN0ZWFkICovXHJcbiAgICB1cGRhdGVEYXRhR3JpZEl0ZW0oaXRlbTogYW55LCBzaG91bGRIaWdobGlnaHRSb3c/OiBib29sZWFuLCBzaG91bGRUcmlnZ2VyRXZlbnQ/OiBib29sZWFuLCBzaG91bGRTZWxlY3RSb3c/OiBib29sZWFuKTogbnVtYmVyO1xyXG4gICAgLyoqIEBkZXByZWNhdGVkIHBsZWFzZSB1c2UgXCJ1cGRhdGVJdGVtc1wiIG1ldGhvZCBpbnN0ZWFkICovXHJcbiAgICB1cGRhdGVEYXRhR3JpZEl0ZW1zKGl0ZW1zOiBhbnkgfCBhbnlbXSwgc2hvdWxkSGlnaGxpZ2h0Um93PzogYm9vbGVhbiwgc2hvdWxkVHJpZ2dlckV2ZW50PzogYm9vbGVhbiwgc2hvdWxkU2VsZWN0Um93PzogYm9vbGVhbik6IG51bWJlcltdO1xyXG4gICAgLyoqIEBkZXByZWNhdGVkIHBsZWFzZSB1c2UgXCJ1cGRhdGVJdGVtQnlJZFwiIG1ldGhvZCBpbnN0ZWFkICovXHJcbiAgICB1cGRhdGVEYXRhR3JpZEl0ZW1CeUlkKGl0ZW1JZDogbnVtYmVyIHwgc3RyaW5nLCBpdGVtOiBhbnksIHNob3VsZEhpZ2hsaWdodFJvdz86IGJvb2xlYW4sIHNob3VsZFRyaWdnZXJFdmVudD86IGJvb2xlYW4sIHNob3VsZFNlbGVjdFJvdz86IGJvb2xlYW4pOiBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSBhbiBleGlzdGluZyBpdGVtIHdpdGggbmV3IHByb3BlcnRpZXMgaW5zaWRlIHRoZSBkYXRhZ3JpZFxyXG4gICAgICogQHBhcmFtIGl0ZW0gb2JqZWN0IHdoaWNoIG11c3QgY29udGFpbiBhIHVuaXF1ZSBcImlkXCIgcHJvcGVydHkgYW5kIGFueSBvdGhlciBzdWl0YWJsZSBwcm9wZXJ0aWVzXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uczogcHJvdmlkZSB0aGUgcG9zc2liaWxpdHkgdG8gZG8gY2VydGFpbiBhY3Rpb25zIGFmdGVyIG9yIGR1cmluZyB0aGUgdXBzZXJ0IChoaWdobGlnaHRSb3csIHNlbGVjdFJvdywgdHJpZ2dlckV2ZW50KVxyXG4gICAgICogQHJldHVybiBncmlkIHJvdyBpbmRleFxyXG4gICAgICovXHJcbiAgICB1cGRhdGVJdGVtPFQgPSBhbnk+KGl0ZW06IFQsIG9wdGlvbnM/OiBHcmlkU2VydmljZVVwZGF0ZU9wdGlvbik6IG51bWJlcjtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIGFuIGFycmF5IG9mIGV4aXN0aW5nIGl0ZW1zIHdpdGggbmV3IHByb3BlcnRpZXMgaW5zaWRlIHRoZSBkYXRhZ3JpZFxyXG4gICAgICogQHBhcmFtIGl0ZW0gb2JqZWN0IGFycmF5cywgd2hpY2ggbXVzdCBjb250YWluIHVuaXF1ZSBcImlkXCIgcHJvcGVydHkgYW5kIGFueSBvdGhlciBzdWl0YWJsZSBwcm9wZXJ0aWVzXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uczogcHJvdmlkZSB0aGUgcG9zc2liaWxpdHkgdG8gZG8gY2VydGFpbiBhY3Rpb25zIGFmdGVyIG9yIGR1cmluZyB0aGUgdXBzZXJ0IChoaWdobGlnaHRSb3csIHNlbGVjdFJvdywgdHJpZ2dlckV2ZW50KVxyXG4gICAgICogQHJldHVybiBncmlkIHJvdyBpbmRleGVzXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZUl0ZW1zPFQgPSBhbnk+KGl0ZW1zOiBUIHwgVFtdLCBvcHRpb25zPzogR3JpZFNlcnZpY2VVcGRhdGVPcHRpb24pOiBudW1iZXJbXTtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIGFuIGV4aXN0aW5nIGl0ZW0gaW4gdGhlIGRhdGFncmlkIGJ5IGl0J3MgaWQgYW5kIG5ldyBwcm9wZXJ0aWVzXHJcbiAgICAgKiBAcGFyYW0gaXRlbUlkOiBpdGVtIHVuaXF1ZSBpZFxyXG4gICAgICogQHBhcmFtIGl0ZW0gb2JqZWN0IHdoaWNoIG11c3QgY29udGFpbiBhIHVuaXF1ZSBcImlkXCIgcHJvcGVydHkgYW5kIGFueSBvdGhlciBzdWl0YWJsZSBwcm9wZXJ0aWVzXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uczogcHJvdmlkZSB0aGUgcG9zc2liaWxpdHkgdG8gZG8gY2VydGFpbiBhY3Rpb25zIGFmdGVyIG9yIGR1cmluZyB0aGUgdXBzZXJ0IChoaWdobGlnaHRSb3csIHNlbGVjdFJvdywgdHJpZ2dlckV2ZW50KVxyXG4gICAgICogQHJldHVybiBncmlkIHJvdyBudW1iZXJcclxuICAgICAqL1xyXG4gICAgdXBkYXRlSXRlbUJ5SWQ8VCA9IGFueT4oaXRlbUlkOiBudW1iZXIgfCBzdHJpbmcsIGl0ZW06IFQsIG9wdGlvbnM/OiBHcmlkU2VydmljZVVwZGF0ZU9wdGlvbik6IG51bWJlcjtcclxuICAgIC8qKlxyXG4gICAgICogSW5zZXJ0IGEgcm93IGludG8gdGhlIGdyaWQgaWYgaXQgZG9lc24ndCBhbHJlYWR5IGV4aXN0IG9yIHVwZGF0ZSBpZiBpdCBkb2VzLlxyXG4gICAgICogQHBhcmFtIGl0ZW0gb2JqZWN0IHdoaWNoIG11c3QgY29udGFpbiBhIHVuaXF1ZSBcImlkXCIgcHJvcGVydHkgYW5kIGFueSBvdGhlciBzdWl0YWJsZSBwcm9wZXJ0aWVzXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uczogcHJvdmlkZSB0aGUgcG9zc2liaWxpdHkgdG8gZG8gY2VydGFpbiBhY3Rpb25zIGFmdGVyIG9yIGR1cmluZyB0aGUgdXBzZXJ0IChoaWdobGlnaHRSb3csIHJlc29ydEdyaWQsIHNlbGVjdFJvdywgdHJpZ2dlckV2ZW50KVxyXG4gICAgICovXHJcbiAgICB1cHNlcnRJdGVtPFQgPSBhbnk+KGl0ZW06IFQsIG9wdGlvbnM/OiBHcmlkU2VydmljZUluc2VydE9wdGlvbik6IHtcclxuICAgICAgICBhZGRlZDogbnVtYmVyO1xyXG4gICAgICAgIHVwZGF0ZWQ6IG51bWJlcjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSBhbiBhcnJheSBvZiBleGlzdGluZyBpdGVtcyB3aXRoIG5ldyBwcm9wZXJ0aWVzIGluc2lkZSB0aGUgZGF0YWdyaWRcclxuICAgICAqIEBwYXJhbSBpdGVtIG9iamVjdCBhcnJheXMsIHdoaWNoIG11c3QgY29udGFpbiB1bmlxdWUgXCJpZFwiIHByb3BlcnR5IGFuZCBhbnkgb3RoZXIgc3VpdGFibGUgcHJvcGVydGllc1xyXG4gICAgICogQHBhcmFtIG9wdGlvbnM6IHByb3ZpZGUgdGhlIHBvc3NpYmlsaXR5IHRvIGRvIGNlcnRhaW4gYWN0aW9ucyBhZnRlciBvciBkdXJpbmcgdGhlIHVwc2VydCAoaGlnaGxpZ2h0Um93LCByZXNvcnRHcmlkLCBzZWxlY3RSb3csIHRyaWdnZXJFdmVudClcclxuICAgICAqIEByZXR1cm4gcm93IG51bWJlcnMgaW4gdGhlIGdyaWRcclxuICAgICAqL1xyXG4gICAgdXBzZXJ0SXRlbXM8VCA9IGFueT4oaXRlbXM6IFQgfCBUW10sIG9wdGlvbnM/OiBHcmlkU2VydmljZUluc2VydE9wdGlvbik6IHtcclxuICAgICAgICBhZGRlZDogbnVtYmVyO1xyXG4gICAgICAgIHVwZGF0ZWQ6IG51bWJlcjtcclxuICAgIH1bXTtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIGFuIGV4aXN0aW5nIGl0ZW0gaW4gdGhlIGRhdGFncmlkIGJ5IGl0J3MgaWQgYW5kIG5ldyBwcm9wZXJ0aWVzXHJcbiAgICAgKiBAcGFyYW0gaXRlbUlkOiBpdGVtIHVuaXF1ZSBpZFxyXG4gICAgICogQHBhcmFtIGl0ZW0gb2JqZWN0IHdoaWNoIG11c3QgY29udGFpbiBhIHVuaXF1ZSBcImlkXCIgcHJvcGVydHkgYW5kIGFueSBvdGhlciBzdWl0YWJsZSBwcm9wZXJ0aWVzXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uczogcHJvdmlkZSB0aGUgcG9zc2liaWxpdHkgdG8gZG8gY2VydGFpbiBhY3Rpb25zIGFmdGVyIG9yIGR1cmluZyB0aGUgdXBzZXJ0IChoaWdobGlnaHRSb3csIHJlc29ydEdyaWQsIHNlbGVjdFJvdywgdHJpZ2dlckV2ZW50KVxyXG4gICAgICogQHJldHVybiBncmlkIHJvdyBudW1iZXIgaW4gdGhlIGdyaWRcclxuICAgICAqL1xyXG4gICAgdXBzZXJ0SXRlbUJ5SWQ8VCA9IGFueT4oaXRlbUlkOiBudW1iZXIgfCBzdHJpbmcsIGl0ZW06IFQsIG9wdGlvbnM/OiBHcmlkU2VydmljZUluc2VydE9wdGlvbik6IHtcclxuICAgICAgICBhZGRlZDogbnVtYmVyO1xyXG4gICAgICAgIHVwZGF0ZWQ6IG51bWJlcjtcclxuICAgIH07XHJcbn1cclxuIl19