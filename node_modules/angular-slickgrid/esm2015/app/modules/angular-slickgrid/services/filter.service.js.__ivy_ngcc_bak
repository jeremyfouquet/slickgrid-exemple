import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import { isObservable, Subject } from 'rxjs';
import * as isequal_ from 'lodash.isequal';
const isequal = isequal_; // patch to fix rollup to work
import { EmitterType, FieldType, KeyCode, OperatorType, } from './../models/index';
import { executeBackendCallback, refreshBackendDataset } from './backend-utilities';
import { getDescendantProperty } from './utilities';
import { FilterConditions } from './../filter-conditions';
import { FilterFactory } from '../filters/filterFactory';
import { SharedService } from './shared.service';
// timer for keeping track of user typing waits
let timer;
const DEFAULT_FILTER_TYPING_DEBOUNCE = 500;
let FilterService = class FilterService {
    constructor(filterFactory, sharedService) {
        this.filterFactory = filterFactory;
        this.sharedService = sharedService;
        this._isFilterFirstRender = true;
        this._firstColumnIdRendered = '';
        this._filtersMetadata = [];
        this._columnFilters = {};
        this.httpCancelRequests$ = new Subject(); // this will be used to cancel any pending http request
        this.onFilterChanged = new Subject();
        this.onFilterCleared = new Subject();
        this._eventHandler = new Slick.EventHandler();
        this._onSearchChange = new Slick.Event();
    }
    /** Getter of the SlickGrid Event Handler */
    get eventHandler() {
        return this._eventHandler;
    }
    /** Getter to know if the filter was already rendered or if it was its first time render */
    get isFilterFirstRender() {
        return this._isFilterFirstRender;
    }
    /** Getter of the SlickGrid Event Handler */
    get onSearchChange() {
        return this._onSearchChange;
    }
    /** Getter for the Grid Options pulled through the Grid Object */
    get _gridOptions() {
        return (this._grid && this._grid.getOptions) ? this._grid.getOptions() : {};
    }
    /** Getter for the Column Definitions pulled through the Grid Object */
    get _columnDefinitions() {
        return (this._grid && this._grid.getColumns) ? this._grid.getColumns() : [];
    }
    /** Getter of SlickGrid DataView object */
    get _dataView() {
        return (this._grid && this._grid.getData) ? this._grid.getData() : {};
    }
    init(grid) {
        this._grid = grid;
        if (this._gridOptions && this._gridOptions.enableTreeData && this._gridOptions.treeDataOptions) {
            this._grid.setSortColumns([{ columnId: this._gridOptions.treeDataOptions.columnId, sortAsc: true }]);
        }
    }
    dispose() {
        // unsubscribe all SlickGrid events
        if (this._eventHandler && this._eventHandler.unsubscribeAll) {
            this._eventHandler.unsubscribeAll();
        }
        if (isObservable(this.httpCancelRequests$)) {
            this.httpCancelRequests$.next(); // this cancels any pending http requests
        }
        this.disposeColumnFilters();
        this._onSearchChange = null;
        this.addFilterTemplateToHeaderRow = null;
        this.customLocalFilter = null;
        this.callbackSearchEvent = null;
        this.handleBackendOnSearchChange = null;
        this.handleLocalOnSearchChange = null;
    }
    /**
     * Dispose of the filters, since it's a singleton, we don't want to affect other grids with same columns
     */
    disposeColumnFilters() {
        // we need to loop through all columnFilters and delete them 1 by 1
        // only trying to make columnFilter an empty (without looping) would not trigger a dataset change
        if (typeof this._columnFilters === 'object') {
            for (const columnId in this._columnFilters) {
                if (columnId && this._columnFilters[columnId]) {
                    delete this._columnFilters[columnId];
                }
            }
        }
        // also destroy each Filter instances
        if (Array.isArray(this._filtersMetadata)) {
            this._filtersMetadata.forEach((filter) => {
                if (filter && filter.destroy) {
                    filter.destroy(true);
                }
            });
        }
        this._filtersMetadata = [];
    }
    /**
     * When clearing or disposing of all filters, we need to loop through all columnFilters and delete them 1 by 1
     * only trying to make columnFilter an empty (without looping) would not trigger a dataset change
     */
    resetColumnFilters() {
        if (typeof this._columnFilters === 'object') {
            for (const columnId in this._columnFilters) {
                if (columnId && this._columnFilters[columnId]) {
                    delete this._columnFilters[columnId];
                }
            }
        }
    }
    /**
     * Bind a backend filter hook to the grid
     * @param grid SlickGrid Grid object
     */
    bindBackendOnFilter(grid) {
        this._filtersMetadata = [];
        // subscribe to SlickGrid onHeaderRowCellRendered event to create filter template
        this._eventHandler.subscribe(grid.onHeaderRowCellRendered, this.handleBackendOnSearchChange.bind(this));
        // subscribe to the SlickGrid event and call the backend execution
        if (this._onSearchChange) {
            this._eventHandler.subscribe(this._onSearchChange, this.onBackendFilterChange.bind(this));
        }
    }
    handleBackendOnSearchChange(_e, args) {
        // firstColumnIdRendered is null at first, so if it changes to being filled and equal, then we would know that it was already rendered
        // this is to avoid rendering the filter twice (only the Select Filter for now), rendering it again also clears the filter which has unwanted side effect
        if (args.column.id === this._firstColumnIdRendered) {
            this._isFilterFirstRender = false;
        }
        this.addFilterTemplateToHeaderRow(null, args, this._isFilterFirstRender);
        if (this._firstColumnIdRendered === '') {
            this._firstColumnIdRendered = args.column.id;
        }
    }
    /**
     * Bind a local filter hook to the grid
     * @param grid SlickGrid Grid object
     * @param dataView
     */
    bindLocalOnFilter(grid) {
        this._filtersMetadata = [];
        this._dataView.setFilterArgs({ columnFilters: this._columnFilters, grid: this._grid, dataView: this._dataView });
        this._dataView.setFilter(this.customLocalFilter.bind(this));
        // bind any search filter change (e.g. input filter input change event)
        if (this._onSearchChange) {
            this._eventHandler.subscribe(this._onSearchChange, this.handleLocalOnSearchChange.bind(this));
            // subscribe to SlickGrid onHeaderRowCellRendered event to create filter template
            this._eventHandler.subscribe(grid.onHeaderRowCellRendered, this.addFilterTemplateToHeaderRow.bind(this));
        }
    }
    handleLocalOnSearchChange(_e, args) {
        const isGridWithTreeData = this._gridOptions && this._gridOptions.enableTreeData || false;
        // When using Tree Data, we need to do it in 2 steps
        // step 1. we need to prefilter (search) the data prior, the result will be an array of IDs which are the node(s) and their parent nodes when necessary.
        // step 2. calling the DataView.refresh() is what triggers the final filtering, with "customLocalFilter()" which will decide which rows should persist
        if (isGridWithTreeData) {
            this._tmpPreFilteredData = this.preFilterTreeData(this._dataView.getItems(), this._columnFilters);
        }
        const columnId = args.columnId;
        if (columnId !== null) {
            this._dataView.refresh();
        }
        // emit an onFilterChanged event when it's not called by a clear filter
        if (args && !args.clearFilterTriggered) {
            this.emitFilterChanged(EmitterType.local);
        }
    }
    clearFilterByColumnId(event, columnId) {
        // get current column filter before clearing, this allow us to know if the filter was empty prior to calling the clear filter
        const currentColumnFilters = Object.keys(this._columnFilters);
        let currentColFilter;
        if (Array.isArray(currentColumnFilters)) {
            currentColFilter = currentColumnFilters.find((name) => name === columnId);
        }
        // find the filter object and call its clear method with true (the argument tells the method it was called by a clear filter)
        const colFilter = this._filtersMetadata.find((filter) => filter.columnDef.id === columnId);
        if (colFilter && colFilter.clear) {
            colFilter.clear(true);
        }
        let emitter = EmitterType.local;
        const isBackendApi = this._gridOptions && this._gridOptions.backendServiceApi || false;
        // when using a backend service, we need to manually trigger a filter change but only if the filter was previously filled
        if (isBackendApi) {
            emitter = EmitterType.remote;
            if (currentColFilter) {
                this.onBackendFilterChange(event, { grid: this._grid, columnFilters: this._columnFilters });
            }
        }
        // emit an event when filter is cleared
        this.emitFilterChanged(emitter);
    }
    /** Clear the search filters (below the column titles) */
    clearFilters(triggerChange = true) {
        this._filtersMetadata.forEach((filter) => {
            if (filter && filter.clear) {
                // clear element but don't trigger individual clear change,
                // we'll do 1 trigger for all filters at once afterward
                filter.clear(false);
            }
        });
        // also reset the columnFilters object and remove any filters from the object
        this.resetColumnFilters();
        // we also need to refresh the dataView and optionally the grid (it's optional since we use DataView)
        if (this._dataView && this._grid) {
            this._dataView.refresh();
            this._grid.invalidate();
        }
        // when using backend service, we need to query only once so it's better to do it here
        const backendApi = this._gridOptions && this._gridOptions.backendServiceApi;
        if (backendApi && triggerChange) {
            const callbackArgs = { clearFilterTriggered: true, shouldTriggerQuery: triggerChange, grid: this._grid, columnFilters: this._columnFilters };
            const queryResponse = backendApi.service.processOnFilterChanged(undefined, callbackArgs);
            if (queryResponse instanceof Promise && queryResponse.then) {
                // @deprecated, processOnFilterChanged in the future should be returned as a query string NOT as a Promise
                console.warn(`[Angular-Slickgrid] please note that the "processOnFilterChanged" from your Backend Service, should now return a string instead of a Promise.
          Returning a Promise will be deprecated in the future.`);
                queryResponse.then((query) => {
                    const totalItems = this._gridOptions && this._gridOptions.pagination && this._gridOptions.pagination.totalItems;
                    executeBackendCallback(backendApi, query, callbackArgs, new Date(), totalItems, this.emitFilterChanged.bind(this));
                });
            }
            else {
                const query = queryResponse;
                const totalItems = this._gridOptions && this._gridOptions.pagination && this._gridOptions.pagination.totalItems;
                executeBackendCallback(backendApi, query, callbackArgs, new Date(), totalItems, this.emitFilterChanged.bind(this));
            }
        }
        // emit an event when filters are all cleared
        if (triggerChange) {
            this.onFilterCleared.next(true);
        }
    }
    /** Local Grid Filter search */
    customLocalFilter(item, args) {
        const dataView = args && args.dataView;
        const grid = args && args.grid;
        const isGridWithTreeData = this._gridOptions && this._gridOptions.enableTreeData || false;
        const columnFilters = args && args.columnFilters || {};
        let treeDataOptions;
        // when the column is a Tree Data structure and the parent is collapsed, we won't go further and just continue with next row
        // so we always run this check even when there are no filter search, the reason is because the user might click on the expand/collapse
        if (isGridWithTreeData && this._gridOptions && this._gridOptions.treeDataOptions) {
            treeDataOptions = this._gridOptions.treeDataOptions;
            const collapsedPropName = treeDataOptions.collapsedPropName || '__collapsed';
            const parentPropName = treeDataOptions.parentPropName || '__parentId';
            const dataViewIdIdentifier = this._gridOptions.datasetIdPropertyName || 'id';
            if (item[parentPropName] !== null) {
                let parent = this._dataView.getItemById(item[parentPropName]);
                while (parent) {
                    if (parent[collapsedPropName]) {
                        return false; // don't display any row that have their parent collapsed
                    }
                    parent = this._dataView.getItemById(parent[parentPropName]);
                }
            }
            // filter out any row items that aren't part of our pre-processed "preFilterTreeData()" result
            if (Array.isArray(this._tmpPreFilteredData)) {
                return this._tmpPreFilteredData.includes(item[dataViewIdIdentifier]); // return true when found, false otherwise
            }
        }
        else {
            if (typeof columnFilters === 'object') {
                for (const columnId of Object.keys(columnFilters)) {
                    const columnFilter = columnFilters[columnId];
                    const conditionOptions = this.getFilterConditionOptionsOrBoolean(item, columnFilter, columnId, grid, dataView);
                    if (typeof conditionOptions === 'boolean') {
                        return conditionOptions;
                    }
                    if (!FilterConditions.executeMappedCondition(conditionOptions)) {
                        return false;
                    }
                }
            }
        }
        // if it reaches here, that means the row is valid and passed all filter
        return true;
    }
    getFilterConditionOptionsOrBoolean(item, columnFilter, columnId, grid, dataView) {
        let columnIndex = grid.getColumnIndex(columnId);
        let columnDef = grid.getColumns()[columnIndex];
        // it might be a hidden column, if so it won't be part of the getColumns (because it we hide a column via setColumns)
        // when that happens we can try to get the column definition from all defined columns
        if (!columnDef && this.sharedService && Array.isArray(this.sharedService.allColumns)) {
            columnIndex = this.sharedService.allColumns.findIndex((col) => col.field === columnId);
            columnDef = this.sharedService.allColumns[columnIndex];
        }
        // if we still don't have a column definition then we should return then row anyway (true)
        if (!columnDef) {
            return true;
        }
        // Row Detail View plugin, if the row is padding we just get the value we're filtering on from it's parent
        if (this._gridOptions.enableRowDetailView) {
            const metadataPrefix = this._gridOptions.rowDetailView && this._gridOptions.rowDetailView.keyPrefix || '__';
            if (item[`${metadataPrefix}isPadding`] && item[`${metadataPrefix}parent`]) {
                item = item[`${metadataPrefix}parent`];
            }
        }
        const dataKey = columnDef.dataKey;
        let queryFieldName = (columnDef.filter && columnDef.filter.queryField) || columnDef.queryFieldFilter || columnDef.queryField || columnDef.field || '';
        if (typeof columnDef.queryFieldNameGetterFn === 'function') {
            queryFieldName = columnDef.queryFieldNameGetterFn(item);
        }
        const fieldType = (columnDef.filter && columnDef.filter.type) || columnDef.type || FieldType.string;
        const filterSearchType = (columnDef.filterSearchType) ? columnDef.filterSearchType : null;
        let cellValue = item[queryFieldName];
        // when item is a complex object (dot "." notation), we need to filter the value contained in the object tree
        if (queryFieldName && queryFieldName.indexOf('.') >= 0) {
            cellValue = getDescendantProperty(item, queryFieldName);
        }
        // if we find searchTerms use them but make a deep copy so that we don't affect original array
        // we might have to overwrite the value(s) locally that are returned
        // e.g: we don't want to operator within the search value, since it will fail filter condition check trigger afterward
        const searchValues = (columnFilter && columnFilter.searchTerms) ? $.extend(true, [], columnFilter.searchTerms) : [];
        let fieldSearchValue = (Array.isArray(searchValues) && searchValues.length === 1) ? searchValues[0] : '';
        let matches = null;
        if (fieldType !== FieldType.object) {
            fieldSearchValue = '' + fieldSearchValue; // make sure it's a string
            matches = fieldSearchValue.match(/^([<>!=\*]{0,2})(.*[^<>!=\*])([\*]?)$/); // group 1: Operator, 2: searchValue, 3: last char is '*' (meaning starts with, ex.: abc*)
        }
        let operator = columnFilter.operator || ((matches) ? matches[1] : '');
        const searchTerm = (!!matches) ? matches[2] : '';
        const lastValueChar = (!!matches) ? matches[3] : (operator === '*z' ? '*' : '');
        if (searchValues && searchValues.length > 1) {
            fieldSearchValue = searchValues.join(',');
        }
        else if (typeof fieldSearchValue === 'string') {
            // escaping the search value
            fieldSearchValue = fieldSearchValue.replace(`'`, `''`); // escape single quotes by doubling them
            if (operator === '*' || operator === 'a*' || operator === '*z' || lastValueChar === '*') {
                operator = (operator === '*' || operator === '*z') ? OperatorType.endsWith : OperatorType.startsWith;
            }
        }
        // no need to query if search value is empty or if the search value is in fact equal to the operator
        if (searchTerm === '' && (!searchValues || (Array.isArray(searchValues) && (searchValues.length === 0 || searchValues.length === 1 && operator === searchValues[0])))) {
            return true;
        }
        // if search value has a regex match we will only keep the value without the operator
        // in this case we need to overwrite the returned search values to truncate operator from the string search
        if (Array.isArray(matches) && matches.length >= 1 && (Array.isArray(searchValues) && searchValues.length === 1)) {
            searchValues[0] = searchTerm;
        }
        // filter search terms should always be string type (even though we permit the end user to input numbers)
        // so make sure each term are strings, if user has some default search terms, we will cast them to string
        if (searchValues && Array.isArray(searchValues) && fieldType !== FieldType.object) {
            for (let k = 0, ln = searchValues.length; k < ln; k++) {
                // make sure all search terms are strings
                searchValues[k] = ((searchValues[k] === undefined || searchValues[k] === null) ? '' : searchValues[k]) + '';
            }
        }
        // when using localization (i18n), we should use the formatter output to search as the new cell value
        if (columnDef && columnDef.params && columnDef.params.useFormatterOuputToFilter) {
            const idPropName = this._gridOptions.datasetIdPropertyName || 'id';
            const rowIndex = (dataView && typeof dataView.getIdxById === 'function') ? dataView.getIdxById(item[idPropName]) : 0;
            cellValue = (columnDef && typeof columnDef.formatter === 'function') ? columnDef.formatter(rowIndex, columnIndex, cellValue, columnDef, item, this._grid) : '';
        }
        // make sure cell value is always a string
        if (typeof cellValue === 'number') {
            cellValue = cellValue.toString();
        }
        const currentCellValue = cellValue;
        return {
            dataKey,
            fieldType,
            searchTerms: searchValues,
            cellValue: currentCellValue,
            operator: operator,
            cellValueLastChar: lastValueChar,
            filterSearchType
        };
    }
    /**
     * When using Tree Data, we need to prefilter (search) the data prior, the result will be an array of IDs which are the node(s) and their parent nodes when necessary.
     * This will then be passed to the DataView setFilter(customLocalFilter), which will itself loop through the list of IDs and display/hide the row if found that array of IDs
     * We do this in 2 steps so that we can still use the DataSet setFilter()
     */
    preFilterTreeData(inputArray, columnFilters) {
        const treeDataOptions = this._gridOptions && this._gridOptions.treeDataOptions;
        const parentPropName = treeDataOptions && treeDataOptions.parentPropName || '__parentId';
        const dataViewIdIdentifier = this._gridOptions && this._gridOptions.datasetIdPropertyName || 'id';
        const treeObj = {};
        const filteredChildrenAndParents = [];
        if (Array.isArray(inputArray)) {
            for (let i = 0; i < inputArray.length; i++) {
                treeObj[inputArray[i][dataViewIdIdentifier]] = inputArray[i];
                // as the filtered data is then used again as each subsequent letter
                // we need to delete the .__used property, otherwise the logic below
                // in the while loop (which checks for parents) doesn't work:
                delete treeObj[inputArray[i][dataViewIdIdentifier]].__used;
            }
            for (let i = 0; i < inputArray.length; i++) {
                const item = inputArray[i];
                let matchFilter = true; // valid until proven otherwise
                // loop through all column filters and execute filter condition(s)
                for (const columnId of Object.keys(columnFilters)) {
                    const columnFilter = columnFilters[columnId];
                    const conditionOptionResult = this.getFilterConditionOptionsOrBoolean(item, columnFilter, columnId, this._grid, this._dataView);
                    if (conditionOptionResult) {
                        const conditionResult = (typeof conditionOptionResult === 'boolean') ? conditionOptionResult : FilterConditions.executeMappedCondition(conditionOptionResult);
                        if (conditionResult) {
                            // don't return true since we still need to check other keys in columnFilters
                            continue;
                        }
                    }
                    matchFilter = false;
                    continue;
                }
                // build an array from the matched filters, anything valid from filter condition
                // will be pushed to the filteredChildrenAndParents array
                if (matchFilter) {
                    const len = filteredChildrenAndParents.length;
                    // add child (id):
                    filteredChildrenAndParents.splice(len, 0, item[dataViewIdIdentifier]);
                    let parent = treeObj[item[parentPropName]] || false;
                    while (parent) {
                        // only add parent (id) if not already added:
                        parent.__used || filteredChildrenAndParents.splice(len, 0, parent[dataViewIdIdentifier]);
                        // mark each parent as used to not use them again later:
                        treeObj[parent[dataViewIdIdentifier]].__used = true;
                        // try to find parent of the current parent, if exists:
                        parent = treeObj[parent[parentPropName]] || false;
                    }
                }
            }
        }
        return filteredChildrenAndParents;
    }
    getColumnFilters() {
        return this._columnFilters;
    }
    getFiltersMetadata() {
        return this._filtersMetadata;
    }
    getCurrentLocalFilters() {
        const currentFilters = [];
        if (this._columnFilters) {
            for (const colId of Object.keys(this._columnFilters)) {
                const columnFilter = this._columnFilters[colId];
                const filter = { columnId: colId || '' };
                if (columnFilter && columnFilter.searchTerms) {
                    filter.searchTerms = columnFilter.searchTerms;
                }
                if (columnFilter.operator) {
                    filter.operator = columnFilter.operator;
                }
                if (Array.isArray(filter.searchTerms) && filter.searchTerms.length > 0 && filter.searchTerms[0] !== '') {
                    currentFilters.push(filter);
                }
            }
        }
        return currentFilters;
    }
    /**
     * A simple function that is binded to the subscriber and emit a change when the filter is called.
     * Other services, like Pagination, can then subscribe to it.
     * @param caller
     */
    emitFilterChanged(caller) {
        if (caller === EmitterType.remote && this._gridOptions && this._gridOptions.backendServiceApi) {
            let currentFilters = [];
            const backendService = this._gridOptions.backendServiceApi.service;
            if (backendService && backendService.getCurrentFilters) {
                currentFilters = backendService.getCurrentFilters();
            }
            this.onFilterChanged.next(currentFilters);
        }
        else if (caller === EmitterType.local) {
            this.onFilterChanged.next(this.getCurrentLocalFilters());
        }
    }
    onBackendFilterChange(event, args) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!args || !args.grid) {
                throw new Error('Something went wrong when trying to bind the "onBackendFilterChange(event, args)" function, it seems that "args" is not populated correctly');
            }
            // const gridOptions: GridOption = (args.grid && args.grid.getOptions) ? args.grid.getOptions() : {};
            const backendApi = this._gridOptions.backendServiceApi;
            if (!backendApi || !backendApi.process || !backendApi.service) {
                throw new Error(`BackendServiceApi requires at least a "process" function and a "service" defined`);
            }
            // keep start time & end timestamps & return it after process execution
            const startTime = new Date();
            // run a preProcess callback if defined
            if (backendApi.preProcess) {
                backendApi.preProcess();
            }
            // only add a delay when user is typing, on select dropdown filter (or "Clear Filter") it will execute right away
            let debounceTypingDelay = 0;
            const isTriggeredByClearFilter = args && args.clearFilterTriggered; // was it trigger by a "Clear Filter" command?
            const eventType = event && event.type;
            const eventKeyCode = event && event.keyCode;
            if (!isTriggeredByClearFilter && eventKeyCode !== KeyCode.ENTER && (eventType === 'input' || eventType === 'keyup' || eventType === 'keydown')) {
                debounceTypingDelay = backendApi.hasOwnProperty('filterTypingDebounce') ? backendApi.filterTypingDebounce : DEFAULT_FILTER_TYPING_DEBOUNCE;
            }
            // query backend, except when it's called by a ClearFilters then we won't
            if (args && args.shouldTriggerQuery) {
                // call the service to get a query back
                // @deprecated TODO: remove async/await on next major change, refer to processOnFilterChanged in BackendService interface (with @deprecated)
                clearTimeout(timer);
                if (debounceTypingDelay > 0) {
                    timer = setTimeout(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
                        const query = yield backendApi.service.processOnFilterChanged(event, args);
                        const totalItems = this._gridOptions && this._gridOptions.pagination && this._gridOptions.pagination.totalItems;
                        executeBackendCallback(backendApi, query, args, startTime, totalItems, this.emitFilterChanged.bind(this), this.httpCancelRequests$);
                    }), debounceTypingDelay);
                }
                else {
                    const query = yield backendApi.service.processOnFilterChanged(event, args);
                    const totalItems = this._gridOptions && this._gridOptions.pagination && this._gridOptions.pagination.totalItems;
                    executeBackendCallback(backendApi, query, args, startTime, totalItems, this.emitFilterChanged.bind(this), this.httpCancelRequests$);
                }
            }
        });
    }
    /**
     * When user passes an array of preset filters, we need to pre-populate each column filter searchTerm(s)
     * The process is to loop through the preset filters array, find the associated column from columnDefinitions and fill in the filter object searchTerm(s)
     * This is basically the same as if we would manually add searchTerm(s) to a column filter object in the column definition, but we do it programmatically.
     * At the end of the day, when creating the Filter (DOM Element), it will use these searchTerm(s) so we can take advantage of that without recoding each Filter type (DOM element)
     */
    populateColumnFilterSearchTermPresets(filters) {
        if (Array.isArray(filters) && filters.length > 0) {
            this._columnDefinitions.forEach((columnDef) => {
                // clear any columnDef searchTerms before applying Presets
                if (columnDef.filter && columnDef.filter.searchTerms) {
                    delete columnDef.filter.searchTerms;
                }
                // from each presets, we will find the associated columnDef and apply the preset searchTerms & operator if there is
                const columnPreset = filters.find((presetFilter) => presetFilter.columnId === columnDef.id);
                if (columnPreset && columnPreset.searchTerms && Array.isArray(columnPreset.searchTerms)) {
                    columnDef.filter = columnDef.filter || {};
                    columnDef.filter.operator = columnPreset.operator || columnDef.filter.operator || '';
                    columnDef.filter.searchTerms = columnPreset.searchTerms;
                }
            });
            // when we have a Filter Presets on a Tree Data View grid, we need to call the pre-filtering of tree data
            this.refreshTreeDataFilters();
        }
        return this._columnDefinitions;
    }
    /**
     * when we have a Filter Presets on a Tree Data View grid, we need to call the pre-filtering of tree data
     * we need to do this because Tree Data is the only type of grid that requires a pre-filter (preFilterTreeData) to be executed before the final filtering
     * @param filters
     */
    refreshTreeDataFilters() {
        if (this._dataView && this._dataView.getItems && this._gridOptions && this._gridOptions.enableTreeData) {
            this._tmpPreFilteredData = this.preFilterTreeData(this._dataView.getItems(), this._columnFilters);
            this._dataView.refresh(); // and finally this refresh() is what triggers a DataView filtering check
        }
    }
    /**
     * Toggle the Filter Functionality
     * @param {boolean} isFilterDisabled - optionally force a disable/enable of the Sort Functionality? Defaults to True
     * @param {boolean} clearFiltersWhenDisabled - when disabling the Filter, do we also want to clear all the filters as well? Defaults to True
     */
    disableFilterFunctionality(isFilterDisabled = true, clearFiltersWhenDisabled = true) {
        const prevShowFilterFlag = this._gridOptions.enableFiltering;
        const newShowFilterFlag = !prevShowFilterFlag;
        if (newShowFilterFlag !== isFilterDisabled) {
            if (clearFiltersWhenDisabled && isFilterDisabled) {
                this.clearFilters();
            }
            this.disableAllFilteringCommands(isFilterDisabled);
            this._grid.setOptions({ enableFiltering: newShowFilterFlag }, false, true);
            this._grid.setHeaderRowVisibility(newShowFilterFlag);
            this._gridOptions.enableFiltering = !isFilterDisabled;
            this.sharedService.gridOptions = this._gridOptions;
            // when displaying header row, we'll call "setColumns" which in terms will recreate the header row filters
            this._grid.setColumns(this.sharedService.columnDefinitions);
        }
    }
    /**
     * Toggle the Filter Functionality (show/hide the header row filter bar as well)
     * @param {boolean} clearFiltersWhenDisabled - when disabling the filters, do we want to clear the filters before hiding the filters? Defaults to True
     */
    toggleFilterFunctionality(clearFiltersWhenDisabled = true) {
        const prevShowFilterFlag = this._gridOptions.enableFiltering;
        this.disableFilterFunctionality(prevShowFilterFlag, clearFiltersWhenDisabled);
    }
    /**
     * Toggle the Header Row filter bar (this does not disable the Filtering itself, you can use "toggleFilterFunctionality()" instead, however this will reset any column positions)
     */
    toggleHeaderFilterRow() {
        let showHeaderRow = this._gridOptions && this._gridOptions.showHeaderRow || false;
        showHeaderRow = !showHeaderRow; // inverse show header flag
        this._grid.setHeaderRowVisibility(showHeaderRow);
        // when displaying header row, we'll call "setColumns" which in terms will recreate the header row filters
        if (showHeaderRow === true) {
            this._grid.setColumns(this.sharedService.columnDefinitions);
        }
    }
    /**
     * Set the sort icons in the UI (ONLY the icons, it does not do any sorting)
     * The column sort icons are not necessarily inter-connected to the sorting functionality itself,
     * you can change the sorting icons separately by passing an array of columnId/sortAsc and that will change ONLY the icons
     * @param sortColumns
     */
    setSortColumnIcons(sortColumns) {
        if (this._grid && Array.isArray(sortColumns)) {
            this._grid.setSortColumns(sortColumns);
        }
    }
    /**
     * Update Filters dynamically just by providing an array of filter(s).
     * You can also choose emit (default) a Filter Changed event that will be picked by the Grid State Service.
     *
     * Also for backend service only, you can choose to trigger a backend query (default) or not if you wish to do it later,
     * this could be useful when using updateFilters & updateSorting and you wish to only send the backend query once.
     * @param filters array
     * @param triggerEvent defaults to True, do we want to emit a filter changed event?
     * @param triggerBackendQuery defaults to True, which will query the backend.
     */
    updateFilters(filters, emitChangedEvent = true, triggerBackendQuery = true, triggerOnSearchChangeEvent = false) {
        if (!this._filtersMetadata || this._filtersMetadata.length === 0 || !this._gridOptions || !this._gridOptions.enableFiltering) {
            throw new Error('[Angular-Slickgrid] in order to use "updateFilters" method, you need to have Filterable Columns defined in your grid and "enableFiltering" set in your Grid Options');
        }
        if (Array.isArray(filters)) {
            // start by clearing all filters (without triggering an event) before applying any new filters
            this.clearFilters(false);
            // pre-fill (value + operator) and render all filters in the DOM
            // loop through each Filters provided (which has a columnId property)
            // then find their associated Filter instances that were originally created in the grid
            filters.forEach((newFilter) => {
                const uiFilter = this._filtersMetadata.find((filter) => newFilter.columnId === filter.columnDef.id);
                if (newFilter && uiFilter) {
                    const newOperator = newFilter.operator || uiFilter.defaultOperator;
                    this.updateColumnFilters(newFilter.searchTerms, uiFilter.columnDef, newOperator);
                    uiFilter.setValues(newFilter.searchTerms, newOperator);
                    if (triggerOnSearchChangeEvent) {
                        this.callbackSearchEvent(null, { columnDef: uiFilter.columnDef, operator: newOperator, searchTerms: newFilter.searchTerms, shouldTriggerQuery: true });
                    }
                }
            });
            const backendApi = this._gridOptions && this._gridOptions.backendServiceApi;
            // refresh the DataView and trigger an event after all filters were updated and rendered
            this._dataView.refresh();
            if (backendApi) {
                const backendApiService = backendApi && backendApi.service;
                if (backendApiService) {
                    backendApiService.updateFilters(filters, true);
                    if (triggerBackendQuery) {
                        refreshBackendDataset(this._gridOptions);
                    }
                }
            }
            if (emitChangedEvent) {
                const emitterType = backendApi ? EmitterType.remote : EmitterType.local;
                this.emitFilterChanged(emitterType);
            }
        }
    }
    // --
    // private functions
    // -------------------
    /** Add all created filters (from their template) to the header row section area */
    addFilterTemplateToHeaderRow(_event, args, isFilterFirstRender = true) {
        const columnDef = args.column;
        const columnId = columnDef && columnDef.id || '';
        if (columnDef && columnId !== 'selector' && columnDef.filterable) {
            let searchTerms;
            let operator;
            const newFilter = this.filterFactory.createFilter(args.column.filter);
            operator = (columnDef && columnDef.filter && columnDef.filter.operator) || (newFilter && newFilter.operator) || undefined;
            if (this._columnFilters[columnDef.id]) {
                searchTerms = this._columnFilters[columnDef.id].searchTerms || undefined;
                operator = this._columnFilters[columnDef.id].operator || undefined;
            }
            else if (columnDef.filter) {
                // when hiding/showing (with Column Picker or Grid Menu), it will try to re-create yet again the filters (since SlickGrid does a re-render)
                // because of that we need to first get searchTerm(s) from the columnFilters (that is what the user last typed in a filter search input)
                searchTerms = columnDef.filter.searchTerms || undefined;
                this.updateColumnFilters(searchTerms, columnDef, operator);
            }
            const filterArguments = {
                grid: this._grid,
                operator,
                searchTerms,
                columnDef,
                callback: this.callbackSearchEvent.bind(this)
            };
            if (newFilter) {
                newFilter.init(filterArguments, isFilterFirstRender);
                const filterExistIndex = this._filtersMetadata.findIndex((filter) => newFilter.columnDef.id === filter.columnDef.id);
                // add to the filters arrays or replace it when found
                if (filterExistIndex === -1) {
                    this._filtersMetadata.push(newFilter);
                }
                else {
                    this._filtersMetadata[filterExistIndex] = newFilter;
                }
                // when hiding/showing (with Column Picker or Grid Menu), it will try to re-create yet again the filters (since SlickGrid does a re-render)
                // we need to also set again the values in the DOM elements if the values were set by a searchTerm(s)
                if (searchTerms && newFilter.setValues) {
                    newFilter.setValues(searchTerms);
                }
            }
        }
    }
    /**
     * Callback method that is called and executed by the individual Filter (DOM element),
     * for example when user type in a word to search (which uses InputFilter), this Filter will execute the callback from an input change event.
     */
    callbackSearchEvent(event, args) {
        if (args) {
            const searchTerm = ((event && event.target) ? event.target.value : undefined);
            const searchTerms = (args.searchTerms && Array.isArray(args.searchTerms)) ? args.searchTerms : (searchTerm ? [searchTerm] : undefined);
            const columnDef = args.columnDef || null;
            const columnId = columnDef && columnDef.id || '';
            const operator = args.operator || undefined;
            const hasSearchTerms = searchTerms && Array.isArray(searchTerms);
            const termsCount = hasSearchTerms && searchTerms && searchTerms.length;
            const oldColumnFilters = Object.assign({}, this._columnFilters);
            if (columnDef && columnId) {
                if (!hasSearchTerms || termsCount === 0 || (termsCount === 1 && Array.isArray(searchTerms) && searchTerms[0] === '')) {
                    // delete the property from the columnFilters when it becomes empty
                    // without doing this, it would leave an incorrect state of the previous column filters when filtering on another column
                    delete this._columnFilters[columnId];
                }
                else {
                    const colId = '' + columnId;
                    const colFilter = {
                        columnId: colId,
                        columnDef,
                        searchTerms,
                    };
                    if (operator) {
                        colFilter.operator = operator;
                    }
                    this._columnFilters[colId] = colFilter;
                }
            }
            // event might have been created as a CustomEvent (e.g. CompoundDateFilter), without being a valid Slick.EventData,
            // if so we will create a new Slick.EventData and merge it with that CustomEvent to avoid having SlickGrid errors
            const eventData = (event && typeof event.isPropagationStopped !== 'function') ? $.extend({}, new Slick.EventData(), event) : event;
            // trigger an event only if Filters changed or if ENTER key was pressed
            const eventKey = event && event.key;
            const eventKeyCode = event && event.keyCode;
            if (this._onSearchChange && (eventKey === 'Enter' || eventKeyCode === KeyCode.ENTER || !isequal(oldColumnFilters, this._columnFilters))) {
                this._onSearchChange.notify({
                    clearFilterTriggered: args.clearFilterTriggered,
                    shouldTriggerQuery: args.shouldTriggerQuery,
                    columnId,
                    columnDef,
                    columnFilters: this._columnFilters,
                    operator,
                    searchTerms,
                    grid: this._grid
                }, eventData);
            }
        }
    }
    /**
     * Loop through all column definitions and do the following thing
     * 1. loop through each Header Menu commands and change the "hidden" commands to show/hide depending if it's enabled/disabled
     * Also note that we aren't deleting any properties, we just toggle their flags so that we can reloop through at later point in time.
     * (if we previously deleted these properties we wouldn't be able to change them back since these properties wouldn't exist anymore, hence why we just hide the commands)
     * @param {boolean} isDisabling - are we disabling the filter functionality? Defaults to true
     */
    disableAllFilteringCommands(isDisabling = true) {
        const columnDefinitions = this._grid.getColumns();
        // loop through column definition to hide/show header menu commands
        columnDefinitions.forEach((col) => {
            if (col && col.header && col.header.menu) {
                col.header.menu.items.forEach(menuItem => {
                    if (menuItem && typeof menuItem !== 'string') {
                        const menuCommand = menuItem.command;
                        if (menuCommand === 'clear-filter') {
                            menuItem.hidden = isDisabling;
                        }
                    }
                });
            }
        });
        // loop through column definition to hide/show grid menu commands
        if (this._gridOptions && this._gridOptions.gridMenu && this._gridOptions.gridMenu.customItems) {
            this._gridOptions.gridMenu.customItems.forEach((menuItem) => {
                if (menuItem && typeof menuItem !== 'string') {
                    const menuCommand = menuItem.command;
                    if (menuCommand === 'clear-filter' || menuCommand === 'toggle-filter') {
                        menuItem.hidden = isDisabling;
                    }
                }
            });
        }
        return columnDefinitions;
    }
    updateColumnFilters(searchTerms, columnDef, operator) {
        if (searchTerms && columnDef) {
            this._columnFilters[columnDef.id] = {
                columnId: columnDef.id,
                columnDef,
                searchTerms,
                operator
            };
        }
    }
};
FilterService.ctorParameters = () => [
    { type: FilterFactory },
    { type: SharedService }
];
FilterService = tslib_1.__decorate([
    Injectable()
], FilterService);
export { FilterService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsdGVyLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9hbmd1bGFyLXNsaWNrZ3JpZC8iLCJzb3VyY2VzIjpbImFwcC9tb2R1bGVzL2FuZ3VsYXItc2xpY2tncmlkL3NlcnZpY2VzL2ZpbHRlci5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBRSxZQUFZLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBRTdDLE9BQU8sS0FBSyxRQUFRLE1BQU0sZ0JBQWdCLENBQUM7QUFDM0MsTUFBTSxPQUFPLEdBQUcsUUFBUSxDQUFDLENBQUMsOEJBQThCO0FBRXhELE9BQU8sRUFLTCxXQUFXLEVBQ1gsU0FBUyxFQU9ULE9BQU8sRUFFUCxZQUFZLEdBSWIsTUFBTSxtQkFBbUIsQ0FBQztBQUMzQixPQUFPLEVBQUUsc0JBQXNCLEVBQUUscUJBQXFCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUNwRixPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDcEQsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDMUQsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQ3pELE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQU1qRCwrQ0FBK0M7QUFDL0MsSUFBSSxLQUFVLENBQUM7QUFDZixNQUFNLDhCQUE4QixHQUFHLEdBQUcsQ0FBQztBQUczQyxJQUFhLGFBQWEsR0FBMUIsTUFBYSxhQUFhO0lBYXhCLFlBQW9CLGFBQTRCLEVBQVUsYUFBNEI7UUFBbEUsa0JBQWEsR0FBYixhQUFhLENBQWU7UUFBVSxrQkFBYSxHQUFiLGFBQWEsQ0FBZTtRQVg5RSx5QkFBb0IsR0FBRyxJQUFJLENBQUM7UUFDNUIsMkJBQXNCLEdBQUcsRUFBRSxDQUFDO1FBQzVCLHFCQUFnQixHQUFVLEVBQUUsQ0FBQztRQUM3QixtQkFBYyxHQUFrQixFQUFFLENBQUM7UUFJbkMsd0JBQW1CLEdBQWtCLElBQUksT0FBTyxFQUFRLENBQUMsQ0FBQyx1REFBdUQ7UUFDekgsb0JBQWUsR0FBRyxJQUFJLE9BQU8sRUFBbUIsQ0FBQztRQUNqRCxvQkFBZSxHQUFHLElBQUksT0FBTyxFQUFXLENBQUM7UUFHdkMsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLEtBQUssQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUM5QyxJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDO0lBQzNDLENBQUM7SUFFRCw0Q0FBNEM7SUFDNUMsSUFBSSxZQUFZO1FBQ2QsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDO0lBQzVCLENBQUM7SUFFRCwyRkFBMkY7SUFDM0YsSUFBSSxtQkFBbUI7UUFDckIsT0FBTyxJQUFJLENBQUMsb0JBQW9CLENBQUM7SUFDbkMsQ0FBQztJQUVELDRDQUE0QztJQUM1QyxJQUFJLGNBQWM7UUFDaEIsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDO0lBQzlCLENBQUM7SUFFRCxpRUFBaUU7SUFDakUsSUFBWSxZQUFZO1FBQ3RCLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztJQUM5RSxDQUFDO0lBRUQsdUVBQXVFO0lBQ3ZFLElBQVksa0JBQWtCO1FBQzVCLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztJQUM5RSxDQUFDO0lBRUQsMENBQTBDO0lBQzFDLElBQVksU0FBUztRQUNuQixPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7SUFDeEUsQ0FBQztJQUVELElBQUksQ0FBQyxJQUFTO1FBQ1osSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7UUFFbEIsSUFBSSxJQUFJLENBQUMsWUFBWSxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsY0FBYyxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsZUFBZSxFQUFFO1lBQzlGLElBQUksQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFDLENBQUMsRUFBRSxRQUFRLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxlQUFlLENBQUMsUUFBUSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUM7U0FDdEc7SUFDSCxDQUFDO0lBRUQsT0FBTztRQUNMLG1DQUFtQztRQUNuQyxJQUFJLElBQUksQ0FBQyxhQUFhLElBQUksSUFBSSxDQUFDLGFBQWEsQ0FBQyxjQUFjLEVBQUU7WUFDM0QsSUFBSSxDQUFDLGFBQWEsQ0FBQyxjQUFjLEVBQUUsQ0FBQztTQUNyQztRQUNELElBQUksWUFBWSxDQUFDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxFQUFFO1lBQzFDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLHlDQUF5QztTQUMzRTtRQUNELElBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO1FBQzVCLElBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDO1FBQzVCLElBQUksQ0FBQyw0QkFBNEIsR0FBRyxJQUFJLENBQUM7UUFDekMsSUFBSSxDQUFDLGlCQUFpQixHQUFHLElBQUksQ0FBQztRQUM5QixJQUFJLENBQUMsbUJBQW1CLEdBQUcsSUFBSSxDQUFDO1FBQ2hDLElBQUksQ0FBQywyQkFBMkIsR0FBRyxJQUFJLENBQUM7UUFDeEMsSUFBSSxDQUFDLHlCQUF5QixHQUFHLElBQUksQ0FBQztJQUN4QyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxvQkFBb0I7UUFDbEIsbUVBQW1FO1FBQ25FLGlHQUFpRztRQUNqRyxJQUFJLE9BQU8sSUFBSSxDQUFDLGNBQWMsS0FBSyxRQUFRLEVBQUU7WUFDM0MsS0FBSyxNQUFNLFFBQVEsSUFBSSxJQUFJLENBQUMsY0FBYyxFQUFFO2dCQUMxQyxJQUFJLFFBQVEsSUFBSSxJQUFJLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxFQUFFO29CQUM3QyxPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLENBQUM7aUJBQ3RDO2FBQ0Y7U0FDRjtRQUVELHFDQUFxQztRQUNyQyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEVBQUU7WUFDeEMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFO2dCQUN2QyxJQUFJLE1BQU0sSUFBSSxNQUFNLENBQUMsT0FBTyxFQUFFO29CQUM1QixNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO2lCQUN0QjtZQUNILENBQUMsQ0FBQyxDQUFDO1NBQ0o7UUFDRCxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsRUFBRSxDQUFDO0lBQzdCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxrQkFBa0I7UUFDaEIsSUFBSSxPQUFPLElBQUksQ0FBQyxjQUFjLEtBQUssUUFBUSxFQUFFO1lBQzNDLEtBQUssTUFBTSxRQUFRLElBQUksSUFBSSxDQUFDLGNBQWMsRUFBRTtnQkFDMUMsSUFBSSxRQUFRLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsRUFBRTtvQkFDN0MsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxDQUFDO2lCQUN0QzthQUNGO1NBQ0Y7SUFDSCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsbUJBQW1CLENBQUMsSUFBUztRQUMzQixJQUFJLENBQUMsZ0JBQWdCLEdBQUcsRUFBRSxDQUFDO1FBRTNCLGlGQUFpRjtRQUNqRixJQUFJLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsdUJBQXVCLEVBQUUsSUFBSSxDQUFDLDJCQUEyQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBRXhHLGtFQUFrRTtRQUNsRSxJQUFJLElBQUksQ0FBQyxlQUFlLEVBQUU7WUFDeEIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLGVBQWUsRUFBRSxJQUFJLENBQUMscUJBQXFCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7U0FDM0Y7SUFDSCxDQUFDO0lBRUQsMkJBQTJCLENBQUMsRUFBaUIsRUFBRSxJQUFTO1FBQ3RELHNJQUFzSTtRQUN0SSx5SkFBeUo7UUFDekosSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsS0FBSyxJQUFJLENBQUMsc0JBQXNCLEVBQUU7WUFDbEQsSUFBSSxDQUFDLG9CQUFvQixHQUFHLEtBQUssQ0FBQztTQUNuQztRQUNELElBQUksQ0FBQyw0QkFBNEIsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO1FBQ3pFLElBQUksSUFBSSxDQUFDLHNCQUFzQixLQUFLLEVBQUUsRUFBRTtZQUN0QyxJQUFJLENBQUMsc0JBQXNCLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUM7U0FDOUM7SUFDSCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILGlCQUFpQixDQUFDLElBQVM7UUFDekIsSUFBSSxDQUFDLGdCQUFnQixHQUFHLEVBQUUsQ0FBQztRQUUzQixJQUFJLENBQUMsU0FBUyxDQUFDLGFBQWEsQ0FBQyxFQUFFLGFBQWEsRUFBRSxJQUFJLENBQUMsY0FBYyxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFLFFBQVEsRUFBRSxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUMsQ0FBQztRQUNqSCxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7UUFFNUQsdUVBQXVFO1FBQ3ZFLElBQUksSUFBSSxDQUFDLGVBQWUsRUFBRTtZQUN4QixJQUFJLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztZQUU5RixpRkFBaUY7WUFDakYsSUFBSSxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLHVCQUF1QixFQUFFLElBQUksQ0FBQyw0QkFBNEIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztTQUMxRztJQUNILENBQUM7SUFFRCx5QkFBeUIsQ0FBQyxFQUFpQixFQUFFLElBQVM7UUFDcEQsTUFBTSxrQkFBa0IsR0FBRyxJQUFJLENBQUMsWUFBWSxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsY0FBYyxJQUFJLEtBQUssQ0FBQztRQUUxRixvREFBb0Q7UUFDcEQsd0pBQXdKO1FBQ3hKLHNKQUFzSjtRQUN0SixJQUFJLGtCQUFrQixFQUFFO1lBQ3RCLElBQUksQ0FBQyxtQkFBbUIsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEVBQUUsRUFBRSxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7U0FDbkc7UUFFRCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO1FBQy9CLElBQUksUUFBUSxLQUFLLElBQUksRUFBRTtZQUNyQixJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sRUFBRSxDQUFDO1NBQzFCO1FBQ0QsdUVBQXVFO1FBQ3ZFLElBQUksSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLG9CQUFvQixFQUFFO1lBQ3RDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDM0M7SUFDSCxDQUFDO0lBRUQscUJBQXFCLENBQUMsS0FBWSxFQUFFLFFBQXlCO1FBQzNELDZIQUE2SDtRQUM3SCxNQUFNLG9CQUFvQixHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBbUIsQ0FBQztRQUNoRixJQUFJLGdCQUE4QixDQUFDO1FBQ25DLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxvQkFBb0IsQ0FBQyxFQUFFO1lBQ3ZDLGdCQUFnQixHQUFHLG9CQUFvQixDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSSxLQUFLLFFBQVEsQ0FBQyxDQUFDO1NBQzNFO1FBRUQsNkhBQTZIO1FBQzdILE1BQU0sU0FBUyxHQUFXLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFjLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsRUFBRSxLQUFLLFFBQVEsQ0FBQyxDQUFDO1FBQzNHLElBQUksU0FBUyxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUU7WUFDaEMsU0FBUyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUN2QjtRQUVELElBQUksT0FBTyxHQUFnQixXQUFXLENBQUMsS0FBSyxDQUFDO1FBQzdDLE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxZQUFZLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxpQkFBaUIsSUFBSSxLQUFLLENBQUM7UUFFdkYseUhBQXlIO1FBQ3pILElBQUksWUFBWSxFQUFFO1lBQ2hCLE9BQU8sR0FBRyxXQUFXLENBQUMsTUFBTSxDQUFDO1lBQzdCLElBQUksZ0JBQWdCLEVBQUU7Z0JBQ3BCLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxLQUFzQixFQUFFLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsYUFBYSxFQUFFLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQyxDQUFDO2FBQzlHO1NBQ0Y7UUFFRCx1Q0FBdUM7UUFDdkMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ2xDLENBQUM7SUFFRCx5REFBeUQ7SUFDekQsWUFBWSxDQUFDLGFBQWEsR0FBRyxJQUFJO1FBQy9CLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFjLEVBQUUsRUFBRTtZQUMvQyxJQUFJLE1BQU0sSUFBSSxNQUFNLENBQUMsS0FBSyxFQUFFO2dCQUMxQiwyREFBMkQ7Z0JBQzNELHVEQUF1RDtnQkFDdkQsTUFBTSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUNyQjtRQUNILENBQUMsQ0FBQyxDQUFDO1FBRUgsNkVBQTZFO1FBQzdFLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1FBRTFCLHFHQUFxRztRQUNyRyxJQUFJLElBQUksQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTtZQUNoQyxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ3pCLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxFQUFFLENBQUM7U0FDekI7UUFFRCxzRkFBc0Y7UUFDdEYsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLFlBQVksSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLGlCQUFpQixDQUFDO1FBQzVFLElBQUksVUFBVSxJQUFJLGFBQWEsRUFBRTtZQUMvQixNQUFNLFlBQVksR0FBRyxFQUFFLG9CQUFvQixFQUFFLElBQUksRUFBRSxrQkFBa0IsRUFBRSxhQUFhLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsYUFBYSxFQUFFLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztZQUM3SSxNQUFNLGFBQWEsR0FBRyxVQUFVLENBQUMsT0FBTyxDQUFDLHNCQUFzQixDQUFDLFNBQVMsRUFBRSxZQUFpQyxDQUFDLENBQUM7WUFDOUcsSUFBSSxhQUFhLFlBQVksT0FBTyxJQUFJLGFBQWEsQ0FBQyxJQUFJLEVBQUU7Z0JBQzFELDBHQUEwRztnQkFDMUcsT0FBTyxDQUFDLElBQUksQ0FBQztnRUFDMkMsQ0FBQyxDQUFDO2dCQUMxRCxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUMsS0FBYSxFQUFFLEVBQUU7b0JBQ25DLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxZQUFZLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxVQUFVLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDO29CQUNoSCxzQkFBc0IsQ0FBQyxVQUFVLEVBQUUsS0FBSyxFQUFFLFlBQVksRUFBRSxJQUFJLElBQUksRUFBRSxFQUFFLFVBQVUsRUFBRSxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7Z0JBQ3JILENBQUMsQ0FBQyxDQUFDO2FBQ0o7aUJBQU07Z0JBQ0wsTUFBTSxLQUFLLEdBQUcsYUFBdUIsQ0FBQztnQkFDdEMsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLFlBQVksSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLFVBQVUsSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUM7Z0JBQ2hILHNCQUFzQixDQUFDLFVBQVUsRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLElBQUksSUFBSSxFQUFFLEVBQUUsVUFBVSxFQUFFLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQzthQUNwSDtTQUNGO1FBRUQsNkNBQTZDO1FBQzdDLElBQUksYUFBYSxFQUFFO1lBQ2pCLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ2pDO0lBQ0gsQ0FBQztJQUVELCtCQUErQjtJQUMvQixpQkFBaUIsQ0FBQyxJQUFTLEVBQUUsSUFBUztRQUNwQyxNQUFNLFFBQVEsR0FBRyxJQUFJLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQztRQUN2QyxNQUFNLElBQUksR0FBRyxJQUFJLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQztRQUMvQixNQUFNLGtCQUFrQixHQUFHLElBQUksQ0FBQyxZQUFZLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxjQUFjLElBQUksS0FBSyxDQUFDO1FBQzFGLE1BQU0sYUFBYSxHQUFHLElBQUksSUFBSSxJQUFJLENBQUMsYUFBYSxJQUFJLEVBQUUsQ0FBQztRQUN2RCxJQUFJLGVBQWUsQ0FBQztRQUVwQiw0SEFBNEg7UUFDNUgsc0lBQXNJO1FBQ3RJLElBQUksa0JBQWtCLElBQUksSUFBSSxDQUFDLFlBQVksSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLGVBQWUsRUFBRTtZQUNoRixlQUFlLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxlQUFlLENBQUM7WUFDcEQsTUFBTSxpQkFBaUIsR0FBRyxlQUFlLENBQUMsaUJBQWlCLElBQUksYUFBYSxDQUFDO1lBQzdFLE1BQU0sY0FBYyxHQUFHLGVBQWUsQ0FBQyxjQUFjLElBQUksWUFBWSxDQUFDO1lBQ3RFLE1BQU0sb0JBQW9CLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxxQkFBcUIsSUFBSSxJQUFJLENBQUM7WUFFN0UsSUFBSSxJQUFJLENBQUMsY0FBYyxDQUFDLEtBQUssSUFBSSxFQUFFO2dCQUNqQyxJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQztnQkFDOUQsT0FBTyxNQUFNLEVBQUU7b0JBQ2IsSUFBSSxNQUFNLENBQUMsaUJBQWlCLENBQUMsRUFBRTt3QkFDN0IsT0FBTyxLQUFLLENBQUMsQ0FBQyx5REFBeUQ7cUJBQ3hFO29CQUNELE1BQU0sR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQztpQkFDN0Q7YUFDRjtZQUVELDhGQUE4RjtZQUM5RixJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLEVBQUU7Z0JBQzNDLE9BQU8sSUFBSSxDQUFDLG1CQUFtQixDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxDQUFDLENBQUMsMENBQTBDO2FBQ2pIO1NBQ0Y7YUFBTTtZQUNMLElBQUksT0FBTyxhQUFhLEtBQUssUUFBUSxFQUFFO2dCQUNyQyxLQUFLLE1BQU0sUUFBUSxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLEVBQUU7b0JBQ2pELE1BQU0sWUFBWSxHQUFHLGFBQWEsQ0FBQyxRQUFRLENBQWlCLENBQUM7b0JBQzdELE1BQU0sZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLGtDQUFrQyxDQUFDLElBQUksRUFBRSxZQUFZLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQztvQkFDL0csSUFBSSxPQUFPLGdCQUFnQixLQUFLLFNBQVMsRUFBRTt3QkFDekMsT0FBTyxnQkFBZ0IsQ0FBQztxQkFDekI7b0JBRUQsSUFBSSxDQUFDLGdCQUFnQixDQUFDLHNCQUFzQixDQUFDLGdCQUF5QyxDQUFDLEVBQUU7d0JBQ3ZGLE9BQU8sS0FBSyxDQUFDO3FCQUNkO2lCQUNGO2FBQ0Y7U0FDRjtRQUVELHdFQUF3RTtRQUN4RSxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRCxrQ0FBa0MsQ0FBQyxJQUFTLEVBQUUsWUFBMEIsRUFBRSxRQUF5QixFQUFFLElBQVMsRUFBRSxRQUFhO1FBQzNILElBQUksV0FBVyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFXLENBQUM7UUFDMUQsSUFBSSxTQUFTLEdBQUcsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDLFdBQVcsQ0FBVyxDQUFDO1FBRXpELHFIQUFxSDtRQUNySCxxRkFBcUY7UUFDckYsSUFBSSxDQUFDLFNBQVMsSUFBSSxJQUFJLENBQUMsYUFBYSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUMsRUFBRTtZQUNwRixXQUFXLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsS0FBSyxLQUFLLFFBQVEsQ0FBQyxDQUFDO1lBQ3ZGLFNBQVMsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsQ0FBQztTQUN4RDtRQUVELDBGQUEwRjtRQUMxRixJQUFJLENBQUMsU0FBUyxFQUFFO1lBQ2QsT0FBTyxJQUFJLENBQUM7U0FDYjtRQUVELDBHQUEwRztRQUMxRyxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsbUJBQW1CLEVBQUU7WUFDekMsTUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxhQUFhLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxhQUFhLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQztZQUM1RyxJQUFJLElBQUksQ0FBQyxHQUFHLGNBQWMsV0FBVyxDQUFDLElBQUksSUFBSSxDQUFDLEdBQUcsY0FBYyxRQUFRLENBQUMsRUFBRTtnQkFDekUsSUFBSSxHQUFHLElBQUksQ0FBQyxHQUFHLGNBQWMsUUFBUSxDQUFDLENBQUM7YUFDeEM7U0FDRjtRQUVELE1BQU0sT0FBTyxHQUFHLFNBQVMsQ0FBQyxPQUFPLENBQUM7UUFDbEMsSUFBSSxjQUFjLEdBQUcsQ0FBQyxTQUFTLENBQUMsTUFBTSxJQUFJLFNBQVMsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksU0FBUyxDQUFDLGdCQUFnQixJQUFJLFNBQVMsQ0FBQyxVQUFVLElBQUksU0FBUyxDQUFDLEtBQUssSUFBSSxFQUFFLENBQUM7UUFDdEosSUFBSSxPQUFPLFNBQVMsQ0FBQyxzQkFBc0IsS0FBSyxVQUFVLEVBQUU7WUFDMUQsY0FBYyxHQUFHLFNBQVMsQ0FBQyxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUN6RDtRQUNELE1BQU0sU0FBUyxHQUFHLENBQUMsU0FBUyxDQUFDLE1BQU0sSUFBSSxTQUFTLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLFNBQVMsQ0FBQyxJQUFJLElBQUksU0FBUyxDQUFDLE1BQU0sQ0FBQztRQUNwRyxNQUFNLGdCQUFnQixHQUFHLENBQUMsU0FBUyxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO1FBQzFGLElBQUksU0FBUyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUVyQyw2R0FBNkc7UUFDN0csSUFBSSxjQUFjLElBQUksY0FBYyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDdEQsU0FBUyxHQUFHLHFCQUFxQixDQUFDLElBQUksRUFBRSxjQUFjLENBQUMsQ0FBQztTQUN6RDtRQUVELDhGQUE4RjtRQUM5RixvRUFBb0U7UUFDcEUsc0hBQXNIO1FBQ3RILE1BQU0sWUFBWSxHQUFpQixDQUFDLFlBQVksSUFBSSxZQUFZLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLEVBQUUsRUFBRSxZQUFZLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUNsSSxJQUFJLGdCQUFnQixHQUFHLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsSUFBSSxZQUFZLENBQUMsTUFBTSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUV6RyxJQUFJLE9BQU8sR0FBRyxJQUFJLENBQUM7UUFDbkIsSUFBSSxTQUFTLEtBQUssU0FBUyxDQUFDLE1BQU0sRUFBRTtZQUNsQyxnQkFBZ0IsR0FBRyxFQUFFLEdBQUcsZ0JBQWdCLENBQUMsQ0FBQywwQkFBMEI7WUFDcEUsT0FBTyxHQUFHLGdCQUFnQixDQUFDLEtBQUssQ0FBQyx1Q0FBdUMsQ0FBQyxDQUFDLENBQUMsMEZBQTBGO1NBQ3RLO1FBRUQsSUFBSSxRQUFRLEdBQUcsWUFBWSxDQUFDLFFBQVEsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDdEUsTUFBTSxVQUFVLEdBQUcsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO1FBQ2pELE1BQU0sYUFBYSxHQUFHLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUVoRixJQUFJLFlBQVksSUFBSSxZQUFZLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUMzQyxnQkFBZ0IsR0FBRyxZQUFZLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQzNDO2FBQU0sSUFBSSxPQUFPLGdCQUFnQixLQUFLLFFBQVEsRUFBRTtZQUMvQyw0QkFBNEI7WUFDNUIsZ0JBQWdCLEdBQUcsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLHdDQUF3QztZQUNoRyxJQUFJLFFBQVEsS0FBSyxHQUFHLElBQUksUUFBUSxLQUFLLElBQUksSUFBSSxRQUFRLEtBQUssSUFBSSxJQUFJLGFBQWEsS0FBSyxHQUFHLEVBQUU7Z0JBQ3ZGLFFBQVEsR0FBRyxDQUFDLFFBQVEsS0FBSyxHQUFHLElBQUksUUFBUSxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsVUFBVSxDQUFDO2FBQ3RHO1NBQ0Y7UUFFRCxvR0FBb0c7UUFDcEcsSUFBSSxVQUFVLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQyxZQUFZLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sS0FBSyxDQUFDLElBQUksWUFBWSxDQUFDLE1BQU0sS0FBSyxDQUFDLElBQUksUUFBUSxLQUFLLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtZQUNySyxPQUFPLElBQUksQ0FBQztTQUNiO1FBRUQscUZBQXFGO1FBQ3JGLDJHQUEyRztRQUMzRyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksT0FBTyxDQUFDLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxJQUFJLFlBQVksQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDLEVBQUU7WUFDL0csWUFBWSxDQUFDLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQztTQUM5QjtRQUVELHlHQUF5RztRQUN6Ryx5R0FBeUc7UUFDekcsSUFBSSxZQUFZLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsSUFBSSxTQUFTLEtBQUssU0FBUyxDQUFDLE1BQU0sRUFBRTtZQUNqRixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLEdBQUcsWUFBWSxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFO2dCQUNyRCx5Q0FBeUM7Z0JBQ3pDLFlBQVksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxLQUFLLFNBQVMsSUFBSSxZQUFZLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO2FBQzdHO1NBQ0Y7UUFFRCxxR0FBcUc7UUFDckcsSUFBSSxTQUFTLElBQUksU0FBUyxDQUFDLE1BQU0sSUFBSSxTQUFTLENBQUMsTUFBTSxDQUFDLHlCQUF5QixFQUFFO1lBQy9FLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMscUJBQXFCLElBQUksSUFBSSxDQUFDO1lBQ25FLE1BQU0sUUFBUSxHQUFHLENBQUMsUUFBUSxJQUFJLE9BQU8sUUFBUSxDQUFDLFVBQVUsS0FBSyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3JILFNBQVMsR0FBRyxDQUFDLFNBQVMsSUFBSSxPQUFPLFNBQVMsQ0FBQyxTQUFTLEtBQUssVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLFdBQVcsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztTQUNoSztRQUVELDBDQUEwQztRQUMxQyxJQUFJLE9BQU8sU0FBUyxLQUFLLFFBQVEsRUFBRTtZQUNqQyxTQUFTLEdBQUcsU0FBUyxDQUFDLFFBQVEsRUFBRSxDQUFDO1NBQ2xDO1FBRUQsTUFBTSxnQkFBZ0IsR0FBRyxTQUFTLENBQUM7UUFDbkMsT0FBTztZQUNMLE9BQU87WUFDUCxTQUFTO1lBQ1QsV0FBVyxFQUFFLFlBQVk7WUFDekIsU0FBUyxFQUFFLGdCQUFnQjtZQUMzQixRQUFRLEVBQUUsUUFBMEI7WUFDcEMsaUJBQWlCLEVBQUUsYUFBYTtZQUNoQyxnQkFBZ0I7U0FDUSxDQUFDO0lBQzdCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsaUJBQWlCLENBQUMsVUFBaUIsRUFBRSxhQUE0QjtRQUMvRCxNQUFNLGVBQWUsR0FBRyxJQUFJLENBQUMsWUFBWSxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsZUFBZSxDQUFDO1FBQy9FLE1BQU0sY0FBYyxHQUFHLGVBQWUsSUFBSSxlQUFlLENBQUMsY0FBYyxJQUFJLFlBQVksQ0FBQztRQUN6RixNQUFNLG9CQUFvQixHQUFHLElBQUksQ0FBQyxZQUFZLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxxQkFBcUIsSUFBSSxJQUFJLENBQUM7UUFFbEcsTUFBTSxPQUFPLEdBQUcsRUFBRSxDQUFDO1FBQ25CLE1BQU0sMEJBQTBCLEdBQVUsRUFBRSxDQUFDO1FBRTdDLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsRUFBRTtZQUM3QixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsVUFBVSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDMUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUM3RCxvRUFBb0U7Z0JBQ3BFLG9FQUFvRTtnQkFDcEUsNkRBQTZEO2dCQUM3RCxPQUFPLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQzthQUM1RDtZQUVELEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxVQUFVLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO2dCQUMxQyxNQUFNLElBQUksR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQzNCLElBQUksV0FBVyxHQUFHLElBQUksQ0FBQyxDQUFDLCtCQUErQjtnQkFFdkQsa0VBQWtFO2dCQUNsRSxLQUFLLE1BQU0sUUFBUSxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLEVBQUU7b0JBQ2pELE1BQU0sWUFBWSxHQUFHLGFBQWEsQ0FBQyxRQUFRLENBQWlCLENBQUM7b0JBQzdELE1BQU0scUJBQXFCLEdBQUcsSUFBSSxDQUFDLGtDQUFrQyxDQUFDLElBQUksRUFBRSxZQUFZLEVBQUUsUUFBUSxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO29CQUVoSSxJQUFJLHFCQUFxQixFQUFFO3dCQUN6QixNQUFNLGVBQWUsR0FBRyxDQUFDLE9BQU8scUJBQXFCLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLHFCQUFxQixDQUFDLENBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxzQkFBc0IsQ0FBQyxxQkFBOEMsQ0FBQyxDQUFDO3dCQUN2TCxJQUFJLGVBQWUsRUFBRTs0QkFDbkIsNkVBQTZFOzRCQUM3RSxTQUFTO3lCQUNWO3FCQUNGO29CQUNELFdBQVcsR0FBRyxLQUFLLENBQUM7b0JBQ3BCLFNBQVM7aUJBQ1Y7Z0JBRUQsZ0ZBQWdGO2dCQUNoRix5REFBeUQ7Z0JBQ3pELElBQUksV0FBVyxFQUFFO29CQUNmLE1BQU0sR0FBRyxHQUFHLDBCQUEwQixDQUFDLE1BQU0sQ0FBQztvQkFDOUMsa0JBQWtCO29CQUNsQiwwQkFBMEIsQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxDQUFDO29CQUN0RSxJQUFJLE1BQU0sR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDO29CQUNwRCxPQUFPLE1BQU0sRUFBRTt3QkFDYiw2Q0FBNkM7d0JBQzdDLE1BQU0sQ0FBQyxNQUFNLElBQUksMEJBQTBCLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLG9CQUFvQixDQUFDLENBQUMsQ0FBQzt3QkFDekYsd0RBQXdEO3dCQUN4RCxPQUFPLENBQUMsTUFBTSxDQUFDLG9CQUFvQixDQUFDLENBQUMsQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDO3dCQUNwRCx1REFBdUQ7d0JBQ3ZELE1BQU0sR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDO3FCQUNuRDtpQkFDRjthQUNGO1NBQ0Y7UUFDRCxPQUFPLDBCQUEwQixDQUFDO0lBQ3BDLENBQUM7SUFFRCxnQkFBZ0I7UUFDZCxPQUFPLElBQUksQ0FBQyxjQUFjLENBQUM7SUFDN0IsQ0FBQztJQUVELGtCQUFrQjtRQUNoQixPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQztJQUMvQixDQUFDO0lBRUQsc0JBQXNCO1FBQ3BCLE1BQU0sY0FBYyxHQUFvQixFQUFFLENBQUM7UUFDM0MsSUFBSSxJQUFJLENBQUMsY0FBYyxFQUFFO1lBQ3ZCLEtBQUssTUFBTSxLQUFLLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLEVBQUU7Z0JBQ3BELE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQ2hELE1BQU0sTUFBTSxHQUFHLEVBQUUsUUFBUSxFQUFFLEtBQUssSUFBSSxFQUFFLEVBQW1CLENBQUM7Z0JBRTFELElBQUksWUFBWSxJQUFJLFlBQVksQ0FBQyxXQUFXLEVBQUU7b0JBQzVDLE1BQU0sQ0FBQyxXQUFXLEdBQUcsWUFBWSxDQUFDLFdBQVcsQ0FBQztpQkFDL0M7Z0JBQ0QsSUFBSSxZQUFZLENBQUMsUUFBUSxFQUFFO29CQUN6QixNQUFNLENBQUMsUUFBUSxHQUFHLFlBQVksQ0FBQyxRQUFRLENBQUM7aUJBQ3pDO2dCQUNELElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLElBQUksTUFBTSxDQUFDLFdBQVcsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFO29CQUN0RyxjQUFjLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO2lCQUM3QjthQUNGO1NBQ0Y7UUFDRCxPQUFPLGNBQWMsQ0FBQztJQUN4QixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILGlCQUFpQixDQUFDLE1BQW1CO1FBQ25DLElBQUksTUFBTSxLQUFLLFdBQVcsQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDLFlBQVksSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLGlCQUFpQixFQUFFO1lBQzdGLElBQUksY0FBYyxHQUFvQixFQUFFLENBQUM7WUFDekMsTUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLENBQUM7WUFDbkUsSUFBSSxjQUFjLElBQUksY0FBYyxDQUFDLGlCQUFpQixFQUFFO2dCQUN0RCxjQUFjLEdBQUcsY0FBYyxDQUFDLGlCQUFpQixFQUFxQixDQUFDO2FBQ3hFO1lBQ0QsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7U0FDM0M7YUFBTSxJQUFJLE1BQU0sS0FBSyxXQUFXLENBQUMsS0FBSyxFQUFFO1lBQ3ZDLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxzQkFBc0IsRUFBRSxDQUFDLENBQUM7U0FDMUQ7SUFDSCxDQUFDO0lBRUsscUJBQXFCLENBQUMsS0FBb0IsRUFBRSxJQUFTOztZQUN6RCxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRTtnQkFDdkIsTUFBTSxJQUFJLEtBQUssQ0FBQyw2SUFBNkksQ0FBQyxDQUFDO2FBQ2hLO1lBRUQscUdBQXFHO1lBQ3JHLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsaUJBQWlCLENBQUM7WUFFdkQsSUFBSSxDQUFDLFVBQVUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxFQUFFO2dCQUM3RCxNQUFNLElBQUksS0FBSyxDQUFDLGtGQUFrRixDQUFDLENBQUM7YUFDckc7WUFFRCx1RUFBdUU7WUFDdkUsTUFBTSxTQUFTLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQztZQUU3Qix1Q0FBdUM7WUFDdkMsSUFBSSxVQUFVLENBQUMsVUFBVSxFQUFFO2dCQUN6QixVQUFVLENBQUMsVUFBVSxFQUFFLENBQUM7YUFDekI7WUFFRCxpSEFBaUg7WUFDakgsSUFBSSxtQkFBbUIsR0FBRyxDQUFDLENBQUM7WUFDNUIsTUFBTSx3QkFBd0IsR0FBRyxJQUFJLElBQUksSUFBSSxDQUFDLG9CQUFvQixDQUFDLENBQUMsOENBQThDO1lBRWxILE1BQU0sU0FBUyxHQUFHLEtBQUssSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDO1lBQ3RDLE1BQU0sWUFBWSxHQUFHLEtBQUssSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDO1lBQzVDLElBQUksQ0FBQyx3QkFBd0IsSUFBSSxZQUFZLEtBQUssT0FBTyxDQUFDLEtBQUssSUFBSSxDQUFDLFNBQVMsS0FBSyxPQUFPLElBQUksU0FBUyxLQUFLLE9BQU8sSUFBSSxTQUFTLEtBQUssU0FBUyxDQUFDLEVBQUU7Z0JBQzlJLG1CQUFtQixHQUFHLFVBQVUsQ0FBQyxjQUFjLENBQUMsc0JBQXNCLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLG9CQUE4QixDQUFDLENBQUMsQ0FBQyw4QkFBOEIsQ0FBQzthQUN0SjtZQUVELHlFQUF5RTtZQUN6RSxJQUFJLElBQUksSUFBSSxJQUFJLENBQUMsa0JBQWtCLEVBQUU7Z0JBQ25DLHVDQUF1QztnQkFDdkMsNElBQTRJO2dCQUM1SSxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQ3BCLElBQUksbUJBQW1CLEdBQUcsQ0FBQyxFQUFFO29CQUMzQixLQUFLLEdBQUcsVUFBVSxDQUFDLEdBQVMsRUFBRTt3QkFDNUIsTUFBTSxLQUFLLEdBQUcsTUFBTSxVQUFVLENBQUMsT0FBTyxDQUFDLHNCQUFzQixDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQzt3QkFDM0UsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLFlBQVksSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLFVBQVUsSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUM7d0JBQ2hILHNCQUFzQixDQUFDLFVBQVUsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxJQUFJLENBQUMsbUJBQW1CLENBQUMsQ0FBQztvQkFDdEksQ0FBQyxDQUFBLEVBQUUsbUJBQW1CLENBQUMsQ0FBQztpQkFDekI7cUJBQU07b0JBQ0wsTUFBTSxLQUFLLEdBQUcsTUFBTSxVQUFVLENBQUMsT0FBTyxDQUFDLHNCQUFzQixDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztvQkFDM0UsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLFlBQVksSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLFVBQVUsSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUM7b0JBQ2hILHNCQUFzQixDQUFDLFVBQVUsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxJQUFJLENBQUMsbUJBQW1CLENBQUMsQ0FBQztpQkFDckk7YUFDRjtRQUNILENBQUM7S0FBQTtJQUVEOzs7OztPQUtHO0lBQ0gscUNBQXFDLENBQUMsT0FBd0I7UUFDNUQsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQ2hELElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxPQUFPLENBQUMsQ0FBQyxTQUFpQixFQUFFLEVBQUU7Z0JBQ3BELDBEQUEwRDtnQkFDMUQsSUFBSSxTQUFTLENBQUMsTUFBTSxJQUFJLFNBQVMsQ0FBQyxNQUFNLENBQUMsV0FBVyxFQUFFO29CQUNwRCxPQUFPLFNBQVMsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDO2lCQUNyQztnQkFFRCxtSEFBbUg7Z0JBQ25ILE1BQU0sWUFBWSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxZQUEyQixFQUFFLEVBQUUsQ0FBQyxZQUFZLENBQUMsUUFBUSxLQUFLLFNBQVMsQ0FBQyxFQUFFLENBQUMsQ0FBQztnQkFDM0csSUFBSSxZQUFZLElBQUksWUFBWSxDQUFDLFdBQVcsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxXQUFXLENBQUMsRUFBRTtvQkFDdkYsU0FBUyxDQUFDLE1BQU0sR0FBRyxTQUFTLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQztvQkFDMUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxRQUFRLEdBQUcsWUFBWSxDQUFDLFFBQVEsSUFBSSxTQUFTLENBQUMsTUFBTSxDQUFDLFFBQVEsSUFBSSxFQUFFLENBQUM7b0JBQ3JGLFNBQVMsQ0FBQyxNQUFNLENBQUMsV0FBVyxHQUFHLFlBQVksQ0FBQyxXQUFXLENBQUM7aUJBQ3pEO1lBQ0gsQ0FBQyxDQUFDLENBQUM7WUFFSCx5R0FBeUc7WUFDekcsSUFBSSxDQUFDLHNCQUFzQixFQUFFLENBQUM7U0FDL0I7UUFDRCxPQUFPLElBQUksQ0FBQyxrQkFBa0IsQ0FBQztJQUNqQyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILHNCQUFzQjtRQUNwQixJQUFJLElBQUksQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLElBQUksSUFBSSxDQUFDLFlBQVksSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLGNBQWMsRUFBRTtZQUN0RyxJQUFJLENBQUMsbUJBQW1CLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLEVBQUUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1lBQ2xHLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyx5RUFBeUU7U0FDcEc7SUFDSCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILDBCQUEwQixDQUFDLGdCQUFnQixHQUFHLElBQUksRUFBRSx3QkFBd0IsR0FBRyxJQUFJO1FBQ2pGLE1BQU0sa0JBQWtCLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxlQUFlLENBQUM7UUFDN0QsTUFBTSxpQkFBaUIsR0FBRyxDQUFDLGtCQUFrQixDQUFDO1FBRTlDLElBQUksaUJBQWlCLEtBQUssZ0JBQWdCLEVBQUU7WUFDMUMsSUFBSSx3QkFBd0IsSUFBSSxnQkFBZ0IsRUFBRTtnQkFDaEQsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO2FBQ3JCO1lBQ0QsSUFBSSxDQUFDLDJCQUEyQixDQUFDLGdCQUFnQixDQUFDLENBQUM7WUFDbkQsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsRUFBRSxlQUFlLEVBQUUsaUJBQWlCLEVBQUUsRUFBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFDM0UsSUFBSSxDQUFDLEtBQUssQ0FBQyxzQkFBc0IsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1lBQ3JELElBQUksQ0FBQyxZQUFZLENBQUMsZUFBZSxHQUFHLENBQUMsZ0JBQWdCLENBQUM7WUFDdEQsSUFBSSxDQUFDLGFBQWEsQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQztZQUVuRCwwR0FBMEc7WUFDMUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1NBQzdEO0lBQ0gsQ0FBQztJQUVEOzs7T0FHRztJQUNILHlCQUF5QixDQUFDLHdCQUF3QixHQUFHLElBQUk7UUFDdkQsTUFBTSxrQkFBa0IsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLGVBQWUsQ0FBQztRQUM3RCxJQUFJLENBQUMsMEJBQTBCLENBQUMsa0JBQWtCLEVBQUUsd0JBQXdCLENBQUMsQ0FBQztJQUNoRixDQUFDO0lBRUQ7O09BRUc7SUFDSCxxQkFBcUI7UUFDbkIsSUFBSSxhQUFhLEdBQUcsSUFBSSxDQUFDLFlBQVksSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLGFBQWEsSUFBSSxLQUFLLENBQUM7UUFDbEYsYUFBYSxHQUFHLENBQUMsYUFBYSxDQUFDLENBQUMsMkJBQTJCO1FBQzNELElBQUksQ0FBQyxLQUFLLENBQUMsc0JBQXNCLENBQUMsYUFBYSxDQUFDLENBQUM7UUFFakQsMEdBQTBHO1FBQzFHLElBQUksYUFBYSxLQUFLLElBQUksRUFBRTtZQUMxQixJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLGlCQUFpQixDQUFDLENBQUM7U0FDN0Q7SUFDSCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxrQkFBa0IsQ0FBQyxXQUFxRDtRQUN0RSxJQUFJLElBQUksQ0FBQyxLQUFLLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsRUFBRTtZQUM1QyxJQUFJLENBQUMsS0FBSyxDQUFDLGNBQWMsQ0FBQyxXQUFXLENBQUMsQ0FBQztTQUN4QztJQUNILENBQUM7SUFFRDs7Ozs7Ozs7O09BU0c7SUFDSCxhQUFhLENBQUMsT0FBd0IsRUFBRSxnQkFBZ0IsR0FBRyxJQUFJLEVBQUUsbUJBQW1CLEdBQUcsSUFBSSxFQUFFLDBCQUEwQixHQUFHLEtBQUs7UUFDN0gsSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLGVBQWUsRUFBRTtZQUM1SCxNQUFNLElBQUksS0FBSyxDQUFDLHFLQUFxSyxDQUFDLENBQUM7U0FDeEw7UUFFRCxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEVBQUU7WUFDMUIsOEZBQThGO1lBQzlGLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUM7WUFFekIsZ0VBQWdFO1lBQ2hFLHFFQUFxRTtZQUNyRSx1RkFBdUY7WUFDdkYsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLFNBQVMsRUFBRSxFQUFFO2dCQUM1QixNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxTQUFTLENBQUMsUUFBUSxLQUFLLE1BQU0sQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLENBQUM7Z0JBQ3BHLElBQUksU0FBUyxJQUFJLFFBQVEsRUFBRTtvQkFDekIsTUFBTSxXQUFXLEdBQUcsU0FBUyxDQUFDLFFBQVEsSUFBSSxRQUFRLENBQUMsZUFBZSxDQUFDO29CQUNuRSxJQUFJLENBQUMsbUJBQW1CLENBQUMsU0FBUyxDQUFDLFdBQVcsRUFBRSxRQUFRLENBQUMsU0FBUyxFQUFFLFdBQVcsQ0FBQyxDQUFDO29CQUNqRixRQUFRLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxXQUFXLEVBQUUsV0FBVyxDQUFDLENBQUM7b0JBRXZELElBQUksMEJBQTBCLEVBQUU7d0JBQzlCLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLEVBQUUsRUFBRSxTQUFTLEVBQUUsUUFBUSxDQUFDLFNBQVMsRUFBRSxRQUFRLEVBQUUsV0FBVyxFQUFFLFdBQVcsRUFBRSxTQUFTLENBQUMsV0FBVyxFQUFFLGtCQUFrQixFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7cUJBQ3hKO2lCQUNGO1lBQ0gsQ0FBQyxDQUFDLENBQUM7WUFFSCxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsWUFBWSxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsaUJBQWlCLENBQUM7WUFFNUUsd0ZBQXdGO1lBQ3hGLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxFQUFFLENBQUM7WUFFekIsSUFBSSxVQUFVLEVBQUU7Z0JBQ2QsTUFBTSxpQkFBaUIsR0FBRyxVQUFVLElBQUksVUFBVSxDQUFDLE9BQU8sQ0FBQztnQkFDM0QsSUFBSSxpQkFBaUIsRUFBRTtvQkFDckIsaUJBQWlCLENBQUMsYUFBYSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztvQkFDL0MsSUFBSSxtQkFBbUIsRUFBRTt3QkFDdkIscUJBQXFCLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO3FCQUMxQztpQkFDRjthQUNGO1lBRUQsSUFBSSxnQkFBZ0IsRUFBRTtnQkFDcEIsTUFBTSxXQUFXLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDO2dCQUN4RSxJQUFJLENBQUMsaUJBQWlCLENBQUMsV0FBVyxDQUFDLENBQUM7YUFDckM7U0FDRjtJQUNILENBQUM7SUFFRCxLQUFLO0lBQ0wsb0JBQW9CO0lBQ3BCLHNCQUFzQjtJQUV0QixtRkFBbUY7SUFDM0UsNEJBQTRCLENBQUMsTUFBYSxFQUFFLElBQXNELEVBQUUsbUJBQW1CLEdBQUcsSUFBSTtRQUNwSSxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO1FBQzlCLE1BQU0sUUFBUSxHQUFHLFNBQVMsSUFBSSxTQUFTLENBQUMsRUFBRSxJQUFJLEVBQUUsQ0FBQztRQUVqRCxJQUFJLFNBQVMsSUFBSSxRQUFRLEtBQUssVUFBVSxJQUFJLFNBQVMsQ0FBQyxVQUFVLEVBQUU7WUFDaEUsSUFBSSxXQUFxQyxDQUFDO1lBQzFDLElBQUksUUFBdUMsQ0FBQztZQUM1QyxNQUFNLFNBQVMsR0FBdUIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUMxRixRQUFRLEdBQUcsQ0FBQyxTQUFTLElBQUksU0FBUyxDQUFDLE1BQU0sSUFBSSxTQUFTLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsU0FBUyxJQUFJLFNBQVMsQ0FBQyxRQUFRLENBQUMsSUFBSSxTQUFTLENBQUM7WUFFMUgsSUFBSSxJQUFJLENBQUMsY0FBYyxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsRUFBRTtnQkFDckMsV0FBVyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxDQUFDLFdBQVcsSUFBSSxTQUFTLENBQUM7Z0JBQ3pFLFFBQVEsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxRQUFRLElBQUksU0FBUyxDQUFDO2FBQ3BFO2lCQUFNLElBQUksU0FBUyxDQUFDLE1BQU0sRUFBRTtnQkFDM0IsMklBQTJJO2dCQUMzSSx3SUFBd0k7Z0JBQ3hJLFdBQVcsR0FBRyxTQUFTLENBQUMsTUFBTSxDQUFDLFdBQVcsSUFBSSxTQUFTLENBQUM7Z0JBQ3hELElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxXQUFXLEVBQUUsU0FBUyxFQUFFLFFBQVEsQ0FBQyxDQUFDO2FBQzVEO1lBRUQsTUFBTSxlQUFlLEdBQW9CO2dCQUN2QyxJQUFJLEVBQUUsSUFBSSxDQUFDLEtBQUs7Z0JBQ2hCLFFBQVE7Z0JBQ1IsV0FBVztnQkFDWCxTQUFTO2dCQUNULFFBQVEsRUFBRSxJQUFJLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQzthQUM5QyxDQUFDO1lBRUYsSUFBSSxTQUFTLEVBQUU7Z0JBQ2IsU0FBUyxDQUFDLElBQUksQ0FBQyxlQUFlLEVBQUUsbUJBQW1CLENBQUMsQ0FBQztnQkFDckQsTUFBTSxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLEVBQUUsS0FBSyxNQUFNLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxDQUFDO2dCQUVySCxxREFBcUQ7Z0JBQ3JELElBQUksZ0JBQWdCLEtBQUssQ0FBQyxDQUFDLEVBQUU7b0JBQzNCLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7aUJBQ3ZDO3FCQUFNO29CQUNMLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLFNBQVMsQ0FBQztpQkFDckQ7Z0JBRUQsMklBQTJJO2dCQUMzSSxxR0FBcUc7Z0JBQ3JHLElBQUksV0FBVyxJQUFJLFNBQVMsQ0FBQyxTQUFTLEVBQUU7b0JBQ3RDLFNBQVMsQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDLENBQUM7aUJBQ2xDO2FBQ0Y7U0FDRjtJQUNILENBQUM7SUFFRDs7O09BR0c7SUFDSyxtQkFBbUIsQ0FBQyxLQUFVLEVBQUUsSUFBdUI7UUFDN0QsSUFBSSxJQUFJLEVBQUU7WUFDUixNQUFNLFVBQVUsR0FBRyxDQUFDLENBQUMsS0FBSyxJQUFJLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUUsS0FBSyxDQUFDLE1BQTJCLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUNwRyxNQUFNLFdBQVcsR0FBRyxDQUFDLElBQUksQ0FBQyxXQUFXLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQ3ZJLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDO1lBQ3pDLE1BQU0sUUFBUSxHQUFHLFNBQVMsSUFBSSxTQUFTLENBQUMsRUFBRSxJQUFJLEVBQUUsQ0FBQztZQUNqRCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxJQUFJLFNBQVMsQ0FBQztZQUM1QyxNQUFNLGNBQWMsR0FBRyxXQUFXLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUNqRSxNQUFNLFVBQVUsR0FBRyxjQUFjLElBQUksV0FBVyxJQUFJLFdBQVcsQ0FBQyxNQUFNLENBQUM7WUFDdkUsTUFBTSxnQkFBZ0IscUJBQVEsSUFBSSxDQUFDLGNBQWMsQ0FBRSxDQUFDO1lBRXBELElBQUksU0FBUyxJQUFJLFFBQVEsRUFBRTtnQkFDekIsSUFBSSxDQUFDLGNBQWMsSUFBSSxVQUFVLEtBQUssQ0FBQyxJQUFJLENBQUMsVUFBVSxLQUFLLENBQUMsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxJQUFJLFdBQVcsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsRUFBRTtvQkFDcEgsbUVBQW1FO29CQUNuRSx3SEFBd0g7b0JBQ3hILE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsQ0FBQztpQkFDdEM7cUJBQU07b0JBQ0wsTUFBTSxLQUFLLEdBQUcsRUFBRSxHQUFHLFFBQWtCLENBQUM7b0JBQ3RDLE1BQU0sU0FBUyxHQUFpQjt3QkFDOUIsUUFBUSxFQUFFLEtBQUs7d0JBQ2YsU0FBUzt3QkFDVCxXQUFXO3FCQUNaLENBQUM7b0JBQ0YsSUFBSSxRQUFRLEVBQUU7d0JBQ1osU0FBUyxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7cUJBQy9CO29CQUNELElBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLEdBQUcsU0FBUyxDQUFDO2lCQUN4QzthQUNGO1lBRUQsbUhBQW1IO1lBQ25ILGlIQUFpSDtZQUNqSCxNQUFNLFNBQVMsR0FBRyxDQUFDLEtBQUssSUFBSSxPQUFPLEtBQUssQ0FBQyxvQkFBb0IsS0FBSyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsSUFBSSxLQUFLLENBQUMsU0FBUyxFQUFFLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztZQUVuSSx1RUFBdUU7WUFDdkUsTUFBTSxRQUFRLEdBQUcsS0FBSyxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUM7WUFDcEMsTUFBTSxZQUFZLEdBQUcsS0FBSyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUM7WUFDNUMsSUFBSSxJQUFJLENBQUMsZUFBZSxJQUFJLENBQUMsUUFBUSxLQUFLLE9BQU8sSUFBSSxZQUFZLEtBQUssT0FBTyxDQUFDLEtBQUssSUFBSSxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsRUFBRSxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsRUFBRTtnQkFDdkksSUFBSSxDQUFDLGVBQWUsQ0FBQyxNQUFNLENBQUM7b0JBQzFCLG9CQUFvQixFQUFFLElBQUksQ0FBQyxvQkFBb0I7b0JBQy9DLGtCQUFrQixFQUFFLElBQUksQ0FBQyxrQkFBa0I7b0JBQzNDLFFBQVE7b0JBQ1IsU0FBUztvQkFDVCxhQUFhLEVBQUUsSUFBSSxDQUFDLGNBQWM7b0JBQ2xDLFFBQVE7b0JBQ1IsV0FBVztvQkFDWCxJQUFJLEVBQUUsSUFBSSxDQUFDLEtBQUs7aUJBQ2pCLEVBQUUsU0FBUyxDQUFDLENBQUM7YUFDZjtTQUNGO0lBQ0gsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNLLDJCQUEyQixDQUFDLFdBQVcsR0FBRyxJQUFJO1FBQ3BELE1BQU0saUJBQWlCLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUVsRCxtRUFBbUU7UUFDbkUsaUJBQWlCLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUU7WUFDaEMsSUFBSSxHQUFHLElBQUksR0FBRyxDQUFDLE1BQU0sSUFBSSxHQUFHLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRTtnQkFDeEMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsRUFBRTtvQkFDdkMsSUFBSSxRQUFRLElBQUksT0FBTyxRQUFRLEtBQUssUUFBUSxFQUFFO3dCQUM1QyxNQUFNLFdBQVcsR0FBRyxRQUFRLENBQUMsT0FBTyxDQUFDO3dCQUNyQyxJQUFJLFdBQVcsS0FBSyxjQUFjLEVBQUU7NEJBQ2xDLFFBQVEsQ0FBQyxNQUFNLEdBQUcsV0FBVyxDQUFDO3lCQUMvQjtxQkFDRjtnQkFDSCxDQUFDLENBQUMsQ0FBQzthQUNKO1FBQ0gsQ0FBQyxDQUFDLENBQUM7UUFFSCxpRUFBaUU7UUFDakUsSUFBSSxJQUFJLENBQUMsWUFBWSxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRTtZQUM3RixJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUMsUUFBUSxFQUFFLEVBQUU7Z0JBQzFELElBQUksUUFBUSxJQUFJLE9BQU8sUUFBUSxLQUFLLFFBQVEsRUFBRTtvQkFDNUMsTUFBTSxXQUFXLEdBQUcsUUFBUSxDQUFDLE9BQU8sQ0FBQztvQkFDckMsSUFBSSxXQUFXLEtBQUssY0FBYyxJQUFJLFdBQVcsS0FBSyxlQUFlLEVBQUU7d0JBQ3JFLFFBQVEsQ0FBQyxNQUFNLEdBQUcsV0FBVyxDQUFDO3FCQUMvQjtpQkFDRjtZQUNILENBQUMsQ0FBQyxDQUFDO1NBQ0o7UUFFRCxPQUFPLGlCQUFpQixDQUFDO0lBQzNCLENBQUM7SUFFTyxtQkFBbUIsQ0FBQyxXQUFxQyxFQUFFLFNBQWMsRUFBRSxRQUF3QztRQUN6SCxJQUFJLFdBQVcsSUFBSSxTQUFTLEVBQUU7WUFDNUIsSUFBSSxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLEdBQUc7Z0JBQ2xDLFFBQVEsRUFBRSxTQUFTLENBQUMsRUFBRTtnQkFDdEIsU0FBUztnQkFDVCxXQUFXO2dCQUNYLFFBQVE7YUFDVCxDQUFDO1NBQ0g7SUFDSCxDQUFDO0NBQ0YsQ0FBQTs7WUF6MkJvQyxhQUFhO1lBQXlCLGFBQWE7O0FBYjNFLGFBQWE7SUFEekIsVUFBVSxFQUFFO0dBQ0EsYUFBYSxDQXMzQnpCO1NBdDNCWSxhQUFhIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBpc09ic2VydmFibGUsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcclxuXHJcbmltcG9ydCAqIGFzIGlzZXF1YWxfIGZyb20gJ2xvZGFzaC5pc2VxdWFsJztcclxuY29uc3QgaXNlcXVhbCA9IGlzZXF1YWxfOyAvLyBwYXRjaCB0byBmaXggcm9sbHVwIHRvIHdvcmtcclxuXHJcbmltcG9ydCB7XHJcbiAgQ29sdW1uLFxyXG4gIENvbHVtbkZpbHRlcixcclxuICBDb2x1bW5GaWx0ZXJzLFxyXG4gIEN1cnJlbnRGaWx0ZXIsXHJcbiAgRW1pdHRlclR5cGUsXHJcbiAgRmllbGRUeXBlLFxyXG4gIEZpbHRlcixcclxuICBGaWx0ZXJBcmd1bWVudHMsXHJcbiAgRmlsdGVyQ2FsbGJhY2tBcmcsXHJcbiAgRmlsdGVyQ2hhbmdlZEFyZ3MsXHJcbiAgRmlsdGVyQ29uZGl0aW9uT3B0aW9uLFxyXG4gIEdyaWRPcHRpb24sXHJcbiAgS2V5Q29kZSxcclxuICBPcGVyYXRvclN0cmluZyxcclxuICBPcGVyYXRvclR5cGUsXHJcbiAgU2VhcmNoVGVybSxcclxuICBTbGlja0V2ZW50LFxyXG4gIFNsaWNrRXZlbnRIYW5kbGVyLFxyXG59IGZyb20gJy4vLi4vbW9kZWxzL2luZGV4JztcclxuaW1wb3J0IHsgZXhlY3V0ZUJhY2tlbmRDYWxsYmFjaywgcmVmcmVzaEJhY2tlbmREYXRhc2V0IH0gZnJvbSAnLi9iYWNrZW5kLXV0aWxpdGllcyc7XHJcbmltcG9ydCB7IGdldERlc2NlbmRhbnRQcm9wZXJ0eSB9IGZyb20gJy4vdXRpbGl0aWVzJztcclxuaW1wb3J0IHsgRmlsdGVyQ29uZGl0aW9ucyB9IGZyb20gJy4vLi4vZmlsdGVyLWNvbmRpdGlvbnMnO1xyXG5pbXBvcnQgeyBGaWx0ZXJGYWN0b3J5IH0gZnJvbSAnLi4vZmlsdGVycy9maWx0ZXJGYWN0b3J5JztcclxuaW1wb3J0IHsgU2hhcmVkU2VydmljZSB9IGZyb20gJy4vc2hhcmVkLnNlcnZpY2UnO1xyXG5cclxuLy8gdXNpbmcgZXh0ZXJuYWwgbm9uLXR5cGVkIGpzIGxpYnJhcmllc1xyXG5kZWNsYXJlIGNvbnN0IFNsaWNrOiBhbnk7XHJcbmRlY2xhcmUgY29uc3QgJDogYW55O1xyXG5cclxuLy8gdGltZXIgZm9yIGtlZXBpbmcgdHJhY2sgb2YgdXNlciB0eXBpbmcgd2FpdHNcclxubGV0IHRpbWVyOiBhbnk7XHJcbmNvbnN0IERFRkFVTFRfRklMVEVSX1RZUElOR19ERUJPVU5DRSA9IDUwMDtcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIEZpbHRlclNlcnZpY2Uge1xyXG4gIHByaXZhdGUgX2V2ZW50SGFuZGxlcjogU2xpY2tFdmVudEhhbmRsZXI7XHJcbiAgcHJpdmF0ZSBfaXNGaWx0ZXJGaXJzdFJlbmRlciA9IHRydWU7XHJcbiAgcHJpdmF0ZSBfZmlyc3RDb2x1bW5JZFJlbmRlcmVkID0gJyc7XHJcbiAgcHJpdmF0ZSBfZmlsdGVyc01ldGFkYXRhOiBhbnlbXSA9IFtdO1xyXG4gIHByaXZhdGUgX2NvbHVtbkZpbHRlcnM6IENvbHVtbkZpbHRlcnMgPSB7fTtcclxuICBwcml2YXRlIF9ncmlkOiBhbnk7XHJcbiAgcHJpdmF0ZSBfb25TZWFyY2hDaGFuZ2U6IFNsaWNrRXZlbnQgfCBudWxsO1xyXG4gIHByaXZhdGUgX3RtcFByZUZpbHRlcmVkRGF0YTogbnVtYmVyW107XHJcbiAgcHJpdmF0ZSBodHRwQ2FuY2VsUmVxdWVzdHMkOiBTdWJqZWN0PHZvaWQ+ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTsgLy8gdGhpcyB3aWxsIGJlIHVzZWQgdG8gY2FuY2VsIGFueSBwZW5kaW5nIGh0dHAgcmVxdWVzdFxyXG4gIG9uRmlsdGVyQ2hhbmdlZCA9IG5ldyBTdWJqZWN0PEN1cnJlbnRGaWx0ZXJbXT4oKTtcclxuICBvbkZpbHRlckNsZWFyZWQgPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xyXG5cclxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGZpbHRlckZhY3Rvcnk6IEZpbHRlckZhY3RvcnksIHByaXZhdGUgc2hhcmVkU2VydmljZTogU2hhcmVkU2VydmljZSkge1xyXG4gICAgdGhpcy5fZXZlbnRIYW5kbGVyID0gbmV3IFNsaWNrLkV2ZW50SGFuZGxlcigpO1xyXG4gICAgdGhpcy5fb25TZWFyY2hDaGFuZ2UgPSBuZXcgU2xpY2suRXZlbnQoKTtcclxuICB9XHJcblxyXG4gIC8qKiBHZXR0ZXIgb2YgdGhlIFNsaWNrR3JpZCBFdmVudCBIYW5kbGVyICovXHJcbiAgZ2V0IGV2ZW50SGFuZGxlcigpOiBTbGlja0V2ZW50SGFuZGxlciB7XHJcbiAgICByZXR1cm4gdGhpcy5fZXZlbnRIYW5kbGVyO1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldHRlciB0byBrbm93IGlmIHRoZSBmaWx0ZXIgd2FzIGFscmVhZHkgcmVuZGVyZWQgb3IgaWYgaXQgd2FzIGl0cyBmaXJzdCB0aW1lIHJlbmRlciAqL1xyXG4gIGdldCBpc0ZpbHRlckZpcnN0UmVuZGVyKCk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHRoaXMuX2lzRmlsdGVyRmlyc3RSZW5kZXI7XHJcbiAgfVxyXG5cclxuICAvKiogR2V0dGVyIG9mIHRoZSBTbGlja0dyaWQgRXZlbnQgSGFuZGxlciAqL1xyXG4gIGdldCBvblNlYXJjaENoYW5nZSgpOiBTbGlja0V2ZW50IHwgbnVsbCB7XHJcbiAgICByZXR1cm4gdGhpcy5fb25TZWFyY2hDaGFuZ2U7XHJcbiAgfVxyXG5cclxuICAvKiogR2V0dGVyIGZvciB0aGUgR3JpZCBPcHRpb25zIHB1bGxlZCB0aHJvdWdoIHRoZSBHcmlkIE9iamVjdCAqL1xyXG4gIHByaXZhdGUgZ2V0IF9ncmlkT3B0aW9ucygpOiBHcmlkT3B0aW9uIHtcclxuICAgIHJldHVybiAodGhpcy5fZ3JpZCAmJiB0aGlzLl9ncmlkLmdldE9wdGlvbnMpID8gdGhpcy5fZ3JpZC5nZXRPcHRpb25zKCkgOiB7fTtcclxuICB9XHJcblxyXG4gIC8qKiBHZXR0ZXIgZm9yIHRoZSBDb2x1bW4gRGVmaW5pdGlvbnMgcHVsbGVkIHRocm91Z2ggdGhlIEdyaWQgT2JqZWN0ICovXHJcbiAgcHJpdmF0ZSBnZXQgX2NvbHVtbkRlZmluaXRpb25zKCk6IENvbHVtbltdIHtcclxuICAgIHJldHVybiAodGhpcy5fZ3JpZCAmJiB0aGlzLl9ncmlkLmdldENvbHVtbnMpID8gdGhpcy5fZ3JpZC5nZXRDb2x1bW5zKCkgOiBbXTtcclxuICB9XHJcblxyXG4gIC8qKiBHZXR0ZXIgb2YgU2xpY2tHcmlkIERhdGFWaWV3IG9iamVjdCAqL1xyXG4gIHByaXZhdGUgZ2V0IF9kYXRhVmlldygpOiBhbnkge1xyXG4gICAgcmV0dXJuICh0aGlzLl9ncmlkICYmIHRoaXMuX2dyaWQuZ2V0RGF0YSkgPyB0aGlzLl9ncmlkLmdldERhdGEoKSA6IHt9O1xyXG4gIH1cclxuXHJcbiAgaW5pdChncmlkOiBhbnkpOiB2b2lkIHtcclxuICAgIHRoaXMuX2dyaWQgPSBncmlkO1xyXG5cclxuICAgIGlmICh0aGlzLl9ncmlkT3B0aW9ucyAmJiB0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVUcmVlRGF0YSAmJiB0aGlzLl9ncmlkT3B0aW9ucy50cmVlRGF0YU9wdGlvbnMpIHtcclxuICAgICAgdGhpcy5fZ3JpZC5zZXRTb3J0Q29sdW1ucyhbeyBjb2x1bW5JZDogdGhpcy5fZ3JpZE9wdGlvbnMudHJlZURhdGFPcHRpb25zLmNvbHVtbklkLCBzb3J0QXNjOiB0cnVlIH1dKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGRpc3Bvc2UoKSB7XHJcbiAgICAvLyB1bnN1YnNjcmliZSBhbGwgU2xpY2tHcmlkIGV2ZW50c1xyXG4gICAgaWYgKHRoaXMuX2V2ZW50SGFuZGxlciAmJiB0aGlzLl9ldmVudEhhbmRsZXIudW5zdWJzY3JpYmVBbGwpIHtcclxuICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyLnVuc3Vic2NyaWJlQWxsKCk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNPYnNlcnZhYmxlKHRoaXMuaHR0cENhbmNlbFJlcXVlc3RzJCkpIHtcclxuICAgICAgdGhpcy5odHRwQ2FuY2VsUmVxdWVzdHMkLm5leHQoKTsgLy8gdGhpcyBjYW5jZWxzIGFueSBwZW5kaW5nIGh0dHAgcmVxdWVzdHNcclxuICAgIH1cclxuICAgIHRoaXMuZGlzcG9zZUNvbHVtbkZpbHRlcnMoKTtcclxuICAgIHRoaXMuX29uU2VhcmNoQ2hhbmdlID0gbnVsbDtcclxuICAgIHRoaXMuYWRkRmlsdGVyVGVtcGxhdGVUb0hlYWRlclJvdyA9IG51bGw7XHJcbiAgICB0aGlzLmN1c3RvbUxvY2FsRmlsdGVyID0gbnVsbDtcclxuICAgIHRoaXMuY2FsbGJhY2tTZWFyY2hFdmVudCA9IG51bGw7XHJcbiAgICB0aGlzLmhhbmRsZUJhY2tlbmRPblNlYXJjaENoYW5nZSA9IG51bGw7XHJcbiAgICB0aGlzLmhhbmRsZUxvY2FsT25TZWFyY2hDaGFuZ2UgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGlzcG9zZSBvZiB0aGUgZmlsdGVycywgc2luY2UgaXQncyBhIHNpbmdsZXRvbiwgd2UgZG9uJ3Qgd2FudCB0byBhZmZlY3Qgb3RoZXIgZ3JpZHMgd2l0aCBzYW1lIGNvbHVtbnNcclxuICAgKi9cclxuICBkaXNwb3NlQ29sdW1uRmlsdGVycygpIHtcclxuICAgIC8vIHdlIG5lZWQgdG8gbG9vcCB0aHJvdWdoIGFsbCBjb2x1bW5GaWx0ZXJzIGFuZCBkZWxldGUgdGhlbSAxIGJ5IDFcclxuICAgIC8vIG9ubHkgdHJ5aW5nIHRvIG1ha2UgY29sdW1uRmlsdGVyIGFuIGVtcHR5ICh3aXRob3V0IGxvb3BpbmcpIHdvdWxkIG5vdCB0cmlnZ2VyIGEgZGF0YXNldCBjaGFuZ2VcclxuICAgIGlmICh0eXBlb2YgdGhpcy5fY29sdW1uRmlsdGVycyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgZm9yIChjb25zdCBjb2x1bW5JZCBpbiB0aGlzLl9jb2x1bW5GaWx0ZXJzKSB7XHJcbiAgICAgICAgaWYgKGNvbHVtbklkICYmIHRoaXMuX2NvbHVtbkZpbHRlcnNbY29sdW1uSWRdKSB7XHJcbiAgICAgICAgICBkZWxldGUgdGhpcy5fY29sdW1uRmlsdGVyc1tjb2x1bW5JZF07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWxzbyBkZXN0cm95IGVhY2ggRmlsdGVyIGluc3RhbmNlc1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5fZmlsdGVyc01ldGFkYXRhKSkge1xyXG4gICAgICB0aGlzLl9maWx0ZXJzTWV0YWRhdGEuZm9yRWFjaCgoZmlsdGVyKSA9PiB7XHJcbiAgICAgICAgaWYgKGZpbHRlciAmJiBmaWx0ZXIuZGVzdHJveSkge1xyXG4gICAgICAgICAgZmlsdGVyLmRlc3Ryb3kodHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIHRoaXMuX2ZpbHRlcnNNZXRhZGF0YSA9IFtdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogV2hlbiBjbGVhcmluZyBvciBkaXNwb3Npbmcgb2YgYWxsIGZpbHRlcnMsIHdlIG5lZWQgdG8gbG9vcCB0aHJvdWdoIGFsbCBjb2x1bW5GaWx0ZXJzIGFuZCBkZWxldGUgdGhlbSAxIGJ5IDFcclxuICAgKiBvbmx5IHRyeWluZyB0byBtYWtlIGNvbHVtbkZpbHRlciBhbiBlbXB0eSAod2l0aG91dCBsb29waW5nKSB3b3VsZCBub3QgdHJpZ2dlciBhIGRhdGFzZXQgY2hhbmdlXHJcbiAgICovXHJcbiAgcmVzZXRDb2x1bW5GaWx0ZXJzKCkge1xyXG4gICAgaWYgKHR5cGVvZiB0aGlzLl9jb2x1bW5GaWx0ZXJzID09PSAnb2JqZWN0Jykge1xyXG4gICAgICBmb3IgKGNvbnN0IGNvbHVtbklkIGluIHRoaXMuX2NvbHVtbkZpbHRlcnMpIHtcclxuICAgICAgICBpZiAoY29sdW1uSWQgJiYgdGhpcy5fY29sdW1uRmlsdGVyc1tjb2x1bW5JZF0pIHtcclxuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jb2x1bW5GaWx0ZXJzW2NvbHVtbklkXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEJpbmQgYSBiYWNrZW5kIGZpbHRlciBob29rIHRvIHRoZSBncmlkXHJcbiAgICogQHBhcmFtIGdyaWQgU2xpY2tHcmlkIEdyaWQgb2JqZWN0XHJcbiAgICovXHJcbiAgYmluZEJhY2tlbmRPbkZpbHRlcihncmlkOiBhbnkpIHtcclxuICAgIHRoaXMuX2ZpbHRlcnNNZXRhZGF0YSA9IFtdO1xyXG5cclxuICAgIC8vIHN1YnNjcmliZSB0byBTbGlja0dyaWQgb25IZWFkZXJSb3dDZWxsUmVuZGVyZWQgZXZlbnQgdG8gY3JlYXRlIGZpbHRlciB0ZW1wbGF0ZVxyXG4gICAgdGhpcy5fZXZlbnRIYW5kbGVyLnN1YnNjcmliZShncmlkLm9uSGVhZGVyUm93Q2VsbFJlbmRlcmVkLCB0aGlzLmhhbmRsZUJhY2tlbmRPblNlYXJjaENoYW5nZS5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAvLyBzdWJzY3JpYmUgdG8gdGhlIFNsaWNrR3JpZCBldmVudCBhbmQgY2FsbCB0aGUgYmFja2VuZCBleGVjdXRpb25cclxuICAgIGlmICh0aGlzLl9vblNlYXJjaENoYW5nZSkge1xyXG4gICAgICB0aGlzLl9ldmVudEhhbmRsZXIuc3Vic2NyaWJlKHRoaXMuX29uU2VhcmNoQ2hhbmdlLCB0aGlzLm9uQmFja2VuZEZpbHRlckNoYW5nZS5iaW5kKHRoaXMpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGhhbmRsZUJhY2tlbmRPblNlYXJjaENoYW5nZShfZTogS2V5Ym9hcmRFdmVudCwgYXJnczogYW55KSB7XHJcbiAgICAvLyBmaXJzdENvbHVtbklkUmVuZGVyZWQgaXMgbnVsbCBhdCBmaXJzdCwgc28gaWYgaXQgY2hhbmdlcyB0byBiZWluZyBmaWxsZWQgYW5kIGVxdWFsLCB0aGVuIHdlIHdvdWxkIGtub3cgdGhhdCBpdCB3YXMgYWxyZWFkeSByZW5kZXJlZFxyXG4gICAgLy8gdGhpcyBpcyB0byBhdm9pZCByZW5kZXJpbmcgdGhlIGZpbHRlciB0d2ljZSAob25seSB0aGUgU2VsZWN0IEZpbHRlciBmb3Igbm93KSwgcmVuZGVyaW5nIGl0IGFnYWluIGFsc28gY2xlYXJzIHRoZSBmaWx0ZXIgd2hpY2ggaGFzIHVud2FudGVkIHNpZGUgZWZmZWN0XHJcbiAgICBpZiAoYXJncy5jb2x1bW4uaWQgPT09IHRoaXMuX2ZpcnN0Q29sdW1uSWRSZW5kZXJlZCkge1xyXG4gICAgICB0aGlzLl9pc0ZpbHRlckZpcnN0UmVuZGVyID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB0aGlzLmFkZEZpbHRlclRlbXBsYXRlVG9IZWFkZXJSb3cobnVsbCwgYXJncywgdGhpcy5faXNGaWx0ZXJGaXJzdFJlbmRlcik7XHJcbiAgICBpZiAodGhpcy5fZmlyc3RDb2x1bW5JZFJlbmRlcmVkID09PSAnJykge1xyXG4gICAgICB0aGlzLl9maXJzdENvbHVtbklkUmVuZGVyZWQgPSBhcmdzLmNvbHVtbi5pZDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEJpbmQgYSBsb2NhbCBmaWx0ZXIgaG9vayB0byB0aGUgZ3JpZFxyXG4gICAqIEBwYXJhbSBncmlkIFNsaWNrR3JpZCBHcmlkIG9iamVjdFxyXG4gICAqIEBwYXJhbSBkYXRhVmlld1xyXG4gICAqL1xyXG4gIGJpbmRMb2NhbE9uRmlsdGVyKGdyaWQ6IGFueSkge1xyXG4gICAgdGhpcy5fZmlsdGVyc01ldGFkYXRhID0gW107XHJcblxyXG4gICAgdGhpcy5fZGF0YVZpZXcuc2V0RmlsdGVyQXJncyh7IGNvbHVtbkZpbHRlcnM6IHRoaXMuX2NvbHVtbkZpbHRlcnMsIGdyaWQ6IHRoaXMuX2dyaWQsIGRhdGFWaWV3OiB0aGlzLl9kYXRhVmlldyB9KTtcclxuICAgIHRoaXMuX2RhdGFWaWV3LnNldEZpbHRlcih0aGlzLmN1c3RvbUxvY2FsRmlsdGVyLmJpbmQodGhpcykpO1xyXG5cclxuICAgIC8vIGJpbmQgYW55IHNlYXJjaCBmaWx0ZXIgY2hhbmdlIChlLmcuIGlucHV0IGZpbHRlciBpbnB1dCBjaGFuZ2UgZXZlbnQpXHJcbiAgICBpZiAodGhpcy5fb25TZWFyY2hDaGFuZ2UpIHtcclxuICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyLnN1YnNjcmliZSh0aGlzLl9vblNlYXJjaENoYW5nZSwgdGhpcy5oYW5kbGVMb2NhbE9uU2VhcmNoQ2hhbmdlLmJpbmQodGhpcykpO1xyXG5cclxuICAgICAgLy8gc3Vic2NyaWJlIHRvIFNsaWNrR3JpZCBvbkhlYWRlclJvd0NlbGxSZW5kZXJlZCBldmVudCB0byBjcmVhdGUgZmlsdGVyIHRlbXBsYXRlXHJcbiAgICAgIHRoaXMuX2V2ZW50SGFuZGxlci5zdWJzY3JpYmUoZ3JpZC5vbkhlYWRlclJvd0NlbGxSZW5kZXJlZCwgdGhpcy5hZGRGaWx0ZXJUZW1wbGF0ZVRvSGVhZGVyUm93LmJpbmQodGhpcykpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaGFuZGxlTG9jYWxPblNlYXJjaENoYW5nZShfZTogS2V5Ym9hcmRFdmVudCwgYXJnczogYW55KSB7XHJcbiAgICBjb25zdCBpc0dyaWRXaXRoVHJlZURhdGEgPSB0aGlzLl9ncmlkT3B0aW9ucyAmJiB0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVUcmVlRGF0YSB8fCBmYWxzZTtcclxuXHJcbiAgICAvLyBXaGVuIHVzaW5nIFRyZWUgRGF0YSwgd2UgbmVlZCB0byBkbyBpdCBpbiAyIHN0ZXBzXHJcbiAgICAvLyBzdGVwIDEuIHdlIG5lZWQgdG8gcHJlZmlsdGVyIChzZWFyY2gpIHRoZSBkYXRhIHByaW9yLCB0aGUgcmVzdWx0IHdpbGwgYmUgYW4gYXJyYXkgb2YgSURzIHdoaWNoIGFyZSB0aGUgbm9kZShzKSBhbmQgdGhlaXIgcGFyZW50IG5vZGVzIHdoZW4gbmVjZXNzYXJ5LlxyXG4gICAgLy8gc3RlcCAyLiBjYWxsaW5nIHRoZSBEYXRhVmlldy5yZWZyZXNoKCkgaXMgd2hhdCB0cmlnZ2VycyB0aGUgZmluYWwgZmlsdGVyaW5nLCB3aXRoIFwiY3VzdG9tTG9jYWxGaWx0ZXIoKVwiIHdoaWNoIHdpbGwgZGVjaWRlIHdoaWNoIHJvd3Mgc2hvdWxkIHBlcnNpc3RcclxuICAgIGlmIChpc0dyaWRXaXRoVHJlZURhdGEpIHtcclxuICAgICAgdGhpcy5fdG1wUHJlRmlsdGVyZWREYXRhID0gdGhpcy5wcmVGaWx0ZXJUcmVlRGF0YSh0aGlzLl9kYXRhVmlldy5nZXRJdGVtcygpLCB0aGlzLl9jb2x1bW5GaWx0ZXJzKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjb2x1bW5JZCA9IGFyZ3MuY29sdW1uSWQ7XHJcbiAgICBpZiAoY29sdW1uSWQgIT09IG51bGwpIHtcclxuICAgICAgdGhpcy5fZGF0YVZpZXcucmVmcmVzaCgpO1xyXG4gICAgfVxyXG4gICAgLy8gZW1pdCBhbiBvbkZpbHRlckNoYW5nZWQgZXZlbnQgd2hlbiBpdCdzIG5vdCBjYWxsZWQgYnkgYSBjbGVhciBmaWx0ZXJcclxuICAgIGlmIChhcmdzICYmICFhcmdzLmNsZWFyRmlsdGVyVHJpZ2dlcmVkKSB7XHJcbiAgICAgIHRoaXMuZW1pdEZpbHRlckNoYW5nZWQoRW1pdHRlclR5cGUubG9jYWwpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY2xlYXJGaWx0ZXJCeUNvbHVtbklkKGV2ZW50OiBFdmVudCwgY29sdW1uSWQ6IG51bWJlciB8IHN0cmluZykge1xyXG4gICAgLy8gZ2V0IGN1cnJlbnQgY29sdW1uIGZpbHRlciBiZWZvcmUgY2xlYXJpbmcsIHRoaXMgYWxsb3cgdXMgdG8ga25vdyBpZiB0aGUgZmlsdGVyIHdhcyBlbXB0eSBwcmlvciB0byBjYWxsaW5nIHRoZSBjbGVhciBmaWx0ZXJcclxuICAgIGNvbnN0IGN1cnJlbnRDb2x1bW5GaWx0ZXJzID0gT2JqZWN0LmtleXModGhpcy5fY29sdW1uRmlsdGVycykgYXMgQ29sdW1uRmlsdGVyW107XHJcbiAgICBsZXQgY3VycmVudENvbEZpbHRlcjogQ29sdW1uRmlsdGVyO1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudENvbHVtbkZpbHRlcnMpKSB7XHJcbiAgICAgIGN1cnJlbnRDb2xGaWx0ZXIgPSBjdXJyZW50Q29sdW1uRmlsdGVycy5maW5kKChuYW1lKSA9PiBuYW1lID09PSBjb2x1bW5JZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZmluZCB0aGUgZmlsdGVyIG9iamVjdCBhbmQgY2FsbCBpdHMgY2xlYXIgbWV0aG9kIHdpdGggdHJ1ZSAodGhlIGFyZ3VtZW50IHRlbGxzIHRoZSBtZXRob2QgaXQgd2FzIGNhbGxlZCBieSBhIGNsZWFyIGZpbHRlcilcclxuICAgIGNvbnN0IGNvbEZpbHRlcjogRmlsdGVyID0gdGhpcy5fZmlsdGVyc01ldGFkYXRhLmZpbmQoKGZpbHRlcjogRmlsdGVyKSA9PiBmaWx0ZXIuY29sdW1uRGVmLmlkID09PSBjb2x1bW5JZCk7XHJcbiAgICBpZiAoY29sRmlsdGVyICYmIGNvbEZpbHRlci5jbGVhcikge1xyXG4gICAgICBjb2xGaWx0ZXIuY2xlYXIodHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGVtaXR0ZXI6IEVtaXR0ZXJUeXBlID0gRW1pdHRlclR5cGUubG9jYWw7XHJcbiAgICBjb25zdCBpc0JhY2tlbmRBcGkgPSB0aGlzLl9ncmlkT3B0aW9ucyAmJiB0aGlzLl9ncmlkT3B0aW9ucy5iYWNrZW5kU2VydmljZUFwaSB8fCBmYWxzZTtcclxuXHJcbiAgICAvLyB3aGVuIHVzaW5nIGEgYmFja2VuZCBzZXJ2aWNlLCB3ZSBuZWVkIHRvIG1hbnVhbGx5IHRyaWdnZXIgYSBmaWx0ZXIgY2hhbmdlIGJ1dCBvbmx5IGlmIHRoZSBmaWx0ZXIgd2FzIHByZXZpb3VzbHkgZmlsbGVkXHJcbiAgICBpZiAoaXNCYWNrZW5kQXBpKSB7XHJcbiAgICAgIGVtaXR0ZXIgPSBFbWl0dGVyVHlwZS5yZW1vdGU7XHJcbiAgICAgIGlmIChjdXJyZW50Q29sRmlsdGVyKSB7XHJcbiAgICAgICAgdGhpcy5vbkJhY2tlbmRGaWx0ZXJDaGFuZ2UoZXZlbnQgYXMgS2V5Ym9hcmRFdmVudCwgeyBncmlkOiB0aGlzLl9ncmlkLCBjb2x1bW5GaWx0ZXJzOiB0aGlzLl9jb2x1bW5GaWx0ZXJzIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZW1pdCBhbiBldmVudCB3aGVuIGZpbHRlciBpcyBjbGVhcmVkXHJcbiAgICB0aGlzLmVtaXRGaWx0ZXJDaGFuZ2VkKGVtaXR0ZXIpO1xyXG4gIH1cclxuXHJcbiAgLyoqIENsZWFyIHRoZSBzZWFyY2ggZmlsdGVycyAoYmVsb3cgdGhlIGNvbHVtbiB0aXRsZXMpICovXHJcbiAgY2xlYXJGaWx0ZXJzKHRyaWdnZXJDaGFuZ2UgPSB0cnVlKSB7XHJcbiAgICB0aGlzLl9maWx0ZXJzTWV0YWRhdGEuZm9yRWFjaCgoZmlsdGVyOiBGaWx0ZXIpID0+IHtcclxuICAgICAgaWYgKGZpbHRlciAmJiBmaWx0ZXIuY2xlYXIpIHtcclxuICAgICAgICAvLyBjbGVhciBlbGVtZW50IGJ1dCBkb24ndCB0cmlnZ2VyIGluZGl2aWR1YWwgY2xlYXIgY2hhbmdlLFxyXG4gICAgICAgIC8vIHdlJ2xsIGRvIDEgdHJpZ2dlciBmb3IgYWxsIGZpbHRlcnMgYXQgb25jZSBhZnRlcndhcmRcclxuICAgICAgICBmaWx0ZXIuY2xlYXIoZmFsc2UpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBhbHNvIHJlc2V0IHRoZSBjb2x1bW5GaWx0ZXJzIG9iamVjdCBhbmQgcmVtb3ZlIGFueSBmaWx0ZXJzIGZyb20gdGhlIG9iamVjdFxyXG4gICAgdGhpcy5yZXNldENvbHVtbkZpbHRlcnMoKTtcclxuXHJcbiAgICAvLyB3ZSBhbHNvIG5lZWQgdG8gcmVmcmVzaCB0aGUgZGF0YVZpZXcgYW5kIG9wdGlvbmFsbHkgdGhlIGdyaWQgKGl0J3Mgb3B0aW9uYWwgc2luY2Ugd2UgdXNlIERhdGFWaWV3KVxyXG4gICAgaWYgKHRoaXMuX2RhdGFWaWV3ICYmIHRoaXMuX2dyaWQpIHtcclxuICAgICAgdGhpcy5fZGF0YVZpZXcucmVmcmVzaCgpO1xyXG4gICAgICB0aGlzLl9ncmlkLmludmFsaWRhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB3aGVuIHVzaW5nIGJhY2tlbmQgc2VydmljZSwgd2UgbmVlZCB0byBxdWVyeSBvbmx5IG9uY2Ugc28gaXQncyBiZXR0ZXIgdG8gZG8gaXQgaGVyZVxyXG4gICAgY29uc3QgYmFja2VuZEFwaSA9IHRoaXMuX2dyaWRPcHRpb25zICYmIHRoaXMuX2dyaWRPcHRpb25zLmJhY2tlbmRTZXJ2aWNlQXBpO1xyXG4gICAgaWYgKGJhY2tlbmRBcGkgJiYgdHJpZ2dlckNoYW5nZSkge1xyXG4gICAgICBjb25zdCBjYWxsYmFja0FyZ3MgPSB7IGNsZWFyRmlsdGVyVHJpZ2dlcmVkOiB0cnVlLCBzaG91bGRUcmlnZ2VyUXVlcnk6IHRyaWdnZXJDaGFuZ2UsIGdyaWQ6IHRoaXMuX2dyaWQsIGNvbHVtbkZpbHRlcnM6IHRoaXMuX2NvbHVtbkZpbHRlcnMgfTtcclxuICAgICAgY29uc3QgcXVlcnlSZXNwb25zZSA9IGJhY2tlbmRBcGkuc2VydmljZS5wcm9jZXNzT25GaWx0ZXJDaGFuZ2VkKHVuZGVmaW5lZCwgY2FsbGJhY2tBcmdzIGFzIEZpbHRlckNoYW5nZWRBcmdzKTtcclxuICAgICAgaWYgKHF1ZXJ5UmVzcG9uc2UgaW5zdGFuY2VvZiBQcm9taXNlICYmIHF1ZXJ5UmVzcG9uc2UudGhlbikge1xyXG4gICAgICAgIC8vIEBkZXByZWNhdGVkLCBwcm9jZXNzT25GaWx0ZXJDaGFuZ2VkIGluIHRoZSBmdXR1cmUgc2hvdWxkIGJlIHJldHVybmVkIGFzIGEgcXVlcnkgc3RyaW5nIE5PVCBhcyBhIFByb21pc2VcclxuICAgICAgICBjb25zb2xlLndhcm4oYFtBbmd1bGFyLVNsaWNrZ3JpZF0gcGxlYXNlIG5vdGUgdGhhdCB0aGUgXCJwcm9jZXNzT25GaWx0ZXJDaGFuZ2VkXCIgZnJvbSB5b3VyIEJhY2tlbmQgU2VydmljZSwgc2hvdWxkIG5vdyByZXR1cm4gYSBzdHJpbmcgaW5zdGVhZCBvZiBhIFByb21pc2UuXHJcbiAgICAgICAgICBSZXR1cm5pbmcgYSBQcm9taXNlIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiB0aGUgZnV0dXJlLmApO1xyXG4gICAgICAgIHF1ZXJ5UmVzcG9uc2UudGhlbigocXVlcnk6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgY29uc3QgdG90YWxJdGVtcyA9IHRoaXMuX2dyaWRPcHRpb25zICYmIHRoaXMuX2dyaWRPcHRpb25zLnBhZ2luYXRpb24gJiYgdGhpcy5fZ3JpZE9wdGlvbnMucGFnaW5hdGlvbi50b3RhbEl0ZW1zO1xyXG4gICAgICAgICAgZXhlY3V0ZUJhY2tlbmRDYWxsYmFjayhiYWNrZW5kQXBpLCBxdWVyeSwgY2FsbGJhY2tBcmdzLCBuZXcgRGF0ZSgpLCB0b3RhbEl0ZW1zLCB0aGlzLmVtaXRGaWx0ZXJDaGFuZ2VkLmJpbmQodGhpcykpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gcXVlcnlSZXNwb25zZSBhcyBzdHJpbmc7XHJcbiAgICAgICAgY29uc3QgdG90YWxJdGVtcyA9IHRoaXMuX2dyaWRPcHRpb25zICYmIHRoaXMuX2dyaWRPcHRpb25zLnBhZ2luYXRpb24gJiYgdGhpcy5fZ3JpZE9wdGlvbnMucGFnaW5hdGlvbi50b3RhbEl0ZW1zO1xyXG4gICAgICAgIGV4ZWN1dGVCYWNrZW5kQ2FsbGJhY2soYmFja2VuZEFwaSwgcXVlcnksIGNhbGxiYWNrQXJncywgbmV3IERhdGUoKSwgdG90YWxJdGVtcywgdGhpcy5lbWl0RmlsdGVyQ2hhbmdlZC5iaW5kKHRoaXMpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGVtaXQgYW4gZXZlbnQgd2hlbiBmaWx0ZXJzIGFyZSBhbGwgY2xlYXJlZFxyXG4gICAgaWYgKHRyaWdnZXJDaGFuZ2UpIHtcclxuICAgICAgdGhpcy5vbkZpbHRlckNsZWFyZWQubmV4dCh0cnVlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKiBMb2NhbCBHcmlkIEZpbHRlciBzZWFyY2ggKi9cclxuICBjdXN0b21Mb2NhbEZpbHRlcihpdGVtOiBhbnksIGFyZ3M6IGFueSk6IGJvb2xlYW4ge1xyXG4gICAgY29uc3QgZGF0YVZpZXcgPSBhcmdzICYmIGFyZ3MuZGF0YVZpZXc7XHJcbiAgICBjb25zdCBncmlkID0gYXJncyAmJiBhcmdzLmdyaWQ7XHJcbiAgICBjb25zdCBpc0dyaWRXaXRoVHJlZURhdGEgPSB0aGlzLl9ncmlkT3B0aW9ucyAmJiB0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVUcmVlRGF0YSB8fCBmYWxzZTtcclxuICAgIGNvbnN0IGNvbHVtbkZpbHRlcnMgPSBhcmdzICYmIGFyZ3MuY29sdW1uRmlsdGVycyB8fCB7fTtcclxuICAgIGxldCB0cmVlRGF0YU9wdGlvbnM7XHJcblxyXG4gICAgLy8gd2hlbiB0aGUgY29sdW1uIGlzIGEgVHJlZSBEYXRhIHN0cnVjdHVyZSBhbmQgdGhlIHBhcmVudCBpcyBjb2xsYXBzZWQsIHdlIHdvbid0IGdvIGZ1cnRoZXIgYW5kIGp1c3QgY29udGludWUgd2l0aCBuZXh0IHJvd1xyXG4gICAgLy8gc28gd2UgYWx3YXlzIHJ1biB0aGlzIGNoZWNrIGV2ZW4gd2hlbiB0aGVyZSBhcmUgbm8gZmlsdGVyIHNlYXJjaCwgdGhlIHJlYXNvbiBpcyBiZWNhdXNlIHRoZSB1c2VyIG1pZ2h0IGNsaWNrIG9uIHRoZSBleHBhbmQvY29sbGFwc2VcclxuICAgIGlmIChpc0dyaWRXaXRoVHJlZURhdGEgJiYgdGhpcy5fZ3JpZE9wdGlvbnMgJiYgdGhpcy5fZ3JpZE9wdGlvbnMudHJlZURhdGFPcHRpb25zKSB7XHJcbiAgICAgIHRyZWVEYXRhT3B0aW9ucyA9IHRoaXMuX2dyaWRPcHRpb25zLnRyZWVEYXRhT3B0aW9ucztcclxuICAgICAgY29uc3QgY29sbGFwc2VkUHJvcE5hbWUgPSB0cmVlRGF0YU9wdGlvbnMuY29sbGFwc2VkUHJvcE5hbWUgfHwgJ19fY29sbGFwc2VkJztcclxuICAgICAgY29uc3QgcGFyZW50UHJvcE5hbWUgPSB0cmVlRGF0YU9wdGlvbnMucGFyZW50UHJvcE5hbWUgfHwgJ19fcGFyZW50SWQnO1xyXG4gICAgICBjb25zdCBkYXRhVmlld0lkSWRlbnRpZmllciA9IHRoaXMuX2dyaWRPcHRpb25zLmRhdGFzZXRJZFByb3BlcnR5TmFtZSB8fCAnaWQnO1xyXG5cclxuICAgICAgaWYgKGl0ZW1bcGFyZW50UHJvcE5hbWVdICE9PSBudWxsKSB7XHJcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMuX2RhdGFWaWV3LmdldEl0ZW1CeUlkKGl0ZW1bcGFyZW50UHJvcE5hbWVdKTtcclxuICAgICAgICB3aGlsZSAocGFyZW50KSB7XHJcbiAgICAgICAgICBpZiAocGFyZW50W2NvbGxhcHNlZFByb3BOYW1lXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIGRvbid0IGRpc3BsYXkgYW55IHJvdyB0aGF0IGhhdmUgdGhlaXIgcGFyZW50IGNvbGxhcHNlZFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcGFyZW50ID0gdGhpcy5fZGF0YVZpZXcuZ2V0SXRlbUJ5SWQocGFyZW50W3BhcmVudFByb3BOYW1lXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBmaWx0ZXIgb3V0IGFueSByb3cgaXRlbXMgdGhhdCBhcmVuJ3QgcGFydCBvZiBvdXIgcHJlLXByb2Nlc3NlZCBcInByZUZpbHRlclRyZWVEYXRhKClcIiByZXN1bHRcclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5fdG1wUHJlRmlsdGVyZWREYXRhKSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90bXBQcmVGaWx0ZXJlZERhdGEuaW5jbHVkZXMoaXRlbVtkYXRhVmlld0lkSWRlbnRpZmllcl0pOyAvLyByZXR1cm4gdHJ1ZSB3aGVuIGZvdW5kLCBmYWxzZSBvdGhlcndpc2VcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHR5cGVvZiBjb2x1bW5GaWx0ZXJzID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGZvciAoY29uc3QgY29sdW1uSWQgb2YgT2JqZWN0LmtleXMoY29sdW1uRmlsdGVycykpIHtcclxuICAgICAgICAgIGNvbnN0IGNvbHVtbkZpbHRlciA9IGNvbHVtbkZpbHRlcnNbY29sdW1uSWRdIGFzIENvbHVtbkZpbHRlcjtcclxuICAgICAgICAgIGNvbnN0IGNvbmRpdGlvbk9wdGlvbnMgPSB0aGlzLmdldEZpbHRlckNvbmRpdGlvbk9wdGlvbnNPckJvb2xlYW4oaXRlbSwgY29sdW1uRmlsdGVyLCBjb2x1bW5JZCwgZ3JpZCwgZGF0YVZpZXcpO1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiBjb25kaXRpb25PcHRpb25zID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbmRpdGlvbk9wdGlvbnM7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKCFGaWx0ZXJDb25kaXRpb25zLmV4ZWN1dGVNYXBwZWRDb25kaXRpb24oY29uZGl0aW9uT3B0aW9ucyBhcyBGaWx0ZXJDb25kaXRpb25PcHRpb24pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBpZiBpdCByZWFjaGVzIGhlcmUsIHRoYXQgbWVhbnMgdGhlIHJvdyBpcyB2YWxpZCBhbmQgcGFzc2VkIGFsbCBmaWx0ZXJcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgZ2V0RmlsdGVyQ29uZGl0aW9uT3B0aW9uc09yQm9vbGVhbihpdGVtOiBhbnksIGNvbHVtbkZpbHRlcjogQ29sdW1uRmlsdGVyLCBjb2x1bW5JZDogc3RyaW5nIHwgbnVtYmVyLCBncmlkOiBhbnksIGRhdGFWaWV3OiBhbnkpOiBGaWx0ZXJDb25kaXRpb25PcHRpb24gfCBib29sZWFuIHtcclxuICAgIGxldCBjb2x1bW5JbmRleCA9IGdyaWQuZ2V0Q29sdW1uSW5kZXgoY29sdW1uSWQpIGFzIG51bWJlcjtcclxuICAgIGxldCBjb2x1bW5EZWYgPSBncmlkLmdldENvbHVtbnMoKVtjb2x1bW5JbmRleF0gYXMgQ29sdW1uO1xyXG5cclxuICAgIC8vIGl0IG1pZ2h0IGJlIGEgaGlkZGVuIGNvbHVtbiwgaWYgc28gaXQgd29uJ3QgYmUgcGFydCBvZiB0aGUgZ2V0Q29sdW1ucyAoYmVjYXVzZSBpdCB3ZSBoaWRlIGEgY29sdW1uIHZpYSBzZXRDb2x1bW5zKVxyXG4gICAgLy8gd2hlbiB0aGF0IGhhcHBlbnMgd2UgY2FuIHRyeSB0byBnZXQgdGhlIGNvbHVtbiBkZWZpbml0aW9uIGZyb20gYWxsIGRlZmluZWQgY29sdW1uc1xyXG4gICAgaWYgKCFjb2x1bW5EZWYgJiYgdGhpcy5zaGFyZWRTZXJ2aWNlICYmIEFycmF5LmlzQXJyYXkodGhpcy5zaGFyZWRTZXJ2aWNlLmFsbENvbHVtbnMpKSB7XHJcbiAgICAgIGNvbHVtbkluZGV4ID0gdGhpcy5zaGFyZWRTZXJ2aWNlLmFsbENvbHVtbnMuZmluZEluZGV4KChjb2wpID0+IGNvbC5maWVsZCA9PT0gY29sdW1uSWQpO1xyXG4gICAgICBjb2x1bW5EZWYgPSB0aGlzLnNoYXJlZFNlcnZpY2UuYWxsQ29sdW1uc1tjb2x1bW5JbmRleF07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaWYgd2Ugc3RpbGwgZG9uJ3QgaGF2ZSBhIGNvbHVtbiBkZWZpbml0aW9uIHRoZW4gd2Ugc2hvdWxkIHJldHVybiB0aGVuIHJvdyBhbnl3YXkgKHRydWUpXHJcbiAgICBpZiAoIWNvbHVtbkRlZikge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSb3cgRGV0YWlsIFZpZXcgcGx1Z2luLCBpZiB0aGUgcm93IGlzIHBhZGRpbmcgd2UganVzdCBnZXQgdGhlIHZhbHVlIHdlJ3JlIGZpbHRlcmluZyBvbiBmcm9tIGl0J3MgcGFyZW50XHJcbiAgICBpZiAodGhpcy5fZ3JpZE9wdGlvbnMuZW5hYmxlUm93RGV0YWlsVmlldykge1xyXG4gICAgICBjb25zdCBtZXRhZGF0YVByZWZpeCA9IHRoaXMuX2dyaWRPcHRpb25zLnJvd0RldGFpbFZpZXcgJiYgdGhpcy5fZ3JpZE9wdGlvbnMucm93RGV0YWlsVmlldy5rZXlQcmVmaXggfHwgJ19fJztcclxuICAgICAgaWYgKGl0ZW1bYCR7bWV0YWRhdGFQcmVmaXh9aXNQYWRkaW5nYF0gJiYgaXRlbVtgJHttZXRhZGF0YVByZWZpeH1wYXJlbnRgXSkge1xyXG4gICAgICAgIGl0ZW0gPSBpdGVtW2Ake21ldGFkYXRhUHJlZml4fXBhcmVudGBdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZGF0YUtleSA9IGNvbHVtbkRlZi5kYXRhS2V5O1xyXG4gICAgbGV0IHF1ZXJ5RmllbGROYW1lID0gKGNvbHVtbkRlZi5maWx0ZXIgJiYgY29sdW1uRGVmLmZpbHRlci5xdWVyeUZpZWxkKSB8fCBjb2x1bW5EZWYucXVlcnlGaWVsZEZpbHRlciB8fCBjb2x1bW5EZWYucXVlcnlGaWVsZCB8fCBjb2x1bW5EZWYuZmllbGQgfHwgJyc7XHJcbiAgICBpZiAodHlwZW9mIGNvbHVtbkRlZi5xdWVyeUZpZWxkTmFtZUdldHRlckZuID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHF1ZXJ5RmllbGROYW1lID0gY29sdW1uRGVmLnF1ZXJ5RmllbGROYW1lR2V0dGVyRm4oaXRlbSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBmaWVsZFR5cGUgPSAoY29sdW1uRGVmLmZpbHRlciAmJiBjb2x1bW5EZWYuZmlsdGVyLnR5cGUpIHx8IGNvbHVtbkRlZi50eXBlIHx8IEZpZWxkVHlwZS5zdHJpbmc7XHJcbiAgICBjb25zdCBmaWx0ZXJTZWFyY2hUeXBlID0gKGNvbHVtbkRlZi5maWx0ZXJTZWFyY2hUeXBlKSA/IGNvbHVtbkRlZi5maWx0ZXJTZWFyY2hUeXBlIDogbnVsbDtcclxuICAgIGxldCBjZWxsVmFsdWUgPSBpdGVtW3F1ZXJ5RmllbGROYW1lXTtcclxuXHJcbiAgICAvLyB3aGVuIGl0ZW0gaXMgYSBjb21wbGV4IG9iamVjdCAoZG90IFwiLlwiIG5vdGF0aW9uKSwgd2UgbmVlZCB0byBmaWx0ZXIgdGhlIHZhbHVlIGNvbnRhaW5lZCBpbiB0aGUgb2JqZWN0IHRyZWVcclxuICAgIGlmIChxdWVyeUZpZWxkTmFtZSAmJiBxdWVyeUZpZWxkTmFtZS5pbmRleE9mKCcuJykgPj0gMCkge1xyXG4gICAgICBjZWxsVmFsdWUgPSBnZXREZXNjZW5kYW50UHJvcGVydHkoaXRlbSwgcXVlcnlGaWVsZE5hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGlmIHdlIGZpbmQgc2VhcmNoVGVybXMgdXNlIHRoZW0gYnV0IG1ha2UgYSBkZWVwIGNvcHkgc28gdGhhdCB3ZSBkb24ndCBhZmZlY3Qgb3JpZ2luYWwgYXJyYXlcclxuICAgIC8vIHdlIG1pZ2h0IGhhdmUgdG8gb3ZlcndyaXRlIHRoZSB2YWx1ZShzKSBsb2NhbGx5IHRoYXQgYXJlIHJldHVybmVkXHJcbiAgICAvLyBlLmc6IHdlIGRvbid0IHdhbnQgdG8gb3BlcmF0b3Igd2l0aGluIHRoZSBzZWFyY2ggdmFsdWUsIHNpbmNlIGl0IHdpbGwgZmFpbCBmaWx0ZXIgY29uZGl0aW9uIGNoZWNrIHRyaWdnZXIgYWZ0ZXJ3YXJkXHJcbiAgICBjb25zdCBzZWFyY2hWYWx1ZXM6IFNlYXJjaFRlcm1bXSA9IChjb2x1bW5GaWx0ZXIgJiYgY29sdW1uRmlsdGVyLnNlYXJjaFRlcm1zKSA/ICQuZXh0ZW5kKHRydWUsIFtdLCBjb2x1bW5GaWx0ZXIuc2VhcmNoVGVybXMpIDogW107XHJcbiAgICBsZXQgZmllbGRTZWFyY2hWYWx1ZSA9IChBcnJheS5pc0FycmF5KHNlYXJjaFZhbHVlcykgJiYgc2VhcmNoVmFsdWVzLmxlbmd0aCA9PT0gMSkgPyBzZWFyY2hWYWx1ZXNbMF0gOiAnJztcclxuXHJcbiAgICBsZXQgbWF0Y2hlcyA9IG51bGw7XHJcbiAgICBpZiAoZmllbGRUeXBlICE9PSBGaWVsZFR5cGUub2JqZWN0KSB7XHJcbiAgICAgIGZpZWxkU2VhcmNoVmFsdWUgPSAnJyArIGZpZWxkU2VhcmNoVmFsdWU7IC8vIG1ha2Ugc3VyZSBpdCdzIGEgc3RyaW5nXHJcbiAgICAgIG1hdGNoZXMgPSBmaWVsZFNlYXJjaFZhbHVlLm1hdGNoKC9eKFs8PiE9XFwqXXswLDJ9KSguKltePD4hPVxcKl0pKFtcXCpdPykkLyk7IC8vIGdyb3VwIDE6IE9wZXJhdG9yLCAyOiBzZWFyY2hWYWx1ZSwgMzogbGFzdCBjaGFyIGlzICcqJyAobWVhbmluZyBzdGFydHMgd2l0aCwgZXguOiBhYmMqKVxyXG4gICAgfVxyXG5cclxuICAgIGxldCBvcGVyYXRvciA9IGNvbHVtbkZpbHRlci5vcGVyYXRvciB8fCAoKG1hdGNoZXMpID8gbWF0Y2hlc1sxXSA6ICcnKTtcclxuICAgIGNvbnN0IHNlYXJjaFRlcm0gPSAoISFtYXRjaGVzKSA/IG1hdGNoZXNbMl0gOiAnJztcclxuICAgIGNvbnN0IGxhc3RWYWx1ZUNoYXIgPSAoISFtYXRjaGVzKSA/IG1hdGNoZXNbM10gOiAob3BlcmF0b3IgPT09ICcqeicgPyAnKicgOiAnJyk7XHJcblxyXG4gICAgaWYgKHNlYXJjaFZhbHVlcyAmJiBzZWFyY2hWYWx1ZXMubGVuZ3RoID4gMSkge1xyXG4gICAgICBmaWVsZFNlYXJjaFZhbHVlID0gc2VhcmNoVmFsdWVzLmpvaW4oJywnKTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGZpZWxkU2VhcmNoVmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIC8vIGVzY2FwaW5nIHRoZSBzZWFyY2ggdmFsdWVcclxuICAgICAgZmllbGRTZWFyY2hWYWx1ZSA9IGZpZWxkU2VhcmNoVmFsdWUucmVwbGFjZShgJ2AsIGAnJ2ApOyAvLyBlc2NhcGUgc2luZ2xlIHF1b3RlcyBieSBkb3VibGluZyB0aGVtXHJcbiAgICAgIGlmIChvcGVyYXRvciA9PT0gJyonIHx8IG9wZXJhdG9yID09PSAnYSonIHx8IG9wZXJhdG9yID09PSAnKnonIHx8IGxhc3RWYWx1ZUNoYXIgPT09ICcqJykge1xyXG4gICAgICAgIG9wZXJhdG9yID0gKG9wZXJhdG9yID09PSAnKicgfHwgb3BlcmF0b3IgPT09ICcqeicpID8gT3BlcmF0b3JUeXBlLmVuZHNXaXRoIDogT3BlcmF0b3JUeXBlLnN0YXJ0c1dpdGg7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBubyBuZWVkIHRvIHF1ZXJ5IGlmIHNlYXJjaCB2YWx1ZSBpcyBlbXB0eSBvciBpZiB0aGUgc2VhcmNoIHZhbHVlIGlzIGluIGZhY3QgZXF1YWwgdG8gdGhlIG9wZXJhdG9yXHJcbiAgICBpZiAoc2VhcmNoVGVybSA9PT0gJycgJiYgKCFzZWFyY2hWYWx1ZXMgfHwgKEFycmF5LmlzQXJyYXkoc2VhcmNoVmFsdWVzKSAmJiAoc2VhcmNoVmFsdWVzLmxlbmd0aCA9PT0gMCB8fCBzZWFyY2hWYWx1ZXMubGVuZ3RoID09PSAxICYmIG9wZXJhdG9yID09PSBzZWFyY2hWYWx1ZXNbMF0pKSkpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaWYgc2VhcmNoIHZhbHVlIGhhcyBhIHJlZ2V4IG1hdGNoIHdlIHdpbGwgb25seSBrZWVwIHRoZSB2YWx1ZSB3aXRob3V0IHRoZSBvcGVyYXRvclxyXG4gICAgLy8gaW4gdGhpcyBjYXNlIHdlIG5lZWQgdG8gb3ZlcndyaXRlIHRoZSByZXR1cm5lZCBzZWFyY2ggdmFsdWVzIHRvIHRydW5jYXRlIG9wZXJhdG9yIGZyb20gdGhlIHN0cmluZyBzZWFyY2hcclxuICAgIGlmIChBcnJheS5pc0FycmF5KG1hdGNoZXMpICYmIG1hdGNoZXMubGVuZ3RoID49IDEgJiYgKEFycmF5LmlzQXJyYXkoc2VhcmNoVmFsdWVzKSAmJiBzZWFyY2hWYWx1ZXMubGVuZ3RoID09PSAxKSkge1xyXG4gICAgICBzZWFyY2hWYWx1ZXNbMF0gPSBzZWFyY2hUZXJtO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGZpbHRlciBzZWFyY2ggdGVybXMgc2hvdWxkIGFsd2F5cyBiZSBzdHJpbmcgdHlwZSAoZXZlbiB0aG91Z2ggd2UgcGVybWl0IHRoZSBlbmQgdXNlciB0byBpbnB1dCBudW1iZXJzKVxyXG4gICAgLy8gc28gbWFrZSBzdXJlIGVhY2ggdGVybSBhcmUgc3RyaW5ncywgaWYgdXNlciBoYXMgc29tZSBkZWZhdWx0IHNlYXJjaCB0ZXJtcywgd2Ugd2lsbCBjYXN0IHRoZW0gdG8gc3RyaW5nXHJcbiAgICBpZiAoc2VhcmNoVmFsdWVzICYmIEFycmF5LmlzQXJyYXkoc2VhcmNoVmFsdWVzKSAmJiBmaWVsZFR5cGUgIT09IEZpZWxkVHlwZS5vYmplY3QpIHtcclxuICAgICAgZm9yIChsZXQgayA9IDAsIGxuID0gc2VhcmNoVmFsdWVzLmxlbmd0aDsgayA8IGxuOyBrKyspIHtcclxuICAgICAgICAvLyBtYWtlIHN1cmUgYWxsIHNlYXJjaCB0ZXJtcyBhcmUgc3RyaW5nc1xyXG4gICAgICAgIHNlYXJjaFZhbHVlc1trXSA9ICgoc2VhcmNoVmFsdWVzW2tdID09PSB1bmRlZmluZWQgfHwgc2VhcmNoVmFsdWVzW2tdID09PSBudWxsKSA/ICcnIDogc2VhcmNoVmFsdWVzW2tdKSArICcnO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gd2hlbiB1c2luZyBsb2NhbGl6YXRpb24gKGkxOG4pLCB3ZSBzaG91bGQgdXNlIHRoZSBmb3JtYXR0ZXIgb3V0cHV0IHRvIHNlYXJjaCBhcyB0aGUgbmV3IGNlbGwgdmFsdWVcclxuICAgIGlmIChjb2x1bW5EZWYgJiYgY29sdW1uRGVmLnBhcmFtcyAmJiBjb2x1bW5EZWYucGFyYW1zLnVzZUZvcm1hdHRlck91cHV0VG9GaWx0ZXIpIHtcclxuICAgICAgY29uc3QgaWRQcm9wTmFtZSA9IHRoaXMuX2dyaWRPcHRpb25zLmRhdGFzZXRJZFByb3BlcnR5TmFtZSB8fCAnaWQnO1xyXG4gICAgICBjb25zdCByb3dJbmRleCA9IChkYXRhVmlldyAmJiB0eXBlb2YgZGF0YVZpZXcuZ2V0SWR4QnlJZCA9PT0gJ2Z1bmN0aW9uJykgPyBkYXRhVmlldy5nZXRJZHhCeUlkKGl0ZW1baWRQcm9wTmFtZV0pIDogMDtcclxuICAgICAgY2VsbFZhbHVlID0gKGNvbHVtbkRlZiAmJiB0eXBlb2YgY29sdW1uRGVmLmZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykgPyBjb2x1bW5EZWYuZm9ybWF0dGVyKHJvd0luZGV4LCBjb2x1bW5JbmRleCwgY2VsbFZhbHVlLCBjb2x1bW5EZWYsIGl0ZW0sIHRoaXMuX2dyaWQpIDogJyc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gbWFrZSBzdXJlIGNlbGwgdmFsdWUgaXMgYWx3YXlzIGEgc3RyaW5nXHJcbiAgICBpZiAodHlwZW9mIGNlbGxWYWx1ZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgY2VsbFZhbHVlID0gY2VsbFZhbHVlLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgY3VycmVudENlbGxWYWx1ZSA9IGNlbGxWYWx1ZTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGRhdGFLZXksXHJcbiAgICAgIGZpZWxkVHlwZSxcclxuICAgICAgc2VhcmNoVGVybXM6IHNlYXJjaFZhbHVlcyxcclxuICAgICAgY2VsbFZhbHVlOiBjdXJyZW50Q2VsbFZhbHVlLFxyXG4gICAgICBvcGVyYXRvcjogb3BlcmF0b3IgYXMgT3BlcmF0b3JTdHJpbmcsXHJcbiAgICAgIGNlbGxWYWx1ZUxhc3RDaGFyOiBsYXN0VmFsdWVDaGFyLFxyXG4gICAgICBmaWx0ZXJTZWFyY2hUeXBlXHJcbiAgICB9IGFzIEZpbHRlckNvbmRpdGlvbk9wdGlvbjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFdoZW4gdXNpbmcgVHJlZSBEYXRhLCB3ZSBuZWVkIHRvIHByZWZpbHRlciAoc2VhcmNoKSB0aGUgZGF0YSBwcmlvciwgdGhlIHJlc3VsdCB3aWxsIGJlIGFuIGFycmF5IG9mIElEcyB3aGljaCBhcmUgdGhlIG5vZGUocykgYW5kIHRoZWlyIHBhcmVudCBub2RlcyB3aGVuIG5lY2Vzc2FyeS5cclxuICAgKiBUaGlzIHdpbGwgdGhlbiBiZSBwYXNzZWQgdG8gdGhlIERhdGFWaWV3IHNldEZpbHRlcihjdXN0b21Mb2NhbEZpbHRlciksIHdoaWNoIHdpbGwgaXRzZWxmIGxvb3AgdGhyb3VnaCB0aGUgbGlzdCBvZiBJRHMgYW5kIGRpc3BsYXkvaGlkZSB0aGUgcm93IGlmIGZvdW5kIHRoYXQgYXJyYXkgb2YgSURzXHJcbiAgICogV2UgZG8gdGhpcyBpbiAyIHN0ZXBzIHNvIHRoYXQgd2UgY2FuIHN0aWxsIHVzZSB0aGUgRGF0YVNldCBzZXRGaWx0ZXIoKVxyXG4gICAqL1xyXG4gIHByZUZpbHRlclRyZWVEYXRhKGlucHV0QXJyYXk6IGFueVtdLCBjb2x1bW5GaWx0ZXJzOiBDb2x1bW5GaWx0ZXJzKSB7XHJcbiAgICBjb25zdCB0cmVlRGF0YU9wdGlvbnMgPSB0aGlzLl9ncmlkT3B0aW9ucyAmJiB0aGlzLl9ncmlkT3B0aW9ucy50cmVlRGF0YU9wdGlvbnM7XHJcbiAgICBjb25zdCBwYXJlbnRQcm9wTmFtZSA9IHRyZWVEYXRhT3B0aW9ucyAmJiB0cmVlRGF0YU9wdGlvbnMucGFyZW50UHJvcE5hbWUgfHwgJ19fcGFyZW50SWQnO1xyXG4gICAgY29uc3QgZGF0YVZpZXdJZElkZW50aWZpZXIgPSB0aGlzLl9ncmlkT3B0aW9ucyAmJiB0aGlzLl9ncmlkT3B0aW9ucy5kYXRhc2V0SWRQcm9wZXJ0eU5hbWUgfHwgJ2lkJztcclxuXHJcbiAgICBjb25zdCB0cmVlT2JqID0ge307XHJcbiAgICBjb25zdCBmaWx0ZXJlZENoaWxkcmVuQW5kUGFyZW50czogYW55W10gPSBbXTtcclxuXHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dEFycmF5KSkge1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0QXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB0cmVlT2JqW2lucHV0QXJyYXlbaV1bZGF0YVZpZXdJZElkZW50aWZpZXJdXSA9IGlucHV0QXJyYXlbaV07XHJcbiAgICAgICAgLy8gYXMgdGhlIGZpbHRlcmVkIGRhdGEgaXMgdGhlbiB1c2VkIGFnYWluIGFzIGVhY2ggc3Vic2VxdWVudCBsZXR0ZXJcclxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGRlbGV0ZSB0aGUgLl9fdXNlZCBwcm9wZXJ0eSwgb3RoZXJ3aXNlIHRoZSBsb2dpYyBiZWxvd1xyXG4gICAgICAgIC8vIGluIHRoZSB3aGlsZSBsb29wICh3aGljaCBjaGVja3MgZm9yIHBhcmVudHMpIGRvZXNuJ3Qgd29yazpcclxuICAgICAgICBkZWxldGUgdHJlZU9ialtpbnB1dEFycmF5W2ldW2RhdGFWaWV3SWRJZGVudGlmaWVyXV0uX191c2VkO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0QXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBpdGVtID0gaW5wdXRBcnJheVtpXTtcclxuICAgICAgICBsZXQgbWF0Y2hGaWx0ZXIgPSB0cnVlOyAvLyB2YWxpZCB1bnRpbCBwcm92ZW4gb3RoZXJ3aXNlXHJcblxyXG4gICAgICAgIC8vIGxvb3AgdGhyb3VnaCBhbGwgY29sdW1uIGZpbHRlcnMgYW5kIGV4ZWN1dGUgZmlsdGVyIGNvbmRpdGlvbihzKVxyXG4gICAgICAgIGZvciAoY29uc3QgY29sdW1uSWQgb2YgT2JqZWN0LmtleXMoY29sdW1uRmlsdGVycykpIHtcclxuICAgICAgICAgIGNvbnN0IGNvbHVtbkZpbHRlciA9IGNvbHVtbkZpbHRlcnNbY29sdW1uSWRdIGFzIENvbHVtbkZpbHRlcjtcclxuICAgICAgICAgIGNvbnN0IGNvbmRpdGlvbk9wdGlvblJlc3VsdCA9IHRoaXMuZ2V0RmlsdGVyQ29uZGl0aW9uT3B0aW9uc09yQm9vbGVhbihpdGVtLCBjb2x1bW5GaWx0ZXIsIGNvbHVtbklkLCB0aGlzLl9ncmlkLCB0aGlzLl9kYXRhVmlldyk7XHJcblxyXG4gICAgICAgICAgaWYgKGNvbmRpdGlvbk9wdGlvblJlc3VsdCkge1xyXG4gICAgICAgICAgICBjb25zdCBjb25kaXRpb25SZXN1bHQgPSAodHlwZW9mIGNvbmRpdGlvbk9wdGlvblJlc3VsdCA9PT0gJ2Jvb2xlYW4nKSA/IGNvbmRpdGlvbk9wdGlvblJlc3VsdCA6IEZpbHRlckNvbmRpdGlvbnMuZXhlY3V0ZU1hcHBlZENvbmRpdGlvbihjb25kaXRpb25PcHRpb25SZXN1bHQgYXMgRmlsdGVyQ29uZGl0aW9uT3B0aW9uKTtcclxuICAgICAgICAgICAgaWYgKGNvbmRpdGlvblJlc3VsdCkge1xyXG4gICAgICAgICAgICAgIC8vIGRvbid0IHJldHVybiB0cnVlIHNpbmNlIHdlIHN0aWxsIG5lZWQgdG8gY2hlY2sgb3RoZXIga2V5cyBpbiBjb2x1bW5GaWx0ZXJzXHJcbiAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIG1hdGNoRmlsdGVyID0gZmFsc2U7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGJ1aWxkIGFuIGFycmF5IGZyb20gdGhlIG1hdGNoZWQgZmlsdGVycywgYW55dGhpbmcgdmFsaWQgZnJvbSBmaWx0ZXIgY29uZGl0aW9uXHJcbiAgICAgICAgLy8gd2lsbCBiZSBwdXNoZWQgdG8gdGhlIGZpbHRlcmVkQ2hpbGRyZW5BbmRQYXJlbnRzIGFycmF5XHJcbiAgICAgICAgaWYgKG1hdGNoRmlsdGVyKSB7XHJcbiAgICAgICAgICBjb25zdCBsZW4gPSBmaWx0ZXJlZENoaWxkcmVuQW5kUGFyZW50cy5sZW5ndGg7XHJcbiAgICAgICAgICAvLyBhZGQgY2hpbGQgKGlkKTpcclxuICAgICAgICAgIGZpbHRlcmVkQ2hpbGRyZW5BbmRQYXJlbnRzLnNwbGljZShsZW4sIDAsIGl0ZW1bZGF0YVZpZXdJZElkZW50aWZpZXJdKTtcclxuICAgICAgICAgIGxldCBwYXJlbnQgPSB0cmVlT2JqW2l0ZW1bcGFyZW50UHJvcE5hbWVdXSB8fCBmYWxzZTtcclxuICAgICAgICAgIHdoaWxlIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgLy8gb25seSBhZGQgcGFyZW50IChpZCkgaWYgbm90IGFscmVhZHkgYWRkZWQ6XHJcbiAgICAgICAgICAgIHBhcmVudC5fX3VzZWQgfHwgZmlsdGVyZWRDaGlsZHJlbkFuZFBhcmVudHMuc3BsaWNlKGxlbiwgMCwgcGFyZW50W2RhdGFWaWV3SWRJZGVudGlmaWVyXSk7XHJcbiAgICAgICAgICAgIC8vIG1hcmsgZWFjaCBwYXJlbnQgYXMgdXNlZCB0byBub3QgdXNlIHRoZW0gYWdhaW4gbGF0ZXI6XHJcbiAgICAgICAgICAgIHRyZWVPYmpbcGFyZW50W2RhdGFWaWV3SWRJZGVudGlmaWVyXV0uX191c2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgLy8gdHJ5IHRvIGZpbmQgcGFyZW50IG9mIHRoZSBjdXJyZW50IHBhcmVudCwgaWYgZXhpc3RzOlxyXG4gICAgICAgICAgICBwYXJlbnQgPSB0cmVlT2JqW3BhcmVudFtwYXJlbnRQcm9wTmFtZV1dIHx8IGZhbHNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZpbHRlcmVkQ2hpbGRyZW5BbmRQYXJlbnRzO1xyXG4gIH1cclxuXHJcbiAgZ2V0Q29sdW1uRmlsdGVycygpIHtcclxuICAgIHJldHVybiB0aGlzLl9jb2x1bW5GaWx0ZXJzO1xyXG4gIH1cclxuXHJcbiAgZ2V0RmlsdGVyc01ldGFkYXRhKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2ZpbHRlcnNNZXRhZGF0YTtcclxuICB9XHJcblxyXG4gIGdldEN1cnJlbnRMb2NhbEZpbHRlcnMoKTogQ3VycmVudEZpbHRlcltdIHtcclxuICAgIGNvbnN0IGN1cnJlbnRGaWx0ZXJzOiBDdXJyZW50RmlsdGVyW10gPSBbXTtcclxuICAgIGlmICh0aGlzLl9jb2x1bW5GaWx0ZXJzKSB7XHJcbiAgICAgIGZvciAoY29uc3QgY29sSWQgb2YgT2JqZWN0LmtleXModGhpcy5fY29sdW1uRmlsdGVycykpIHtcclxuICAgICAgICBjb25zdCBjb2x1bW5GaWx0ZXIgPSB0aGlzLl9jb2x1bW5GaWx0ZXJzW2NvbElkXTtcclxuICAgICAgICBjb25zdCBmaWx0ZXIgPSB7IGNvbHVtbklkOiBjb2xJZCB8fCAnJyB9IGFzIEN1cnJlbnRGaWx0ZXI7XHJcblxyXG4gICAgICAgIGlmIChjb2x1bW5GaWx0ZXIgJiYgY29sdW1uRmlsdGVyLnNlYXJjaFRlcm1zKSB7XHJcbiAgICAgICAgICBmaWx0ZXIuc2VhcmNoVGVybXMgPSBjb2x1bW5GaWx0ZXIuc2VhcmNoVGVybXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb2x1bW5GaWx0ZXIub3BlcmF0b3IpIHtcclxuICAgICAgICAgIGZpbHRlci5vcGVyYXRvciA9IGNvbHVtbkZpbHRlci5vcGVyYXRvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmlsdGVyLnNlYXJjaFRlcm1zKSAmJiBmaWx0ZXIuc2VhcmNoVGVybXMubGVuZ3RoID4gMCAmJiBmaWx0ZXIuc2VhcmNoVGVybXNbMF0gIT09ICcnKSB7XHJcbiAgICAgICAgICBjdXJyZW50RmlsdGVycy5wdXNoKGZpbHRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3VycmVudEZpbHRlcnM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBIHNpbXBsZSBmdW5jdGlvbiB0aGF0IGlzIGJpbmRlZCB0byB0aGUgc3Vic2NyaWJlciBhbmQgZW1pdCBhIGNoYW5nZSB3aGVuIHRoZSBmaWx0ZXIgaXMgY2FsbGVkLlxyXG4gICAqIE90aGVyIHNlcnZpY2VzLCBsaWtlIFBhZ2luYXRpb24sIGNhbiB0aGVuIHN1YnNjcmliZSB0byBpdC5cclxuICAgKiBAcGFyYW0gY2FsbGVyXHJcbiAgICovXHJcbiAgZW1pdEZpbHRlckNoYW5nZWQoY2FsbGVyOiBFbWl0dGVyVHlwZSkge1xyXG4gICAgaWYgKGNhbGxlciA9PT0gRW1pdHRlclR5cGUucmVtb3RlICYmIHRoaXMuX2dyaWRPcHRpb25zICYmIHRoaXMuX2dyaWRPcHRpb25zLmJhY2tlbmRTZXJ2aWNlQXBpKSB7XHJcbiAgICAgIGxldCBjdXJyZW50RmlsdGVyczogQ3VycmVudEZpbHRlcltdID0gW107XHJcbiAgICAgIGNvbnN0IGJhY2tlbmRTZXJ2aWNlID0gdGhpcy5fZ3JpZE9wdGlvbnMuYmFja2VuZFNlcnZpY2VBcGkuc2VydmljZTtcclxuICAgICAgaWYgKGJhY2tlbmRTZXJ2aWNlICYmIGJhY2tlbmRTZXJ2aWNlLmdldEN1cnJlbnRGaWx0ZXJzKSB7XHJcbiAgICAgICAgY3VycmVudEZpbHRlcnMgPSBiYWNrZW5kU2VydmljZS5nZXRDdXJyZW50RmlsdGVycygpIGFzIEN1cnJlbnRGaWx0ZXJbXTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLm9uRmlsdGVyQ2hhbmdlZC5uZXh0KGN1cnJlbnRGaWx0ZXJzKTtcclxuICAgIH0gZWxzZSBpZiAoY2FsbGVyID09PSBFbWl0dGVyVHlwZS5sb2NhbCkge1xyXG4gICAgICB0aGlzLm9uRmlsdGVyQ2hhbmdlZC5uZXh0KHRoaXMuZ2V0Q3VycmVudExvY2FsRmlsdGVycygpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIG9uQmFja2VuZEZpbHRlckNoYW5nZShldmVudDogS2V5Ym9hcmRFdmVudCwgYXJnczogYW55KSB7XHJcbiAgICBpZiAoIWFyZ3MgfHwgIWFyZ3MuZ3JpZCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NvbWV0aGluZyB3ZW50IHdyb25nIHdoZW4gdHJ5aW5nIHRvIGJpbmQgdGhlIFwib25CYWNrZW5kRmlsdGVyQ2hhbmdlKGV2ZW50LCBhcmdzKVwiIGZ1bmN0aW9uLCBpdCBzZWVtcyB0aGF0IFwiYXJnc1wiIGlzIG5vdCBwb3B1bGF0ZWQgY29ycmVjdGx5Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY29uc3QgZ3JpZE9wdGlvbnM6IEdyaWRPcHRpb24gPSAoYXJncy5ncmlkICYmIGFyZ3MuZ3JpZC5nZXRPcHRpb25zKSA/IGFyZ3MuZ3JpZC5nZXRPcHRpb25zKCkgOiB7fTtcclxuICAgIGNvbnN0IGJhY2tlbmRBcGkgPSB0aGlzLl9ncmlkT3B0aW9ucy5iYWNrZW5kU2VydmljZUFwaTtcclxuXHJcbiAgICBpZiAoIWJhY2tlbmRBcGkgfHwgIWJhY2tlbmRBcGkucHJvY2VzcyB8fCAhYmFja2VuZEFwaS5zZXJ2aWNlKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQmFja2VuZFNlcnZpY2VBcGkgcmVxdWlyZXMgYXQgbGVhc3QgYSBcInByb2Nlc3NcIiBmdW5jdGlvbiBhbmQgYSBcInNlcnZpY2VcIiBkZWZpbmVkYCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8ga2VlcCBzdGFydCB0aW1lICYgZW5kIHRpbWVzdGFtcHMgJiByZXR1cm4gaXQgYWZ0ZXIgcHJvY2VzcyBleGVjdXRpb25cclxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IG5ldyBEYXRlKCk7XHJcblxyXG4gICAgLy8gcnVuIGEgcHJlUHJvY2VzcyBjYWxsYmFjayBpZiBkZWZpbmVkXHJcbiAgICBpZiAoYmFja2VuZEFwaS5wcmVQcm9jZXNzKSB7XHJcbiAgICAgIGJhY2tlbmRBcGkucHJlUHJvY2VzcygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIG9ubHkgYWRkIGEgZGVsYXkgd2hlbiB1c2VyIGlzIHR5cGluZywgb24gc2VsZWN0IGRyb3Bkb3duIGZpbHRlciAob3IgXCJDbGVhciBGaWx0ZXJcIikgaXQgd2lsbCBleGVjdXRlIHJpZ2h0IGF3YXlcclxuICAgIGxldCBkZWJvdW5jZVR5cGluZ0RlbGF5ID0gMDtcclxuICAgIGNvbnN0IGlzVHJpZ2dlcmVkQnlDbGVhckZpbHRlciA9IGFyZ3MgJiYgYXJncy5jbGVhckZpbHRlclRyaWdnZXJlZDsgLy8gd2FzIGl0IHRyaWdnZXIgYnkgYSBcIkNsZWFyIEZpbHRlclwiIGNvbW1hbmQ/XHJcblxyXG4gICAgY29uc3QgZXZlbnRUeXBlID0gZXZlbnQgJiYgZXZlbnQudHlwZTtcclxuICAgIGNvbnN0IGV2ZW50S2V5Q29kZSA9IGV2ZW50ICYmIGV2ZW50LmtleUNvZGU7XHJcbiAgICBpZiAoIWlzVHJpZ2dlcmVkQnlDbGVhckZpbHRlciAmJiBldmVudEtleUNvZGUgIT09IEtleUNvZGUuRU5URVIgJiYgKGV2ZW50VHlwZSA9PT0gJ2lucHV0JyB8fCBldmVudFR5cGUgPT09ICdrZXl1cCcgfHwgZXZlbnRUeXBlID09PSAna2V5ZG93bicpKSB7XHJcbiAgICAgIGRlYm91bmNlVHlwaW5nRGVsYXkgPSBiYWNrZW5kQXBpLmhhc093blByb3BlcnR5KCdmaWx0ZXJUeXBpbmdEZWJvdW5jZScpID8gYmFja2VuZEFwaS5maWx0ZXJUeXBpbmdEZWJvdW5jZSBhcyBudW1iZXIgOiBERUZBVUxUX0ZJTFRFUl9UWVBJTkdfREVCT1VOQ0U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcXVlcnkgYmFja2VuZCwgZXhjZXB0IHdoZW4gaXQncyBjYWxsZWQgYnkgYSBDbGVhckZpbHRlcnMgdGhlbiB3ZSB3b24ndFxyXG4gICAgaWYgKGFyZ3MgJiYgYXJncy5zaG91bGRUcmlnZ2VyUXVlcnkpIHtcclxuICAgICAgLy8gY2FsbCB0aGUgc2VydmljZSB0byBnZXQgYSBxdWVyeSBiYWNrXHJcbiAgICAgIC8vIEBkZXByZWNhdGVkIFRPRE86IHJlbW92ZSBhc3luYy9hd2FpdCBvbiBuZXh0IG1ham9yIGNoYW5nZSwgcmVmZXIgdG8gcHJvY2Vzc09uRmlsdGVyQ2hhbmdlZCBpbiBCYWNrZW5kU2VydmljZSBpbnRlcmZhY2UgKHdpdGggQGRlcHJlY2F0ZWQpXHJcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XHJcbiAgICAgIGlmIChkZWJvdW5jZVR5cGluZ0RlbGF5ID4gMCkge1xyXG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBxdWVyeSA9IGF3YWl0IGJhY2tlbmRBcGkuc2VydmljZS5wcm9jZXNzT25GaWx0ZXJDaGFuZ2VkKGV2ZW50LCBhcmdzKTtcclxuICAgICAgICAgIGNvbnN0IHRvdGFsSXRlbXMgPSB0aGlzLl9ncmlkT3B0aW9ucyAmJiB0aGlzLl9ncmlkT3B0aW9ucy5wYWdpbmF0aW9uICYmIHRoaXMuX2dyaWRPcHRpb25zLnBhZ2luYXRpb24udG90YWxJdGVtcztcclxuICAgICAgICAgIGV4ZWN1dGVCYWNrZW5kQ2FsbGJhY2soYmFja2VuZEFwaSwgcXVlcnksIGFyZ3MsIHN0YXJ0VGltZSwgdG90YWxJdGVtcywgdGhpcy5lbWl0RmlsdGVyQ2hhbmdlZC5iaW5kKHRoaXMpLCB0aGlzLmh0dHBDYW5jZWxSZXF1ZXN0cyQpO1xyXG4gICAgICAgIH0sIGRlYm91bmNlVHlwaW5nRGVsYXkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gYXdhaXQgYmFja2VuZEFwaS5zZXJ2aWNlLnByb2Nlc3NPbkZpbHRlckNoYW5nZWQoZXZlbnQsIGFyZ3MpO1xyXG4gICAgICAgIGNvbnN0IHRvdGFsSXRlbXMgPSB0aGlzLl9ncmlkT3B0aW9ucyAmJiB0aGlzLl9ncmlkT3B0aW9ucy5wYWdpbmF0aW9uICYmIHRoaXMuX2dyaWRPcHRpb25zLnBhZ2luYXRpb24udG90YWxJdGVtcztcclxuICAgICAgICBleGVjdXRlQmFja2VuZENhbGxiYWNrKGJhY2tlbmRBcGksIHF1ZXJ5LCBhcmdzLCBzdGFydFRpbWUsIHRvdGFsSXRlbXMsIHRoaXMuZW1pdEZpbHRlckNoYW5nZWQuYmluZCh0aGlzKSwgdGhpcy5odHRwQ2FuY2VsUmVxdWVzdHMkKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogV2hlbiB1c2VyIHBhc3NlcyBhbiBhcnJheSBvZiBwcmVzZXQgZmlsdGVycywgd2UgbmVlZCB0byBwcmUtcG9wdWxhdGUgZWFjaCBjb2x1bW4gZmlsdGVyIHNlYXJjaFRlcm0ocylcclxuICAgKiBUaGUgcHJvY2VzcyBpcyB0byBsb29wIHRocm91Z2ggdGhlIHByZXNldCBmaWx0ZXJzIGFycmF5LCBmaW5kIHRoZSBhc3NvY2lhdGVkIGNvbHVtbiBmcm9tIGNvbHVtbkRlZmluaXRpb25zIGFuZCBmaWxsIGluIHRoZSBmaWx0ZXIgb2JqZWN0IHNlYXJjaFRlcm0ocylcclxuICAgKiBUaGlzIGlzIGJhc2ljYWxseSB0aGUgc2FtZSBhcyBpZiB3ZSB3b3VsZCBtYW51YWxseSBhZGQgc2VhcmNoVGVybShzKSB0byBhIGNvbHVtbiBmaWx0ZXIgb2JqZWN0IGluIHRoZSBjb2x1bW4gZGVmaW5pdGlvbiwgYnV0IHdlIGRvIGl0IHByb2dyYW1tYXRpY2FsbHkuXHJcbiAgICogQXQgdGhlIGVuZCBvZiB0aGUgZGF5LCB3aGVuIGNyZWF0aW5nIHRoZSBGaWx0ZXIgKERPTSBFbGVtZW50KSwgaXQgd2lsbCB1c2UgdGhlc2Ugc2VhcmNoVGVybShzKSBzbyB3ZSBjYW4gdGFrZSBhZHZhbnRhZ2Ugb2YgdGhhdCB3aXRob3V0IHJlY29kaW5nIGVhY2ggRmlsdGVyIHR5cGUgKERPTSBlbGVtZW50KVxyXG4gICAqL1xyXG4gIHBvcHVsYXRlQ29sdW1uRmlsdGVyU2VhcmNoVGVybVByZXNldHMoZmlsdGVyczogQ3VycmVudEZpbHRlcltdKSB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmaWx0ZXJzKSAmJiBmaWx0ZXJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgdGhpcy5fY29sdW1uRGVmaW5pdGlvbnMuZm9yRWFjaCgoY29sdW1uRGVmOiBDb2x1bW4pID0+IHtcclxuICAgICAgICAvLyBjbGVhciBhbnkgY29sdW1uRGVmIHNlYXJjaFRlcm1zIGJlZm9yZSBhcHBseWluZyBQcmVzZXRzXHJcbiAgICAgICAgaWYgKGNvbHVtbkRlZi5maWx0ZXIgJiYgY29sdW1uRGVmLmZpbHRlci5zZWFyY2hUZXJtcykge1xyXG4gICAgICAgICAgZGVsZXRlIGNvbHVtbkRlZi5maWx0ZXIuc2VhcmNoVGVybXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBmcm9tIGVhY2ggcHJlc2V0cywgd2Ugd2lsbCBmaW5kIHRoZSBhc3NvY2lhdGVkIGNvbHVtbkRlZiBhbmQgYXBwbHkgdGhlIHByZXNldCBzZWFyY2hUZXJtcyAmIG9wZXJhdG9yIGlmIHRoZXJlIGlzXHJcbiAgICAgICAgY29uc3QgY29sdW1uUHJlc2V0ID0gZmlsdGVycy5maW5kKChwcmVzZXRGaWx0ZXI6IEN1cnJlbnRGaWx0ZXIpID0+IHByZXNldEZpbHRlci5jb2x1bW5JZCA9PT0gY29sdW1uRGVmLmlkKTtcclxuICAgICAgICBpZiAoY29sdW1uUHJlc2V0ICYmIGNvbHVtblByZXNldC5zZWFyY2hUZXJtcyAmJiBBcnJheS5pc0FycmF5KGNvbHVtblByZXNldC5zZWFyY2hUZXJtcykpIHtcclxuICAgICAgICAgIGNvbHVtbkRlZi5maWx0ZXIgPSBjb2x1bW5EZWYuZmlsdGVyIHx8IHt9O1xyXG4gICAgICAgICAgY29sdW1uRGVmLmZpbHRlci5vcGVyYXRvciA9IGNvbHVtblByZXNldC5vcGVyYXRvciB8fCBjb2x1bW5EZWYuZmlsdGVyLm9wZXJhdG9yIHx8ICcnO1xyXG4gICAgICAgICAgY29sdW1uRGVmLmZpbHRlci5zZWFyY2hUZXJtcyA9IGNvbHVtblByZXNldC5zZWFyY2hUZXJtcztcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gd2hlbiB3ZSBoYXZlIGEgRmlsdGVyIFByZXNldHMgb24gYSBUcmVlIERhdGEgVmlldyBncmlkLCB3ZSBuZWVkIHRvIGNhbGwgdGhlIHByZS1maWx0ZXJpbmcgb2YgdHJlZSBkYXRhXHJcbiAgICAgIHRoaXMucmVmcmVzaFRyZWVEYXRhRmlsdGVycygpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuX2NvbHVtbkRlZmluaXRpb25zO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogd2hlbiB3ZSBoYXZlIGEgRmlsdGVyIFByZXNldHMgb24gYSBUcmVlIERhdGEgVmlldyBncmlkLCB3ZSBuZWVkIHRvIGNhbGwgdGhlIHByZS1maWx0ZXJpbmcgb2YgdHJlZSBkYXRhXHJcbiAgICogd2UgbmVlZCB0byBkbyB0aGlzIGJlY2F1c2UgVHJlZSBEYXRhIGlzIHRoZSBvbmx5IHR5cGUgb2YgZ3JpZCB0aGF0IHJlcXVpcmVzIGEgcHJlLWZpbHRlciAocHJlRmlsdGVyVHJlZURhdGEpIHRvIGJlIGV4ZWN1dGVkIGJlZm9yZSB0aGUgZmluYWwgZmlsdGVyaW5nXHJcbiAgICogQHBhcmFtIGZpbHRlcnNcclxuICAgKi9cclxuICByZWZyZXNoVHJlZURhdGFGaWx0ZXJzKCkge1xyXG4gICAgaWYgKHRoaXMuX2RhdGFWaWV3ICYmIHRoaXMuX2RhdGFWaWV3LmdldEl0ZW1zICYmIHRoaXMuX2dyaWRPcHRpb25zICYmIHRoaXMuX2dyaWRPcHRpb25zLmVuYWJsZVRyZWVEYXRhKSB7XHJcbiAgICAgIHRoaXMuX3RtcFByZUZpbHRlcmVkRGF0YSA9IHRoaXMucHJlRmlsdGVyVHJlZURhdGEodGhpcy5fZGF0YVZpZXcuZ2V0SXRlbXMoKSwgdGhpcy5fY29sdW1uRmlsdGVycyk7XHJcbiAgICAgIHRoaXMuX2RhdGFWaWV3LnJlZnJlc2goKTsgLy8gYW5kIGZpbmFsbHkgdGhpcyByZWZyZXNoKCkgaXMgd2hhdCB0cmlnZ2VycyBhIERhdGFWaWV3IGZpbHRlcmluZyBjaGVja1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVG9nZ2xlIHRoZSBGaWx0ZXIgRnVuY3Rpb25hbGl0eVxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNGaWx0ZXJEaXNhYmxlZCAtIG9wdGlvbmFsbHkgZm9yY2UgYSBkaXNhYmxlL2VuYWJsZSBvZiB0aGUgU29ydCBGdW5jdGlvbmFsaXR5PyBEZWZhdWx0cyB0byBUcnVlXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBjbGVhckZpbHRlcnNXaGVuRGlzYWJsZWQgLSB3aGVuIGRpc2FibGluZyB0aGUgRmlsdGVyLCBkbyB3ZSBhbHNvIHdhbnQgdG8gY2xlYXIgYWxsIHRoZSBmaWx0ZXJzIGFzIHdlbGw/IERlZmF1bHRzIHRvIFRydWVcclxuICAgKi9cclxuICBkaXNhYmxlRmlsdGVyRnVuY3Rpb25hbGl0eShpc0ZpbHRlckRpc2FibGVkID0gdHJ1ZSwgY2xlYXJGaWx0ZXJzV2hlbkRpc2FibGVkID0gdHJ1ZSkge1xyXG4gICAgY29uc3QgcHJldlNob3dGaWx0ZXJGbGFnID0gdGhpcy5fZ3JpZE9wdGlvbnMuZW5hYmxlRmlsdGVyaW5nO1xyXG4gICAgY29uc3QgbmV3U2hvd0ZpbHRlckZsYWcgPSAhcHJldlNob3dGaWx0ZXJGbGFnO1xyXG5cclxuICAgIGlmIChuZXdTaG93RmlsdGVyRmxhZyAhPT0gaXNGaWx0ZXJEaXNhYmxlZCkge1xyXG4gICAgICBpZiAoY2xlYXJGaWx0ZXJzV2hlbkRpc2FibGVkICYmIGlzRmlsdGVyRGlzYWJsZWQpIHtcclxuICAgICAgICB0aGlzLmNsZWFyRmlsdGVycygpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuZGlzYWJsZUFsbEZpbHRlcmluZ0NvbW1hbmRzKGlzRmlsdGVyRGlzYWJsZWQpO1xyXG4gICAgICB0aGlzLl9ncmlkLnNldE9wdGlvbnMoeyBlbmFibGVGaWx0ZXJpbmc6IG5ld1Nob3dGaWx0ZXJGbGFnIH0sIGZhbHNlLCB0cnVlKTtcclxuICAgICAgdGhpcy5fZ3JpZC5zZXRIZWFkZXJSb3dWaXNpYmlsaXR5KG5ld1Nob3dGaWx0ZXJGbGFnKTtcclxuICAgICAgdGhpcy5fZ3JpZE9wdGlvbnMuZW5hYmxlRmlsdGVyaW5nID0gIWlzRmlsdGVyRGlzYWJsZWQ7XHJcbiAgICAgIHRoaXMuc2hhcmVkU2VydmljZS5ncmlkT3B0aW9ucyA9IHRoaXMuX2dyaWRPcHRpb25zO1xyXG5cclxuICAgICAgLy8gd2hlbiBkaXNwbGF5aW5nIGhlYWRlciByb3csIHdlJ2xsIGNhbGwgXCJzZXRDb2x1bW5zXCIgd2hpY2ggaW4gdGVybXMgd2lsbCByZWNyZWF0ZSB0aGUgaGVhZGVyIHJvdyBmaWx0ZXJzXHJcbiAgICAgIHRoaXMuX2dyaWQuc2V0Q29sdW1ucyh0aGlzLnNoYXJlZFNlcnZpY2UuY29sdW1uRGVmaW5pdGlvbnMpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVG9nZ2xlIHRoZSBGaWx0ZXIgRnVuY3Rpb25hbGl0eSAoc2hvdy9oaWRlIHRoZSBoZWFkZXIgcm93IGZpbHRlciBiYXIgYXMgd2VsbClcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNsZWFyRmlsdGVyc1doZW5EaXNhYmxlZCAtIHdoZW4gZGlzYWJsaW5nIHRoZSBmaWx0ZXJzLCBkbyB3ZSB3YW50IHRvIGNsZWFyIHRoZSBmaWx0ZXJzIGJlZm9yZSBoaWRpbmcgdGhlIGZpbHRlcnM/IERlZmF1bHRzIHRvIFRydWVcclxuICAgKi9cclxuICB0b2dnbGVGaWx0ZXJGdW5jdGlvbmFsaXR5KGNsZWFyRmlsdGVyc1doZW5EaXNhYmxlZCA9IHRydWUpIHtcclxuICAgIGNvbnN0IHByZXZTaG93RmlsdGVyRmxhZyA9IHRoaXMuX2dyaWRPcHRpb25zLmVuYWJsZUZpbHRlcmluZztcclxuICAgIHRoaXMuZGlzYWJsZUZpbHRlckZ1bmN0aW9uYWxpdHkocHJldlNob3dGaWx0ZXJGbGFnLCBjbGVhckZpbHRlcnNXaGVuRGlzYWJsZWQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVG9nZ2xlIHRoZSBIZWFkZXIgUm93IGZpbHRlciBiYXIgKHRoaXMgZG9lcyBub3QgZGlzYWJsZSB0aGUgRmlsdGVyaW5nIGl0c2VsZiwgeW91IGNhbiB1c2UgXCJ0b2dnbGVGaWx0ZXJGdW5jdGlvbmFsaXR5KClcIiBpbnN0ZWFkLCBob3dldmVyIHRoaXMgd2lsbCByZXNldCBhbnkgY29sdW1uIHBvc2l0aW9ucylcclxuICAgKi9cclxuICB0b2dnbGVIZWFkZXJGaWx0ZXJSb3coKSB7XHJcbiAgICBsZXQgc2hvd0hlYWRlclJvdyA9IHRoaXMuX2dyaWRPcHRpb25zICYmIHRoaXMuX2dyaWRPcHRpb25zLnNob3dIZWFkZXJSb3cgfHwgZmFsc2U7XHJcbiAgICBzaG93SGVhZGVyUm93ID0gIXNob3dIZWFkZXJSb3c7IC8vIGludmVyc2Ugc2hvdyBoZWFkZXIgZmxhZ1xyXG4gICAgdGhpcy5fZ3JpZC5zZXRIZWFkZXJSb3dWaXNpYmlsaXR5KHNob3dIZWFkZXJSb3cpO1xyXG5cclxuICAgIC8vIHdoZW4gZGlzcGxheWluZyBoZWFkZXIgcm93LCB3ZSdsbCBjYWxsIFwic2V0Q29sdW1uc1wiIHdoaWNoIGluIHRlcm1zIHdpbGwgcmVjcmVhdGUgdGhlIGhlYWRlciByb3cgZmlsdGVyc1xyXG4gICAgaWYgKHNob3dIZWFkZXJSb3cgPT09IHRydWUpIHtcclxuICAgICAgdGhpcy5fZ3JpZC5zZXRDb2x1bW5zKHRoaXMuc2hhcmVkU2VydmljZS5jb2x1bW5EZWZpbml0aW9ucyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgdGhlIHNvcnQgaWNvbnMgaW4gdGhlIFVJIChPTkxZIHRoZSBpY29ucywgaXQgZG9lcyBub3QgZG8gYW55IHNvcnRpbmcpXHJcbiAgICogVGhlIGNvbHVtbiBzb3J0IGljb25zIGFyZSBub3QgbmVjZXNzYXJpbHkgaW50ZXItY29ubmVjdGVkIHRvIHRoZSBzb3J0aW5nIGZ1bmN0aW9uYWxpdHkgaXRzZWxmLFxyXG4gICAqIHlvdSBjYW4gY2hhbmdlIHRoZSBzb3J0aW5nIGljb25zIHNlcGFyYXRlbHkgYnkgcGFzc2luZyBhbiBhcnJheSBvZiBjb2x1bW5JZC9zb3J0QXNjIGFuZCB0aGF0IHdpbGwgY2hhbmdlIE9OTFkgdGhlIGljb25zXHJcbiAgICogQHBhcmFtIHNvcnRDb2x1bW5zXHJcbiAgICovXHJcbiAgc2V0U29ydENvbHVtbkljb25zKHNvcnRDb2x1bW5zOiB7IGNvbHVtbklkOiBzdHJpbmcsIHNvcnRBc2M6IGJvb2xlYW4gfVtdKSB7XHJcbiAgICBpZiAodGhpcy5fZ3JpZCAmJiBBcnJheS5pc0FycmF5KHNvcnRDb2x1bW5zKSkge1xyXG4gICAgICB0aGlzLl9ncmlkLnNldFNvcnRDb2x1bW5zKHNvcnRDb2x1bW5zKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBGaWx0ZXJzIGR5bmFtaWNhbGx5IGp1c3QgYnkgcHJvdmlkaW5nIGFuIGFycmF5IG9mIGZpbHRlcihzKS5cclxuICAgKiBZb3UgY2FuIGFsc28gY2hvb3NlIGVtaXQgKGRlZmF1bHQpIGEgRmlsdGVyIENoYW5nZWQgZXZlbnQgdGhhdCB3aWxsIGJlIHBpY2tlZCBieSB0aGUgR3JpZCBTdGF0ZSBTZXJ2aWNlLlxyXG4gICAqXHJcbiAgICogQWxzbyBmb3IgYmFja2VuZCBzZXJ2aWNlIG9ubHksIHlvdSBjYW4gY2hvb3NlIHRvIHRyaWdnZXIgYSBiYWNrZW5kIHF1ZXJ5IChkZWZhdWx0KSBvciBub3QgaWYgeW91IHdpc2ggdG8gZG8gaXQgbGF0ZXIsXHJcbiAgICogdGhpcyBjb3VsZCBiZSB1c2VmdWwgd2hlbiB1c2luZyB1cGRhdGVGaWx0ZXJzICYgdXBkYXRlU29ydGluZyBhbmQgeW91IHdpc2ggdG8gb25seSBzZW5kIHRoZSBiYWNrZW5kIHF1ZXJ5IG9uY2UuXHJcbiAgICogQHBhcmFtIGZpbHRlcnMgYXJyYXlcclxuICAgKiBAcGFyYW0gdHJpZ2dlckV2ZW50IGRlZmF1bHRzIHRvIFRydWUsIGRvIHdlIHdhbnQgdG8gZW1pdCBhIGZpbHRlciBjaGFuZ2VkIGV2ZW50P1xyXG4gICAqIEBwYXJhbSB0cmlnZ2VyQmFja2VuZFF1ZXJ5IGRlZmF1bHRzIHRvIFRydWUsIHdoaWNoIHdpbGwgcXVlcnkgdGhlIGJhY2tlbmQuXHJcbiAgICovXHJcbiAgdXBkYXRlRmlsdGVycyhmaWx0ZXJzOiBDdXJyZW50RmlsdGVyW10sIGVtaXRDaGFuZ2VkRXZlbnQgPSB0cnVlLCB0cmlnZ2VyQmFja2VuZFF1ZXJ5ID0gdHJ1ZSwgdHJpZ2dlck9uU2VhcmNoQ2hhbmdlRXZlbnQgPSBmYWxzZSkge1xyXG4gICAgaWYgKCF0aGlzLl9maWx0ZXJzTWV0YWRhdGEgfHwgdGhpcy5fZmlsdGVyc01ldGFkYXRhLmxlbmd0aCA9PT0gMCB8fCAhdGhpcy5fZ3JpZE9wdGlvbnMgfHwgIXRoaXMuX2dyaWRPcHRpb25zLmVuYWJsZUZpbHRlcmluZykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tBbmd1bGFyLVNsaWNrZ3JpZF0gaW4gb3JkZXIgdG8gdXNlIFwidXBkYXRlRmlsdGVyc1wiIG1ldGhvZCwgeW91IG5lZWQgdG8gaGF2ZSBGaWx0ZXJhYmxlIENvbHVtbnMgZGVmaW5lZCBpbiB5b3VyIGdyaWQgYW5kIFwiZW5hYmxlRmlsdGVyaW5nXCIgc2V0IGluIHlvdXIgR3JpZCBPcHRpb25zJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZmlsdGVycykpIHtcclxuICAgICAgLy8gc3RhcnQgYnkgY2xlYXJpbmcgYWxsIGZpbHRlcnMgKHdpdGhvdXQgdHJpZ2dlcmluZyBhbiBldmVudCkgYmVmb3JlIGFwcGx5aW5nIGFueSBuZXcgZmlsdGVyc1xyXG4gICAgICB0aGlzLmNsZWFyRmlsdGVycyhmYWxzZSk7XHJcblxyXG4gICAgICAvLyBwcmUtZmlsbCAodmFsdWUgKyBvcGVyYXRvcikgYW5kIHJlbmRlciBhbGwgZmlsdGVycyBpbiB0aGUgRE9NXHJcbiAgICAgIC8vIGxvb3AgdGhyb3VnaCBlYWNoIEZpbHRlcnMgcHJvdmlkZWQgKHdoaWNoIGhhcyBhIGNvbHVtbklkIHByb3BlcnR5KVxyXG4gICAgICAvLyB0aGVuIGZpbmQgdGhlaXIgYXNzb2NpYXRlZCBGaWx0ZXIgaW5zdGFuY2VzIHRoYXQgd2VyZSBvcmlnaW5hbGx5IGNyZWF0ZWQgaW4gdGhlIGdyaWRcclxuICAgICAgZmlsdGVycy5mb3JFYWNoKChuZXdGaWx0ZXIpID0+IHtcclxuICAgICAgICBjb25zdCB1aUZpbHRlciA9IHRoaXMuX2ZpbHRlcnNNZXRhZGF0YS5maW5kKChmaWx0ZXIpID0+IG5ld0ZpbHRlci5jb2x1bW5JZCA9PT0gZmlsdGVyLmNvbHVtbkRlZi5pZCk7XHJcbiAgICAgICAgaWYgKG5ld0ZpbHRlciAmJiB1aUZpbHRlcikge1xyXG4gICAgICAgICAgY29uc3QgbmV3T3BlcmF0b3IgPSBuZXdGaWx0ZXIub3BlcmF0b3IgfHwgdWlGaWx0ZXIuZGVmYXVsdE9wZXJhdG9yO1xyXG4gICAgICAgICAgdGhpcy51cGRhdGVDb2x1bW5GaWx0ZXJzKG5ld0ZpbHRlci5zZWFyY2hUZXJtcywgdWlGaWx0ZXIuY29sdW1uRGVmLCBuZXdPcGVyYXRvcik7XHJcbiAgICAgICAgICB1aUZpbHRlci5zZXRWYWx1ZXMobmV3RmlsdGVyLnNlYXJjaFRlcm1zLCBuZXdPcGVyYXRvcik7XHJcblxyXG4gICAgICAgICAgaWYgKHRyaWdnZXJPblNlYXJjaENoYW5nZUV2ZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tTZWFyY2hFdmVudChudWxsLCB7IGNvbHVtbkRlZjogdWlGaWx0ZXIuY29sdW1uRGVmLCBvcGVyYXRvcjogbmV3T3BlcmF0b3IsIHNlYXJjaFRlcm1zOiBuZXdGaWx0ZXIuc2VhcmNoVGVybXMsIHNob3VsZFRyaWdnZXJRdWVyeTogdHJ1ZSB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgY29uc3QgYmFja2VuZEFwaSA9IHRoaXMuX2dyaWRPcHRpb25zICYmIHRoaXMuX2dyaWRPcHRpb25zLmJhY2tlbmRTZXJ2aWNlQXBpO1xyXG5cclxuICAgICAgLy8gcmVmcmVzaCB0aGUgRGF0YVZpZXcgYW5kIHRyaWdnZXIgYW4gZXZlbnQgYWZ0ZXIgYWxsIGZpbHRlcnMgd2VyZSB1cGRhdGVkIGFuZCByZW5kZXJlZFxyXG4gICAgICB0aGlzLl9kYXRhVmlldy5yZWZyZXNoKCk7XHJcblxyXG4gICAgICBpZiAoYmFja2VuZEFwaSkge1xyXG4gICAgICAgIGNvbnN0IGJhY2tlbmRBcGlTZXJ2aWNlID0gYmFja2VuZEFwaSAmJiBiYWNrZW5kQXBpLnNlcnZpY2U7XHJcbiAgICAgICAgaWYgKGJhY2tlbmRBcGlTZXJ2aWNlKSB7XHJcbiAgICAgICAgICBiYWNrZW5kQXBpU2VydmljZS51cGRhdGVGaWx0ZXJzKGZpbHRlcnMsIHRydWUpO1xyXG4gICAgICAgICAgaWYgKHRyaWdnZXJCYWNrZW5kUXVlcnkpIHtcclxuICAgICAgICAgICAgcmVmcmVzaEJhY2tlbmREYXRhc2V0KHRoaXMuX2dyaWRPcHRpb25zKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChlbWl0Q2hhbmdlZEV2ZW50KSB7XHJcbiAgICAgICAgY29uc3QgZW1pdHRlclR5cGUgPSBiYWNrZW5kQXBpID8gRW1pdHRlclR5cGUucmVtb3RlIDogRW1pdHRlclR5cGUubG9jYWw7XHJcbiAgICAgICAgdGhpcy5lbWl0RmlsdGVyQ2hhbmdlZChlbWl0dGVyVHlwZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIC0tXHJcbiAgLy8gcHJpdmF0ZSBmdW5jdGlvbnNcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8qKiBBZGQgYWxsIGNyZWF0ZWQgZmlsdGVycyAoZnJvbSB0aGVpciB0ZW1wbGF0ZSkgdG8gdGhlIGhlYWRlciByb3cgc2VjdGlvbiBhcmVhICovXHJcbiAgcHJpdmF0ZSBhZGRGaWx0ZXJUZW1wbGF0ZVRvSGVhZGVyUm93KF9ldmVudDogRXZlbnQsIGFyZ3M6IHsgY29sdW1uOiBDb2x1bW47IGdyaWQ6IGFueTsgbm9kZTogSFRNTEVsZW1lbnQgfSwgaXNGaWx0ZXJGaXJzdFJlbmRlciA9IHRydWUpIHtcclxuICAgIGNvbnN0IGNvbHVtbkRlZiA9IGFyZ3MuY29sdW1uO1xyXG4gICAgY29uc3QgY29sdW1uSWQgPSBjb2x1bW5EZWYgJiYgY29sdW1uRGVmLmlkIHx8ICcnO1xyXG5cclxuICAgIGlmIChjb2x1bW5EZWYgJiYgY29sdW1uSWQgIT09ICdzZWxlY3RvcicgJiYgY29sdW1uRGVmLmZpbHRlcmFibGUpIHtcclxuICAgICAgbGV0IHNlYXJjaFRlcm1zOiBTZWFyY2hUZXJtW10gfCB1bmRlZmluZWQ7XHJcbiAgICAgIGxldCBvcGVyYXRvcjogT3BlcmF0b3JUeXBlIHwgT3BlcmF0b3JTdHJpbmc7XHJcbiAgICAgIGNvbnN0IG5ld0ZpbHRlcjogRmlsdGVyIHwgdW5kZWZpbmVkID0gdGhpcy5maWx0ZXJGYWN0b3J5LmNyZWF0ZUZpbHRlcihhcmdzLmNvbHVtbi5maWx0ZXIpO1xyXG4gICAgICBvcGVyYXRvciA9IChjb2x1bW5EZWYgJiYgY29sdW1uRGVmLmZpbHRlciAmJiBjb2x1bW5EZWYuZmlsdGVyLm9wZXJhdG9yKSB8fCAobmV3RmlsdGVyICYmIG5ld0ZpbHRlci5vcGVyYXRvcikgfHwgdW5kZWZpbmVkO1xyXG5cclxuICAgICAgaWYgKHRoaXMuX2NvbHVtbkZpbHRlcnNbY29sdW1uRGVmLmlkXSkge1xyXG4gICAgICAgIHNlYXJjaFRlcm1zID0gdGhpcy5fY29sdW1uRmlsdGVyc1tjb2x1bW5EZWYuaWRdLnNlYXJjaFRlcm1zIHx8IHVuZGVmaW5lZDtcclxuICAgICAgICBvcGVyYXRvciA9IHRoaXMuX2NvbHVtbkZpbHRlcnNbY29sdW1uRGVmLmlkXS5vcGVyYXRvciB8fCB1bmRlZmluZWQ7XHJcbiAgICAgIH0gZWxzZSBpZiAoY29sdW1uRGVmLmZpbHRlcikge1xyXG4gICAgICAgIC8vIHdoZW4gaGlkaW5nL3Nob3dpbmcgKHdpdGggQ29sdW1uIFBpY2tlciBvciBHcmlkIE1lbnUpLCBpdCB3aWxsIHRyeSB0byByZS1jcmVhdGUgeWV0IGFnYWluIHRoZSBmaWx0ZXJzIChzaW5jZSBTbGlja0dyaWQgZG9lcyBhIHJlLXJlbmRlcilcclxuICAgICAgICAvLyBiZWNhdXNlIG9mIHRoYXQgd2UgbmVlZCB0byBmaXJzdCBnZXQgc2VhcmNoVGVybShzKSBmcm9tIHRoZSBjb2x1bW5GaWx0ZXJzICh0aGF0IGlzIHdoYXQgdGhlIHVzZXIgbGFzdCB0eXBlZCBpbiBhIGZpbHRlciBzZWFyY2ggaW5wdXQpXHJcbiAgICAgICAgc2VhcmNoVGVybXMgPSBjb2x1bW5EZWYuZmlsdGVyLnNlYXJjaFRlcm1zIHx8IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnVwZGF0ZUNvbHVtbkZpbHRlcnMoc2VhcmNoVGVybXMsIGNvbHVtbkRlZiwgb3BlcmF0b3IpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBmaWx0ZXJBcmd1bWVudHM6IEZpbHRlckFyZ3VtZW50cyA9IHtcclxuICAgICAgICBncmlkOiB0aGlzLl9ncmlkLFxyXG4gICAgICAgIG9wZXJhdG9yLFxyXG4gICAgICAgIHNlYXJjaFRlcm1zLFxyXG4gICAgICAgIGNvbHVtbkRlZixcclxuICAgICAgICBjYWxsYmFjazogdGhpcy5jYWxsYmFja1NlYXJjaEV2ZW50LmJpbmQodGhpcylcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGlmIChuZXdGaWx0ZXIpIHtcclxuICAgICAgICBuZXdGaWx0ZXIuaW5pdChmaWx0ZXJBcmd1bWVudHMsIGlzRmlsdGVyRmlyc3RSZW5kZXIpO1xyXG4gICAgICAgIGNvbnN0IGZpbHRlckV4aXN0SW5kZXggPSB0aGlzLl9maWx0ZXJzTWV0YWRhdGEuZmluZEluZGV4KChmaWx0ZXIpID0+IG5ld0ZpbHRlci5jb2x1bW5EZWYuaWQgPT09IGZpbHRlci5jb2x1bW5EZWYuaWQpO1xyXG5cclxuICAgICAgICAvLyBhZGQgdG8gdGhlIGZpbHRlcnMgYXJyYXlzIG9yIHJlcGxhY2UgaXQgd2hlbiBmb3VuZFxyXG4gICAgICAgIGlmIChmaWx0ZXJFeGlzdEluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgdGhpcy5fZmlsdGVyc01ldGFkYXRhLnB1c2gobmV3RmlsdGVyKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5fZmlsdGVyc01ldGFkYXRhW2ZpbHRlckV4aXN0SW5kZXhdID0gbmV3RmlsdGVyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gd2hlbiBoaWRpbmcvc2hvd2luZyAod2l0aCBDb2x1bW4gUGlja2VyIG9yIEdyaWQgTWVudSksIGl0IHdpbGwgdHJ5IHRvIHJlLWNyZWF0ZSB5ZXQgYWdhaW4gdGhlIGZpbHRlcnMgKHNpbmNlIFNsaWNrR3JpZCBkb2VzIGEgcmUtcmVuZGVyKVxyXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gYWxzbyBzZXQgYWdhaW4gdGhlIHZhbHVlcyBpbiB0aGUgRE9NIGVsZW1lbnRzIGlmIHRoZSB2YWx1ZXMgd2VyZSBzZXQgYnkgYSBzZWFyY2hUZXJtKHMpXHJcbiAgICAgICAgaWYgKHNlYXJjaFRlcm1zICYmIG5ld0ZpbHRlci5zZXRWYWx1ZXMpIHtcclxuICAgICAgICAgIG5ld0ZpbHRlci5zZXRWYWx1ZXMoc2VhcmNoVGVybXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsbGJhY2sgbWV0aG9kIHRoYXQgaXMgY2FsbGVkIGFuZCBleGVjdXRlZCBieSB0aGUgaW5kaXZpZHVhbCBGaWx0ZXIgKERPTSBlbGVtZW50KSxcclxuICAgKiBmb3IgZXhhbXBsZSB3aGVuIHVzZXIgdHlwZSBpbiBhIHdvcmQgdG8gc2VhcmNoICh3aGljaCB1c2VzIElucHV0RmlsdGVyKSwgdGhpcyBGaWx0ZXIgd2lsbCBleGVjdXRlIHRoZSBjYWxsYmFjayBmcm9tIGFuIGlucHV0IGNoYW5nZSBldmVudC5cclxuICAgKi9cclxuICBwcml2YXRlIGNhbGxiYWNrU2VhcmNoRXZlbnQoZXZlbnQ6IGFueSwgYXJnczogRmlsdGVyQ2FsbGJhY2tBcmcpIHtcclxuICAgIGlmIChhcmdzKSB7XHJcbiAgICAgIGNvbnN0IHNlYXJjaFRlcm0gPSAoKGV2ZW50ICYmIGV2ZW50LnRhcmdldCkgPyAoZXZlbnQudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQpLnZhbHVlIDogdW5kZWZpbmVkKTtcclxuICAgICAgY29uc3Qgc2VhcmNoVGVybXMgPSAoYXJncy5zZWFyY2hUZXJtcyAmJiBBcnJheS5pc0FycmF5KGFyZ3Muc2VhcmNoVGVybXMpKSA/IGFyZ3Muc2VhcmNoVGVybXMgOiAoc2VhcmNoVGVybSA/IFtzZWFyY2hUZXJtXSA6IHVuZGVmaW5lZCk7XHJcbiAgICAgIGNvbnN0IGNvbHVtbkRlZiA9IGFyZ3MuY29sdW1uRGVmIHx8IG51bGw7XHJcbiAgICAgIGNvbnN0IGNvbHVtbklkID0gY29sdW1uRGVmICYmIGNvbHVtbkRlZi5pZCB8fCAnJztcclxuICAgICAgY29uc3Qgb3BlcmF0b3IgPSBhcmdzLm9wZXJhdG9yIHx8IHVuZGVmaW5lZDtcclxuICAgICAgY29uc3QgaGFzU2VhcmNoVGVybXMgPSBzZWFyY2hUZXJtcyAmJiBBcnJheS5pc0FycmF5KHNlYXJjaFRlcm1zKTtcclxuICAgICAgY29uc3QgdGVybXNDb3VudCA9IGhhc1NlYXJjaFRlcm1zICYmIHNlYXJjaFRlcm1zICYmIHNlYXJjaFRlcm1zLmxlbmd0aDtcclxuICAgICAgY29uc3Qgb2xkQ29sdW1uRmlsdGVycyA9IHsgLi4udGhpcy5fY29sdW1uRmlsdGVycyB9O1xyXG5cclxuICAgICAgaWYgKGNvbHVtbkRlZiAmJiBjb2x1bW5JZCkge1xyXG4gICAgICAgIGlmICghaGFzU2VhcmNoVGVybXMgfHwgdGVybXNDb3VudCA9PT0gMCB8fCAodGVybXNDb3VudCA9PT0gMSAmJiBBcnJheS5pc0FycmF5KHNlYXJjaFRlcm1zKSAmJiBzZWFyY2hUZXJtc1swXSA9PT0gJycpKSB7XHJcbiAgICAgICAgICAvLyBkZWxldGUgdGhlIHByb3BlcnR5IGZyb20gdGhlIGNvbHVtbkZpbHRlcnMgd2hlbiBpdCBiZWNvbWVzIGVtcHR5XHJcbiAgICAgICAgICAvLyB3aXRob3V0IGRvaW5nIHRoaXMsIGl0IHdvdWxkIGxlYXZlIGFuIGluY29ycmVjdCBzdGF0ZSBvZiB0aGUgcHJldmlvdXMgY29sdW1uIGZpbHRlcnMgd2hlbiBmaWx0ZXJpbmcgb24gYW5vdGhlciBjb2x1bW5cclxuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jb2x1bW5GaWx0ZXJzW2NvbHVtbklkXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY29uc3QgY29sSWQgPSAnJyArIGNvbHVtbklkIGFzIHN0cmluZztcclxuICAgICAgICAgIGNvbnN0IGNvbEZpbHRlcjogQ29sdW1uRmlsdGVyID0ge1xyXG4gICAgICAgICAgICBjb2x1bW5JZDogY29sSWQsXHJcbiAgICAgICAgICAgIGNvbHVtbkRlZixcclxuICAgICAgICAgICAgc2VhcmNoVGVybXMsXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgaWYgKG9wZXJhdG9yKSB7XHJcbiAgICAgICAgICAgIGNvbEZpbHRlci5vcGVyYXRvciA9IG9wZXJhdG9yO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGhpcy5fY29sdW1uRmlsdGVyc1tjb2xJZF0gPSBjb2xGaWx0ZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBldmVudCBtaWdodCBoYXZlIGJlZW4gY3JlYXRlZCBhcyBhIEN1c3RvbUV2ZW50IChlLmcuIENvbXBvdW5kRGF0ZUZpbHRlciksIHdpdGhvdXQgYmVpbmcgYSB2YWxpZCBTbGljay5FdmVudERhdGEsXHJcbiAgICAgIC8vIGlmIHNvIHdlIHdpbGwgY3JlYXRlIGEgbmV3IFNsaWNrLkV2ZW50RGF0YSBhbmQgbWVyZ2UgaXQgd2l0aCB0aGF0IEN1c3RvbUV2ZW50IHRvIGF2b2lkIGhhdmluZyBTbGlja0dyaWQgZXJyb3JzXHJcbiAgICAgIGNvbnN0IGV2ZW50RGF0YSA9IChldmVudCAmJiB0eXBlb2YgZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQgIT09ICdmdW5jdGlvbicpID8gJC5leHRlbmQoe30sIG5ldyBTbGljay5FdmVudERhdGEoKSwgZXZlbnQpIDogZXZlbnQ7XHJcblxyXG4gICAgICAvLyB0cmlnZ2VyIGFuIGV2ZW50IG9ubHkgaWYgRmlsdGVycyBjaGFuZ2VkIG9yIGlmIEVOVEVSIGtleSB3YXMgcHJlc3NlZFxyXG4gICAgICBjb25zdCBldmVudEtleSA9IGV2ZW50ICYmIGV2ZW50LmtleTtcclxuICAgICAgY29uc3QgZXZlbnRLZXlDb2RlID0gZXZlbnQgJiYgZXZlbnQua2V5Q29kZTtcclxuICAgICAgaWYgKHRoaXMuX29uU2VhcmNoQ2hhbmdlICYmIChldmVudEtleSA9PT0gJ0VudGVyJyB8fCBldmVudEtleUNvZGUgPT09IEtleUNvZGUuRU5URVIgfHwgIWlzZXF1YWwob2xkQ29sdW1uRmlsdGVycywgdGhpcy5fY29sdW1uRmlsdGVycykpKSB7XHJcbiAgICAgICAgdGhpcy5fb25TZWFyY2hDaGFuZ2Uubm90aWZ5KHtcclxuICAgICAgICAgIGNsZWFyRmlsdGVyVHJpZ2dlcmVkOiBhcmdzLmNsZWFyRmlsdGVyVHJpZ2dlcmVkLFxyXG4gICAgICAgICAgc2hvdWxkVHJpZ2dlclF1ZXJ5OiBhcmdzLnNob3VsZFRyaWdnZXJRdWVyeSxcclxuICAgICAgICAgIGNvbHVtbklkLFxyXG4gICAgICAgICAgY29sdW1uRGVmLFxyXG4gICAgICAgICAgY29sdW1uRmlsdGVyczogdGhpcy5fY29sdW1uRmlsdGVycyxcclxuICAgICAgICAgIG9wZXJhdG9yLFxyXG4gICAgICAgICAgc2VhcmNoVGVybXMsXHJcbiAgICAgICAgICBncmlkOiB0aGlzLl9ncmlkXHJcbiAgICAgICAgfSwgZXZlbnREYXRhKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTG9vcCB0aHJvdWdoIGFsbCBjb2x1bW4gZGVmaW5pdGlvbnMgYW5kIGRvIHRoZSBmb2xsb3dpbmcgdGhpbmdcclxuICAgKiAxLiBsb29wIHRocm91Z2ggZWFjaCBIZWFkZXIgTWVudSBjb21tYW5kcyBhbmQgY2hhbmdlIHRoZSBcImhpZGRlblwiIGNvbW1hbmRzIHRvIHNob3cvaGlkZSBkZXBlbmRpbmcgaWYgaXQncyBlbmFibGVkL2Rpc2FibGVkXHJcbiAgICogQWxzbyBub3RlIHRoYXQgd2UgYXJlbid0IGRlbGV0aW5nIGFueSBwcm9wZXJ0aWVzLCB3ZSBqdXN0IHRvZ2dsZSB0aGVpciBmbGFncyBzbyB0aGF0IHdlIGNhbiByZWxvb3AgdGhyb3VnaCBhdCBsYXRlciBwb2ludCBpbiB0aW1lLlxyXG4gICAqIChpZiB3ZSBwcmV2aW91c2x5IGRlbGV0ZWQgdGhlc2UgcHJvcGVydGllcyB3ZSB3b3VsZG4ndCBiZSBhYmxlIHRvIGNoYW5nZSB0aGVtIGJhY2sgc2luY2UgdGhlc2UgcHJvcGVydGllcyB3b3VsZG4ndCBleGlzdCBhbnltb3JlLCBoZW5jZSB3aHkgd2UganVzdCBoaWRlIHRoZSBjb21tYW5kcylcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzRGlzYWJsaW5nIC0gYXJlIHdlIGRpc2FibGluZyB0aGUgZmlsdGVyIGZ1bmN0aW9uYWxpdHk/IERlZmF1bHRzIHRvIHRydWVcclxuICAgKi9cclxuICBwcml2YXRlIGRpc2FibGVBbGxGaWx0ZXJpbmdDb21tYW5kcyhpc0Rpc2FibGluZyA9IHRydWUpOiBDb2x1bW5bXSB7XHJcbiAgICBjb25zdCBjb2x1bW5EZWZpbml0aW9ucyA9IHRoaXMuX2dyaWQuZ2V0Q29sdW1ucygpO1xyXG5cclxuICAgIC8vIGxvb3AgdGhyb3VnaCBjb2x1bW4gZGVmaW5pdGlvbiB0byBoaWRlL3Nob3cgaGVhZGVyIG1lbnUgY29tbWFuZHNcclxuICAgIGNvbHVtbkRlZmluaXRpb25zLmZvckVhY2goKGNvbCkgPT4ge1xyXG4gICAgICBpZiAoY29sICYmIGNvbC5oZWFkZXIgJiYgY29sLmhlYWRlci5tZW51KSB7XHJcbiAgICAgICAgY29sLmhlYWRlci5tZW51Lml0ZW1zLmZvckVhY2gobWVudUl0ZW0gPT4ge1xyXG4gICAgICAgICAgaWYgKG1lbnVJdGVtICYmIHR5cGVvZiBtZW51SXRlbSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgY29uc3QgbWVudUNvbW1hbmQgPSBtZW51SXRlbS5jb21tYW5kO1xyXG4gICAgICAgICAgICBpZiAobWVudUNvbW1hbmQgPT09ICdjbGVhci1maWx0ZXInKSB7XHJcbiAgICAgICAgICAgICAgbWVudUl0ZW0uaGlkZGVuID0gaXNEaXNhYmxpbmc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gbG9vcCB0aHJvdWdoIGNvbHVtbiBkZWZpbml0aW9uIHRvIGhpZGUvc2hvdyBncmlkIG1lbnUgY29tbWFuZHNcclxuICAgIGlmICh0aGlzLl9ncmlkT3B0aW9ucyAmJiB0aGlzLl9ncmlkT3B0aW9ucy5ncmlkTWVudSAmJiB0aGlzLl9ncmlkT3B0aW9ucy5ncmlkTWVudS5jdXN0b21JdGVtcykge1xyXG4gICAgICB0aGlzLl9ncmlkT3B0aW9ucy5ncmlkTWVudS5jdXN0b21JdGVtcy5mb3JFYWNoKChtZW51SXRlbSkgPT4ge1xyXG4gICAgICAgIGlmIChtZW51SXRlbSAmJiB0eXBlb2YgbWVudUl0ZW0gIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICBjb25zdCBtZW51Q29tbWFuZCA9IG1lbnVJdGVtLmNvbW1hbmQ7XHJcbiAgICAgICAgICBpZiAobWVudUNvbW1hbmQgPT09ICdjbGVhci1maWx0ZXInIHx8IG1lbnVDb21tYW5kID09PSAndG9nZ2xlLWZpbHRlcicpIHtcclxuICAgICAgICAgICAgbWVudUl0ZW0uaGlkZGVuID0gaXNEaXNhYmxpbmc7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY29sdW1uRGVmaW5pdGlvbnM7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHVwZGF0ZUNvbHVtbkZpbHRlcnMoc2VhcmNoVGVybXM6IFNlYXJjaFRlcm1bXSB8IHVuZGVmaW5lZCwgY29sdW1uRGVmOiBhbnksIG9wZXJhdG9yPzogT3BlcmF0b3JUeXBlIHwgT3BlcmF0b3JTdHJpbmcpIHtcclxuICAgIGlmIChzZWFyY2hUZXJtcyAmJiBjb2x1bW5EZWYpIHtcclxuICAgICAgdGhpcy5fY29sdW1uRmlsdGVyc1tjb2x1bW5EZWYuaWRdID0ge1xyXG4gICAgICAgIGNvbHVtbklkOiBjb2x1bW5EZWYuaWQsXHJcbiAgICAgICAgY29sdW1uRGVmLFxyXG4gICAgICAgIHNlYXJjaFRlcm1zLFxyXG4gICAgICAgIG9wZXJhdG9yXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiJdfQ==