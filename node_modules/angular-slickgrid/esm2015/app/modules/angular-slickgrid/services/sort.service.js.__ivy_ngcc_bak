import * as tslib_1 from "tslib";
import { isObservable, Subject } from 'rxjs';
import { EmitterType, FieldType, SortDirection, SortDirectionNumber, } from './../models/index';
import { executeBackendCallback, refreshBackendDataset } from './backend-utilities';
import { convertHierarchicalViewToParentChildArray, getDescendantProperty } from './utilities';
import { sortByFieldType } from '../sorters/sorterUtilities';
import { SharedService } from './shared.service';
import { Injectable } from '@angular/core';
let SortService = class SortService {
    constructor(sharedService) {
        this.sharedService = sharedService;
        this._currentLocalSorters = [];
        this._isBackendGrid = false;
        this.httpCancelRequests$ = new Subject(); // this will be used to cancel any pending http request
        this.onSortChanged = new Subject();
        this.onSortCleared = new Subject();
        this._eventHandler = new Slick.EventHandler();
    }
    /** Getter of the SlickGrid Event Handler */
    get eventHandler() {
        return this._eventHandler;
    }
    /** Getter for the Grid Options pulled through the Grid Object */
    get _gridOptions() {
        return (this._grid && this._grid.getOptions) ? this._grid.getOptions() : {};
    }
    /** Getter for the Column Definitions pulled through the Grid Object */
    get _columnDefinitions() {
        return (this._grid && this._grid.getColumns) ? this._grid.getColumns() : [];
    }
    /** Getter of SlickGrid DataView object */
    get _dataView() {
        return (this._grid && this._grid.getData) ? this._grid.getData() : {};
    }
    /**
     * Bind a backend sort (single/multi) hook to the grid
     * @param grid SlickGrid Grid object
     * @param dataView SlickGrid DataView object
     */
    bindBackendOnSort(grid) {
        this._isBackendGrid = true;
        this._grid = grid;
        // subscribe to the SlickGrid event and call the backend execution
        this._eventHandler.subscribe(grid.onSort, this.onBackendSortChanged.bind(this));
    }
    /**
     * Bind a local sort (single/multi) hook to the grid
     * @param grid SlickGrid Grid object
     * @param gridOptions Grid Options object
     * @param dataView
     */
    bindLocalOnSort(grid) {
        this._isBackendGrid = false;
        this._grid = grid;
        this.processTreeDataInitialSort();
        this._eventHandler.subscribe(grid.onSort, this.handleLocalOnSort.bind(this));
    }
    handleLocalOnSort(_e, args) {
        if (args && (args.sortCols || args.sortCol)) {
            // multiSort and singleSort are not exactly the same, but we want to structure it the same for the (for loop) after
            // also to avoid having to rewrite the for loop in the sort, we will make the singleSort an array of 1 object
            const sortColumns = (args.multiColumnSort) ? args.sortCols : new Array({ sortAsc: args.sortAsc, sortCol: args.sortCol });
            // keep current sorters
            this._currentLocalSorters = []; // reset current local sorters
            if (Array.isArray(sortColumns)) {
                sortColumns.forEach((sortColumn) => {
                    if (sortColumn.sortCol) {
                        this._currentLocalSorters.push({
                            columnId: sortColumn.sortCol.id,
                            direction: sortColumn.sortAsc ? SortDirection.ASC : SortDirection.DESC
                        });
                    }
                });
            }
            this.onLocalSortChanged(this._grid, sortColumns);
            this.emitSortChanged(EmitterType.local);
        }
    }
    clearSortByColumnId(event, columnId) {
        // get previously sorted columns
        const allSortedCols = this.getCurrentColumnSorts();
        const sortedColsWithoutCurrent = this.getCurrentColumnSorts(`${columnId}`);
        if (Array.isArray(allSortedCols) && Array.isArray(sortedColsWithoutCurrent) && allSortedCols.length !== sortedColsWithoutCurrent.length) {
            if (this._gridOptions.backendServiceApi) {
                this.onBackendSortChanged(event, { multiColumnSort: true, sortCols: sortedColsWithoutCurrent, grid: this._grid });
            }
            else if (this._dataView) {
                this.onLocalSortChanged(this._grid, sortedColsWithoutCurrent, true, true);
            }
            else {
                // when using customDataView, we will simply send it as a onSort event with notify
                const isMultiSort = this._gridOptions && this._gridOptions.multiColumnSort || false;
                const sortOutput = isMultiSort ? sortedColsWithoutCurrent : sortedColsWithoutCurrent[0];
                this._grid.onSort.notify(sortOutput);
            }
            // update the grid sortColumns array which will at the same add the visual sort icon(s) on the UI
            const updatedSortColumns = sortedColsWithoutCurrent.map((col) => {
                return {
                    columnId: col && col.sortCol && col.sortCol.id,
                    sortAsc: col && col.sortAsc,
                    sortCol: col && col.sortCol,
                };
            });
            this._grid.setSortColumns(updatedSortColumns); // add sort icon in UI
        }
        // when there's no more sorting, we re-sort by the default sort field, user can customize it "defaultColumnSortFieldId", defaults to "id"
        if (Array.isArray(sortedColsWithoutCurrent) && sortedColsWithoutCurrent.length === 0) {
            this.sortLocalGridByDefaultSortFieldId();
        }
    }
    /**
     * Clear Sorting
     * - 1st, remove the SlickGrid sort icons (this setSortColumns function call really does only that)
     * - 2nd, we also need to trigger a sort change
     *   - for a backend grid, we will trigger a backend sort changed with an empty sort columns array
     *   - however for a local grid, we need to pass a sort column and so we will sort by the 1st column
     * @param trigger query event after executing clear filter?
     */
    clearSorting(triggerQueryEvent = true) {
        if (this._grid && this._gridOptions && this._dataView) {
            // remove any sort icons (this setSortColumns function call really does only that)
            this._grid.setSortColumns([]);
            // we also need to trigger a sort change
            // for a backend grid, we will trigger a backend sort changed with an empty sort columns array
            // however for a local grid, we need to pass a sort column and so we will sort by the 1st column
            if (triggerQueryEvent) {
                if (this._isBackendGrid) {
                    this.onBackendSortChanged(undefined, { grid: this._grid, sortCols: [], clearSortTriggered: true });
                }
                else {
                    if (this._columnDefinitions && Array.isArray(this._columnDefinitions)) {
                        this.sortLocalGridByDefaultSortFieldId();
                    }
                }
            }
            else if (this._isBackendGrid) {
                const backendService = this._gridOptions && this._gridOptions.backendServiceApi && this._gridOptions.backendServiceApi.service;
                if (backendService && backendService.clearSorters) {
                    backendService.clearSorters();
                }
            }
        }
        // set current sorter to empty & emit a sort changed event
        this._currentLocalSorters = [];
        // emit an event when sorts are all cleared
        this.onSortCleared.next(true);
    }
    dispose() {
        // unsubscribe all SlickGrid events
        if (this._eventHandler && this._eventHandler.unsubscribeAll) {
            this._eventHandler.unsubscribeAll();
        }
        if (isObservable(this.httpCancelRequests$)) {
            this.httpCancelRequests$.next(); // this cancels any pending http requests
        }
    }
    /**
     * Toggle the Sorting Functionality
     * @param {boolean} isSortingDisabled - optionally force a disable/enable of the Sort Functionality? Defaults to True
     * @param {boolean} clearSortingWhenDisabled - when disabling the sorting, do we also want to clear the sorting as well? Defaults to True
     */
    disableSortFunctionality(isSortingDisabled = true, clearSortingWhenDisabled = true) {
        const prevSorting = this._gridOptions.enableSorting;
        const newSorting = !prevSorting;
        this._gridOptions.enableSorting = newSorting;
        let updatedColumnDefinitions;
        if (isSortingDisabled) {
            if (clearSortingWhenDisabled) {
                this.clearSorting();
            }
            this._eventHandler.unsubscribeAll();
            updatedColumnDefinitions = this.disableAllSortingCommands(true);
        }
        else {
            updatedColumnDefinitions = this.disableAllSortingCommands(false);
            const onSortHandler = this._grid.onSort;
            this._eventHandler.subscribe(onSortHandler, (e, args) => this.handleLocalOnSort(e, args));
        }
        this._grid.setOptions({ enableSorting: this._gridOptions.enableSorting }, false, true);
        this.sharedService.gridOptions = this._gridOptions;
        // reset columns so that it recreate the column headers and remove/add the sort icon hints
        // basically without this, the sort icon hints were still showing up even after disabling the Sorting
        this._grid.setColumns(updatedColumnDefinitions);
    }
    /**
     * Toggle the Sorting functionality
     * @param {boolean} clearSortingWhenDisabled - when disabling the sorting, do we also want to clear the sorting as well? Defaults to True
     */
    toggleSortFunctionality(clearSortingOnDisable = true) {
        const previousSorting = this._gridOptions.enableSorting;
        this.disableSortFunctionality(previousSorting, clearSortingOnDisable);
    }
    /**
     * A simple function that is binded to the subscriber and emit a change when the sort is called.
     * Other services, like Pagination, can then subscribe to it.
     * @param sender
     */
    emitSortChanged(sender, currentLocalSorters) {
        if (sender === EmitterType.remote && this._gridOptions && this._gridOptions.backendServiceApi) {
            let currentSorters = [];
            const backendService = this._gridOptions.backendServiceApi.service;
            if (backendService && backendService.getCurrentSorters) {
                currentSorters = backendService.getCurrentSorters();
            }
            this.onSortChanged.next(currentSorters);
        }
        else if (sender === EmitterType.local) {
            if (currentLocalSorters) {
                this._currentLocalSorters = currentLocalSorters;
            }
            this.onSortChanged.next(this.getCurrentLocalSorters());
        }
    }
    getCurrentLocalSorters() {
        return this._currentLocalSorters;
    }
    /**
     * Get current column sorts,
     * If a column is passed as an argument, that will be exclusion so we won't add this column to our output array since it is already in the array.
     * The usage of this method is that we want to know the sort prior to calling the next sorting command
     */
    getCurrentColumnSorts(excludedColumnId) {
        // getSortColumns() only returns sortAsc & columnId, we want the entire column definition
        const oldSortColumns = this._grid && this._grid.getSortColumns();
        // get the column definition but only keep column which are not equal to our current column
        if (Array.isArray(oldSortColumns)) {
            const sortedCols = oldSortColumns.reduce((cols, col) => {
                if (!excludedColumnId || col.columnId !== excludedColumnId) {
                    cols.push({ sortCol: this._columnDefinitions[this._grid.getColumnIndex(col.columnId)], sortAsc: col.sortAsc });
                }
                return cols;
            }, []);
            return sortedCols;
        }
        return [];
    }
    /** Load defined Sorting (sorters) into the grid */
    loadGridSorters(sorters) {
        this._currentLocalSorters = []; // reset current local sorters
        const sortCols = [];
        if (Array.isArray(sorters)) {
            sorters.forEach((sorter) => {
                const gridColumn = this._columnDefinitions.find((col) => col.id === sorter.columnId);
                if (gridColumn) {
                    sortCols.push({
                        columnId: gridColumn.id,
                        sortAsc: ((sorter.direction.toUpperCase() === SortDirection.ASC) ? true : false),
                        sortCol: gridColumn
                    });
                    // keep current sorters
                    this._currentLocalSorters.push({
                        columnId: gridColumn.id + '',
                        direction: sorter.direction.toUpperCase()
                    });
                }
            });
        }
        if (sortCols.length > 0) {
            this.onLocalSortChanged(this._grid, sortCols);
            this._grid.setSortColumns(sortCols); // use this to add sort icon(s) in UI
        }
        return sortCols;
    }
    /** Process the initial sort, typically it will sort ascending by the column that has the Tree Data unless user specifies a different initialSort */
    processTreeDataInitialSort() {
        // when a Tree Data view is defined, we must sort the data so that the UI works correctly
        if (this._gridOptions && this._gridOptions.enableTreeData && this._gridOptions.treeDataOptions) {
            // first presort it once by tree level
            const treeDataOptions = this._gridOptions.treeDataOptions;
            const columnWithTreeData = this._columnDefinitions.find((col) => col && col.id === treeDataOptions.columnId);
            if (columnWithTreeData) {
                let sortDirection = SortDirection.ASC;
                let sortTreeLevelColumn = { columnId: treeDataOptions.columnId, sortCol: columnWithTreeData, sortAsc: true };
                // user could provide a custom sort field id, if so get that column and sort by it
                if (treeDataOptions && treeDataOptions.initialSort && treeDataOptions.initialSort.columnId) {
                    const initialSortColumnId = treeDataOptions.initialSort.columnId;
                    const initialSortColumn = this._columnDefinitions.find((col) => col.id === initialSortColumnId);
                    sortDirection = (treeDataOptions.initialSort.direction || SortDirection.ASC).toUpperCase();
                    sortTreeLevelColumn = { columnId: initialSortColumnId, sortCol: initialSortColumn, sortAsc: (sortDirection === SortDirection.ASC) };
                }
                // when we have a valid column with Tree Data, we can sort by that column
                if (sortTreeLevelColumn && sortTreeLevelColumn.columnId) {
                    this.updateSorting([{ columnId: sortTreeLevelColumn.columnId || '', direction: sortDirection }]);
                }
            }
        }
    }
    onBackendSortChanged(event, args) {
        if (!args || !args.grid) {
            throw new Error('Something went wrong when trying to bind the "onBackendSortChanged(event, args)" function, it seems that "args" is not populated correctly');
        }
        const gridOptions = (args.grid && args.grid.getOptions) ? args.grid.getOptions() : {};
        const backendApi = gridOptions.backendServiceApi;
        if (!backendApi || !backendApi.process || !backendApi.service) {
            throw new Error(`BackendServiceApi requires at least a "process" function and a "service" defined`);
        }
        // keep start time & end timestamps & return it after process execution
        const startTime = new Date();
        if (backendApi.preProcess) {
            backendApi.preProcess();
        }
        // query backend
        const query = backendApi.service.processOnSortChanged(event, args);
        const totalItems = gridOptions && gridOptions.pagination && gridOptions.pagination.totalItems;
        executeBackendCallback(backendApi, query, args, startTime, totalItems, this.emitSortChanged.bind(this), this.httpCancelRequests$);
    }
    /** When a Sort Changes on a Local grid (JSON dataset) */
    onLocalSortChanged(grid, sortColumns, forceReSort = false, emitSortChanged = false) {
        const isTreeDataEnabled = this._gridOptions && this._gridOptions.enableTreeData || false;
        const dataView = grid && grid.getData && grid.getData();
        if (grid && dataView) {
            if (forceReSort && !isTreeDataEnabled) {
                dataView.reSort();
            }
            if (isTreeDataEnabled && this.sharedService && Array.isArray(this.sharedService.hierarchicalDataset)) {
                const hierarchicalDataset = this.sharedService.hierarchicalDataset;
                this.sortTreeData(hierarchicalDataset, sortColumns);
                const dataViewIdIdentifier = this._gridOptions && this._gridOptions.datasetIdPropertyName || 'id';
                const treeDataOpt = this._gridOptions && this._gridOptions.treeDataOptions || { columnId: '' };
                const treeDataOptions = Object.assign({}, treeDataOpt, { identifierPropName: treeDataOpt.identifierPropName || dataViewIdIdentifier });
                const sortedFlatArray = convertHierarchicalViewToParentChildArray(hierarchicalDataset, treeDataOptions);
                dataView.setItems(sortedFlatArray, this._gridOptions && this._gridOptions.datasetIdPropertyName || 'id');
            }
            else {
                dataView.sort(this.sortComparers.bind(this, sortColumns));
            }
            grid.invalidate();
            grid.render();
            if (emitSortChanged) {
                this.emitSortChanged(EmitterType.local, sortColumns.map(col => {
                    return {
                        columnId: col.sortCol && col.sortCol.id || 'id',
                        direction: col.sortAsc ? SortDirection.ASC : SortDirection.DESC
                    };
                }));
            }
        }
    }
    /** Call a local grid sort by its default sort field id (user can customize default field by configuring "defaultColumnSortFieldId" in the grid options, defaults to "id") */
    sortLocalGridByDefaultSortFieldId() {
        const sortColFieldId = this._gridOptions && this._gridOptions.defaultColumnSortFieldId || this._gridOptions.datasetIdPropertyName || 'id';
        const sortCol = { id: sortColFieldId, field: sortColFieldId };
        this.onLocalSortChanged(this._grid, new Array({ sortAsc: true, sortCol, clearSortTriggered: true }));
    }
    sortComparers(sortColumns, dataRow1, dataRow2) {
        if (Array.isArray(sortColumns)) {
            for (const sortColumn of sortColumns) {
                const result = this.sortComparer(sortColumn, dataRow1, dataRow2);
                if (result !== undefined) {
                    return result;
                }
            }
        }
        return SortDirectionNumber.neutral;
    }
    sortComparer(sortColumn, dataRow1, dataRow2, querySortField) {
        if (sortColumn && sortColumn.sortCol) {
            const columnDef = sortColumn.sortCol;
            const sortDirection = sortColumn.sortAsc ? SortDirectionNumber.asc : SortDirectionNumber.desc;
            let queryFieldName1 = querySortField || columnDef.queryFieldSorter || columnDef.queryField || columnDef.field;
            let queryFieldName2 = queryFieldName1;
            const fieldType = columnDef.type || FieldType.string;
            // if user provided a query field name getter callback, we need to get the name on each item independently
            if (typeof columnDef.queryFieldNameGetterFn === 'function') {
                queryFieldName1 = columnDef.queryFieldNameGetterFn(dataRow1);
                queryFieldName2 = columnDef.queryFieldNameGetterFn(dataRow2);
            }
            let value1 = dataRow1[queryFieldName1];
            let value2 = dataRow2[queryFieldName2];
            // when item is a complex object (dot "." notation), we need to filter the value contained in the object tree
            if (queryFieldName1 && queryFieldName1.indexOf('.') >= 0) {
                value1 = getDescendantProperty(dataRow1, queryFieldName1);
            }
            if (queryFieldName2 && queryFieldName2.indexOf('.') >= 0) {
                value2 = getDescendantProperty(dataRow2, queryFieldName2);
            }
            // user could provide his own custom Sorter
            if (columnDef.sorter) {
                const customSortResult = columnDef.sorter(value1, value2, sortDirection, columnDef);
                if (customSortResult !== SortDirectionNumber.neutral) {
                    return customSortResult;
                }
            }
            else {
                const sortResult = sortByFieldType(fieldType, value1, value2, sortDirection, columnDef);
                if (sortResult !== SortDirectionNumber.neutral) {
                    return sortResult;
                }
            }
        }
        return undefined;
    }
    sortTreeData(hierarchicalArray, sortColumns) {
        if (Array.isArray(sortColumns)) {
            for (const sortColumn of sortColumns) {
                this.sortTreeChild(hierarchicalArray, sortColumn, 0);
            }
        }
    }
    /** Sort the Tree Children of a hierarchical dataset by recursion */
    sortTreeChild(hierarchicalArray, sortColumn, treeLevel) {
        const treeDataOptions = this._gridOptions && this._gridOptions.treeDataOptions;
        const childrenPropName = treeDataOptions && treeDataOptions.childrenPropName || 'children';
        hierarchicalArray.sort((a, b) => this.sortComparer(sortColumn, a, b) || SortDirectionNumber.neutral);
        // when item has a child, we'll sort recursively
        for (const item of hierarchicalArray) {
            if (item) {
                const hasChildren = item.hasOwnProperty(childrenPropName) && Array.isArray(item[childrenPropName]);
                // when item has a child, we'll sort recursively
                if (hasChildren) {
                    treeLevel++;
                    this.sortTreeChild(item[childrenPropName], sortColumn, treeLevel);
                    treeLevel--;
                }
            }
        }
    }
    /**
     * Update Sorting (sorters) dynamically just by providing an array of sorter(s).
     * You can also choose emit (default) a Sort Changed event that will be picked by the Grid State Service.
     *
     * Also for backend service only, you can choose to trigger a backend query (default) or not if you wish to do it later,
     * this could be useful when using updateFilters & updateSorting and you wish to only send the backend query once.
     * @param sorters array
     * @param triggerEvent defaults to True, do we want to emit a sort changed event?
     * @param triggerBackendQuery defaults to True, which will query the backend.
     */
    updateSorting(sorters, emitChangedEvent = true, triggerBackendQuery = true) {
        if (!this._gridOptions || !this._gridOptions.enableSorting) {
            throw new Error('[Angular-Slickgrid] in order to use "updateSorting" method, you need to have Sortable Columns defined in your grid and "enableSorting" set in your Grid Options');
        }
        if (Array.isArray(sorters)) {
            const backendApi = this._gridOptions && this._gridOptions.backendServiceApi;
            if (backendApi) {
                const backendApiService = backendApi && backendApi.service;
                if (backendApiService) {
                    backendApiService.updateSorters(undefined, sorters);
                    if (triggerBackendQuery) {
                        refreshBackendDataset(this._gridOptions);
                    }
                }
            }
            else {
                this.loadGridSorters(sorters);
            }
            if (emitChangedEvent) {
                const emitterType = backendApi ? EmitterType.remote : EmitterType.local;
                this.emitSortChanged(emitterType);
            }
        }
    }
    // --
    // private functions
    // -------------------
    /**
     * Loop through all column definitions and do the following 2 things
     * 1. disable/enable the "sortable" property of each column
     * 2. loop through each Header Menu commands and change the "hidden" commands to show/hide depending if it's enabled/disabled
     * Also note that we aren't deleting any properties, we just toggle their flags so that we can reloop through at later point in time.
     * (if we previously deleted these properties we wouldn't be able to change them back since these properties wouldn't exist anymore, hence why we just hide the commands)
     * @param {boolean} isDisabling - are we disabling the sort functionality? Defaults to true
     */
    disableAllSortingCommands(isDisabling = true) {
        const columnDefinitions = this._grid.getColumns();
        // loop through column definition to hide/show header menu commands
        columnDefinitions.forEach((col) => {
            if (typeof col.sortable !== undefined) {
                col.sortable = !isDisabling;
            }
            if (col && col.header && col.header.menu) {
                col.header.menu.items.forEach(menuItem => {
                    if (menuItem && typeof menuItem !== 'string') {
                        const menuCommand = menuItem.command;
                        if (menuCommand === 'sort-asc' || menuCommand === 'sort-desc' || menuCommand === 'clear-sort') {
                            menuItem.hidden = isDisabling;
                        }
                    }
                });
            }
        });
        // loop through column definition to hide/show grid menu commands
        if (this._gridOptions && this._gridOptions.gridMenu && this._gridOptions.gridMenu.customItems) {
            this._gridOptions.gridMenu.customItems.forEach((menuItem) => {
                if (menuItem && typeof menuItem !== 'string') {
                    const menuCommand = menuItem.command;
                    if (menuCommand === 'clear-sorting') {
                        menuItem.hidden = isDisabling;
                    }
                }
            });
        }
        return columnDefinitions;
    }
};
SortService.ctorParameters = () => [
    { type: SharedService }
];
SortService = tslib_1.__decorate([
    Injectable()
], SortService);
export { SortService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29ydC5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci1zbGlja2dyaWQvIiwic291cmNlcyI6WyJhcHAvbW9kdWxlcy9hbmd1bGFyLXNsaWNrZ3JpZC9zZXJ2aWNlcy9zb3J0LnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxZQUFZLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBRTdDLE9BQU8sRUFJTCxXQUFXLEVBQ1gsU0FBUyxFQUdULGFBQWEsRUFDYixtQkFBbUIsR0FHcEIsTUFBTSxtQkFBbUIsQ0FBQztBQUMzQixPQUFPLEVBQUUsc0JBQXNCLEVBQUUscUJBQXFCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUNwRixPQUFPLEVBQUUseUNBQXlDLEVBQUUscUJBQXFCLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDL0YsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQzdELE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUNqRCxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBTTNDLElBQWEsV0FBVyxHQUF4QixNQUFhLFdBQVc7SUFTdEIsWUFBb0IsYUFBNEI7UUFBNUIsa0JBQWEsR0FBYixhQUFhLENBQWU7UUFSeEMseUJBQW9CLEdBQW9CLEVBQUUsQ0FBQztRQUczQyxtQkFBYyxHQUFHLEtBQUssQ0FBQztRQUN2Qix3QkFBbUIsR0FBa0IsSUFBSSxPQUFPLEVBQVEsQ0FBQyxDQUFDLHVEQUF1RDtRQUN6SCxrQkFBYSxHQUFHLElBQUksT0FBTyxFQUFtQixDQUFDO1FBQy9DLGtCQUFhLEdBQUcsSUFBSSxPQUFPLEVBQVcsQ0FBQztRQUdyQyxJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksS0FBSyxDQUFDLFlBQVksRUFBRSxDQUFDO0lBQ2hELENBQUM7SUFFRCw0Q0FBNEM7SUFDNUMsSUFBSSxZQUFZO1FBQ2QsT0FBTyxJ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bXBvcnQgeyBpc09ic2VydmFibGUsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHtcbiAgQ29sdW1uLFxuICBDb2x1bW5Tb3J0LFxuICBDdXJyZW50U29ydGVyLFxuICBFbWl0dGVyVHlwZSxcbiAgRmllbGRUeXBlLFxuICBHcmlkT3B0aW9uLFxuICBTbGlja0V2ZW50SGFuZGxlcixcbiAgU29ydERpcmVjdGlvbixcbiAgU29ydERpcmVjdGlvbk51bWJlcixcbiAgU29ydERpcmVjdGlvblN0cmluZyxcbiAgVHJlZURhdGFPcHRpb24sXG59IGZyb20gJy4vLi4vbW9kZWxzL2luZGV4JztcbmltcG9ydCB7IGV4ZWN1dGVCYWNrZW5kQ2FsbGJhY2ssIHJlZnJlc2hCYWNrZW5kRGF0YXNldCB9IGZyb20gJy4vYmFja2VuZC11dGlsaXRpZXMnO1xuaW1wb3J0IHsgY29udmVydEhpZXJhcmNoaWNhbFZpZXdUb1BhcmVudENoaWxkQXJyYXksIGdldERlc2NlbmRhbnRQcm9wZXJ0eSB9IGZyb20gJy4vdXRpbGl0aWVzJztcbmltcG9ydCB7IHNvcnRCeUZpZWxkVHlwZSB9IGZyb20gJy4uL3NvcnRlcnMvc29ydGVyVXRpbGl0aWVzJztcbmltcG9ydCB7IFNoYXJlZFNlcnZpY2UgfSBmcm9tICcuL3NoYXJlZC5zZXJ2aWNlJztcbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLy8gdXNpbmcgZXh0ZXJuYWwgbm9uLXR5cGVkIGpzIGxpYnJhcmllc1xuZGVjbGFyZSBjb25zdCBTbGljazogYW55O1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgU29ydFNlcnZpY2Uge1xuICBwcml2YXRlIF9jdXJyZW50TG9jYWxTb3J0ZXJzOiBDdXJyZW50U29ydGVyW10gPSBbXTtcbiAgcHJpdmF0ZSBfZXZlbnRIYW5kbGVyOiBTbGlja0V2ZW50SGFuZGxlcjtcbiAgcHJpdmF0ZSBfZ3JpZDogYW55O1xuICBwcml2YXRlIF9pc0JhY2tlbmRHcmlkID0gZmFsc2U7XG4gIHByaXZhdGUgaHR0cENhbmNlbFJlcXVlc3RzJDogU3ViamVjdDx2b2lkPiA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7IC8vIHRoaXMgd2lsbCBiZSB1c2VkIHRvIGNhbmNlbCBhbnkgcGVuZGluZyBodHRwIHJlcXVlc3RcbiAgb25Tb3J0Q2hhbmdlZCA9IG5ldyBTdWJqZWN0PEN1cnJlbnRTb3J0ZXJbXT4oKTtcbiAgb25Tb3J0Q2xlYXJlZCA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBzaGFyZWRTZXJ2aWNlOiBTaGFyZWRTZXJ2aWNlKSB7XG4gICAgdGhpcy5fZXZlbnRIYW5kbGVyID0gbmV3IFNsaWNrLkV2ZW50SGFuZGxlcigpO1xuICB9XG5cbiAgLyoqIEdldHRlciBvZiB0aGUgU2xpY2tHcmlkIEV2ZW50IEhhbmRsZXIgKi9cbiAgZ2V0IGV2ZW50SGFuZGxlcigpOiBTbGlja0V2ZW50SGFuZGxlciB7XG4gICAgcmV0dXJuIHRoaXMuX2V2ZW50SGFuZGxlcjtcbiAgfVxuXG4gIC8qKiBHZXR0ZXIgZm9yIHRoZSBHcmlkIE9wdGlvbnMgcHVsbGVkIHRocm91Z2ggdGhlIEdyaWQgT2JqZWN0ICovXG4gIHByaXZhdGUgZ2V0IF9ncmlkT3B0aW9ucygpOiBHcmlkT3B0aW9uIHtcbiAgICByZXR1cm4gKHRoaXMuX2dyaWQgJiYgdGhpcy5fZ3JpZC5nZXRPcHRpb25zKSA/IHRoaXMuX2dyaWQuZ2V0T3B0aW9ucygpIDoge307XG4gIH1cblxuICAvKiogR2V0dGVyIGZvciB0aGUgQ29sdW1uIERlZmluaXRpb25zIHB1bGxlZCB0aHJvdWdoIHRoZSBHcmlkIE9iamVjdCAqL1xuICBwcml2YXRlIGdldCBfY29sdW1uRGVmaW5pdGlvbnMoKTogQ29sdW1uW10ge1xuICAgIHJldHVybiAodGhpcy5fZ3JpZCAmJiB0aGlzLl9ncmlkLmdldENvbHVtbnMpID8gdGhpcy5fZ3JpZC5nZXRDb2x1bW5zKCkgOiBbXTtcbiAgfVxuXG4gIC8qKiBHZXR0ZXIgb2YgU2xpY2tHcmlkIERhdGFWaWV3IG9iamVjdCAqL1xuICBwcml2YXRlIGdldCBfZGF0YVZpZXcoKTogYW55IHtcbiAgICByZXR1cm4gKHRoaXMuX2dyaWQgJiYgdGhpcy5fZ3JpZC5nZXREYXRhKSA/IHRoaXMuX2dyaWQuZ2V0RGF0YSgpIDoge307XG4gIH1cblxuICAvKipcbiAgICogQmluZCBhIGJhY2tlbmQgc29ydCAoc2luZ2xlL211bHRpKSBob29rIHRvIHRoZSBncmlkXG4gICAqIEBwYXJhbSBncmlkIFNsaWNrR3JpZCBHcmlkIG9iamVjdFxuICAgKiBAcGFyYW0gZGF0YVZpZXcgU2xpY2tHcmlkIERhdGFWaWV3IG9iamVjdFxuICAgKi9cbiAgYmluZEJhY2tlbmRPblNvcnQoZ3JpZDogYW55KSB7XG4gICAgdGhpcy5faXNCYWNrZW5kR3JpZCA9IHRydWU7XG4gICAgdGhpcy5fZ3JpZCA9IGdyaWQ7XG5cbiAgICAvLyBzdWJzY3JpYmUgdG8gdGhlIFNsaWNrR3JpZCBldmVudCBhbmQgY2FsbCB0aGUgYmFja2VuZCBleGVjdXRpb25cbiAgICB0aGlzLl9ldmVudEhhbmRsZXIuc3Vic2NyaWJlKGdyaWQub25Tb3J0LCB0aGlzLm9uQmFja2VuZFNvcnRDaGFuZ2VkLmJpbmQodGhpcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJpbmQgYSBsb2NhbCBzb3J0IChzaW5nbGUvbXVsdGkpIGhvb2sgdG8gdGhlIGdyaWRcbiAgICogQHBhcmFtIGdyaWQgU2xpY2tHcmlkIEdyaWQgb2JqZWN0XG4gICAqIEBwYXJhbSBncmlkT3B0aW9ucyBHcmlkIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSBkYXRhVmlld1xuICAgKi9cbiAgYmluZExvY2FsT25Tb3J0KGdyaWQ6IGFueSkge1xuICAgIHRoaXMuX2lzQmFja2VuZEdyaWQgPSBmYWxzZTtcbiAgICB0aGlzLl9ncmlkID0gZ3JpZDtcblxuICAgIHRoaXMucHJvY2Vzc1RyZWVEYXRhSW5pdGlhbFNvcnQoKTtcbiAgICB0aGlzLl9ldmVudEhhbmRsZXIuc3Vic2NyaWJlKGdyaWQub25Tb3J0LCB0aGlzLmhhbmRsZUxvY2FsT25Tb3J0LmJpbmQodGhpcykpO1xuICB9XG5cbiAgaGFuZGxlTG9jYWxPblNvcnQoX2U6IGFueSwgYXJnczogYW55KSB7XG4gICAgaWYgKGFyZ3MgJiYgKGFyZ3Muc29ydENvbHMgfHwgYXJncy5zb3J0Q29sKSkge1xuICAgICAgLy8gbXVsdGlTb3J0IGFuZCBzaW5nbGVTb3J0IGFyZSBub3QgZXhhY3RseSB0aGUgc2FtZSwgYnV0IHdlIHdhbnQgdG8gc3RydWN0dXJlIGl0IHRoZSBzYW1lIGZvciB0aGUgKGZvciBsb29wKSBhZnRlclxuICAgICAgLy8gYWxzbyB0byBhdm9pZCBoYXZpbmcgdG8gcmV3cml0ZSB0aGUgZm9yIGxvb3AgaW4gdGhlIHNvcnQsIHdlIHdpbGwgbWFrZSB0aGUgc2luZ2xlU29ydCBhbiBhcnJheSBvZiAxIG9iamVjdFxuICAgICAgY29uc3Qgc29ydENvbHVtbnMgPSAoYXJncy5tdWx0aUNvbHVtblNvcnQpID8gYXJncy5zb3J0Q29scyA6IG5ldyBBcnJheSh7IHNvcnRBc2M6IGFyZ3Muc29ydEFzYywgc29ydENvbDogYXJncy5zb3J0Q29sIH0pO1xuXG4gICAgICAvLyBrZWVwIGN1cnJlbnQgc29ydGVyc1xuICAgICAgdGhpcy5fY3VycmVudExvY2FsU29ydGVycyA9IFtdOyAvLyByZXNldCBjdXJyZW50IGxvY2FsIHNvcnRlcnNcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNvcnRDb2x1bW5zKSkge1xuICAgICAgICBzb3J0Q29sdW1ucy5mb3JFYWNoKChzb3J0Q29sdW1uOiB7IHNvcnRDb2w6IENvbHVtbjsgc29ydEFzYzogYm9vbGVhbjsgfSkgPT4ge1xuICAgICAgICAgIGlmIChzb3J0Q29sdW1uLnNvcnRDb2wpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRMb2NhbFNvcnRlcnMucHVzaCh7XG4gICAgICAgICAgICAgIGNvbHVtbklkOiBzb3J0Q29sdW1uLnNvcnRDb2wuaWQsXG4gICAgICAgICAgICAgIGRpcmVjdGlvbjogc29ydENvbHVtbi5zb3J0QXNjID8gU29ydERpcmVjdGlvbi5BU0MgOiBTb3J0RGlyZWN0aW9uLkRFU0NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMub25Mb2NhbFNvcnRDaGFuZ2VkKHRoaXMuX2dyaWQsIHNvcnRDb2x1bW5zKTtcbiAgICAgIHRoaXMuZW1pdFNvcnRDaGFuZ2VkKEVtaXR0ZXJUeXBlLmxvY2FsKTtcbiAgICB9XG4gIH1cblxuICBjbGVhclNvcnRCeUNvbHVtbklkKGV2ZW50OiBFdmVudCB8IHVuZGVmaW5lZCwgY29sdW1uSWQ6IHN0cmluZyB8IG51bWJlcikge1xuICAgIC8vIGdldCBwcmV2aW91c2x5IHNvcnRlZCBjb2x1bW5zXG4gICAgY29uc3QgYWxsU29ydGVkQ29sczogQ29sdW1uU29ydFtdID0gdGhpcy5nZXRDdXJyZW50Q29sdW1uU29ydHMoKTtcbiAgICBjb25zdCBzb3J0ZWRDb2xzV2l0aG91dEN1cnJlbnQ6IENvbHVtblNvcnRbXSA9IHRoaXMuZ2V0Q3VycmVudENvbHVtblNvcnRzKGAke2NvbHVtbklkfWApO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYWxsU29ydGVkQ29scykgJiYgQXJyYXkuaXNBcnJheShzb3J0ZWRDb2xzV2l0aG91dEN1cnJlbnQpICYmIGFsbFNvcnRlZENvbHMubGVuZ3RoICE9PSBzb3J0ZWRDb2xzV2l0aG91dEN1cnJlbnQubGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5fZ3JpZE9wdGlvbnMuYmFja2VuZFNlcnZpY2VBcGkpIHtcbiAgICAgICAgdGhpcy5vbkJhY2tlbmRTb3J0Q2hhbmdlZChldmVudCwgeyBtdWx0aUNvbHVtblNvcnQ6IHRydWUsIHNvcnRDb2xzOiBzb3J0ZWRDb2xzV2l0aG91dEN1cnJlbnQsIGdyaWQ6IHRoaXMuX2dyaWQgfSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2RhdGFWaWV3KSB7XG4gICAgICAgIHRoaXMub25Mb2NhbFNvcnRDaGFuZ2VkKHRoaXMuX2dyaWQsIHNvcnRlZENvbHNXaXRob3V0Q3VycmVudCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB3aGVuIHVzaW5nIGN1c3RvbURhdGFWaWV3LCB3ZSB3aWxsIHNpbXBseSBzZW5kIGl0IGFzIGEgb25Tb3J0IGV2ZW50IHdpdGggbm90aWZ5XG4gICAgICAgIGNvbnN0IGlzTXVsdGlTb3J0ID0gdGhpcy5fZ3JpZE9wdGlvbnMgJiYgdGhpcy5fZ3JpZE9wdGlvbnMubXVsdGlDb2x1bW5Tb3J0IHx8IGZhbHNlO1xuICAgICAgICBjb25zdCBzb3J0T3V0cHV0ID0gaXNNdWx0aVNvcnQgPyBzb3J0ZWRDb2xzV2l0aG91dEN1cnJlbnQgOiBzb3J0ZWRDb2xzV2l0aG91dEN1cnJlbnRbMF07XG4gICAgICAgIHRoaXMuX2dyaWQub25Tb3J0Lm5vdGlmeShzb3J0T3V0cHV0KTtcbiAgICAgIH1cblxuICAgICAgLy8gdXBkYXRlIHRoZSBncmlkIHNvcnRDb2x1bW5zIGFycmF5IHdoaWNoIHdpbGwgYXQgdGhlIHNhbWUgYWRkIHRoZSB2aXN1YWwgc29ydCBpY29uKHMpIG9uIHRoZSBVSVxuICAgICAgY29uc3QgdXBkYXRlZFNvcnRDb2x1bW5zOiBDb2x1bW5Tb3J0W10gPSBzb3J0ZWRDb2xzV2l0aG91dEN1cnJlbnQubWFwKChjb2wpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb2x1bW5JZDogY29sICYmIGNvbC5zb3J0Q29sICYmIGNvbC5zb3J0Q29sLmlkLFxuICAgICAgICAgIHNvcnRBc2M6IGNvbCAmJiBjb2wuc29ydEFzYyxcbiAgICAgICAgICBzb3J0Q29sOiBjb2wgJiYgY29sLnNvcnRDb2wsXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2dyaWQuc2V0U29ydENvbHVtbnModXBkYXRlZFNvcnRDb2x1bW5zKTsgLy8gYWRkIHNvcnQgaWNvbiBpbiBVSVxuICAgIH1cblxuICAgIC8vIHdoZW4gdGhlcmUncyBubyBtb3JlIHNvcnRpbmcsIHdlIHJlLXNvcnQgYnkgdGhlIGRlZmF1bHQgc29ydCBmaWVsZCwgdXNlciBjYW4gY3VzdG9taXplIGl0IFwiZGVmYXVsdENvbHVtblNvcnRGaWVsZElkXCIsIGRlZmF1bHRzIHRvIFwiaWRcIlxuICAgIGlmIChBcnJheS5pc0FycmF5KHNvcnRlZENvbHNXaXRob3V0Q3VycmVudCkgJiYgc29ydGVkQ29sc1dpdGhvdXRDdXJyZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5zb3J0TG9jYWxHcmlkQnlEZWZhdWx0U29ydEZpZWxkSWQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgU29ydGluZ1xuICAgKiAtIDFzdCwgcmVtb3ZlIHRoZSBTbGlja0dyaWQgc29ydCBpY29ucyAodGhpcyBzZXRTb3J0Q29sdW1ucyBmdW5jdGlvbiBjYWxsIHJlYWxseSBkb2VzIG9ubHkgdGhhdClcbiAgICogLSAybmQsIHdlIGFsc28gbmVlZCB0byB0cmlnZ2VyIGEgc29ydCBjaGFuZ2VcbiAgICogICAtIGZvciBhIGJhY2tlbmQgZ3JpZCwgd2Ugd2lsbCB0cmlnZ2VyIGEgYmFja2VuZCBzb3J0IGNoYW5nZWQgd2l0aCBhbiBlbXB0eSBzb3J0IGNvbHVtbnMgYXJyYXlcbiAgICogICAtIGhvd2V2ZXIgZm9yIGEgbG9jYWwgZ3JpZCwgd2UgbmVlZCB0byBwYXNzIGEgc29ydCBjb2x1bW4gYW5kIHNvIHdlIHdpbGwgc29ydCBieSB0aGUgMXN0IGNvbHVtblxuICAgKiBAcGFyYW0gdHJpZ2dlciBxdWVyeSBldmVudCBhZnRlciBleGVjdXRpbmcgY2xlYXIgZmlsdGVyP1xuICAgKi9cbiAgY2xlYXJTb3J0aW5nKHRyaWdnZXJRdWVyeUV2ZW50ID0gdHJ1ZSkge1xuICAgIGlmICh0aGlzLl9ncmlkICYmIHRoaXMuX2dyaWRPcHRpb25zICYmIHRoaXMuX2RhdGFWaWV3KSB7XG4gICAgICAvLyByZW1vdmUgYW55IHNvcnQgaWNvbnMgKHRoaXMgc2V0U29ydENvbHVtbnMgZnVuY3Rpb24gY2FsbCByZWFsbHkgZG9lcyBvbmx5IHRoYXQpXG4gICAgICB0aGlzLl9ncmlkLnNldFNvcnRDb2x1bW5zKFtdKTtcblxuICAgICAgLy8gd2UgYWxzbyBuZWVkIHRvIHRyaWdnZXIgYSBzb3J0IGNoYW5nZVxuICAgICAgLy8gZm9yIGEgYmFja2VuZCBncmlkLCB3ZSB3aWxsIHRyaWdnZXIgYSBiYWNrZW5kIHNvcnQgY2hhbmdlZCB3aXRoIGFuIGVtcHR5IHNvcnQgY29sdW1ucyBhcnJheVxuICAgICAgLy8gaG93ZXZlciBmb3IgYSBsb2NhbCBncmlkLCB3ZSBuZWVkIHRvIHBhc3MgYSBzb3J0IGNvbHVtbiBhbmQgc28gd2Ugd2lsbCBzb3J0IGJ5IHRoZSAxc3QgY29sdW1uXG4gICAgICBpZiAodHJpZ2dlclF1ZXJ5RXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzQmFja2VuZEdyaWQpIHtcbiAgICAgICAgICB0aGlzLm9uQmFja2VuZFNvcnRDaGFuZ2VkKHVuZGVmaW5lZCwgeyBncmlkOiB0aGlzLl9ncmlkLCBzb3J0Q29sczogW10sIGNsZWFyU29ydFRyaWdnZXJlZDogdHJ1ZSB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5fY29sdW1uRGVmaW5pdGlvbnMgJiYgQXJyYXkuaXNBcnJheSh0aGlzLl9jb2x1bW5EZWZpbml0aW9ucykpIHtcbiAgICAgICAgICAgIHRoaXMuc29ydExvY2FsR3JpZEJ5RGVmYXVsdFNvcnRGaWVsZElkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2lzQmFja2VuZEdyaWQpIHtcbiAgICAgICAgY29uc3QgYmFja2VuZFNlcnZpY2UgPSB0aGlzLl9ncmlkT3B0aW9ucyAmJiB0aGlzLl9ncmlkT3B0aW9ucy5iYWNrZW5kU2VydmljZUFwaSAmJiB0aGlzLl9ncmlkT3B0aW9ucy5iYWNrZW5kU2VydmljZUFwaS5zZXJ2aWNlO1xuICAgICAgICBpZiAoYmFja2VuZFNlcnZpY2UgJiYgYmFja2VuZFNlcnZpY2UuY2xlYXJTb3J0ZXJzKSB7XG4gICAgICAgICAgYmFja2VuZFNlcnZpY2UuY2xlYXJTb3J0ZXJzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzZXQgY3VycmVudCBzb3J0ZXIgdG8gZW1wdHkgJiBlbWl0IGEgc29ydCBjaGFuZ2VkIGV2ZW50XG4gICAgdGhpcy5fY3VycmVudExvY2FsU29ydGVycyA9IFtdO1xuXG4gICAgLy8gZW1pdCBhbiBldmVudCB3aGVuIHNvcnRzIGFyZSBhbGwgY2xlYXJlZFxuICAgIHRoaXMub25Tb3J0Q2xlYXJlZC5uZXh0KHRydWUpO1xuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICAvLyB1bnN1YnNjcmliZSBhbGwgU2xpY2tHcmlkIGV2ZW50c1xuICAgIGlmICh0aGlzLl9ldmVudEhhbmRsZXIgJiYgdGhpcy5fZXZlbnRIYW5kbGVyLnVuc3Vic2NyaWJlQWxsKSB7XG4gICAgICB0aGlzLl9ldmVudEhhbmRsZXIudW5zdWJzY3JpYmVBbGwoKTtcbiAgICB9XG4gICAgaWYgKGlzT2JzZXJ2YWJsZSh0aGlzLmh0dHBDYW5jZWxSZXF1ZXN0cyQpKSB7XG4gICAgICB0aGlzLmh0dHBDYW5jZWxSZXF1ZXN0cyQubmV4dCgpOyAvLyB0aGlzIGNhbmNlbHMgYW55IHBlbmRpbmcgaHR0cCByZXF1ZXN0c1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGUgdGhlIFNvcnRpbmcgRnVuY3Rpb25hbGl0eVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzU29ydGluZ0Rpc2FibGVkIC0gb3B0aW9uYWxseSBmb3JjZSBhIGRpc2FibGUvZW5hYmxlIG9mIHRoZSBTb3J0IEZ1bmN0aW9uYWxpdHk/IERlZmF1bHRzIHRvIFRydWVcbiAgICogQHBhcmFtIHtib29sZWFufSBjbGVhclNvcnRpbmdXaGVuRGlzYWJsZWQgLSB3aGVuIGRpc2FibGluZyB0aGUgc29ydGluZywgZG8gd2UgYWxzbyB3YW50IHRvIGNsZWFyIHRoZSBzb3J0aW5nIGFzIHdlbGw/IERlZmF1bHRzIHRvIFRydWVcbiAgICovXG4gIGRpc2FibGVTb3J0RnVuY3Rpb25hbGl0eShpc1NvcnRpbmdEaXNhYmxlZCA9IHRydWUsIGNsZWFyU29ydGluZ1doZW5EaXNhYmxlZCA9IHRydWUpIHtcbiAgICBjb25zdCBwcmV2U29ydGluZyA9IHRoaXMuX2dyaWRPcHRpb25zLmVuYWJsZVNvcnRpbmc7XG4gICAgY29uc3QgbmV3U29ydGluZyA9ICFwcmV2U29ydGluZztcblxuICAgIHRoaXMuX2dyaWRPcHRpb25zLmVuYWJsZVNvcnRpbmcgPSBuZXdTb3J0aW5nO1xuICAgIGxldCB1cGRhdGVkQ29sdW1uRGVmaW5pdGlvbnM7XG4gICAgaWYgKGlzU29ydGluZ0Rpc2FibGVkKSB7XG4gICAgICBpZiAoY2xlYXJTb3J0aW5nV2hlbkRpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuY2xlYXJTb3J0aW5nKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9ldmVudEhhbmRsZXIudW5zdWJzY3JpYmVBbGwoKTtcbiAgICAgIHVwZGF0ZWRDb2x1bW5EZWZpbml0aW9ucyA9IHRoaXMuZGlzYWJsZUFsbFNvcnRpbmdDb21tYW5kcyh0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXBkYXRlZENvbHVtbkRlZmluaXRpb25zID0gdGhpcy5kaXNhYmxlQWxsU29ydGluZ0NvbW1hbmRzKGZhbHNlKTtcbiAgICAgIGNvbnN0IG9uU29ydEhhbmRsZXIgPSB0aGlzLl9ncmlkLm9uU29ydDtcbiAgICAgIHRoaXMuX2V2ZW50SGFuZGxlci5zdWJzY3JpYmUob25Tb3J0SGFuZGxlciwgKGU6IEV2ZW50LCBhcmdzOiBhbnkpID0+IHRoaXMuaGFuZGxlTG9jYWxPblNvcnQoZSwgYXJncykpO1xuICAgIH1cbiAgICB0aGlzLl9ncmlkLnNldE9wdGlvbnMoeyBlbmFibGVTb3J0aW5nOiB0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVTb3J0aW5nIH0sIGZhbHNlLCB0cnVlKTtcbiAgICB0aGlzLnNoYXJlZFNlcnZpY2UuZ3JpZE9wdGlvbnMgPSB0aGlzLl9ncmlkT3B0aW9ucztcblxuICAgIC8vIHJlc2V0IGNvbHVtbnMgc28gdGhhdCBpdCByZWNyZWF0ZSB0aGUgY29sdW1uIGhlYWRlcnMgYW5kIHJlbW92ZS9hZGQgdGhlIHNvcnQgaWNvbiBoaW50c1xuICAgIC8vIGJhc2ljYWxseSB3aXRob3V0IHRoaXMsIHRoZSBzb3J0IGljb24gaGludHMgd2VyZSBzdGlsbCBzaG93aW5nIHVwIGV2ZW4gYWZ0ZXIgZGlzYWJsaW5nIHRoZSBTb3J0aW5nXG4gICAgdGhpcy5fZ3JpZC5zZXRDb2x1bW5zKHVwZGF0ZWRDb2x1bW5EZWZpbml0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlIHRoZSBTb3J0aW5nIGZ1bmN0aW9uYWxpdHlcbiAgICogQHBhcmFtIHtib29sZWFufSBjbGVhclNvcnRpbmdXaGVuRGlzYWJsZWQgLSB3aGVuIGRpc2FibGluZyB0aGUgc29ydGluZywgZG8gd2UgYWxzbyB3YW50IHRvIGNsZWFyIHRoZSBzb3J0aW5nIGFzIHdlbGw/IERlZmF1bHRzIHRvIFRydWVcbiAgICovXG4gIHRvZ2dsZVNvcnRGdW5jdGlvbmFsaXR5KGNsZWFyU29ydGluZ09uRGlzYWJsZSA9IHRydWUpIHtcbiAgICBjb25zdCBwcmV2aW91c1NvcnRpbmcgPSB0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVTb3J0aW5nO1xuICAgIHRoaXMuZGlzYWJsZVNvcnRGdW5jdGlvbmFsaXR5KHByZXZpb3VzU29ydGluZywgY2xlYXJTb3J0aW5nT25EaXNhYmxlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNpbXBsZSBmdW5jdGlvbiB0aGF0IGlzIGJpbmRlZCB0byB0aGUgc3Vic2NyaWJlciBhbmQgZW1pdCBhIGNoYW5nZSB3aGVuIHRoZSBzb3J0IGlzIGNhbGxlZC5cbiAgICogT3RoZXIgc2VydmljZXMsIGxpa2UgUGFnaW5hdGlvbiwgY2FuIHRoZW4gc3Vic2NyaWJlIHRvIGl0LlxuICAgKiBAcGFyYW0gc2VuZGVyXG4gICAqL1xuICBlbWl0U29ydENoYW5nZWQoc2VuZGVyOiBFbWl0dGVyVHlwZSwgY3VycmVudExvY2FsU29ydGVycz86IEN1cnJlbnRTb3J0ZXJbXSkge1xuICAgIGlmIChzZW5kZXIgPT09IEVtaXR0ZXJUeXBlLnJlbW90ZSAmJiB0aGlzLl9ncmlkT3B0aW9ucyAmJiB0aGlzLl9ncmlkT3B0aW9ucy5iYWNrZW5kU2VydmljZUFwaSkge1xuICAgICAgbGV0IGN1cnJlbnRTb3J0ZXJzOiBDdXJyZW50U29ydGVyW10gPSBbXTtcbiAgICAgIGNvbnN0IGJhY2tlbmRTZXJ2aWNlID0gdGhpcy5fZ3JpZE9wdGlvbnMuYmFja2VuZFNlcnZpY2VBcGkuc2VydmljZTtcbiAgICAgIGlmIChiYWNrZW5kU2VydmljZSAmJiBiYWNrZW5kU2VydmljZS5nZXRDdXJyZW50U29ydGVycykge1xuICAgICAgICBjdXJyZW50U29ydGVycyA9IGJhY2tlbmRTZXJ2aWNlLmdldEN1cnJlbnRTb3J0ZXJzKCkgYXMgQ3VycmVudFNvcnRlcltdO1xuICAgICAgfVxuICAgICAgdGhpcy5vblNvcnRDaGFuZ2VkLm5leHQoY3VycmVudFNvcnRlcnMpO1xuICAgIH0gZWxzZSBpZiAoc2VuZGVyID09PSBFbWl0dGVyVHlwZS5sb2NhbCkge1xuICAgICAgaWYgKGN1cnJlbnRMb2NhbFNvcnRlcnMpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudExvY2FsU29ydGVycyA9IGN1cnJlbnRMb2NhbFNvcnRlcnM7XG4gICAgICB9XG4gICAgICB0aGlzLm9uU29ydENoYW5nZWQubmV4dCh0aGlzLmdldEN1cnJlbnRMb2NhbFNvcnRlcnMoKSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0Q3VycmVudExvY2FsU29ydGVycygpOiBDdXJyZW50U29ydGVyW10ge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50TG9jYWxTb3J0ZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBjdXJyZW50IGNvbHVtbiBzb3J0cyxcbiAgICogSWYgYSBjb2x1bW4gaXMgcGFzc2VkIGFzIGFuIGFyZ3VtZW50LCB0aGF0IHdpbGwgYmUgZXhjbHVzaW9uIHNvIHdlIHdvbid0IGFkZCB0aGlzIGNvbHVtbiB0byBvdXIgb3V0cHV0IGFycmF5IHNpbmNlIGl0IGlzIGFscmVhZHkgaW4gdGhlIGFycmF5LlxuICAgKiBUaGUgdXNhZ2Ugb2YgdGhpcyBtZXRob2QgaXMgdGhhdCB3ZSB3YW50IHRvIGtub3cgdGhlIHNvcnQgcHJpb3IgdG8gY2FsbGluZyB0aGUgbmV4dCBzb3J0aW5nIGNvbW1hbmRcbiAgICovXG4gIGdldEN1cnJlbnRDb2x1bW5Tb3J0cyhleGNsdWRlZENvbHVtbklkPzogc3RyaW5nKTogeyBzb3J0Q29sOiBDb2x1bW47IHNvcnRBc2M6IGJvb2xlYW47IH1bXSB7XG4gICAgLy8gZ2V0U29ydENvbHVtbnMoKSBvbmx5IHJldHVybnMgc29ydEFzYyAmIGNvbHVtbklkLCB3ZSB3YW50IHRoZSBlbnRpcmUgY29sdW1uIGRlZmluaXRpb25cbiAgICBjb25zdCBvbGRTb3J0Q29sdW1ucyA9IHRoaXMuX2dyaWQgJiYgdGhpcy5fZ3JpZC5nZXRTb3J0Q29sdW1ucygpO1xuXG4gICAgLy8gZ2V0IHRoZSBjb2x1bW4gZGVmaW5pdGlvbiBidXQgb25seSBrZWVwIGNvbHVtbiB3aGljaCBhcmUgbm90IGVxdWFsIHRvIG91ciBjdXJyZW50IGNvbHVtblxuICAgIGlmIChBcnJheS5pc0FycmF5KG9sZFNvcnRDb2x1bW5zKSkge1xuICAgICAgY29uc3Qgc29ydGVkQ29scyA9IG9sZFNvcnRDb2x1bW5zLnJlZHVjZSgoY29scywgY29sKSA9PiB7XG4gICAgICAgIGlmICghZXhjbHVkZWRDb2x1bW5JZCB8fCBjb2wuY29sdW1uSWQgIT09IGV4Y2x1ZGVkQ29sdW1uSWQpIHtcbiAgICAgICAgICBjb2xzLnB1c2goeyBzb3J0Q29sOiB0aGlzLl9jb2x1bW5EZWZpbml0aW9uc1t0aGlzLl9ncmlkLmdldENvbHVtbkluZGV4KGNvbC5jb2x1bW5JZCldLCBzb3J0QXNjOiBjb2wuc29ydEFzYyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29scztcbiAgICAgIH0sIFtdKTtcblxuICAgICAgcmV0dXJuIHNvcnRlZENvbHM7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIC8qKiBMb2FkIGRlZmluZWQgU29ydGluZyAoc29ydGVycykgaW50byB0aGUgZ3JpZCAqL1xuICBsb2FkR3JpZFNvcnRlcnMoc29ydGVyczogQ3VycmVudFNvcnRlcltdKTogQ29sdW1uU29ydFtdIHtcbiAgICB0aGlzLl9jdXJyZW50TG9jYWxTb3J0ZXJzID0gW107IC8vIHJlc2V0IGN1cnJlbnQgbG9jYWwgc29ydGVyc1xuICAgIGNvbnN0IHNvcnRDb2xzOiBDb2x1bW5Tb3J0W10gPSBbXTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHNvcnRlcnMpKSB7XG4gICAgICBzb3J0ZXJzLmZvckVhY2goKHNvcnRlcjogQ3VycmVudFNvcnRlcikgPT4ge1xuICAgICAgICBjb25zdCBncmlkQ29sdW1uID0gdGhpcy5fY29sdW1uRGVmaW5pdGlvbnMuZmluZCgoY29sOiBDb2x1bW4pID0+IGNvbC5pZCA9PT0gc29ydGVyLmNvbHVtbklkKTtcbiAgICAgICAgaWYgKGdyaWRDb2x1bW4pIHtcbiAgICAgICAgICBzb3J0Q29scy5wdXNoKHtcbiAgICAgICAgICAgIGNvbHVtbklkOiBncmlkQ29sdW1uLmlkLFxuICAgICAgICAgICAgc29ydEFzYzogKChzb3J0ZXIuZGlyZWN0aW9uLnRvVXBwZXJDYXNlKCkgPT09IFNvcnREaXJlY3Rpb24uQVNDKSA/IHRydWUgOiBmYWxzZSksXG4gICAgICAgICAgICBzb3J0Q29sOiBncmlkQ29sdW1uXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBrZWVwIGN1cnJlbnQgc29ydGVyc1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnRMb2NhbFNvcnRlcnMucHVzaCh7XG4gICAgICAgICAgICBjb2x1bW5JZDogZ3JpZENvbHVtbi5pZCArICcnLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBzb3J0ZXIuZGlyZWN0aW9uLnRvVXBwZXJDYXNlKCkgYXMgU29ydERpcmVjdGlvblN0cmluZ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoc29ydENvbHMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5vbkxvY2FsU29ydENoYW5nZWQodGhpcy5fZ3JpZCwgc29ydENvbHMpO1xuICAgICAgdGhpcy5fZ3JpZC5zZXRTb3J0Q29sdW1ucyhzb3J0Q29scyk7IC8vIHVzZSB0aGlzIHRvIGFkZCBzb3J0IGljb24ocykgaW4gVUlcbiAgICB9XG5cbiAgICByZXR1cm4gc29ydENvbHM7XG4gIH1cblxuICAvKiogUHJvY2VzcyB0aGUgaW5pdGlhbCBzb3J0LCB0eXBpY2FsbHkgaXQgd2lsbCBzb3J0IGFzY2VuZGluZyBieSB0aGUgY29sdW1uIHRoYXQgaGFzIHRoZSBUcmVlIERhdGEgdW5sZXNzIHVzZXIgc3BlY2lmaWVzIGEgZGlmZmVyZW50IGluaXRpYWxTb3J0ICovXG4gIHByb2Nlc3NUcmVlRGF0YUluaXRpYWxTb3J0KCkge1xuICAgIC8vIHdoZW4gYSBUcmVlIERhdGEgdmlldyBpcyBkZWZpbmVkLCB3ZSBtdXN0IHNvcnQgdGhlIGRhdGEgc28gdGhhdCB0aGUgVUkgd29ya3MgY29ycmVjdGx5XG4gICAgaWYgKHRoaXMuX2dyaWRPcHRpb25zICYmIHRoaXMuX2dyaWRPcHRpb25zLmVuYWJsZVRyZWVEYXRhICYmIHRoaXMuX2dyaWRPcHRpb25zLnRyZWVEYXRhT3B0aW9ucykge1xuICAgICAgLy8gZmlyc3QgcHJlc29ydCBpdCBvbmNlIGJ5IHRyZWUgbGV2ZWxcbiAgICAgIGNvbnN0IHRyZWVEYXRhT3B0aW9ucyA9IHRoaXMuX2dyaWRPcHRpb25zLnRyZWVEYXRhT3B0aW9ucztcbiAgICAgIGNvbnN0IGNvbHVtbldpdGhUcmVlRGF0YSA9IHRoaXMuX2NvbHVtbkRlZmluaXRpb25zLmZpbmQoKGNvbDogQ29sdW1uKSA9PiBjb2wgJiYgY29sLmlkID09PSB0cmVlRGF0YU9wdGlvbnMuY29sdW1uSWQpO1xuICAgICAgaWYgKGNvbHVtbldpdGhUcmVlRGF0YSkge1xuICAgICAgICBsZXQgc29ydERpcmVjdGlvbiA9IFNvcnREaXJlY3Rpb24uQVNDO1xuICAgICAgICBsZXQgc29ydFRyZWVMZXZlbENvbHVtbjogQ29sdW1uU29ydCA9IHsgY29sdW1uSWQ6IHRyZWVEYXRhT3B0aW9ucy5jb2x1bW5JZCwgc29ydENvbDogY29sdW1uV2l0aFRyZWVEYXRhLCBzb3J0QXNjOiB0cnVlIH07XG5cbiAgICAgICAgLy8gdXNlciBjb3VsZCBwcm92aWRlIGEgY3VzdG9tIHNvcnQgZmllbGQgaWQsIGlmIHNvIGdldCB0aGF0IGNvbHVtbiBhbmQgc29ydCBieSBpdFxuICAgICAgICBpZiAodHJlZURhdGFPcHRpb25zICYmIHRyZWVEYXRhT3B0aW9ucy5pbml0aWFsU29ydCAmJiB0cmVlRGF0YU9wdGlvbnMuaW5pdGlhbFNvcnQuY29sdW1uSWQpIHtcbiAgICAgICAgICBjb25zdCBpbml0aWFsU29ydENvbHVtbklkID0gdHJlZURhdGFPcHRpb25zLmluaXRpYWxTb3J0LmNvbHVtbklkO1xuICAgICAgICAgIGNvbnN0IGluaXRpYWxTb3J0Q29sdW1uID0gdGhpcy5fY29sdW1uRGVmaW5pdGlvbnMuZmluZCgoY29sOiBDb2x1bW4pID0+IGNvbC5pZCA9PT0gaW5pdGlhbFNvcnRDb2x1bW5JZCk7XG4gICAgICAgICAgc29ydERpcmVjdGlvbiA9ICh0cmVlRGF0YU9wdGlvbnMuaW5pdGlhbFNvcnQuZGlyZWN0aW9uIHx8IFNvcnREaXJlY3Rpb24uQVNDKS50b1VwcGVyQ2FzZSgpIGFzIFNvcnREaXJlY3Rpb247XG4gICAgICAgICAgc29ydFRyZWVMZXZlbENvbHVtbiA9IHsgY29sdW1uSWQ6IGluaXRpYWxTb3J0Q29sdW1uSWQsIHNvcnRDb2w6IGluaXRpYWxTb3J0Q29sdW1uLCBzb3J0QXNjOiAoc29ydERpcmVjdGlvbiA9PT0gU29ydERpcmVjdGlvbi5BU0MpIH0gYXMgQ29sdW1uU29ydDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdoZW4gd2UgaGF2ZSBhIHZhbGlkIGNvbHVtbiB3aXRoIFRyZWUgRGF0YSwgd2UgY2FuIHNvcnQgYnkgdGhhdCBjb2x1bW5cbiAgICAgICAgaWYgKHNvcnRUcmVlTGV2ZWxDb2x1bW4gJiYgc29ydFRyZWVMZXZlbENvbHVtbi5jb2x1bW5JZCkge1xuICAgICAgICAgIHRoaXMudXBkYXRlU29ydGluZyhbeyBjb2x1bW5JZDogc29ydFRyZWVMZXZlbENvbHVtbi5jb2x1bW5JZCB8fCAnJywgZGlyZWN0aW9uOiBzb3J0RGlyZWN0aW9uIH1dKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uQmFja2VuZFNvcnRDaGFuZ2VkKGV2ZW50OiBFdmVudCwgYXJnczogeyBtdWx0aUNvbHVtblNvcnQ/OiBib29sZWFuOyBncmlkOiBhbnk7IHNvcnRDb2xzOiBDb2x1bW5Tb3J0W107IGNsZWFyU29ydFRyaWdnZXJlZD86IGJvb2xlYW47IH0pIHtcbiAgICBpZiAoIWFyZ3MgfHwgIWFyZ3MuZ3JpZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTb21ldGhpbmcgd2VudCB3cm9uZyB3aGVuIHRyeWluZyB0byBiaW5kIHRoZSBcIm9uQmFja2VuZFNvcnRDaGFuZ2VkKGV2ZW50LCBhcmdzKVwiIGZ1bmN0aW9uLCBpdCBzZWVtcyB0aGF0IFwiYXJnc1wiIGlzIG5vdCBwb3B1bGF0ZWQgY29ycmVjdGx5Jyk7XG4gICAgfVxuICAgIGNvbnN0IGdyaWRPcHRpb25zOiBHcmlkT3B0aW9uID0gKGFyZ3MuZ3JpZCAmJiBhcmdzLmdyaWQuZ2V0T3B0aW9ucykgPyBhcmdzLmdyaWQuZ2V0T3B0aW9ucygpIDoge307XG4gICAgY29uc3QgYmFja2VuZEFwaSA9IGdyaWRPcHRpb25zLmJhY2tlbmRTZXJ2aWNlQXBpO1xuXG4gICAgaWYgKCFiYWNrZW5kQXBpIHx8ICFiYWNrZW5kQXBpLnByb2Nlc3MgfHwgIWJhY2tlbmRBcGkuc2VydmljZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBCYWNrZW5kU2VydmljZUFwaSByZXF1aXJlcyBhdCBsZWFzdCBhIFwicHJvY2Vzc1wiIGZ1bmN0aW9uIGFuZCBhIFwic2VydmljZVwiIGRlZmluZWRgKTtcbiAgICB9XG5cbiAgICAvLyBrZWVwIHN0YXJ0IHRpbWUgJiBlbmQgdGltZXN0YW1wcyAmIHJldHVybiBpdCBhZnRlciBwcm9jZXNzIGV4ZWN1dGlvblxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IG5ldyBEYXRlKCk7XG5cbiAgICBpZiAoYmFja2VuZEFwaS5wcmVQcm9jZXNzKSB7XG4gICAgICBiYWNrZW5kQXBpLnByZVByb2Nlc3MoKTtcbiAgICB9XG5cbiAgICAvLyBxdWVyeSBiYWNrZW5kXG4gICAgY29uc3QgcXVlcnkgPSBiYWNrZW5kQXBpLnNlcnZpY2UucHJvY2Vzc09uU29ydENoYW5nZWQoZXZlbnQsIGFyZ3MpO1xuICAgIGNvbnN0IHRvdGFsSXRlbXMgPSBncmlkT3B0aW9ucyAmJiBncmlkT3B0aW9ucy5wYWdpbmF0aW9uICYmIGdyaWRPcHRpb25zLnBhZ2luYXRpb24udG90YWxJdGVtcztcbiAgICBleGVjdXRlQmFja2VuZENhbGxiYWNrKGJhY2tlbmRBcGksIHF1ZXJ5LCBhcmdzLCBzdGFydFRpbWUsIHRvdGFsSXRlbXMsIHRoaXMuZW1pdFNvcnRDaGFuZ2VkLmJpbmQodGhpcyksIHRoaXMuaHR0cENhbmNlbFJlcXVlc3RzJCk7XG4gIH1cblxuICAvKiogV2hlbiBhIFNvcnQgQ2hhbmdlcyBvbiBhIExvY2FsIGdyaWQgKEpTT04gZGF0YXNldCkgKi9cbiAgb25Mb2NhbFNvcnRDaGFuZ2VkKGdyaWQ6IGFueSwgc29ydENvbHVtbnM6IENvbHVtblNvcnRbXSwgZm9yY2VSZVNvcnQgPSBmYWxzZSwgZW1pdFNvcnRDaGFuZ2VkID0gZmFsc2UpIHtcbiAgICBjb25zdCBpc1RyZWVEYXRhRW5hYmxlZCA9IHRoaXMuX2dyaWRPcHRpb25zICYmIHRoaXMuX2dyaWRPcHRpb25zLmVuYWJsZVRyZWVEYXRhIHx8IGZhbHNlO1xuICAgIGNvbnN0IGRhdGFWaWV3ID0gZ3JpZCAmJiBncmlkLmdldERhdGEgJiYgZ3JpZC5nZXREYXRhKCk7XG5cbiAgICBpZiAoZ3JpZCAmJiBkYXRhVmlldykge1xuICAgICAgaWYgKGZvcmNlUmVTb3J0ICYmICFpc1RyZWVEYXRhRW5hYmxlZCkge1xuICAgICAgICBkYXRhVmlldy5yZVNvcnQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzVHJlZURhdGFFbmFibGVkICYmIHRoaXMuc2hhcmVkU2VydmljZSAmJiBBcnJheS5pc0FycmF5KHRoaXMuc2hhcmVkU2VydmljZS5oaWVyYXJjaGljYWxEYXRhc2V0KSkge1xuICAgICAgICBjb25zdCBoaWVyYXJjaGljYWxEYXRhc2V0ID0gdGhpcy5zaGFyZWRTZXJ2aWNlLmhpZXJhcmNoaWNhbERhdGFzZXQ7XG4gICAgICAgIHRoaXMuc29ydFRyZWVEYXRhKGhpZXJhcmNoaWNhbERhdGFzZXQsIHNvcnRDb2x1bW5zKTtcbiAgICAgICAgY29uc3QgZGF0YVZpZXdJZElkZW50aWZpZXIgPSB0aGlzLl9ncmlkT3B0aW9ucyAmJiB0aGlzLl9ncmlkT3B0aW9ucy5kYXRhc2V0SWRQcm9wZXJ0eU5hbWUgfHwgJ2lkJztcbiAgICAgICAgY29uc3QgdHJlZURhdGFPcHQ6IFRyZWVEYXRhT3B0aW9uID0gdGhpcy5fZ3JpZE9wdGlvbnMgJiYgdGhpcy5fZ3JpZE9wdGlvbnMudHJlZURhdGFPcHRpb25zIHx8IHsgY29sdW1uSWQ6ICcnIH07XG4gICAgICAgIGNvbnN0IHRyZWVEYXRhT3B0aW9ucyA9IHsgLi4udHJlZURhdGFPcHQsIGlkZW50aWZpZXJQcm9wTmFtZTogdHJlZURhdGFPcHQuaWRlbnRpZmllclByb3BOYW1lIHx8IGRhdGFWaWV3SWRJZGVudGlmaWVyIH07XG4gICAgICAgIGNvbnN0IHNvcnRlZEZsYXRBcnJheSA9IGNvbnZlcnRIaWVyYXJjaGljYWxWaWV3VG9QYXJlbnRDaGlsZEFycmF5KGhpZXJhcmNoaWNhbERhdGFzZXQsIHRyZWVEYXRhT3B0aW9ucyk7XG4gICAgICAgIGRhdGFWaWV3LnNldEl0ZW1zKHNvcnRlZEZsYXRBcnJheSwgdGhpcy5fZ3JpZE9wdGlvbnMgJiYgdGhpcy5fZ3JpZE9wdGlvbnMuZGF0YXNldElkUHJvcGVydHlOYW1lIHx8ICdpZCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YVZpZXcuc29ydCh0aGlzLnNvcnRDb21wYXJlcnMuYmluZCh0aGlzLCBzb3J0Q29sdW1ucykpO1xuICAgICAgfVxuXG4gICAgICBncmlkLmludmFsaWRhdGUoKTtcbiAgICAgIGdyaWQucmVuZGVyKCk7XG5cbiAgICAgIGlmIChlbWl0U29ydENoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5lbWl0U29ydENoYW5nZWQoRW1pdHRlclR5cGUubG9jYWwsIHNvcnRDb2x1bW5zLm1hcChjb2wgPT4ge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2x1bW5JZDogY29sLnNvcnRDb2wgJiYgY29sLnNvcnRDb2wuaWQgfHwgJ2lkJyxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogY29sLnNvcnRBc2MgPyBTb3J0RGlyZWN0aW9uLkFTQyA6IFNvcnREaXJlY3Rpb24uREVTQ1xuICAgICAgICAgIH07XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiogQ2FsbCBhIGxvY2FsIGdyaWQgc29ydCBieSBpdHMgZGVmYXVsdCBzb3J0IGZpZWxkIGlkICh1c2VyIGNhbiBjdXN0b21pemUgZGVmYXVsdCBmaWVsZCBieSBjb25maWd1cmluZyBcImRlZmF1bHRDb2x1bW5Tb3J0RmllbGRJZFwiIGluIHRoZSBncmlkIG9wdGlvbnMsIGRlZmF1bHRzIHRvIFwiaWRcIikgKi9cbiAgc29ydExvY2FsR3JpZEJ5RGVmYXVsdFNvcnRGaWVsZElkKCkge1xuICAgIGNvbnN0IHNvcnRDb2xGaWVsZElkID0gdGhpcy5fZ3JpZE9wdGlvbnMgJiYgdGhpcy5fZ3JpZE9wdGlvbnMuZGVmYXVsdENvbHVtblNvcnRGaWVsZElkIHx8IHRoaXMuX2dyaWRPcHRpb25zLmRhdGFzZXRJZFByb3BlcnR5TmFtZSB8fCAnaWQnO1xuICAgIGNvbnN0IHNvcnRDb2wgPSB7IGlkOiBzb3J0Q29sRmllbGRJZCwgZmllbGQ6IHNvcnRDb2xGaWVsZElkIH0gYXMgQ29sdW1uO1xuICAgIHRoaXMub25Mb2NhbFNvcnRDaGFuZ2VkKHRoaXMuX2dyaWQsIG5ldyBBcnJheSh7IHNvcnRBc2M6IHRydWUsIHNvcnRDb2wsIGNsZWFyU29ydFRyaWdnZXJlZDogdHJ1ZSB9KSk7XG4gIH1cblxuICBzb3J0Q29tcGFyZXJzKHNvcnRDb2x1bW5zOiBDb2x1bW5Tb3J0W10sIGRhdGFSb3cxOiBhbnksIGRhdGFSb3cyOiBhbnkpOiBudW1iZXIge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNvcnRDb2x1bW5zKSkge1xuICAgICAgZm9yIChjb25zdCBzb3J0Q29sdW1uIG9mIHNvcnRDb2x1bW5zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuc29ydENvbXBhcmVyKHNvcnRDb2x1bW4sIGRhdGFSb3cxLCBkYXRhUm93Mik7XG4gICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFNvcnREaXJlY3Rpb25OdW1iZXIubmV1dHJhbDtcbiAgfVxuXG4gIHNvcnRDb21wYXJlcihzb3J0Q29sdW1uOiBDb2x1bW5Tb3J0LCBkYXRhUm93MTogYW55LCBkYXRhUm93MjogYW55LCBxdWVyeVNvcnRGaWVsZD86IHN0cmluZyk6IG51bWJlciB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKHNvcnRDb2x1bW4gJiYgc29ydENvbHVtbi5zb3J0Q29sKSB7XG4gICAgICBjb25zdCBjb2x1bW5EZWYgPSBzb3J0Q29sdW1uLnNvcnRDb2w7XG4gICAgICBjb25zdCBzb3J0RGlyZWN0aW9uID0gc29ydENvbHVtbi5zb3J0QXNjID8gU29ydERpcmVjdGlvbk51bWJlci5hc2MgOiBTb3J0RGlyZWN0aW9uTnVtYmVyLmRlc2M7XG4gICAgICBsZXQgcXVlcnlGaWVsZE5hbWUxID0gcXVlcnlTb3J0RmllbGQgfHwgY29sdW1uRGVmLnF1ZXJ5RmllbGRTb3J0ZXIgfHwgY29sdW1uRGVmLnF1ZXJ5RmllbGQgfHwgY29sdW1uRGVmLmZpZWxkO1xuICAgICAgbGV0IHF1ZXJ5RmllbGROYW1lMiA9IHF1ZXJ5RmllbGROYW1lMTtcbiAgICAgIGNvbnN0IGZpZWxkVHlwZSA9IGNvbHVtbkRlZi50eXBlIHx8IEZpZWxkVHlwZS5zdHJpbmc7XG5cbiAgICAgIC8vIGlmIHVzZXIgcHJvdmlkZWQgYSBxdWVyeSBmaWVsZCBuYW1lIGdldHRlciBjYWxsYmFjaywgd2UgbmVlZCB0byBnZXQgdGhlIG5hbWUgb24gZWFjaCBpdGVtIGluZGVwZW5kZW50bHlcbiAgICAgIGlmICh0eXBlb2YgY29sdW1uRGVmLnF1ZXJ5RmllbGROYW1lR2V0dGVyRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcXVlcnlGaWVsZE5hbWUxID0gY29sdW1uRGVmLnF1ZXJ5RmllbGROYW1lR2V0dGVyRm4oZGF0YVJvdzEpO1xuICAgICAgICBxdWVyeUZpZWxkTmFtZTIgPSBjb2x1bW5EZWYucXVlcnlGaWVsZE5hbWVHZXR0ZXJGbihkYXRhUm93Mik7XG4gICAgICB9XG5cbiAgICAgIGxldCB2YWx1ZTEgPSBkYXRhUm93MVtxdWVyeUZpZWxkTmFtZTFdO1xuICAgICAgbGV0IHZhbHVlMiA9IGRhdGFSb3cyW3F1ZXJ5RmllbGROYW1lMl07XG5cbiAgICAgIC8vIHdoZW4gaXRlbSBpcyBhIGNvbXBsZXggb2JqZWN0IChkb3QgXCIuXCIgbm90YXRpb24pLCB3ZSBuZWVkIHRvIGZpbHRlciB0aGUgdmFsdWUgY29udGFpbmVkIGluIHRoZSBvYmplY3QgdHJlZVxuICAgICAgaWYgKHF1ZXJ5RmllbGROYW1lMSAmJiBxdWVyeUZpZWxkTmFtZTEuaW5kZXhPZignLicpID49IDApIHtcbiAgICAgICAgdmFsdWUxID0gZ2V0RGVzY2VuZGFudFByb3BlcnR5KGRhdGFSb3cxLCBxdWVyeUZpZWxkTmFtZTEpO1xuICAgICAgfVxuICAgICAgaWYgKHF1ZXJ5RmllbGROYW1lMiAmJiBxdWVyeUZpZWxkTmFtZTIuaW5kZXhPZignLicpID49IDApIHtcbiAgICAgICAgdmFsdWUyID0gZ2V0RGVzY2VuZGFudFByb3BlcnR5KGRhdGFSb3cyLCBxdWVyeUZpZWxkTmFtZTIpO1xuICAgICAgfVxuXG4gICAgICAvLyB1c2VyIGNvdWxkIHByb3ZpZGUgaGlzIG93biBjdXN0b20gU29ydGVyXG4gICAgICBpZiAoY29sdW1uRGVmLnNvcnRlcikge1xuICAgICAgICBjb25zdCBjdXN0b21Tb3J0UmVzdWx0ID0gY29sdW1uRGVmLnNvcnRlcih2YWx1ZTEsIHZhbHVlMiwgc29ydERpcmVjdGlvbiwgY29sdW1uRGVmKTtcbiAgICAgICAgaWYgKGN1c3RvbVNvcnRSZXN1bHQgIT09IFNvcnREaXJlY3Rpb25OdW1iZXIubmV1dHJhbCkge1xuICAgICAgICAgIHJldHVybiBjdXN0b21Tb3J0UmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzb3J0UmVzdWx0ID0gc29ydEJ5RmllbGRUeXBlKGZpZWxkVHlwZSwgdmFsdWUxLCB2YWx1ZTIsIHNvcnREaXJlY3Rpb24sIGNvbHVtbkRlZik7XG4gICAgICAgIGlmIChzb3J0UmVzdWx0ICE9PSBTb3J0RGlyZWN0aW9uTnVtYmVyLm5ldXRyYWwpIHtcbiAgICAgICAgICByZXR1cm4gc29ydFJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgc29ydFRyZWVEYXRhKGhpZXJhcmNoaWNhbEFycmF5OiBhbnlbXSwgc29ydENvbHVtbnM6IENvbHVtblNvcnRbXSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNvcnRDb2x1bW5zKSkge1xuICAgICAgZm9yIChjb25zdCBzb3J0Q29sdW1uIG9mIHNvcnRDb2x1bW5zKSB7XG4gICAgICAgIHRoaXMuc29ydFRyZWVDaGlsZChoaWVyYXJjaGljYWxBcnJheSwgc29ydENvbHVtbiwgMCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqIFNvcnQgdGhlIFRyZWUgQ2hpbGRyZW4gb2YgYSBoaWVyYXJjaGljYWwgZGF0YXNldCBieSByZWN1cnNpb24gKi9cbiAgc29ydFRyZWVDaGlsZChoaWVyYXJjaGljYWxBcnJheTogYW55W10sIHNvcnRDb2x1bW46IENvbHVtblNvcnQsIHRyZWVMZXZlbDogbnVtYmVyKSB7XG4gICAgY29uc3QgdHJlZURhdGFPcHRpb25zID0gdGhpcy5fZ3JpZE9wdGlvbnMgJiYgdGhpcy5fZ3JpZE9wdGlvbnMudHJlZURhdGFPcHRpb25zO1xuICAgIGNvbnN0IGNoaWxkcmVuUHJvcE5hbWUgPSB0cmVlRGF0YU9wdGlvbnMgJiYgdHJlZURhdGFPcHRpb25zLmNoaWxkcmVuUHJvcE5hbWUgfHwgJ2NoaWxkcmVuJztcbiAgICBoaWVyYXJjaGljYWxBcnJheS5zb3J0KChhOiBhbnksIGI6IGFueSkgPT4gdGhpcy5zb3J0Q29tcGFyZXIoc29ydENvbHVtbiwgYSwgYikgfHwgU29ydERpcmVjdGlvbk51bWJlci5uZXV0cmFsKTtcblxuICAgIC8vIHdoZW4gaXRlbSBoYXMgYSBjaGlsZCwgd2UnbGwgc29ydCByZWN1cnNpdmVseVxuICAgIGZvciAoY29uc3QgaXRlbSBvZiBoaWVyYXJjaGljYWxBcnJheSkge1xuICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgY29uc3QgaGFzQ2hpbGRyZW4gPSBpdGVtLmhhc093blByb3BlcnR5KGNoaWxkcmVuUHJvcE5hbWUpICYmIEFycmF5LmlzQXJyYXkoaXRlbVtjaGlsZHJlblByb3BOYW1lXSk7XG4gICAgICAgIC8vIHdoZW4gaXRlbSBoYXMgYSBjaGlsZCwgd2UnbGwgc29ydCByZWN1cnNpdmVseVxuICAgICAgICBpZiAoaGFzQ2hpbGRyZW4pIHtcbiAgICAgICAgICB0cmVlTGV2ZWwrKztcbiAgICAgICAgICB0aGlzLnNvcnRUcmVlQ2hpbGQoaXRlbVtjaGlsZHJlblByb3BOYW1lXSwgc29ydENvbHVtbiwgdHJlZUxldmVsKTtcbiAgICAgICAgICB0cmVlTGV2ZWwtLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgU29ydGluZyAoc29ydGVycykgZHluYW1pY2FsbHkganVzdCBieSBwcm92aWRpbmcgYW4gYXJyYXkgb2Ygc29ydGVyKHMpLlxuICAgKiBZb3UgY2FuIGFsc28gY2hvb3NlIGVtaXQgKGRlZmF1bHQpIGEgU29ydCBDaGFuZ2VkIGV2ZW50IHRoYXQgd2lsbCBiZSBwaWNrZWQgYnkgdGhlIEdyaWQgU3RhdGUgU2VydmljZS5cbiAgICpcbiAgICogQWxzbyBmb3IgYmFja2VuZCBzZXJ2aWNlIG9ubHksIHlvdSBjYW4gY2hvb3NlIHRvIHRyaWdnZXIgYSBiYWNrZW5kIHF1ZXJ5IChkZWZhdWx0KSBvciBub3QgaWYgeW91IHdpc2ggdG8gZG8gaXQgbGF0ZXIsXG4gICAqIHRoaXMgY291bGQgYmUgdXNlZnVsIHdoZW4gdXNpbmcgdXBkYXRlRmlsdGVycyAmIHVwZGF0ZVNvcnRpbmcgYW5kIHlvdSB3aXNoIHRvIG9ubHkgc2VuZCB0aGUgYmFja2VuZCBxdWVyeSBvbmNlLlxuICAgKiBAcGFyYW0gc29ydGVycyBhcnJheVxuICAgKiBAcGFyYW0gdHJpZ2dlckV2ZW50IGRlZmF1bHRzIHRvIFRydWUsIGRvIHdlIHdhbnQgdG8gZW1pdCBhIHNvcnQgY2hhbmdlZCBldmVudD9cbiAgICogQHBhcmFtIHRyaWdnZXJCYWNrZW5kUXVlcnkgZGVmYXVsdHMgdG8gVHJ1ZSwgd2hpY2ggd2lsbCBxdWVyeSB0aGUgYmFja2VuZC5cbiAgICovXG4gIHVwZGF0ZVNvcnRpbmcoc29ydGVyczogQ3VycmVudFNvcnRlcltdLCBlbWl0Q2hhbmdlZEV2ZW50ID0gdHJ1ZSwgdHJpZ2dlckJhY2tlbmRRdWVyeSA9IHRydWUpIHtcbiAgICBpZiAoIXRoaXMuX2dyaWRPcHRpb25zIHx8ICF0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVTb3J0aW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tBbmd1bGFyLVNsaWNrZ3JpZF0gaW4gb3JkZXIgdG8gdXNlIFwidXBkYXRlU29ydGluZ1wiIG1ldGhvZCwgeW91IG5lZWQgdG8gaGF2ZSBTb3J0YWJsZSBDb2x1bW5zIGRlZmluZWQgaW4geW91ciBncmlkIGFuZCBcImVuYWJsZVNvcnRpbmdcIiBzZXQgaW4geW91ciBHcmlkIE9wdGlvbnMnKTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShzb3J0ZXJzKSkge1xuICAgICAgY29uc3QgYmFja2VuZEFwaSA9IHRoaXMuX2dyaWRPcHRpb25zICYmIHRoaXMuX2dyaWRPcHRpb25zLmJhY2tlbmRTZXJ2aWNlQXBpO1xuXG4gICAgICBpZiAoYmFja2VuZEFwaSkge1xuICAgICAgICBjb25zdCBiYWNrZW5kQXBpU2VydmljZSA9IGJhY2tlbmRBcGkgJiYgYmFja2VuZEFwaS5zZXJ2aWNlO1xuICAgICAgICBpZiAoYmFja2VuZEFwaVNlcnZpY2UpIHtcbiAgICAgICAgICBiYWNrZW5kQXBpU2VydmljZS51cGRhdGVTb3J0ZXJzKHVuZGVmaW5lZCwgc29ydGVycyk7XG4gICAgICAgICAgaWYgKHRyaWdnZXJCYWNrZW5kUXVlcnkpIHtcbiAgICAgICAgICAgIHJlZnJlc2hCYWNrZW5kRGF0YXNldCh0aGlzLl9ncmlkT3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvYWRHcmlkU29ydGVycyhzb3J0ZXJzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVtaXRDaGFuZ2VkRXZlbnQpIHtcbiAgICAgICAgY29uc3QgZW1pdHRlclR5cGUgPSBiYWNrZW5kQXBpID8gRW1pdHRlclR5cGUucmVtb3RlIDogRW1pdHRlclR5cGUubG9jYWw7XG4gICAgICAgIHRoaXMuZW1pdFNvcnRDaGFuZ2VkKGVtaXR0ZXJUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyAtLVxuICAvLyBwcml2YXRlIGZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gICAqIExvb3AgdGhyb3VnaCBhbGwgY29sdW1uIGRlZmluaXRpb25zIGFuZCBkbyB0aGUgZm9sbG93aW5nIDIgdGhpbmdzXG4gICAqIDEuIGRpc2FibGUvZW5hYmxlIHRoZSBcInNvcnRhYmxlXCIgcHJvcGVydHkgb2YgZWFjaCBjb2x1bW5cbiAgICogMi4gbG9vcCB0aHJvdWdoIGVhY2ggSGVhZGVyIE1lbnUgY29tbWFuZHMgYW5kIGNoYW5nZSB0aGUgXCJoaWRkZW5cIiBjb21tYW5kcyB0byBzaG93L2hpZGUgZGVwZW5kaW5nIGlmIGl0J3MgZW5hYmxlZC9kaXNhYmxlZFxuICAgKiBBbHNvIG5vdGUgdGhhdCB3ZSBhcmVuJ3QgZGVsZXRpbmcgYW55IHByb3BlcnRpZXMsIHdlIGp1c3QgdG9nZ2xlIHRoZWlyIGZsYWdzIHNvIHRoYXQgd2UgY2FuIHJlbG9vcCB0aHJvdWdoIGF0IGxhdGVyIHBvaW50IGluIHRpbWUuXG4gICAqIChpZiB3ZSBwcmV2aW91c2x5IGRlbGV0ZWQgdGhlc2UgcHJvcGVydGllcyB3ZSB3b3VsZG4ndCBiZSBhYmxlIHRvIGNoYW5nZSB0aGVtIGJhY2sgc2luY2UgdGhlc2UgcHJvcGVydGllcyB3b3VsZG4ndCBleGlzdCBhbnltb3JlLCBoZW5jZSB3aHkgd2UganVzdCBoaWRlIHRoZSBjb21tYW5kcylcbiAgICogQHBhcmFtIHtib29sZWFufSBpc0Rpc2FibGluZyAtIGFyZSB3ZSBkaXNhYmxpbmcgdGhlIHNvcnQgZnVuY3Rpb25hbGl0eT8gRGVmYXVsdHMgdG8gdHJ1ZVxuICAgKi9cbiAgcHJpdmF0ZSBkaXNhYmxlQWxsU29ydGluZ0NvbW1hbmRzKGlzRGlzYWJsaW5nID0gdHJ1ZSk6IENvbHVtbltdIHtcbiAgICBjb25zdCBjb2x1bW5EZWZpbml0aW9ucyA9IHRoaXMuX2dyaWQuZ2V0Q29sdW1ucygpO1xuXG4gICAgLy8gbG9vcCB0aHJvdWdoIGNvbHVtbiBkZWZpbml0aW9uIHRvIGhpZGUvc2hvdyBoZWFkZXIgbWVudSBjb21tYW5kc1xuICAgIGNvbHVtbkRlZmluaXRpb25zLmZvckVhY2goKGNvbCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBjb2wuc29ydGFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb2wuc29ydGFibGUgPSAhaXNEaXNhYmxpbmc7XG4gICAgICB9XG4gICAgICBpZiAoY29sICYmIGNvbC5oZWFkZXIgJiYgY29sLmhlYWRlci5tZW51KSB7XG4gICAgICAgIGNvbC5oZWFkZXIubWVudS5pdGVtcy5mb3JFYWNoKG1lbnVJdGVtID0+IHtcbiAgICAgICAgICBpZiAobWVudUl0ZW0gJiYgdHlwZW9mIG1lbnVJdGVtICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc3QgbWVudUNvbW1hbmQgPSBtZW51SXRlbS5jb21tYW5kO1xuICAgICAgICAgICAgaWYgKG1lbnVDb21tYW5kID09PSAnc29ydC1hc2MnIHx8IG1lbnVDb21tYW5kID09PSAnc29ydC1kZXNjJyB8fCBtZW51Q29tbWFuZCA9PT0gJ2NsZWFyLXNvcnQnKSB7XG4gICAgICAgICAgICAgIG1lbnVJdGVtLmhpZGRlbiA9IGlzRGlzYWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBsb29wIHRocm91Z2ggY29sdW1uIGRlZmluaXRpb24gdG8gaGlkZS9zaG93IGdyaWQgbWVudSBjb21tYW5kc1xuICAgIGlmICh0aGlzLl9ncmlkT3B0aW9ucyAmJiB0aGlzLl9ncmlkT3B0aW9ucy5ncmlkTWVudSAmJiB0aGlzLl9ncmlkT3B0aW9ucy5ncmlkTWVudS5jdXN0b21JdGVtcykge1xuICAgICAgdGhpcy5fZ3JpZE9wdGlvbnMuZ3JpZE1lbnUuY3VzdG9tSXRlbXMuZm9yRWFjaCgobWVudUl0ZW0pID0+IHtcbiAgICAgICAgaWYgKG1lbnVJdGVtICYmIHR5cGVvZiBtZW51SXRlbSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBjb25zdCBtZW51Q29tbWFuZCA9IG1lbnVJdGVtLmNvbW1hbmQ7XG4gICAgICAgICAgaWYgKG1lbnVDb21tYW5kID09PSAnY2xlYXItc29ydGluZycpIHtcbiAgICAgICAgICAgIG1lbnVJdGVtLmhpZGRlbiA9IGlzRGlzYWJsaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbHVtbkRlZmluaXRpb25zO1xuICB9XG59XG4iXX0=