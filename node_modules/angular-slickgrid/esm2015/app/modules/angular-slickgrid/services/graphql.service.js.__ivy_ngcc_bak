import { mapOperatorType, mapOperatorByFieldType } from './utilities';
import { FieldType, OperatorType, SortDirection } from './../models/index';
import QueryBuilder from './graphqlQueryBuilder';
const DEFAULT_ITEMS_PER_PAGE = 25;
const DEFAULT_PAGE_SIZE = 20;
export class GraphqlService {
    constructor() {
        this._currentFilters = [];
        this._currentSorters = [];
        this._datasetIdPropName = 'id';
        this.defaultPaginationOptions = {
            first: DEFAULT_ITEMS_PER_PAGE,
            offset: 0
        };
    }
    /** Getter for the Column Definitions */
    get columnDefinitions() {
        return this._columnDefinitions;
    }
    /** Getter for the Grid Options pulled through the Grid Object */
    get _gridOptions() {
        return (this._grid && this._grid.getOptions) ? this._grid.getOptions() : {};
    }
    /** Initialization of the service, which acts as a constructor */
    init(serviceOptions, pagination, grid) {
        this._grid = grid;
        this.options = serviceOptions || { datasetName: '', columnDefinitions: [] };
        this.pagination = pagination;
        this._datasetIdPropName = this._gridOptions.datasetIdPropertyName || 'id';
        if (grid && grid.getColumns) {
            this._columnDefinitions = (serviceOptions && serviceOptions.columnDefinitions) || grid.getColumns();
        }
    }
    /**
     * Build the GraphQL query, since the service include/exclude cursor, the output query will be different.
     * @param serviceOptions GraphqlServiceOption
     */
    buildQuery() {
        if (!this.options || !this.options.datasetName || (!this._columnDefinitions && !Array.isArray(this.options.columnDefinitions))) {
            throw new Error('GraphQL Service requires the "datasetName" property to properly build the GraphQL query');
        }
        // get the column definitions and exclude some if they were tagged as excluded
        let columnDefinitions = this._columnDefinitions || this.options.columnDefinitions;
        columnDefinitions = columnDefinitions.filter((column) => !column.excludeFromQuery);
        const queryQb = new QueryBuilder('query');
        const datasetQb = new QueryBuilder(this.options.datasetName);
        const nodesQb = new QueryBuilder('nodes');
        // get all the columnds Ids for the filters to work
        const columnIds = [];
        if (columnDefinitions && Array.isArray(columnDefinitions)) {
            for (const column of columnDefinitions) {
                columnIds.push(column.field);
                // if extra "fields" are passed, also push them to columnIds
                if (column.fields) {
                    columnIds.push(...column.fields);
                }
            }
        }
        // Slickgrid also requires the "id" (or the dataset defined unique ide) field to be part of DataView
        // add it to the GraphQL query if it wasn't already part of the list
        if (columnIds.indexOf(this._datasetIdPropName) === -1) {
            columnIds.unshift(this._datasetIdPropName);
        }
        const columnsQuery = this.buildFilterQuery(columnIds);
        let graphqlNodeFields = [];
        if (this._gridOptions.enablePagination !== false) {
            if (this.options.isWithCursor) {
                // ...pageInfo { hasNextPage, endCursor }, edges { cursor, node { _columns_ } }, totalCount: 100
                const edgesQb = new QueryBuilder('edges');
                const pageInfoQb = new QueryBuilder('pageInfo');
                pageInfoQb.find('hasNextPage', 'hasPreviousPage', 'endCursor', 'startCursor');
                nodesQb.find(columnsQuery);
                edgesQb.find(['cursor']);
                graphqlNodeFields = ['totalCount', nodesQb, pageInfoQb, edgesQb];
            }
            else {
                // ...nodes { _columns_ }, totalCount: 100
                nodesQb.find(columnsQuery);
                graphqlNodeFields = ['totalCount', nodesQb];
            }
            // all properties to be returned by the query
            datasetQb.find(graphqlNodeFields);
        }
        else {
            // include all columns to be returned
            datasetQb.find(columnsQuery);
        }
        // add dataset filters, could be Pagination and SortingFilters and/or FieldFilters
        let datasetFilters = {};
        // only add pagination if it's enabled in the grid options
        if (this._gridOptions.enablePagination !== false) {
            datasetFilters = Object.assign({}, this.options.paginationOptions, { first: ((this.options.paginationOptions && this.options.paginationOptions.first) ? this.options.paginationOptions.first : ((this.pagination && this.pagination.pageSize) ? this.pagination.pageSize : null)) || this.defaultPaginationOptions.first });
            if (!this.options.isWithCursor) {
                datasetFilters.offset = ((this.options.paginationOptions && this.options.paginationOptions.hasOwnProperty('offset')) ? +this.options.paginationOptions['offset'] : 0);
            }
        }
        if (this.options.sortingOptions && Array.isArray(this.options.sortingOptions) && this.options.sortingOptions.length > 0) {
            // orderBy: [{ field:x, direction: 'ASC' }]
            datasetFilters.orderBy = this.options.sortingOptions;
        }
        if (this.options.filteringOptions && Array.isArray(this.options.filteringOptions) && this.options.filteringOptions.length > 0) {
            // filterBy: [{ field: date, operator: '>', value: '2000-10-10' }]
            datasetFilters.filterBy = this.options.filteringOptions;
        }
        if (this.options.addLocaleIntoQuery) {
            // first: 20, ... locale: "en-CA"
            datasetFilters.locale = this._gridOptions && this._gridOptions.i18n && this._gridOptions.i18n.currentLang || this._gridOptions.locale || 'en';
        }
        if (this.options.extraQueryArguments) {
            // first: 20, ... userId: 123
            for (const queryArgument of this.options.extraQueryArguments) {
                datasetFilters[queryArgument.field] = queryArgument.value;
            }
        }
        // with pagination:: query { users(first: 20, offset: 0, orderBy: [], filterBy: []) { totalCount: 100, nodes: { _columns_ }}}
        // without pagination:: query { users(orderBy: [], filterBy: []) { _columns_ }}
        datasetQb.filter(datasetFilters);
        queryQb.find(datasetQb);
        const enumSearchProperties = ['direction:', 'field:', 'operator:'];
        return this.trimDoubleQuotesOnEnumField(queryQb.toString(), enumSearchProperties, this.options.keepArgumentFieldDoubleQuotes || false);
    }
    /**
     * From an input array of strings, we want to build a GraphQL query string.
     * The process has to take the dot notation and parse it into a valid GraphQL query
     * Following this SO answer https://stackoverflow.com/a/47705476/1212166
     *
     * INPUT
     *  ['firstName', 'lastName', 'billing.address.street', 'billing.address.zip']
     * OUTPUT
     * firstName, lastName, billing{address{street, zip}}
     * @param inputArray
     */
    buildFilterQuery(inputArray) {
        const set = (o = {}, a) => {
            const k = a.shift();
            o[k] = a.length ? set(o[k], a) : null;
            return o;
        };
        const output = inputArray.reduce((o, a) => set(o, a.split('.')), {});
        return JSON.stringify(output)
            .replace(/\"|\:|null/g, '')
            .replace(/^\{/, '')
            .replace(/\}$/, '');
    }
    clearFilters() {
        this._currentFilters = [];
        this.updateOptions({ filteringOptions: [] });
    }
    clearSorters() {
        this._currentSorters = [];
        this.updateOptions({ sortingOptions: [] });
    }
    /**
     * Get an initialization of Pagination options
     * @return Pagination Options
     */
    getInitPaginationOptions() {
        const paginationFirst = this.pagination ? this.pagination.pageSize : DEFAULT_ITEMS_PER_PAGE;
        return (this.options && this.options.isWithCursor) ? { first: paginationFirst } : { first: paginationFirst, offset: 0 };
    }
    /** Get the GraphQL dataset name */
    getDatasetName() {
        return this.options.datasetName || '';
    }
    /** Get the Filters that are currently used by the grid */
    getCurrentFilters() {
        return this._currentFilters;
    }
    /** Get the Pagination that is currently used by the grid */
    getCurrentPagination() {
        return this._currentPagination;
    }
    /** Get the Sorters that are currently used by the grid */
    getCurrentSorters() {
        return this._currentSorters;
    }
    /*
     * Reset the pagination options
     */
    resetPaginationOptions() {
        let paginationOptions;
        if (this.options && this.options.isWithCursor) {
            // first, last, after, before
            paginationOptions = {
                after: '',
                before: undefined,
                last: undefined
            };
        }
        else {
            // first, last, offset
            paginationOptions = ((this.options && this.options.paginationOptions) || this.getInitPaginationOptions());
            paginationOptions.offset = 0;
        }
        // save current pagination as Page 1 and page size as "first" set size
        this._currentPagination = {
            pageNumber: 1,
            pageSize: paginationOptions.first || DEFAULT_PAGE_SIZE,
        };
        this.updateOptions({ paginationOptions });
    }
    updateOptions(serviceOptions) {
        this.options = Object.assign({}, this.options, serviceOptions);
    }
    /*
     * FILTERING
     */
    processOnFilterChanged(event, args) {
        const gridOptions = this._gridOptions;
        const backendApi = gridOptions.backendServiceApi;
        if (backendApi === undefined) {
            throw new Error('Something went wrong in the GraphqlService, "backendServiceApi" is not initialized');
        }
        // keep current filters & always save it as an array (columnFilters can be an object when it is dealt by SlickGrid Filter)
        this._currentFilters = this.castFilterToColumnFilters(args.columnFilters);
        if (!args || !args.grid) {
            throw new Error('Something went wrong when trying create the GraphQL Backend Service, it seems that "args" is not populated correctly');
        }
        // loop through all columns to inspect filters & set the query
        this.updateFilters(args.columnFilters, false);
        this.resetPaginationOptions();
        return this.buildQuery();
    }
    /*
     * PAGINATION
     * With cursor, the query can have 4 arguments (first, after, last, before), for example:
     *   users (first:20, after:"YXJyYXljb25uZWN0aW9uOjM=") {
     *     totalCount
     *     pageInfo {
     *       hasNextPage
     *       hasPreviousPage
     *       endCursor
     *       startCursor
     *     }
     *     edges {
     *       cursor
     *       node {
     *         name
     *         gender
     *       }
     *     }
     *   }
     * Without cursor, the query can have 3 arguments (first, last, offset), for example:
     *   users (first:20, offset: 10) {
     *     totalCount
     *     nodes {
     *       name
     *       gender
     *     }
     *   }
     */
    processOnPaginationChanged(event, args) {
        const pageSize = +(args.pageSize || ((this.pagination) ? this.pagination.pageSize : DEFAULT_PAGE_SIZE));
        this.updatePagination(args.newPage, pageSize);
        // build the GraphQL query which we will use in the WebAPI callback
        return this.buildQuery();
    }
    /*
     * SORTING
     * we will use sorting as per a Facebook suggestion on a Github issue (with some small changes)
     * https://github.com/graphql/graphql-relay-js/issues/20#issuecomment-220494222
     *
     *  users (first: 20, offset: 10, orderBy: [{field: lastName, direction: ASC}, {field: firstName, direction: DESC}]) {
     *    totalCount
     *    nodes {
     *      name
     *      gender
     *    }
     *  }
     */
    // @deprecated note, we should remove "SortChangedArgs" and only use: ColumnSort | MultiColumnSort
    processOnSortChanged(event, args) {
        const sortColumns = (args.multiColumnSort) ? args.sortCols : new Array({ sortCol: args.sortCol, sortAsc: args.sortAsc });
        // loop through all columns to inspect sorters & set the query
        this.updateSorters(sortColumns);
        // build the GraphQL query which we will use in the WebAPI callback
        return this.buildQuery();
    }
    /**
     * loop through all columns to inspect filters & update backend service filteringOptions
     * @param columnFilters
     */
    updateFilters(columnFilters, isUpdatedByPresetOrDynamically) {
        const searchByArray = [];
        let searchValue;
        // on filter preset load, we need to keep current filters
        if (isUpdatedByPresetOrDynamically) {
            this._currentFilters = this.castFilterToColumnFilters(columnFilters);
        }
        for (const columnId in columnFilters) {
            if (columnFilters.hasOwnProperty(columnId)) {
                const columnFilter = columnFilters[columnId];
                // if user defined some "presets", then we need to find the filters from the column definitions instead
                let columnDef;
                if (isUpdatedByPresetOrDynamically && Array.isArray(this._columnDefinitions)) {
                    columnDef = this._columnDefinitions.find((column) => column.id === columnFilter.columnId);
                }
                else {
                    columnDef = columnFilter.columnDef;
                }
                if (!columnDef) {
                    throw new Error('[GraphQL Service]: Something went wrong in trying to get the column definition of the specified filter (or preset filters). Did you make a typo on the filter columnId?');
                }
                const fieldName = (columnDef.filter && columnDef.filter.queryField) || columnDef.queryFieldFilter || columnDef.queryField || columnDef.field || columnDef.name || '';
                let searchTerms = columnFilter && columnFilter.searchTerms || [];
                let fieldSearchValue = (Array.isArray(searchTerms) && searchTerms.length === 1) ? searchTerms[0] : '';
                if (typeof fieldSearchValue === 'undefined') {
                    fieldSearchValue = '';
                }
                if (!fieldName) {
                    throw new Error(`GraphQL filter could not find the field name to query the search, your column definition must include a valid "field" or "name" (optionally you can also use the "queryfield").`);
                }
                fieldSearchValue = '' + fieldSearchValue; // make sure it's a string
                const matches = fieldSearchValue.match(/^([<>!=\*]{0,2})(.*[^<>!=\*])([\*]?)$/); // group 1: Operator, 2: searchValue, 3: last char is '*' (meaning starts with, ex.: abc*)
                let operator = columnFilter.operator || ((matches) ? matches[1] : '');
                searchValue = (!!matches) ? matches[2] : '';
                const lastValueChar = (!!matches) ? matches[3] : (operator === '*z' ? '*' : '');
                // no need to query if search value is empty
                if (fieldName && searchValue === '' && searchTerms.length === 0) {
                    continue;
                }
                if (Array.isArray(searchTerms) && searchTerms.length === 1 && typeof searchTerms[0] === 'string' && searchTerms[0].indexOf('..') > 0) {
                    searchTerms = searchTerms[0].split('..');
                    if (!operator) {
                        operator = OperatorType.rangeExclusive;
                    }
                }
                if (typeof searchValue === 'string') {
                    // escaping the search value
                    searchValue = searchValue.replace(`'`, `''`); // escape single quotes by doubling them
                    if (operator === '*' || operator === 'a*' || operator === '*z' || lastValueChar === '*') {
                        operator = ((operator === '*' || operator === '*z') ? 'EndsWith' : 'StartsWith');
                    }
                }
                // if we didn't find an Operator but we have a Column Operator inside the Filter (DOM Element), we should use its default Operator
                // multipleSelect is "IN", while singleSelect is "EQ", else don't map any operator
                if (!operator && columnDef.filter) {
                    operator = columnDef.filter.operator;
                }
                // when having more than 1 search term (we need to create a CSV string for GraphQL "IN" or "NOT IN" filter search)
                if (searchTerms && searchTerms.length > 1 && (operator === 'IN' || operator === 'NIN' || operator === 'NOTIN' || operator === 'NOT IN' || operator === 'NOT_IN')) {
                    searchValue = searchTerms.join(',');
                }
                else if (searchTerms && searchTerms.length === 2 && (!operator || operator === OperatorType.rangeExclusive || operator === OperatorType.rangeInclusive)) {
                    if (!operator) {
                        operator = OperatorType.rangeExclusive;
                    }
                    searchByArray.push({ field: fieldName, operator: (operator === OperatorType.rangeInclusive ? 'GE' : 'GT'), value: searchTerms[0] });
                    searchByArray.push({ field: fieldName, operator: (operator === OperatorType.rangeInclusive ? 'LE' : 'LT'), value: searchTerms[1] });
                    continue;
                }
                // if we still don't have an operator find the proper Operator to use by it's field type
                if (!operator) {
                    operator = mapOperatorByFieldType(columnDef.type || FieldType.string);
                }
                // build the search array
                searchByArray.push({ field: fieldName, operator: mapOperatorType(operator), value: searchValue });
            }
        }
        // update the service options with filters for the buildQuery() to work later
        this.updateOptions({ filteringOptions: searchByArray });
    }
    /**
     * Update the pagination component with it's new page number and size
     * @param newPage
     * @param pageSize
     */
    updatePagination(newPage, pageSize) {
        this._currentPagination = {
            pageNumber: newPage,
            pageSize,
        };
        let paginationOptions;
        if (this.options && this.options.isWithCursor) {
            paginationOptions = {
                first: pageSize
            };
        }
        else {
            paginationOptions = {
                first: pageSize,
                offset: (newPage > 1) ? ((newPage - 1) * pageSize) : 0 // recalculate offset but make sure the result is always over 0
            };
        }
        // unless user specifically set "enablePagination" to False, we'll update pagination options in every other cases
        if (this._gridOptions && (this._gridOptions.enablePagination || !this._gridOptions.hasOwnProperty('enablePagination'))) {
            this.updateOptions({ paginationOptions });
        }
    }
    /**
     * loop through all columns to inspect sorters & update backend service sortingOptions
     * @param columnFilters
     */
    updateSorters(sortColumns, presetSorters) {
        let currentSorters = [];
        const graphqlSorters = [];
        if (!sortColumns && presetSorters) {
            // make the presets the current sorters, also make sure that all direction are in uppercase for GraphQL
            currentSorters = presetSorters;
            currentSorters.forEach((sorter) => sorter.direction = sorter.direction.toUpperCase());
            // display the correct sorting icons on the UI, for that it requires (columnId, sortAsc) properties
            const tmpSorterArray = currentSorters.map((sorter) => {
                const columnDef = this._columnDefinitions.find((column) => column.id === sorter.columnId);
                graphqlSorters.push({
                    field: columnDef ? ((columnDef.queryFieldSorter || columnDef.queryField || columnDef.field) + '') : (sorter.columnId + ''),
                    direction: sorter.direction
                });
                // return only the column(s) found in the Column Definitions ELSE null
                if (columnDef) {
                    return {
                        columnId: sorter.columnId,
                        sortAsc: sorter.direction.toUpperCase() === SortDirection.ASC
                    };
                }
                return null;
            });
            // set the sort icons, but also make sure to filter out null values (that happens when columnDef is not found)
            if (Array.isArray(tmpSorterArray)) {
                this._grid.setSortColumns(tmpSorterArray.filter((sorter) => sorter));
            }
        }
        else if (sortColumns && !presetSorters) {
            // build the orderBy array, it could be multisort, example
            // orderBy:[{field: lastName, direction: ASC}, {field: firstName, direction: DESC}]
            if (Array.isArray(sortColumns) && sortColumns.length > 0) {
                for (const column of sortColumns) {
                    if (column && column.sortCol) {
                        currentSorters.push({
                            columnId: column.sortCol.id + '',
                            direction: column.sortAsc ? SortDirection.ASC : SortDirection.DESC
                        });
                        const fieldName = (column.sortCol.queryFieldSorter || column.sortCol.queryField || column.sortCol.field || '') + '';
                        if (fieldName) {
                            graphqlSorters.push({
                                field: fieldName,
                                direction: column.sortAsc ? SortDirection.ASC : SortDirection.DESC
                            });
                        }
                    }
                }
            }
        }
        // keep current Sorters and update the service options with the new sorting
        this._currentSorters = currentSorters;
        this.updateOptions({ sortingOptions: graphqlSorters });
    }
    /**
     * A function which takes an input string and removes double quotes only
     * on certain fields are identified as GraphQL enums (except fields with dot notation)
     * For example let say we identified ("direction:", "sort") as word which are GraphQL enum fields
     * then the result will be:
     * FROM
     * query { users (orderBy:[{field:"firstName", direction:"ASC"} }]) }
     * TO
     * query { users (orderBy:[{field: firstName, direction: ASC}})}
     *
     * EXCEPTIONS (fields with dot notation "." which are inside a "field:")
     * these fields will keep double quotes while everything else will be stripped of double quotes
     * query { users (orderBy:[{field:"billing.street.name", direction: "ASC"} }
     * TO
     * query { users (orderBy:[{field:"billing.street.name", direction: ASC}}
     * @param inputStr input string
     * @param enumSearchWords array of enum words to filter
     * @returns outputStr output string
     */
    trimDoubleQuotesOnEnumField(inputStr, enumSearchWords, keepArgumentFieldDoubleQuotes) {
        const patternWordInQuotes = `\s?((field:\s*)?".*?")`;
        let patternRegex = enumSearchWords.join(patternWordInQuotes + '|');
        patternRegex += patternWordInQuotes; // the last one should also have the pattern but without the pipe "|"
        // example with (field: & direction:):  /field:s?(".*?")|direction:s?(".*?")/
        const reg = new RegExp(patternRegex, 'g');
        return inputStr.replace(reg, (group1, group2, group3) => {
            // remove double quotes except when the string starts with a "field:"
            let removeDoubleQuotes = true;
            if (group1.startsWith('field:') && keepArgumentFieldDoubleQuotes) {
                removeDoubleQuotes = false;
            }
            const rep = removeDoubleQuotes ? group1.replace(/"/g, '') : group1;
            return rep;
        });
    }
    //
    // private functions
    // -------------------
    /**
     * Cast provided filters (could be in multiple formats) into an array of CurrentFilter
     * @param columnFilters
     */
    castFilterToColumnFilters(columnFilters) {
        // keep current filters & always save it as an array (columnFilters can be an object when it is dealt by SlickGrid Filter)
        const filtersArray = (typeof columnFilters === 'object') ? Object.keys(columnFilters).map(key => columnFilters[key]) : columnFilters;
        if (!Array.isArray(filtersArray)) {
            return [];
        }
        return filtersArray.map((filter) => {
            const tmpFilter = { columnId: filter.columnId || '' };
            if (filter.operator) {
                tmpFilter.operator = filter.operator;
            }
            if (Array.isArray(filter.searchTerms)) {
                tmpFilter.searchTerms = filter.searchTerms;
            }
            return tmpFilter;
        });
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JhcGhxbC5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci1zbGlja2dyaWQvIiwic291cmNlcyI6WyJhcHAvbW9kdWxlcy9hbmd1bGFyLXNsaWNrZ3JpZC9zZXJ2aWNlcy9ncmFwaHFsLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLGVBQWUsRUFBRSxzQkFBc0IsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUN0RSxPQUFPLEVBU0wsU0FBUyxFQVVULFlBQVksRUFJWixhQUFhLEVBR2QsTUFBTSxtQkFBbUIsQ0FBQztBQUMzQixPQUFPLFlBQVksTUFBTSx1QkFBdUIsQ0FBQztBQUVqRCxNQUFNLHNCQUFzQixHQUFHLEVBQUUsQ0FBQztBQUNsQyxNQUFNLGlCQUFpQixHQUFHLEVBQUUsQ0FBQztBQUU3QixNQUFNLE9BQU8sY0FBYztJQUEzQjtRQUNVLG9CQUFlLEdBQW9DLEVBQUUsQ0FBQztRQUV0RCxvQkFBZSxHQUFvQixFQUFFLENBQUM7UUFHdEMsdUJBQWtCLEdBQUcsSUFBSSxDQUFDO1FBR2xDLDZCQUF3QixHQUE0RDtZQUNsRixLQUFLLEVBQUUsc0JBQXNCO1lBQzdCLE1BQU0sRUFBRSxDQUFDO1NBQ1YsQ0FBQztJQW1qQkosQ0FBQztJQWpqQkMsd0NBQXdDO0lBQ3hDLElBQUksaUJBQWlCO1FBQ25CLE9BQU8sSUFBSSxDQUFDLGtCQUFrQixDQUFDO0lBQ2pDLENBQUM7SUFFRCxpRUFBaUU7SUFDakUsSUFBWSxZQUFZO1FBQ3RCLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztJQUM5RSxDQUFDO0lBRUQsaUVBQWlFO0lBQ2pFLElBQUksQ0FBQyxjQUFxQyxFQUFFLFVBQXVCLEVBQUUsSUFBVTtRQUM3RSxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztRQUNsQixJQUFJLENBQUMsT0FBTyxHQUFHLGNBQWMsSUFBSSxFQUFFLFdBQVcsRUFBRSxFQUFFLEVBQUUsaUJBQWlCLEVBQUUsRUFBRSxFQUFFLENBQUM7UUFDNUUsSUFBSSxDQUFDLFVBQVUsR0FBRyxVQUFVLENBQUM7UUFDN0IsSUFBSSxDQUFDLGtCQUFrQixHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMscUJBQXFCLElBQUksSUFBSSxDQUFDO1FBRTFFLElBQUksSUFBSSxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUU7WUFDM0IsSUFBSSxDQUFDLGtCQUFrQixHQUFHLENBQUMsY0FBYyxJQUFJLGNBQWMsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztTQUNyRztJQUNILENBQUM7SUFFRDs7O09BR0c7SUFDSCxVQUFVO1FBQ1IsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLGtCQUFrQixJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLGlCQUFpQixDQUFDLENBQUMsRUFBRTtZQUM5SCxNQUFNLElBQUksS0FBSyxDQUFDLHlGQUF5RixDQUFDLENBQUM7U0FDNUc7UUFFRCw4RUFBOEU7UUFDOUUsSUFBSSxpQkFBaUIsR0FBRyxJQUFJLENBQUMsa0JBQWtCLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQztRQUNsRixpQkFBaUIsR0FBRyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFjLEVBQUUsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFFM0YsTUFBTSxPQUFPLEdBQUcsSUFBSSxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDMUMsTUFBTSxTQUFTLEdBQUcsSUFBSSxZQUFZLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUM3RCxNQUFNLE9BQU8sR0FBRyxJQUFJLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUUxQyxtREFBbUQ7UUFDbkQsTUFBTSxTQUFTLEdBQWEsRUFBRSxDQUFDO1FBQy9CLElBQUksaUJBQWlCLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFO1lBQ3pELEtBQUssTUFBTSxNQUFNLElBQUksaUJBQWlCLEVBQUU7Z0JBQ3RDLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUU3Qiw0REFBNEQ7Z0JBQzVELElBQUksTUFBTSxDQUFDLE1BQU0sRUFBRTtvQkFDakIsU0FBUyxDQUFDLElBQUksQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztpQkFDbEM7YUFDRjtTQUNGO1FBRUQsb0dBQW9HO1FBQ3BHLG9FQUFvRTtRQUNwRSxJQUFJLFNBQVMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUU7WUFDckQsU0FBUyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsQ0FBQztTQUM1QztRQUVELE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUN0RCxJQUFJLGlCQUFpQixHQUFHLEVBQUUsQ0FBQztRQUUzQixJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsZ0JBQWdCLEtBQUssS0FBSyxFQUFFO1lBQ2hELElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLEVBQUU7Z0JBQzdCLGdHQUFnRztnQkFDaEcsTUFBTSxPQUFPLEdBQUcsSUFBSSxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBQzFDLE1BQU0sVUFBVSxHQUFHLElBQUksWUFBWSxDQUFDLFVBQVUsQ0FBQyxDQUFDO2dCQUNoRCxVQUFVLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxpQkFBaUIsRUFBRSxXQUFXLEVBQUUsYUFBYSxDQUFDLENBQUM7Z0JBQzlFLE9BQU8sQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7Z0JBQzNCLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO2dCQUN6QixpQkFBaUIsR0FBRyxDQUFDLFlBQVksRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLE9BQU8sQ0FBQyxDQUFDO2FBQ2xFO2lCQUFNO2dCQUNMLDBDQUEwQztnQkFDMUMsT0FBTyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztnQkFDM0IsaUJBQWlCLEdBQUcsQ0FBQyxZQUFZLEVBQUUsT0FBTyxDQUFDLENBQUM7YUFDN0M7WUFDRCw2Q0FBNkM7WUFDN0MsU0FBUyxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1NBQ25DO2FBQU07WUFDTCxxQ0FBcUM7WUFDckMsU0FBUyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztTQUM5QjtRQUVELGtGQUFrRjtRQUNsRixJQUFJLGNBQWMsR0FBeUIsRUFBRSxDQUFDO1FBRTlDLDBEQUEwRDtRQUMxRCxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsZ0JBQWdCLEtBQUssS0FBSyxFQUFFO1lBQ2hELGNBQWMscUJBQ1QsSUFBSSxDQUFDLE9BQU8sQ0FBQyxpQkFBaUIsSUFDakMsS0FBSyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLGlCQUFpQixJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsaUJBQWlCLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsaUJBQWlCLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsd0JBQXdCLENBQUMsS0FBSyxHQUNwUCxDQUFDO1lBRUYsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsWUFBWSxFQUFFO2dCQUM5QixjQUFjLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLGlCQUFpQixJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsaUJBQWlCLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDdks7U0FDRjtRQUVELElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxjQUFjLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBQyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDdkgsMkNBQTJDO1lBQzNDLGNBQWMsQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxjQUFjLENBQUM7U0FDdEQ7UUFDRCxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLGdCQUFnQixDQUFDLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQzdILGtFQUFrRTtZQUNsRSxjQUFjLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLENBQUM7U0FDekQ7UUFDRCxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsa0JBQWtCLEVBQUU7WUFDbkMsaUNBQWlDO1lBQ2pDLGNBQWMsQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLFlBQVksSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxXQUFXLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDO1NBQy9JO1FBQ0QsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLG1CQUFtQixFQUFFO1lBQ3BDLDZCQUE2QjtZQUM3QixLQUFLLE1BQU0sYUFBYSxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsbUJBQW1CLEVBQUU7Z0JBQzVELGNBQWMsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLEdBQUcsYUFBYSxDQUFDLEtBQUssQ0FBQzthQUMzRDtTQUNGO1FBRUQsNkhBQTZIO1FBQzdILCtFQUErRTtRQUMvRSxTQUFTLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQ2pDLE9BQU8sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7UUFFeEIsTUFBTSxvQkFBb0IsR0FBRyxDQUFDLFlBQVksRUFBRSxRQUFRLEVBQUUsV0FBVyxDQUFDLENBQUM7UUFDbkUsT0FBTyxJQUFJLENBQUMsMkJBQTJCLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxFQUFFLG9CQUFvQixFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsNkJBQTZCLElBQUksS0FBSyxDQUFDLENBQUM7SUFDekksQ0FBQztJQUVEOzs7Ozs7Ozs7O09BVUc7SUFDSCxnQkFBZ0IsQ0FBQyxVQUFvQjtRQUVuQyxNQUFNLEdBQUcsR0FBRyxDQUFDLElBQVMsRUFBRSxFQUFFLENBQU0sRUFBRSxFQUFFO1lBQ2xDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUNwQixDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO1lBQ3RDLE9BQU8sQ0FBQyxDQUFDO1FBQ1gsQ0FBQyxDQUFDO1FBRUYsTUFBTSxNQUFNLEdBQUcsVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQU0sRUFBRSxDQUFTLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBRWxGLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUM7YUFDMUIsT0FBTyxDQUFDLGFBQWEsRUFBRSxFQUFFLENBQUM7YUFDMUIsT0FBTyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUM7YUFDbEIsT0FBTyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztJQUN4QixDQUFDO0lBRUQsWUFBWTtRQUNWLElBQUksQ0FBQyxlQUFlLEdBQUcsRUFBRSxDQUFDO1FBQzFCLElBQUksQ0FBQyxhQUFhLENBQUMsRUFBRSxnQkFBZ0IsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQy9DLENBQUM7SUFFRCxZQUFZO1FBQ1YsSUFBSSxDQUFDLGVBQWUsR0FBRyxFQUFFLENBQUM7UUFDMUIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxFQUFFLGNBQWMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQzdDLENBQUM7SUFFRDs7O09BR0c7SUFDSCx3QkFBd0I7UUFDdEIsTUFBTSxlQUFlLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLHNCQUFzQixDQUFDO1FBQzVGLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxFQUFFLGVBQWUsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBRSxlQUFlLEVBQUUsTUFBTSxFQUFFLENBQUMsRUFBRSxDQUFDO0lBQzFILENBQUM7SUFFRCxtQ0FBbUM7SUFDbkMsY0FBYztRQUNaLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLElBQUksRUFBRSxDQUFDO0lBQ3hDLENBQUM7SUFFRCwwREFBMEQ7SUFDMUQsaUJBQWlCO1FBQ2YsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDO0lBQzlCLENBQUM7SUFFRCw0REFBNEQ7SUFDNUQsb0JBQW9CO1FBQ2xCLE9BQU8sSUFBSSxDQUFDLGtCQUFrQixDQUFDO0lBQ2pDLENBQUM7SUFFRCwwREFBMEQ7SUFDMUQsaUJBQWlCO1FBQ2YsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDO0lBQzlCLENBQUM7SUFFRDs7T0FFRztJQUNILHNCQUFzQjtRQUNwQixJQUFJLGlCQUEwRSxDQUFDO1FBRS9FLElBQUksSUFBSSxDQUFDLE9BQU8sSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLFlBQVksRUFBRTtZQUM3Qyw2QkFBNkI7WUFDN0IsaUJBQWlCLEdBQUc7Z0JBQ2xCLEtBQUssRUFBRSxFQUFFO2dCQUNULE1BQU0sRUFBRSxTQUFTO2dCQUNqQixJQUFJLEVBQUUsU0FBUzthQUNpQixDQUFDO1NBQ3BDO2FBQU07WUFDTCxzQkFBc0I7WUFDdEIsaUJBQWlCLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLElBQUksQ0FBQyx3QkFBd0IsRUFBRSxDQUE0QixDQUFDO1lBQ3BJLGlCQUE2QyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7U0FDM0Q7UUFFRCxzRUFBc0U7UUFDdEUsSUFBSSxDQUFDLGtCQUFrQixHQUFHO1lBQ3hCLFVBQVUsRUFBRSxDQUFDO1lBQ2IsUUFBUSxFQUFFLGlCQUFpQixDQUFDLEtBQUssSUFBSSxpQkFBaUI7U0FDdkQsQ0FBQztRQUVGLElBQUksQ0FBQyxhQUFhLENBQUMsRUFBRSxpQkFBaUIsRUFBRSxDQUFDLENBQUM7SUFDNUMsQ0FBQztJQUVELGFBQWEsQ0FBQyxjQUE4QztRQUMxRCxJQUFJLENBQUMsT0FBTyxxQkFBUSxJQUFJLENBQUMsT0FBTyxFQUFLLGNBQWMsQ0FBRSxDQUFDO0lBQ3hELENBQUM7SUFFRDs7T0FFRztJQUNILHNCQUFzQixDQUFDLEtBQVksRUFBRSxJQUF1QjtRQUMxRCxNQUFNLFdBQVcsR0FBZSxJQUFJLENBQUMsWUFBWSxDQUFDO1FBQ2xELE1BQU0sVUFBVSxHQUFHLFdBQVcsQ0FBQyxpQkFBaUIsQ0FBQztRQUVqRCxJQUFJLFVBQVUsS0FBSyxTQUFTLEVBQUU7WUFDNUIsTUFBTSxJQUFJLEtBQUssQ0FBQyxvRkFBb0YsQ0FBQyxDQUFDO1NBQ3ZHO1FBRUQsMEhBQTBIO1FBQzFILElBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDLHlCQUF5QixDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUUxRSxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRTtZQUN2QixNQUFNLElBQUksS0FBSyxDQUFDLHNIQUFzSCxDQUFDLENBQUM7U0FDekk7UUFFRCw4REFBOEQ7UUFDOUQsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBRTlDLElBQUksQ0FBQyxzQkFBc0IsRUFBRSxDQUFDO1FBQzlCLE9BQU8sSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO0lBQzNCLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BMkJHO0lBQ0gsMEJBQTBCLENBQUMsS0FBWSxFQUFFLElBQTJCO1FBQ2xFLE1BQU0sUUFBUSxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUM7UUFDeEcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFFOUMsbUVBQW1FO1FBQ25FLE9BQU8sSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO0lBQzNCLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7O09BWUc7SUFDSCxrR0FBa0c7SUFDbEcsb0JBQW9CLENBQUMsS0FBWSxFQUFFLElBQW9EO1FBQ3JGLE1BQU0sV0FBVyxHQUFHLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBRSxJQUF3QixDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsRUFBRSxPQUFPLEVBQUcsSUFBbUIsQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFHLElBQW1CLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztRQUU5Syw4REFBOEQ7UUFDOUQsSUFBSSxDQUFDLGFBQWEsQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUVoQyxtRUFBbUU7UUFDbkUsT0FBTyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7SUFDM0IsQ0FBQztJQUVEOzs7T0FHRztJQUNILGFBQWEsQ0FBQyxhQUE4QyxFQUFFLDhCQUF1QztRQUNuRyxNQUFNLGFBQWEsR0FBNkIsRUFBRSxDQUFDO1FBQ25ELElBQUksV0FBOEIsQ0FBQztRQUVuQyx5REFBeUQ7UUFDekQsSUFBSSw4QkFBOEIsRUFBRTtZQUNsQyxJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxhQUFhLENBQUMsQ0FBQztTQUN0RTtRQUVELEtBQUssTUFBTSxRQUFRLElBQUksYUFBYSxFQUFFO1lBQ3BDLElBQUksYUFBYSxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsRUFBRTtnQkFDMUMsTUFBTSxZQUFZLEdBQUcsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDO2dCQUU3Qyx1R0FBdUc7Z0JBQ3ZHLElBQUksU0FBNkIsQ0FBQztnQkFDbEMsSUFBSSw4QkFBOEIsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxFQUFFO29CQUM1RSxTQUFTLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxDQUFDLE1BQWMsRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLEVBQUUsS0FBSyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7aUJBQ25HO3FCQUFNO29CQUNMLFNBQVMsR0FBRyxZQUFZLENBQUMsU0FBUyxDQUFDO2lCQUNwQztnQkFDRCxJQUFJLENBQUMsU0FBUyxFQUFFO29CQUNkLE1BQU0sSUFBSSxLQUFLLENBQUMseUtBQXlLLENBQUMsQ0FBQztpQkFDNUw7Z0JBRUQsTUFBTSxTQUFTLEdBQUcsQ0FBQyxTQUFTLENBQUMsTUFBTSxJQUFJLFNBQVMsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksU0FBUyxDQUFDLGdCQUFnQixJQUFJLFNBQVMsQ0FBQyxVQUFVLElBQUksU0FBUyxDQUFDLEtBQUssSUFBSSxTQUFTLENBQUMsSUFBSSxJQUFJLEVBQUUsQ0FBQztnQkFDckssSUFBSSxXQUFXLEdBQUcsWUFBWSxJQUFJLFlBQVksQ0FBQyxXQUFXLElBQUksRUFBRSxDQUFDO2dCQUNqRSxJQUFJLGdCQUFnQixHQUFHLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsSUFBSSxXQUFXLENBQUMsTUFBTSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztnQkFDdEcsSUFBSSxPQUFPLGdCQUFnQixLQUFLLFdBQVcsRUFBRTtvQkFDM0MsZ0JBQWdCLEdBQUcsRUFBRSxDQUFDO2lCQUN2QjtnQkFFRCxJQUFJLENBQUMsU0FBUyxFQUFFO29CQUNkLE1BQU0sSUFBSSxLQUFLLENBQUMsaUxBQWlMLENBQUMsQ0FBQztpQkFDcE07Z0JBRUQsZ0JBQWdCLEdBQUcsRUFBRSxHQUFHLGdCQUFnQixDQUFDLENBQUMsMEJBQTBCO2dCQUNwRSxNQUFNLE9BQU8sR0FBRyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsdUNBQXVDLENBQUMsQ0FBQyxDQUFDLDBGQUEwRjtnQkFDM0ssSUFBSSxRQUFRLEdBQUcsWUFBWSxDQUFDLFFBQVEsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7Z0JBQ3RFLFdBQVcsR0FBRyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7Z0JBQzVDLE1BQU0sYUFBYSxHQUFHLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztnQkFFaEYsNENBQTRDO2dCQUM1QyxJQUFJLFNBQVMsSUFBSSxXQUFXLEtBQUssRUFBRSxJQUFJLFdBQVcsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO29CQUMvRCxTQUFTO2lCQUNWO2dCQUVELElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsSUFBSSxXQUFXLENBQUMsTUFBTSxLQUFLLENBQUMsSUFBSSxPQUFPLFdBQVcsQ0FBQyxDQUFDLENBQUMsS0FBSyxRQUFRLElBQUksV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUU7b0JBQ3BJLFdBQVcsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO29CQUN6QyxJQUFJLENBQUMsUUFBUSxFQUFFO3dCQUNiLFFBQVEsR0FBRyxZQUFZLENBQUMsY0FBYyxDQUFDO3FCQUN4QztpQkFDRjtnQkFFRCxJQUFJLE9BQU8sV0FBVyxLQUFLLFFBQVEsRUFBRTtvQkFDbkMsNEJBQTRCO29CQUM1QixXQUFXLEdBQUcsV0FBVyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyx3Q0FBd0M7b0JBQ3RGLElBQUksUUFBUSxLQUFLLEdBQUcsSUFBSSxRQUFRLEtBQUssSUFBSSxJQUFJLFFBQVEsS0FBSyxJQUFJLElBQUksYUFBYSxLQUFLLEdBQUcsRUFBRTt3QkFDdkYsUUFBUSxHQUFHLENBQUMsQ0FBQyxRQUFRLEtBQUssR0FBRyxJQUFJLFFBQVEsS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQW1CLENBQUM7cUJBQ3BHO2lCQUNGO2dCQUVELGtJQUFrSTtnQkFDbEksa0ZBQWtGO2dCQUNsRixJQUFJLENBQUMsUUFBUSxJQUFJLFNBQVMsQ0FBQyxNQUFNLEVBQUU7b0JBQ2pDLFFBQVEsR0FBRyxTQUFTLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQztpQkFDdEM7Z0JBRUQsa0hBQWtIO2dCQUNsSCxJQUFJLFdBQVcsSUFBSSxXQUFXLENBQUMsTUFBTSxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsS0FBSyxJQUFJLElBQUksUUFBUSxLQUFLLEtBQUssSUFBSSxRQUFRLEtBQUssT0FBTyxJQUFJLFFBQVEsS0FBSyxRQUFRLElBQUksUUFBUSxLQUFLLFFBQVEsQ0FBQyxFQUFFO29CQUNoSyxXQUFXLEdBQUcsV0FBVyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztpQkFDckM7cUJBQU0sSUFBSSxXQUFXLElBQUksV0FBVyxDQUFDLE1BQU0sS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLFFBQVEsSUFBSSxRQUFRLEtBQUssWUFBWSxDQUFDLGNBQWMsSUFBSSxRQUFRLEtBQUssWUFBWSxDQUFDLGNBQWMsQ0FBQyxFQUFFO29CQUN6SixJQUFJLENBQUMsUUFBUSxFQUFFO3dCQUNiLFFBQVEsR0FBRyxZQUFZLENBQUMsY0FBYyxDQUFDO3FCQUN4QztvQkFDRCxhQUFhLENBQUMsSUFBSSxDQUFDLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxRQUFRLEVBQUUsQ0FBQyxRQUFRLEtBQUssWUFBWSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxLQUFLLEVBQUUsV0FBVyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztvQkFDcEksYUFBYSxDQUFDLElBQUksQ0FBQyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLENBQUMsUUFBUSxLQUFLLFlBQVksQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsS0FBSyxFQUFFLFdBQVcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7b0JBQ3BJLFNBQVM7aUJBQ1Y7Z0JBRUQsd0ZBQXdGO2dCQUN4RixJQUFJLENBQUMsUUFBUSxFQUFFO29CQUNiLFFBQVEsR0FBRyxzQkFBc0IsQ0FBQyxTQUFTLENBQUMsSUFBSSxJQUFJLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztpQkFDdkU7Z0JBRUQseUJBQXlCO2dCQUN6QixhQUFhLENBQUMsSUFBSSxDQUFDLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxRQUFRLEVBQUUsZUFBZSxDQUFDLFFBQVEsQ0FBQyxFQUFFLEtBQUssRUFBRSxXQUFXLEVBQUUsQ0FBQyxDQUFDO2FBQ25HO1NBQ0Y7UUFFRCw2RUFBNkU7UUFDN0UsSUFBSSxDQUFDLGFBQWEsQ0FBQyxFQUFFLGdCQUFnQixFQUFFLGFBQWEsRUFBRSxDQUFDLENBQUM7SUFDMUQsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxnQkFBZ0IsQ0FBQyxPQUFlLEVBQUUsUUFBZ0I7UUFDaEQsSUFBSSxDQUFDLGtCQUFrQixHQUFHO1lBQ3hCLFVBQVUsRUFBRSxPQUFPO1lBQ25CLFFBQVE7U0FDVCxDQUFDO1FBRUYsSUFBSSxpQkFBaUIsQ0FBQztRQUN0QixJQUFJLElBQUksQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLEVBQUU7WUFDN0MsaUJBQWlCLEdBQUc7Z0JBQ2xCLEtBQUssRUFBRSxRQUFRO2FBQ2hCLENBQUM7U0FDSDthQUFNO1lBQ0wsaUJBQWlCLEdBQUc7Z0JBQ2xCLEtBQUssRUFBRSxRQUFRO2dCQUNmLE1BQU0sRUFBRSxDQUFDLE9BQU8sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sR0FBRyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLCtEQUErRDthQUN2SCxDQUFDO1NBQ0g7UUFFRCxpSEFBaUg7UUFDakgsSUFBSSxJQUFJLENBQUMsWUFBWSxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxnQkFBZ0IsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsY0FBYyxDQUFDLGtCQUFrQixDQUFDLENBQUMsRUFBRTtZQUN0SCxJQUFJLENBQUMsYUFBYSxDQUFDLEVBQUUsaUJBQWlCLEVBQUUsQ0FBQyxDQUFDO1NBQzNDO0lBQ0gsQ0FBQztJQUVEOzs7T0FHRztJQUNILGFBQWEsQ0FBQyxXQUEwQixFQUFFLGFBQStCO1FBQ3ZFLElBQUksY0FBYyxHQUFvQixFQUFFLENBQUM7UUFDekMsTUFBTSxjQUFjLEdBQTJCLEVBQUUsQ0FBQztRQUVsRCxJQUFJLENBQUMsV0FBVyxJQUFJLGFBQWEsRUFBRTtZQUNqQyx1R0FBdUc7WUFDdkcsY0FBYyxHQUFHLGFBQWEsQ0FBQztZQUMvQixjQUFjLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxNQUFNLENBQUMsU0FBUyxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsV0FBVyxFQUF5QixDQUFDLENBQUM7WUFFN0csbUdBQW1HO1lBQ25HLE1BQU0sY0FBYyxHQUFHLGNBQWMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBRTtnQkFDbkQsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxDQUFDLE1BQWMsRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLEVBQUUsS0FBSyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7Z0JBRWxHLGNBQWMsQ0FBQyxJQUFJLENBQUM7b0JBQ2xCLEtBQUssRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsZ0JBQWdCLElBQUksU0FBUyxDQUFDLFVBQVUsSUFBSSxTQUFTLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFFBQVEsR0FBRyxFQUFFLENBQUM7b0JBQzFILFNBQVMsRUFBRSxNQUFNLENBQUMsU0FBUztpQkFDNUIsQ0FBQyxDQUFDO2dCQUVILHNFQUFzRTtnQkFDdEUsSUFBSSxTQUFTLEVBQUU7b0JBQ2IsT0FBTzt3QkFDTCxRQUFRLEVBQUUsTUFBTSxDQUFDLFFBQVE7d0JBQ3pCLE9BQU8sRUFBRSxNQUFNLENBQUMsU0FBUyxDQUFDLFdBQVcsRUFBRSxLQUFLLGFBQWEsQ0FBQyxHQUFHO3FCQUM5RCxDQUFDO2lCQUNIO2dCQUNELE9BQU8sSUFBSSxDQUFDO1lBQ2QsQ0FBQyxDQUFDLENBQUM7WUFFSCw4R0FBOEc7WUFDOUcsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBQyxFQUFFO2dCQUNqQyxJQUFJLENBQUMsS0FBSyxDQUFDLGNBQWMsQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO2FBQ3RFO1NBQ0Y7YUFBTSxJQUFJLFdBQVcsSUFBSSxDQUFDLGFBQWEsRUFBRTtZQUN4QywwREFBMEQ7WUFDMUQsbUZBQW1GO1lBQ25GLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsSUFBSSxXQUFXLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtnQkFDeEQsS0FBSyxNQUFNLE1BQU0sSUFBSSxXQUFXLEVBQUU7b0JBQ2hDLElBQUksTUFBTSxJQUFJLE1BQU0sQ0FBQyxPQUFPLEVBQUU7d0JBQzVCLGNBQWMsQ0FBQyxJQUFJLENBQUM7NEJBQ2xCLFFBQVEsRUFBRSxNQUFNLENBQUMsT0FBTyxDQUFDLEVBQUUsR0FBRyxFQUFFOzRCQUNoQyxTQUFTLEVBQUUsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLElBQUk7eUJBQ25FLENBQUMsQ0FBQzt3QkFFSCxNQUFNLFNBQVMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxVQUFVLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLElBQUksRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDO3dCQUNwSCxJQUFJLFNBQVMsRUFBRTs0QkFDYixjQUFjLENBQUMsSUFBSSxDQUFDO2dDQUNsQixLQUFLLEVBQUUsU0FBUztnQ0FDaEIsU0FBUyxFQUFFLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxJQUFJOzZCQUNuRSxDQUFDLENBQUM7eUJBQ0o7cUJBQ0Y7aUJBQ0Y7YUFDRjtTQUNGO1FBRUQsMkVBQTJFO1FBQzNFLElBQUksQ0FBQyxlQUFlLEdBQUcsY0FBYyxDQUFDO1FBQ3RDLElBQUksQ0FBQyxhQUFhLENBQUMsRUFBRSxjQUFjLEVBQUUsY0FBYyxFQUFFLENBQUMsQ0FBQztJQUN6RCxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQWtCRztJQUNILDJCQUEyQixDQUFDLFFBQWdCLEVBQUUsZUFBeUIsRUFBRSw2QkFBc0M7UUFDN0csTUFBTSxtQkFBbUIsR0FBRyx3QkFBd0IsQ0FBQztRQUNyRCxJQUFJLFlBQVksR0FBRyxlQUFlLENBQUMsSUFBSSxDQUFDLG1CQUFtQixHQUFHLEdBQUcsQ0FBQyxDQUFDO1FBQ25FLFlBQVksSUFBSSxtQkFBbUIsQ0FBQyxDQUFDLHFFQUFxRTtRQUMxRyw2RUFBNkU7UUFDN0UsTUFBTSxHQUFHLEdBQUcsSUFBSSxNQUFNLENBQUMsWUFBWSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBRTFDLE9BQU8sUUFBUSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxNQUFNLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxFQUFFO1lBQ3RELHFFQUFxRTtZQUNyRSxJQUFJLGtCQUFrQixHQUFHLElBQUksQ0FBQztZQUM5QixJQUFJLE1BQU0sQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLElBQUksNkJBQTZCLEVBQUU7Z0JBQ2hFLGtCQUFrQixHQUFHLEtBQUssQ0FBQzthQUM1QjtZQUNELE1BQU0sR0FBRyxHQUFHLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDO1lBQ25FLE9BQU8sR0FBRyxDQUFDO1FBQ2IsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQsRUFBRTtJQUNGLG9CQUFvQjtJQUNwQixzQkFBc0I7SUFDdEI7OztPQUdHO0lBQ0sseUJBQXlCLENBQUMsYUFBOEM7UUFDOUUsMEhBQTBIO1FBQzFILE1BQU0sWUFBWSxHQUFtQixDQUFDLE9BQU8sYUFBYSxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUM7UUFFckosSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLEVBQUU7WUFDaEMsT0FBTyxFQUFFLENBQUM7U0FDWDtRQUVELE9BQU8sWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFO1lBQ2pDLE1BQU0sU0FBUyxHQUFrQixFQUFFLFFBQVEsRUFBRSxNQUFNLENBQUMsUUFBUSxJQUFJLEVBQUUsRUFBRSxDQUFDO1lBQ3JFLElBQUksTUFBTSxDQUFDLFFBQVEsRUFBRTtnQkFDbkIsU0FBUyxDQUFDLFFBQVEsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDO2FBQ3RDO1lBQ0QsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsRUFBRTtnQkFDckMsU0FBUyxDQUFDLFdBQVcsR0FBRyxNQUFNLENBQUMsV0FBVyxDQUFDO2FBQzVDO1lBQ0QsT0FBTyxTQUFTLENBQUM7UUFDbkIsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtYXBPcGVyYXRvclR5cGUsIG1hcE9wZXJhdG9yQnlGaWVsZFR5cGUgfSBmcm9tICcuL3V0aWxpdGllcyc7XHJcbmltcG9ydCB7XHJcbiAgQmFja2VuZFNlcnZpY2UsXHJcbiAgQ29sdW1uLFxyXG4gIENvbHVtbkZpbHRlcixcclxuICBDb2x1bW5GaWx0ZXJzLFxyXG4gIENvbHVtblNvcnQsXHJcbiAgQ3VycmVudEZpbHRlcixcclxuICBDdXJyZW50UGFnaW5hdGlvbixcclxuICBDdXJyZW50U29ydGVyLFxyXG4gIEZpZWxkVHlwZSxcclxuICBGaWx0ZXJDaGFuZ2VkQXJncyxcclxuICBHcmFwaHFsQ3Vyc29yUGFnaW5hdGlvbk9wdGlvbixcclxuICBHcmFwaHFsRGF0YXNldEZpbHRlcixcclxuICBHcmFwaHFsRmlsdGVyaW5nT3B0aW9uLFxyXG4gIEdyYXBocWxQYWdpbmF0aW9uT3B0aW9uLFxyXG4gIEdyYXBocWxTZXJ2aWNlT3B0aW9uLFxyXG4gIEdyYXBocWxTb3J0aW5nT3B0aW9uLFxyXG4gIEdyaWRPcHRpb24sXHJcbiAgTXVsdGlDb2x1bW5Tb3J0LFxyXG4gIE9wZXJhdG9yVHlwZSxcclxuICBQYWdpbmF0aW9uLFxyXG4gIFBhZ2luYXRpb25DaGFuZ2VkQXJncyxcclxuICBTb3J0Q2hhbmdlZEFyZ3MsXHJcbiAgU29ydERpcmVjdGlvbixcclxuICBTb3J0RGlyZWN0aW9uU3RyaW5nLFxyXG4gIE9wZXJhdG9yU3RyaW5nXHJcbn0gZnJvbSAnLi8uLi9tb2RlbHMvaW5kZXgnO1xyXG5pbXBvcnQgUXVlcnlCdWlsZGVyIGZyb20gJy4vZ3JhcGhxbFF1ZXJ5QnVpbGRlcic7XHJcblxyXG5jb25zdCBERUZBVUxUX0lURU1TX1BFUl9QQUdFID0gMjU7XHJcbmNvbnN0IERFRkFVTFRfUEFHRV9TSVpFID0gMjA7XHJcblxyXG5leHBvcnQgY2xhc3MgR3JhcGhxbFNlcnZpY2UgaW1wbGVtZW50cyBCYWNrZW5kU2VydmljZSB7XHJcbiAgcHJpdmF0ZSBfY3VycmVudEZpbHRlcnM6IENvbHVtbkZpbHRlcnMgfCBDdXJyZW50RmlsdGVyW10gPSBbXTtcclxuICBwcml2YXRlIF9jdXJyZW50UGFnaW5hdGlvbjogQ3VycmVudFBhZ2luYXRpb247XHJcbiAgcHJpdmF0ZSBfY3VycmVudFNvcnRlcnM6IEN1cnJlbnRTb3J0ZXJbXSA9IFtdO1xyXG4gIHByaXZhdGUgX2NvbHVtbkRlZmluaXRpb25zOiBDb2x1bW5bXTtcclxuICBwcml2YXRlIF9ncmlkOiBhbnk7XHJcbiAgcHJpdmF0ZSBfZGF0YXNldElkUHJvcE5hbWUgPSAnaWQnO1xyXG4gIG9wdGlvbnM6IEdyYXBocWxTZXJ2aWNlT3B0aW9uO1xyXG4gIHBhZ2luYXRpb246IFBhZ2luYXRpb24gfCB1bmRlZmluZWQ7XHJcbiAgZGVmYXVsdFBhZ2luYXRpb25PcHRpb25zOiBHcmFwaHFsUGFnaW5hdGlvbk9wdGlvbiB8IEdyYXBocWxDdXJzb3JQYWdpbmF0aW9uT3B0aW9uID0ge1xyXG4gICAgZmlyc3Q6IERFRkFVTFRfSVRFTVNfUEVSX1BBR0UsXHJcbiAgICBvZmZzZXQ6IDBcclxuICB9O1xyXG5cclxuICAvKiogR2V0dGVyIGZvciB0aGUgQ29sdW1uIERlZmluaXRpb25zICovXHJcbiAgZ2V0IGNvbHVtbkRlZmluaXRpb25zKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2NvbHVtbkRlZmluaXRpb25zO1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldHRlciBmb3IgdGhlIEdyaWQgT3B0aW9ucyBwdWxsZWQgdGhyb3VnaCB0aGUgR3JpZCBPYmplY3QgKi9cclxuICBwcml2YXRlIGdldCBfZ3JpZE9wdGlvbnMoKTogR3JpZE9wdGlvbiB7XHJcbiAgICByZXR1cm4gKHRoaXMuX2dyaWQgJiYgdGhpcy5fZ3JpZC5nZXRPcHRpb25zKSA/IHRoaXMuX2dyaWQuZ2V0T3B0aW9ucygpIDoge307XHJcbiAgfVxyXG5cclxuICAvKiogSW5pdGlhbGl6YXRpb24gb2YgdGhlIHNlcnZpY2UsIHdoaWNoIGFjdHMgYXMgYSBjb25zdHJ1Y3RvciAqL1xyXG4gIGluaXQoc2VydmljZU9wdGlvbnM/OiBHcmFwaHFsU2VydmljZU9wdGlvbiwgcGFnaW5hdGlvbj86IFBhZ2luYXRpb24sIGdyaWQ/OiBhbnkpOiB2b2lkIHtcclxuICAgIHRoaXMuX2dyaWQgPSBncmlkO1xyXG4gICAgdGhpcy5vcHRpb25zID0gc2VydmljZU9wdGlvbnMgfHwgeyBkYXRhc2V0TmFtZTogJycsIGNvbHVtbkRlZmluaXRpb25zOiBbXSB9O1xyXG4gICAgdGhpcy5wYWdpbmF0aW9uID0gcGFnaW5hdGlvbjtcclxuICAgIHRoaXMuX2RhdGFzZXRJZFByb3BOYW1lID0gdGhpcy5fZ3JpZE9wdGlvbnMuZGF0YXNldElkUHJvcGVydHlOYW1lIHx8ICdpZCc7XHJcblxyXG4gICAgaWYgKGdyaWQgJiYgZ3JpZC5nZXRDb2x1bW5zKSB7XHJcbiAgICAgIHRoaXMuX2NvbHVtbkRlZmluaXRpb25zID0gKHNlcnZpY2VPcHRpb25zICYmIHNlcnZpY2VPcHRpb25zLmNvbHVtbkRlZmluaXRpb25zKSB8fCBncmlkLmdldENvbHVtbnMoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEJ1aWxkIHRoZSBHcmFwaFFMIHF1ZXJ5LCBzaW5jZSB0aGUgc2VydmljZSBpbmNsdWRlL2V4Y2x1ZGUgY3Vyc29yLCB0aGUgb3V0cHV0IHF1ZXJ5IHdpbGwgYmUgZGlmZmVyZW50LlxyXG4gICAqIEBwYXJhbSBzZXJ2aWNlT3B0aW9ucyBHcmFwaHFsU2VydmljZU9wdGlvblxyXG4gICAqL1xyXG4gIGJ1aWxkUXVlcnkoKSB7XHJcbiAgICBpZiAoIXRoaXMub3B0aW9ucyB8fCAhdGhpcy5vcHRpb25zLmRhdGFzZXROYW1lIHx8ICghdGhpcy5fY29sdW1uRGVmaW5pdGlvbnMgJiYgIUFycmF5LmlzQXJyYXkodGhpcy5vcHRpb25zLmNvbHVtbkRlZmluaXRpb25zKSkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdHcmFwaFFMIFNlcnZpY2UgcmVxdWlyZXMgdGhlIFwiZGF0YXNldE5hbWVcIiBwcm9wZXJ0eSB0byBwcm9wZXJseSBidWlsZCB0aGUgR3JhcGhRTCBxdWVyeScpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGdldCB0aGUgY29sdW1uIGRlZmluaXRpb25zIGFuZCBleGNsdWRlIHNvbWUgaWYgdGhleSB3ZXJlIHRhZ2dlZCBhcyBleGNsdWRlZFxyXG4gICAgbGV0IGNvbHVtbkRlZmluaXRpb25zID0gdGhpcy5fY29sdW1uRGVmaW5pdGlvbnMgfHwgdGhpcy5vcHRpb25zLmNvbHVtbkRlZmluaXRpb25zO1xyXG4gICAgY29sdW1uRGVmaW5pdGlvbnMgPSBjb2x1bW5EZWZpbml0aW9ucy5maWx0ZXIoKGNvbHVtbjogQ29sdW1uKSA9PiAhY29sdW1uLmV4Y2x1ZGVGcm9tUXVlcnkpO1xyXG5cclxuICAgIGNvbnN0IHF1ZXJ5UWIgPSBuZXcgUXVlcnlCdWlsZGVyKCdxdWVyeScpO1xyXG4gICAgY29uc3QgZGF0YXNldFFiID0gbmV3IFF1ZXJ5QnVpbGRlcih0aGlzLm9wdGlvbnMuZGF0YXNldE5hbWUpO1xyXG4gICAgY29uc3Qgbm9kZXNRYiA9IG5ldyBRdWVyeUJ1aWxkZXIoJ25vZGVzJyk7XHJcblxyXG4gICAgLy8gZ2V0IGFsbCB0aGUgY29sdW1uZHMgSWRzIGZvciB0aGUgZmlsdGVycyB0byB3b3JrXHJcbiAgICBjb25zdCBjb2x1bW5JZHM6IHN0cmluZ1tdID0gW107XHJcbiAgICBpZiAoY29sdW1uRGVmaW5pdGlvbnMgJiYgQXJyYXkuaXNBcnJheShjb2x1bW5EZWZpbml0aW9ucykpIHtcclxuICAgICAgZm9yIChjb25zdCBjb2x1bW4gb2YgY29sdW1uRGVmaW5pdGlvbnMpIHtcclxuICAgICAgICBjb2x1bW5JZHMucHVzaChjb2x1bW4uZmllbGQpO1xyXG5cclxuICAgICAgICAvLyBpZiBleHRyYSBcImZpZWxkc1wiIGFyZSBwYXNzZWQsIGFsc28gcHVzaCB0aGVtIHRvIGNvbHVtbklkc1xyXG4gICAgICAgIGlmIChjb2x1bW4uZmllbGRzKSB7XHJcbiAgICAgICAgICBjb2x1bW5JZHMucHVzaCguLi5jb2x1bW4uZmllbGRzKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBTbGlja2dyaWQgYWxzbyByZXF1aXJlcyB0aGUgXCJpZFwiIChvciB0aGUgZGF0YXNldCBkZWZpbmVkIHVuaXF1ZSBpZGUpIGZpZWxkIHRvIGJlIHBhcnQgb2YgRGF0YVZpZXdcclxuICAgIC8vIGFkZCBpdCB0byB0aGUgR3JhcGhRTCBxdWVyeSBpZiBpdCB3YXNuJ3QgYWxyZWFkeSBwYXJ0IG9mIHRoZSBsaXN0XHJcbiAgICBpZiAoY29sdW1uSWRzLmluZGV4T2YodGhpcy5fZGF0YXNldElkUHJvcE5hbWUpID09PSAtMSkge1xyXG4gICAgICBjb2x1bW5JZHMudW5zaGlmdCh0aGlzLl9kYXRhc2V0SWRQcm9wTmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgY29sdW1uc1F1ZXJ5ID0gdGhpcy5idWlsZEZpbHRlclF1ZXJ5KGNvbHVtbklkcyk7XHJcbiAgICBsZXQgZ3JhcGhxbE5vZGVGaWVsZHMgPSBbXTtcclxuXHJcbiAgICBpZiAodGhpcy5fZ3JpZE9wdGlvbnMuZW5hYmxlUGFnaW5hdGlvbiAhPT0gZmFsc2UpIHtcclxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5pc1dpdGhDdXJzb3IpIHtcclxuICAgICAgICAvLyAuLi5wYWdlSW5mbyB7IGhhc05leHRQYWdlLCBlbmRDdXJzb3IgfSwgZWRnZXMgeyBjdXJzb3IsIG5vZGUgeyBfY29sdW1uc18gfSB9LCB0b3RhbENvdW50OiAxMDBcclxuICAgICAgICBjb25zdCBlZGdlc1FiID0gbmV3IFF1ZXJ5QnVpbGRlcignZWRnZXMnKTtcclxuICAgICAgICBjb25zdCBwYWdlSW5mb1FiID0gbmV3IFF1ZXJ5QnVpbGRlcigncGFnZUluZm8nKTtcclxuICAgICAgICBwYWdlSW5mb1FiLmZpbmQoJ2hhc05leHRQYWdlJywgJ2hhc1ByZXZpb3VzUGFnZScsICdlbmRDdXJzb3InLCAnc3RhcnRDdXJzb3InKTtcclxuICAgICAgICBub2Rlc1FiLmZpbmQoY29sdW1uc1F1ZXJ5KTtcclxuICAgICAgICBlZGdlc1FiLmZpbmQoWydjdXJzb3InXSk7XHJcbiAgICAgICAgZ3JhcGhxbE5vZGVGaWVsZHMgPSBbJ3RvdGFsQ291bnQnLCBub2Rlc1FiLCBwYWdlSW5mb1FiLCBlZGdlc1FiXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyAuLi5ub2RlcyB7IF9jb2x1bW5zXyB9LCB0b3RhbENvdW50OiAxMDBcclxuICAgICAgICBub2Rlc1FiLmZpbmQoY29sdW1uc1F1ZXJ5KTtcclxuICAgICAgICBncmFwaHFsTm9kZUZpZWxkcyA9IFsndG90YWxDb3VudCcsIG5vZGVzUWJdO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIGFsbCBwcm9wZXJ0aWVzIHRvIGJlIHJldHVybmVkIGJ5IHRoZSBxdWVyeVxyXG4gICAgICBkYXRhc2V0UWIuZmluZChncmFwaHFsTm9kZUZpZWxkcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBpbmNsdWRlIGFsbCBjb2x1bW5zIHRvIGJlIHJldHVybmVkXHJcbiAgICAgIGRhdGFzZXRRYi5maW5kKGNvbHVtbnNRdWVyeSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWRkIGRhdGFzZXQgZmlsdGVycywgY291bGQgYmUgUGFnaW5hdGlvbiBhbmQgU29ydGluZ0ZpbHRlcnMgYW5kL29yIEZpZWxkRmlsdGVyc1xyXG4gICAgbGV0IGRhdGFzZXRGaWx0ZXJzOiBHcmFwaHFsRGF0YXNldEZpbHRlciA9IHt9O1xyXG5cclxuICAgIC8vIG9ubHkgYWRkIHBhZ2luYXRpb24gaWYgaXQncyBlbmFibGVkIGluIHRoZSBncmlkIG9wdGlvbnNcclxuICAgIGlmICh0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVQYWdpbmF0aW9uICE9PSBmYWxzZSkge1xyXG4gICAgICBkYXRhc2V0RmlsdGVycyA9IHtcclxuICAgICAgICAuLi50aGlzLm9wdGlvbnMucGFnaW5hdGlvbk9wdGlvbnMsXHJcbiAgICAgICAgZmlyc3Q6ICgodGhpcy5vcHRpb25zLnBhZ2luYXRpb25PcHRpb25zICYmIHRoaXMub3B0aW9ucy5wYWdpbmF0aW9uT3B0aW9ucy5maXJzdCkgPyB0aGlzLm9wdGlvbnMucGFnaW5hdGlvbk9wdGlvbnMuZmlyc3QgOiAoKHRoaXMucGFnaW5hdGlvbiAmJiB0aGlzLnBhZ2luYXRpb24ucGFnZVNpemUpID8gdGhpcy5wYWdpbmF0aW9uLnBhZ2VTaXplIDogbnVsbCkpIHx8IHRoaXMuZGVmYXVsdFBhZ2luYXRpb25PcHRpb25zLmZpcnN0XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5pc1dpdGhDdXJzb3IpIHtcclxuICAgICAgICBkYXRhc2V0RmlsdGVycy5vZmZzZXQgPSAoKHRoaXMub3B0aW9ucy5wYWdpbmF0aW9uT3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMucGFnaW5hdGlvbk9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ29mZnNldCcpKSA/ICt0aGlzLm9wdGlvbnMucGFnaW5hdGlvbk9wdGlvbnNbJ29mZnNldCddIDogMCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5vcHRpb25zLnNvcnRpbmdPcHRpb25zICYmIEFycmF5LmlzQXJyYXkodGhpcy5vcHRpb25zLnNvcnRpbmdPcHRpb25zKSAmJiB0aGlzLm9wdGlvbnMuc29ydGluZ09wdGlvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAvLyBvcmRlckJ5OiBbeyBmaWVsZDp4LCBkaXJlY3Rpb246ICdBU0MnIH1dXHJcbiAgICAgIGRhdGFzZXRGaWx0ZXJzLm9yZGVyQnkgPSB0aGlzLm9wdGlvbnMuc29ydGluZ09wdGlvbnM7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5vcHRpb25zLmZpbHRlcmluZ09wdGlvbnMgJiYgQXJyYXkuaXNBcnJheSh0aGlzLm9wdGlvbnMuZmlsdGVyaW5nT3B0aW9ucykgJiYgdGhpcy5vcHRpb25zLmZpbHRlcmluZ09wdGlvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAvLyBmaWx0ZXJCeTogW3sgZmllbGQ6IGRhdGUsIG9wZXJhdG9yOiAnPicsIHZhbHVlOiAnMjAwMC0xMC0xMCcgfV1cclxuICAgICAgZGF0YXNldEZpbHRlcnMuZmlsdGVyQnkgPSB0aGlzLm9wdGlvbnMuZmlsdGVyaW5nT3B0aW9ucztcclxuICAgIH1cclxuICAgIGlmICh0aGlzLm9wdGlvbnMuYWRkTG9jYWxlSW50b1F1ZXJ5KSB7XHJcbiAgICAgIC8vIGZpcnN0OiAyMCwgLi4uIGxvY2FsZTogXCJlbi1DQVwiXHJcbiAgICAgIGRhdGFzZXRGaWx0ZXJzLmxvY2FsZSA9IHRoaXMuX2dyaWRPcHRpb25zICYmIHRoaXMuX2dyaWRPcHRpb25zLmkxOG4gJiYgdGhpcy5fZ3JpZE9wdGlvbnMuaTE4bi5jdXJyZW50TGFuZyB8fCB0aGlzLl9ncmlkT3B0aW9ucy5sb2NhbGUgfHwgJ2VuJztcclxuICAgIH1cclxuICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0cmFRdWVyeUFyZ3VtZW50cykge1xyXG4gICAgICAvLyBmaXJzdDogMjAsIC4uLiB1c2VySWQ6IDEyM1xyXG4gICAgICBmb3IgKGNvbnN0IHF1ZXJ5QXJndW1lbnQgb2YgdGhpcy5vcHRpb25zLmV4dHJhUXVlcnlBcmd1bWVudHMpIHtcclxuICAgICAgICBkYXRhc2V0RmlsdGVyc1txdWVyeUFyZ3VtZW50LmZpZWxkXSA9IHF1ZXJ5QXJndW1lbnQudmFsdWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyB3aXRoIHBhZ2luYXRpb246OiBxdWVyeSB7IHVzZXJzKGZpcnN0OiAyMCwgb2Zmc2V0OiAwLCBvcmRlckJ5OiBbXSwgZmlsdGVyQnk6IFtdKSB7IHRvdGFsQ291bnQ6IDEwMCwgbm9kZXM6IHsgX2NvbHVtbnNfIH19fVxyXG4gICAgLy8gd2l0aG91dCBwYWdpbmF0aW9uOjogcXVlcnkgeyB1c2VycyhvcmRlckJ5OiBbXSwgZmlsdGVyQnk6IFtdKSB7IF9jb2x1bW5zXyB9fVxyXG4gICAgZGF0YXNldFFiLmZpbHRlcihkYXRhc2V0RmlsdGVycyk7XHJcbiAgICBxdWVyeVFiLmZpbmQoZGF0YXNldFFiKTtcclxuXHJcbiAgICBjb25zdCBlbnVtU2VhcmNoUHJvcGVydGllcyA9IFsnZGlyZWN0aW9uOicsICdmaWVsZDonLCAnb3BlcmF0b3I6J107XHJcbiAgICByZXR1cm4gdGhpcy50cmltRG91YmxlUXVvdGVzT25FbnVtRmllbGQocXVlcnlRYi50b1N0cmluZygpLCBlbnVtU2VhcmNoUHJvcGVydGllcywgdGhpcy5vcHRpb25zLmtlZXBBcmd1bWVudEZpZWxkRG91YmxlUXVvdGVzIHx8IGZhbHNlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZyb20gYW4gaW5wdXQgYXJyYXkgb2Ygc3RyaW5ncywgd2Ugd2FudCB0byBidWlsZCBhIEdyYXBoUUwgcXVlcnkgc3RyaW5nLlxyXG4gICAqIFRoZSBwcm9jZXNzIGhhcyB0byB0YWtlIHRoZSBkb3Qgbm90YXRpb24gYW5kIHBhcnNlIGl0IGludG8gYSB2YWxpZCBHcmFwaFFMIHF1ZXJ5XHJcbiAgICogRm9sbG93aW5nIHRoaXMgU08gYW5zd2VyIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80NzcwNTQ3Ni8xMjEyMTY2XHJcbiAgICpcclxuICAgKiBJTlBVVFxyXG4gICAqICBbJ2ZpcnN0TmFtZScsICdsYXN0TmFtZScsICdiaWxsaW5nLmFkZHJlc3Muc3RyZWV0JywgJ2JpbGxpbmcuYWRkcmVzcy56aXAnXVxyXG4gICAqIE9VVFBVVFxyXG4gICAqIGZpcnN0TmFtZSwgbGFzdE5hbWUsIGJpbGxpbmd7YWRkcmVzc3tzdHJlZXQsIHppcH19XHJcbiAgICogQHBhcmFtIGlucHV0QXJyYXlcclxuICAgKi9cclxuICBidWlsZEZpbHRlclF1ZXJ5KGlucHV0QXJyYXk6IHN0cmluZ1tdKSB7XHJcblxyXG4gICAgY29uc3Qgc2V0ID0gKG86IGFueSA9IHt9LCBhOiBhbnkpID0+IHtcclxuICAgICAgY29uc3QgayA9IGEuc2hpZnQoKTtcclxuICAgICAgb1trXSA9IGEubGVuZ3RoID8gc2V0KG9ba10sIGEpIDogbnVsbDtcclxuICAgICAgcmV0dXJuIG87XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IG91dHB1dCA9IGlucHV0QXJyYXkucmVkdWNlKChvOiBhbnksIGE6IHN0cmluZykgPT4gc2V0KG8sIGEuc3BsaXQoJy4nKSksIHt9KTtcclxuXHJcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob3V0cHV0KVxyXG4gICAgICAucmVwbGFjZSgvXFxcInxcXDp8bnVsbC9nLCAnJylcclxuICAgICAgLnJlcGxhY2UoL15cXHsvLCAnJylcclxuICAgICAgLnJlcGxhY2UoL1xcfSQvLCAnJyk7XHJcbiAgfVxyXG5cclxuICBjbGVhckZpbHRlcnMoKSB7XHJcbiAgICB0aGlzLl9jdXJyZW50RmlsdGVycyA9IFtdO1xyXG4gICAgdGhpcy51cGRhdGVPcHRpb25zKHsgZmlsdGVyaW5nT3B0aW9uczogW10gfSk7XHJcbiAgfVxyXG5cclxuICBjbGVhclNvcnRlcnMoKSB7XHJcbiAgICB0aGlzLl9jdXJyZW50U29ydGVycyA9IFtdO1xyXG4gICAgdGhpcy51cGRhdGVPcHRpb25zKHsgc29ydGluZ09wdGlvbnM6IFtdIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGFuIGluaXRpYWxpemF0aW9uIG9mIFBhZ2luYXRpb24gb3B0aW9uc1xyXG4gICAqIEByZXR1cm4gUGFnaW5hdGlvbiBPcHRpb25zXHJcbiAgICovXHJcbiAgZ2V0SW5pdFBhZ2luYXRpb25PcHRpb25zKCk6IEdyYXBocWxEYXRhc2V0RmlsdGVyIHtcclxuICAgIGNvbnN0IHBhZ2luYXRpb25GaXJzdCA9IHRoaXMucGFnaW5hdGlvbiA/IHRoaXMucGFnaW5hdGlvbi5wYWdlU2l6ZSA6IERFRkFVTFRfSVRFTVNfUEVSX1BBR0U7XHJcbiAgICByZXR1cm4gKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMuaXNXaXRoQ3Vyc29yKSA/IHsgZmlyc3Q6IHBhZ2luYXRpb25GaXJzdCB9IDogeyBmaXJzdDogcGFnaW5hdGlvbkZpcnN0LCBvZmZzZXQ6IDAgfTtcclxuICB9XHJcblxyXG4gIC8qKiBHZXQgdGhlIEdyYXBoUUwgZGF0YXNldCBuYW1lICovXHJcbiAgZ2V0RGF0YXNldE5hbWUoKTogc3RyaW5nIHtcclxuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZGF0YXNldE5hbWUgfHwgJyc7XHJcbiAgfVxyXG5cclxuICAvKiogR2V0IHRoZSBGaWx0ZXJzIHRoYXQgYXJlIGN1cnJlbnRseSB1c2VkIGJ5IHRoZSBncmlkICovXHJcbiAgZ2V0Q3VycmVudEZpbHRlcnMoKTogQ29sdW1uRmlsdGVycyB8IEN1cnJlbnRGaWx0ZXJbXSB7XHJcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudEZpbHRlcnM7XHJcbiAgfVxyXG5cclxuICAvKiogR2V0IHRoZSBQYWdpbmF0aW9uIHRoYXQgaXMgY3VycmVudGx5IHVzZWQgYnkgdGhlIGdyaWQgKi9cclxuICBnZXRDdXJyZW50UGFnaW5hdGlvbigpOiBDdXJyZW50UGFnaW5hdGlvbiB7XHJcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFBhZ2luYXRpb247XHJcbiAgfVxyXG5cclxuICAvKiogR2V0IHRoZSBTb3J0ZXJzIHRoYXQgYXJlIGN1cnJlbnRseSB1c2VkIGJ5IHRoZSBncmlkICovXHJcbiAgZ2V0Q3VycmVudFNvcnRlcnMoKTogQ3VycmVudFNvcnRlcltdIHtcclxuICAgIHJldHVybiB0aGlzLl9jdXJyZW50U29ydGVycztcclxuICB9XHJcblxyXG4gIC8qXHJcbiAgICogUmVzZXQgdGhlIHBhZ2luYXRpb24gb3B0aW9uc1xyXG4gICAqL1xyXG4gIHJlc2V0UGFnaW5hdGlvbk9wdGlvbnMoKSB7XHJcbiAgICBsZXQgcGFnaW5hdGlvbk9wdGlvbnM6IEdyYXBocWxQYWdpbmF0aW9uT3B0aW9uIHwgR3JhcGhxbEN1cnNvclBhZ2luYXRpb25PcHRpb247XHJcblxyXG4gICAgaWYgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMuaXNXaXRoQ3Vyc29yKSB7XHJcbiAgICAgIC8vIGZpcnN0LCBsYXN0LCBhZnRlciwgYmVmb3JlXHJcbiAgICAgIHBhZ2luYXRpb25PcHRpb25zID0ge1xyXG4gICAgICAgIGFmdGVyOiAnJyxcclxuICAgICAgICBiZWZvcmU6IHVuZGVmaW5lZCxcclxuICAgICAgICBsYXN0OiB1bmRlZmluZWRcclxuICAgICAgfSBhcyBHcmFwaHFsQ3Vyc29yUGFnaW5hdGlvbk9wdGlvbjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIGZpcnN0LCBsYXN0LCBvZmZzZXRcclxuICAgICAgcGFnaW5hdGlvbk9wdGlvbnMgPSAoKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMucGFnaW5hdGlvbk9wdGlvbnMpIHx8IHRoaXMuZ2V0SW5pdFBhZ2luYXRpb25PcHRpb25zKCkpIGFzIEdyYXBocWxQYWdpbmF0aW9uT3B0aW9uO1xyXG4gICAgICAocGFnaW5hdGlvbk9wdGlvbnMgYXMgR3JhcGhxbFBhZ2luYXRpb25PcHRpb24pLm9mZnNldCA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc2F2ZSBjdXJyZW50IHBhZ2luYXRpb24gYXMgUGFnZSAxIGFuZCBwYWdlIHNpemUgYXMgXCJmaXJzdFwiIHNldCBzaXplXHJcbiAgICB0aGlzLl9jdXJyZW50UGFnaW5hdGlvbiA9IHtcclxuICAgICAgcGFnZU51bWJlcjogMSxcclxuICAgICAgcGFnZVNpemU6IHBhZ2luYXRpb25PcHRpb25zLmZpcnN0IHx8IERFRkFVTFRfUEFHRV9TSVpFLFxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZU9wdGlvbnMoeyBwYWdpbmF0aW9uT3B0aW9ucyB9KTtcclxuICB9XHJcblxyXG4gIHVwZGF0ZU9wdGlvbnMoc2VydmljZU9wdGlvbnM/OiBQYXJ0aWFsPEdyYXBocWxTZXJ2aWNlT3B0aW9uPikge1xyXG4gICAgdGhpcy5vcHRpb25zID0geyAuLi50aGlzLm9wdGlvbnMsIC4uLnNlcnZpY2VPcHRpb25zIH07XHJcbiAgfVxyXG5cclxuICAvKlxyXG4gICAqIEZJTFRFUklOR1xyXG4gICAqL1xyXG4gIHByb2Nlc3NPbkZpbHRlckNoYW5nZWQoZXZlbnQ6IEV2ZW50LCBhcmdzOiBGaWx0ZXJDaGFuZ2VkQXJncyk6IHN0cmluZyB7XHJcbiAgICBjb25zdCBncmlkT3B0aW9uczogR3JpZE9wdGlvbiA9IHRoaXMuX2dyaWRPcHRpb25zO1xyXG4gICAgY29uc3QgYmFja2VuZEFwaSA9IGdyaWRPcHRpb25zLmJhY2tlbmRTZXJ2aWNlQXBpO1xyXG5cclxuICAgIGlmIChiYWNrZW5kQXBpID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTb21ldGhpbmcgd2VudCB3cm9uZyBpbiB0aGUgR3JhcGhxbFNlcnZpY2UsIFwiYmFja2VuZFNlcnZpY2VBcGlcIiBpcyBub3QgaW5pdGlhbGl6ZWQnKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBrZWVwIGN1cnJlbnQgZmlsdGVycyAmIGFsd2F5cyBzYXZlIGl0IGFzIGFuIGFycmF5IChjb2x1bW5GaWx0ZXJzIGNhbiBiZSBhbiBvYmplY3Qgd2hlbiBpdCBpcyBkZWFsdCBieSBTbGlja0dyaWQgRmlsdGVyKVxyXG4gICAgdGhpcy5fY3VycmVudEZpbHRlcnMgPSB0aGlzLmNhc3RGaWx0ZXJUb0NvbHVtbkZpbHRlcnMoYXJncy5jb2x1bW5GaWx0ZXJzKTtcclxuXHJcbiAgICBpZiAoIWFyZ3MgfHwgIWFyZ3MuZ3JpZCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NvbWV0aGluZyB3ZW50IHdyb25nIHdoZW4gdHJ5aW5nIGNyZWF0ZSB0aGUgR3JhcGhRTCBCYWNrZW5kIFNlcnZpY2UsIGl0IHNlZW1zIHRoYXQgXCJhcmdzXCIgaXMgbm90IHBvcHVsYXRlZCBjb3JyZWN0bHknKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBsb29wIHRocm91Z2ggYWxsIGNvbHVtbnMgdG8gaW5zcGVjdCBmaWx0ZXJzICYgc2V0IHRoZSBxdWVyeVxyXG4gICAgdGhpcy51cGRhdGVGaWx0ZXJzKGFyZ3MuY29sdW1uRmlsdGVycywgZmFsc2UpO1xyXG5cclxuICAgIHRoaXMucmVzZXRQYWdpbmF0aW9uT3B0aW9ucygpO1xyXG4gICAgcmV0dXJuIHRoaXMuYnVpbGRRdWVyeSgpO1xyXG4gIH1cclxuXHJcbiAgLypcclxuICAgKiBQQUdJTkFUSU9OXHJcbiAgICogV2l0aCBjdXJzb3IsIHRoZSBxdWVyeSBjYW4gaGF2ZSA0IGFyZ3VtZW50cyAoZmlyc3QsIGFmdGVyLCBsYXN0LCBiZWZvcmUpLCBmb3IgZXhhbXBsZTpcclxuICAgKiAgIHVzZXJzIChmaXJzdDoyMCwgYWZ0ZXI6XCJZWEp5WVhsamIyNXVaV04wYVc5dU9qTT1cIikge1xyXG4gICAqICAgICB0b3RhbENvdW50XHJcbiAgICogICAgIHBhZ2VJbmZvIHtcclxuICAgKiAgICAgICBoYXNOZXh0UGFnZVxyXG4gICAqICAgICAgIGhhc1ByZXZpb3VzUGFnZVxyXG4gICAqICAgICAgIGVuZEN1cnNvclxyXG4gICAqICAgICAgIHN0YXJ0Q3Vyc29yXHJcbiAgICogICAgIH1cclxuICAgKiAgICAgZWRnZXMge1xyXG4gICAqICAgICAgIGN1cnNvclxyXG4gICAqICAgICAgIG5vZGUge1xyXG4gICAqICAgICAgICAgbmFtZVxyXG4gICAqICAgICAgICAgZ2VuZGVyXHJcbiAgICogICAgICAgfVxyXG4gICAqICAgICB9XHJcbiAgICogICB9XHJcbiAgICogV2l0aG91dCBjdXJzb3IsIHRoZSBxdWVyeSBjYW4gaGF2ZSAzIGFyZ3VtZW50cyAoZmlyc3QsIGxhc3QsIG9mZnNldCksIGZvciBleGFtcGxlOlxyXG4gICAqICAgdXNlcnMgKGZpcnN0OjIwLCBvZmZzZXQ6IDEwKSB7XHJcbiAgICogICAgIHRvdGFsQ291bnRcclxuICAgKiAgICAgbm9kZXMge1xyXG4gICAqICAgICAgIG5hbWVcclxuICAgKiAgICAgICBnZW5kZXJcclxuICAgKiAgICAgfVxyXG4gICAqICAgfVxyXG4gICAqL1xyXG4gIHByb2Nlc3NPblBhZ2luYXRpb25DaGFuZ2VkKGV2ZW50OiBFdmVudCwgYXJnczogUGFnaW5hdGlvbkNoYW5nZWRBcmdzKTogc3RyaW5nIHtcclxuICAgIGNvbnN0IHBhZ2VTaXplID0gKyhhcmdzLnBhZ2VTaXplIHx8ICgodGhpcy5wYWdpbmF0aW9uKSA/IHRoaXMucGFnaW5hdGlvbi5wYWdlU2l6ZSA6IERFRkFVTFRfUEFHRV9TSVpFKSk7XHJcbiAgICB0aGlzLnVwZGF0ZVBhZ2luYXRpb24oYXJncy5uZXdQYWdlLCBwYWdlU2l6ZSk7XHJcblxyXG4gICAgLy8gYnVpbGQgdGhlIEdyYXBoUUwgcXVlcnkgd2hpY2ggd2Ugd2lsbCB1c2UgaW4gdGhlIFdlYkFQSSBjYWxsYmFja1xyXG4gICAgcmV0dXJuIHRoaXMuYnVpbGRRdWVyeSgpO1xyXG4gIH1cclxuXHJcbiAgLypcclxuICAgKiBTT1JUSU5HXHJcbiAgICogd2Ugd2lsbCB1c2Ugc29ydGluZyBhcyBwZXIgYSBGYWNlYm9vayBzdWdnZXN0aW9uIG9uIGEgR2l0aHViIGlzc3VlICh3aXRoIHNvbWUgc21hbGwgY2hhbmdlcylcclxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vZ3JhcGhxbC9ncmFwaHFsLXJlbGF5LWpzL2lzc3Vlcy8yMCNpc3N1ZWNvbW1lbnQtMjIwNDk0MjIyXHJcbiAgICpcclxuICAgKiAgdXNlcnMgKGZpcnN0OiAyMCwgb2Zmc2V0OiAxMCwgb3JkZXJCeTogW3tmaWVsZDogbGFzdE5hbWUsIGRpcmVjdGlvbjogQVNDfSwge2ZpZWxkOiBmaXJzdE5hbWUsIGRpcmVjdGlvbjogREVTQ31dKSB7XHJcbiAgICogICAgdG90YWxDb3VudFxyXG4gICAqICAgIG5vZGVzIHtcclxuICAgKiAgICAgIG5hbWVcclxuICAgKiAgICAgIGdlbmRlclxyXG4gICAqICAgIH1cclxuICAgKiAgfVxyXG4gICAqL1xyXG4gIC8vIEBkZXByZWNhdGVkIG5vdGUsIHdlIHNob3VsZCByZW1vdmUgXCJTb3J0Q2hhbmdlZEFyZ3NcIiBhbmQgb25seSB1c2U6IENvbHVtblNvcnQgfCBNdWx0aUNvbHVtblNvcnRcclxuICBwcm9jZXNzT25Tb3J0Q2hhbmdlZChldmVudDogRXZlbnQsIGFyZ3M6IFNvcnRDaGFuZ2VkQXJncyB8IENvbHVtblNvcnQgfCBNdWx0aUNvbHVtblNvcnQpOiBzdHJpbmcge1xyXG4gICAgY29uc3Qgc29ydENvbHVtbnMgPSAoYXJncy5tdWx0aUNvbHVtblNvcnQpID8gKGFyZ3MgYXMgTXVsdGlDb2x1bW5Tb3J0KS5zb3J0Q29scyA6IG5ldyBBcnJheSh7IHNvcnRDb2w6IChhcmdzIGFzIENvbHVtblNvcnQpLnNvcnRDb2wsIHNvcnRBc2M6IChhcmdzIGFzIENvbHVtblNvcnQpLnNvcnRBc2MgfSk7XHJcblxyXG4gICAgLy8gbG9vcCB0aHJvdWdoIGFsbCBjb2x1bW5zIHRvIGluc3BlY3Qgc29ydGVycyAmIHNldCB0aGUgcXVlcnlcclxuICAgIHRoaXMudXBkYXRlU29ydGVycyhzb3J0Q29sdW1ucyk7XHJcblxyXG4gICAgLy8gYnVpbGQgdGhlIEdyYXBoUUwgcXVlcnkgd2hpY2ggd2Ugd2lsbCB1c2UgaW4gdGhlIFdlYkFQSSBjYWxsYmFja1xyXG4gICAgcmV0dXJuIHRoaXMuYnVpbGRRdWVyeSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogbG9vcCB0aHJvdWdoIGFsbCBjb2x1bW5zIHRvIGluc3BlY3QgZmlsdGVycyAmIHVwZGF0ZSBiYWNrZW5kIHNlcnZpY2UgZmlsdGVyaW5nT3B0aW9uc1xyXG4gICAqIEBwYXJhbSBjb2x1bW5GaWx0ZXJzXHJcbiAgICovXHJcbiAgdXBkYXRlRmlsdGVycyhjb2x1bW5GaWx0ZXJzOiBDb2x1bW5GaWx0ZXJzIHwgQ3VycmVudEZpbHRlcltdLCBpc1VwZGF0ZWRCeVByZXNldE9yRHluYW1pY2FsbHk6IGJvb2xlYW4pIHtcclxuICAgIGNvbnN0IHNlYXJjaEJ5QXJyYXk6IEdyYXBocWxGaWx0ZXJpbmdPcHRpb25bXSA9IFtdO1xyXG4gICAgbGV0IHNlYXJjaFZhbHVlOiBzdHJpbmcgfCBzdHJpbmdbXTtcclxuXHJcbiAgICAvLyBvbiBmaWx0ZXIgcHJlc2V0IGxvYWQsIHdlIG5lZWQgdG8ga2VlcCBjdXJyZW50IGZpbHRlcnNcclxuICAgIGlmIChpc1VwZGF0ZWRCeVByZXNldE9yRHluYW1pY2FsbHkpIHtcclxuICAgICAgdGhpcy5fY3VycmVudEZpbHRlcnMgPSB0aGlzLmNhc3RGaWx0ZXJUb0NvbHVtbkZpbHRlcnMoY29sdW1uRmlsdGVycyk7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChjb25zdCBjb2x1bW5JZCBpbiBjb2x1bW5GaWx0ZXJzKSB7XHJcbiAgICAgIGlmIChjb2x1bW5GaWx0ZXJzLmhhc093blByb3BlcnR5KGNvbHVtbklkKSkge1xyXG4gICAgICAgIGNvbnN0IGNvbHVtbkZpbHRlciA9IGNvbHVtbkZpbHRlcnNbY29sdW1uSWRdO1xyXG5cclxuICAgICAgICAvLyBpZiB1c2VyIGRlZmluZWQgc29tZSBcInByZXNldHNcIiwgdGhlbiB3ZSBuZWVkIHRvIGZpbmQgdGhlIGZpbHRlcnMgZnJvbSB0aGUgY29sdW1uIGRlZmluaXRpb25zIGluc3RlYWRcclxuICAgICAgICBsZXQgY29sdW1uRGVmOiBDb2x1bW4gfCB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKGlzVXBkYXRlZEJ5UHJlc2V0T3JEeW5hbWljYWxseSAmJiBBcnJheS5pc0FycmF5KHRoaXMuX2NvbHVtbkRlZmluaXRpb25zKSkge1xyXG4gICAgICAgICAgY29sdW1uRGVmID0gdGhpcy5fY29sdW1uRGVmaW5pdGlvbnMuZmluZCgoY29sdW1uOiBDb2x1bW4pID0+IGNvbHVtbi5pZCA9PT0gY29sdW1uRmlsdGVyLmNvbHVtbklkKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY29sdW1uRGVmID0gY29sdW1uRmlsdGVyLmNvbHVtbkRlZjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFjb2x1bW5EZWYpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignW0dyYXBoUUwgU2VydmljZV06IFNvbWV0aGluZyB3ZW50IHdyb25nIGluIHRyeWluZyB0byBnZXQgdGhlIGNvbHVtbiBkZWZpbml0aW9uIG9mIHRoZSBzcGVjaWZpZWQgZmlsdGVyIChvciBwcmVzZXQgZmlsdGVycykuIERpZCB5b3UgbWFrZSBhIHR5cG8gb24gdGhlIGZpbHRlciBjb2x1bW5JZD8nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGZpZWxkTmFtZSA9IChjb2x1bW5EZWYuZmlsdGVyICYmIGNvbHVtbkRlZi5maWx0ZXIucXVlcnlGaWVsZCkgfHwgY29sdW1uRGVmLnF1ZXJ5RmllbGRGaWx0ZXIgfHwgY29sdW1uRGVmLnF1ZXJ5RmllbGQgfHwgY29sdW1uRGVmLmZpZWxkIHx8IGNvbHVtbkRlZi5uYW1lIHx8ICcnO1xyXG4gICAgICAgIGxldCBzZWFyY2hUZXJtcyA9IGNvbHVtbkZpbHRlciAmJiBjb2x1bW5GaWx0ZXIuc2VhcmNoVGVybXMgfHwgW107XHJcbiAgICAgICAgbGV0IGZpZWxkU2VhcmNoVmFsdWUgPSAoQXJyYXkuaXNBcnJheShzZWFyY2hUZXJtcykgJiYgc2VhcmNoVGVybXMubGVuZ3RoID09PSAxKSA/IHNlYXJjaFRlcm1zWzBdIDogJyc7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZFNlYXJjaFZhbHVlID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgZmllbGRTZWFyY2hWYWx1ZSA9ICcnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFmaWVsZE5hbWUpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgR3JhcGhRTCBmaWx0ZXIgY291bGQgbm90IGZpbmQgdGhlIGZpZWxkIG5hbWUgdG8gcXVlcnkgdGhlIHNlYXJjaCwgeW91ciBjb2x1bW4gZGVmaW5pdGlvbiBtdXN0IGluY2x1ZGUgYSB2YWxpZCBcImZpZWxkXCIgb3IgXCJuYW1lXCIgKG9wdGlvbmFsbHkgeW91IGNhbiBhbHNvIHVzZSB0aGUgXCJxdWVyeWZpZWxkXCIpLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZmllbGRTZWFyY2hWYWx1ZSA9ICcnICsgZmllbGRTZWFyY2hWYWx1ZTsgLy8gbWFrZSBzdXJlIGl0J3MgYSBzdHJpbmdcclxuICAgICAgICBjb25zdCBtYXRjaGVzID0gZmllbGRTZWFyY2hWYWx1ZS5tYXRjaCgvXihbPD4hPVxcKl17MCwyfSkoLipbXjw+IT1cXCpdKShbXFwqXT8pJC8pOyAvLyBncm91cCAxOiBPcGVyYXRvciwgMjogc2VhcmNoVmFsdWUsIDM6IGxhc3QgY2hhciBpcyAnKicgKG1lYW5pbmcgc3RhcnRzIHdpdGgsIGV4LjogYWJjKilcclxuICAgICAgICBsZXQgb3BlcmF0b3IgPSBjb2x1bW5GaWx0ZXIub3BlcmF0b3IgfHwgKChtYXRjaGVzKSA/IG1hdGNoZXNbMV0gOiAnJyk7XHJcbiAgICAgICAgc2VhcmNoVmFsdWUgPSAoISFtYXRjaGVzKSA/IG1hdGNoZXNbMl0gOiAnJztcclxuICAgICAgICBjb25zdCBsYXN0VmFsdWVDaGFyID0gKCEhbWF0Y2hlcykgPyBtYXRjaGVzWzNdIDogKG9wZXJhdG9yID09PSAnKnonID8gJyonIDogJycpO1xyXG5cclxuICAgICAgICAvLyBubyBuZWVkIHRvIHF1ZXJ5IGlmIHNlYXJjaCB2YWx1ZSBpcyBlbXB0eVxyXG4gICAgICAgIGlmIChmaWVsZE5hbWUgJiYgc2VhcmNoVmFsdWUgPT09ICcnICYmIHNlYXJjaFRlcm1zLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzZWFyY2hUZXJtcykgJiYgc2VhcmNoVGVybXMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBzZWFyY2hUZXJtc1swXSA9PT0gJ3N0cmluZycgJiYgc2VhcmNoVGVybXNbMF0uaW5kZXhPZignLi4nKSA+IDApIHtcclxuICAgICAgICAgIHNlYXJjaFRlcm1zID0gc2VhcmNoVGVybXNbMF0uc3BsaXQoJy4uJyk7XHJcbiAgICAgICAgICBpZiAoIW9wZXJhdG9yKSB7XHJcbiAgICAgICAgICAgIG9wZXJhdG9yID0gT3BlcmF0b3JUeXBlLnJhbmdlRXhjbHVzaXZlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBzZWFyY2hWYWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgIC8vIGVzY2FwaW5nIHRoZSBzZWFyY2ggdmFsdWVcclxuICAgICAgICAgIHNlYXJjaFZhbHVlID0gc2VhcmNoVmFsdWUucmVwbGFjZShgJ2AsIGAnJ2ApOyAvLyBlc2NhcGUgc2luZ2xlIHF1b3RlcyBieSBkb3VibGluZyB0aGVtXHJcbiAgICAgICAgICBpZiAob3BlcmF0b3IgPT09ICcqJyB8fCBvcGVyYXRvciA9PT0gJ2EqJyB8fCBvcGVyYXRvciA9PT0gJyp6JyB8fCBsYXN0VmFsdWVDaGFyID09PSAnKicpIHtcclxuICAgICAgICAgICAgb3BlcmF0b3IgPSAoKG9wZXJhdG9yID09PSAnKicgfHwgb3BlcmF0b3IgPT09ICcqeicpID8gJ0VuZHNXaXRoJyA6ICdTdGFydHNXaXRoJykgYXMgT3BlcmF0b3JTdHJpbmc7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgZmluZCBhbiBPcGVyYXRvciBidXQgd2UgaGF2ZSBhIENvbHVtbiBPcGVyYXRvciBpbnNpZGUgdGhlIEZpbHRlciAoRE9NIEVsZW1lbnQpLCB3ZSBzaG91bGQgdXNlIGl0cyBkZWZhdWx0IE9wZXJhdG9yXHJcbiAgICAgICAgLy8gbXVsdGlwbGVTZWxlY3QgaXMgXCJJTlwiLCB3aGlsZSBzaW5nbGVTZWxlY3QgaXMgXCJFUVwiLCBlbHNlIGRvbid0IG1hcCBhbnkgb3BlcmF0b3JcclxuICAgICAgICBpZiAoIW9wZXJhdG9yICYmIGNvbHVtbkRlZi5maWx0ZXIpIHtcclxuICAgICAgICAgIG9wZXJhdG9yID0gY29sdW1uRGVmLmZpbHRlci5vcGVyYXRvcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHdoZW4gaGF2aW5nIG1vcmUgdGhhbiAxIHNlYXJjaCB0ZXJtICh3ZSBuZWVkIHRvIGNyZWF0ZSBhIENTViBzdHJpbmcgZm9yIEdyYXBoUUwgXCJJTlwiIG9yIFwiTk9UIElOXCIgZmlsdGVyIHNlYXJjaClcclxuICAgICAgICBpZiAoc2VhcmNoVGVybXMgJiYgc2VhcmNoVGVybXMubGVuZ3RoID4gMSAmJiAob3BlcmF0b3IgPT09ICdJTicgfHwgb3BlcmF0b3IgPT09ICdOSU4nIHx8IG9wZXJhdG9yID09PSAnTk9USU4nIHx8IG9wZXJhdG9yID09PSAnTk9UIElOJyB8fCBvcGVyYXRvciA9PT0gJ05PVF9JTicpKSB7XHJcbiAgICAgICAgICBzZWFyY2hWYWx1ZSA9IHNlYXJjaFRlcm1zLmpvaW4oJywnKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHNlYXJjaFRlcm1zICYmIHNlYXJjaFRlcm1zLmxlbmd0aCA9PT0gMiAmJiAoIW9wZXJhdG9yIHx8IG9wZXJhdG9yID09PSBPcGVyYXRvclR5cGUucmFuZ2VFeGNsdXNpdmUgfHwgb3BlcmF0b3IgPT09IE9wZXJhdG9yVHlwZS5yYW5nZUluY2x1c2l2ZSkpIHtcclxuICAgICAgICAgIGlmICghb3BlcmF0b3IpIHtcclxuICAgICAgICAgICAgb3BlcmF0b3IgPSBPcGVyYXRvclR5cGUucmFuZ2VFeGNsdXNpdmU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBzZWFyY2hCeUFycmF5LnB1c2goeyBmaWVsZDogZmllbGROYW1lLCBvcGVyYXRvcjogKG9wZXJhdG9yID09PSBPcGVyYXRvclR5cGUucmFuZ2VJbmNsdXNpdmUgPyAnR0UnIDogJ0dUJyksIHZhbHVlOiBzZWFyY2hUZXJtc1swXSB9KTtcclxuICAgICAgICAgIHNlYXJjaEJ5QXJyYXkucHVzaCh7IGZpZWxkOiBmaWVsZE5hbWUsIG9wZXJhdG9yOiAob3BlcmF0b3IgPT09IE9wZXJhdG9yVHlwZS5yYW5nZUluY2x1c2l2ZSA/ICdMRScgOiAnTFQnKSwgdmFsdWU6IHNlYXJjaFRlcm1zWzFdIH0pO1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBpZiB3ZSBzdGlsbCBkb24ndCBoYXZlIGFuIG9wZXJhdG9yIGZpbmQgdGhlIHByb3BlciBPcGVyYXRvciB0byB1c2UgYnkgaXQncyBmaWVsZCB0eXBlXHJcbiAgICAgICAgaWYgKCFvcGVyYXRvcikge1xyXG4gICAgICAgICAgb3BlcmF0b3IgPSBtYXBPcGVyYXRvckJ5RmllbGRUeXBlKGNvbHVtbkRlZi50eXBlIHx8IEZpZWxkVHlwZS5zdHJpbmcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gYnVpbGQgdGhlIHNlYXJjaCBhcnJheVxyXG4gICAgICAgIHNlYXJjaEJ5QXJyYXkucHVzaCh7IGZpZWxkOiBmaWVsZE5hbWUsIG9wZXJhdG9yOiBtYXBPcGVyYXRvclR5cGUob3BlcmF0b3IpLCB2YWx1ZTogc2VhcmNoVmFsdWUgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyB1cGRhdGUgdGhlIHNlcnZpY2Ugb3B0aW9ucyB3aXRoIGZpbHRlcnMgZm9yIHRoZSBidWlsZFF1ZXJ5KCkgdG8gd29yayBsYXRlclxyXG4gICAgdGhpcy51cGRhdGVPcHRpb25zKHsgZmlsdGVyaW5nT3B0aW9uczogc2VhcmNoQnlBcnJheSB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSB0aGUgcGFnaW5hdGlvbiBjb21wb25lbnQgd2l0aCBpdCdzIG5ldyBwYWdlIG51bWJlciBhbmQgc2l6ZVxyXG4gICAqIEBwYXJhbSBuZXdQYWdlXHJcbiAgICogQHBhcmFtIHBhZ2VTaXplXHJcbiAgICovXHJcbiAgdXBkYXRlUGFnaW5hdGlvbihuZXdQYWdlOiBudW1iZXIsIHBhZ2VTaXplOiBudW1iZXIpIHtcclxuICAgIHRoaXMuX2N1cnJlbnRQYWdpbmF0aW9uID0ge1xyXG4gICAgICBwYWdlTnVtYmVyOiBuZXdQYWdlLFxyXG4gICAgICBwYWdlU2l6ZSxcclxuICAgIH07XHJcblxyXG4gICAgbGV0IHBhZ2luYXRpb25PcHRpb25zO1xyXG4gICAgaWYgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMuaXNXaXRoQ3Vyc29yKSB7XHJcbiAgICAgIHBhZ2luYXRpb25PcHRpb25zID0ge1xyXG4gICAgICAgIGZpcnN0OiBwYWdlU2l6ZVxyXG4gICAgICB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcGFnaW5hdGlvbk9wdGlvbnMgPSB7XHJcbiAgICAgICAgZmlyc3Q6IHBhZ2VTaXplLFxyXG4gICAgICAgIG9mZnNldDogKG5ld1BhZ2UgPiAxKSA/ICgobmV3UGFnZSAtIDEpICogcGFnZVNpemUpIDogMCAvLyByZWNhbGN1bGF0ZSBvZmZzZXQgYnV0IG1ha2Ugc3VyZSB0aGUgcmVzdWx0IGlzIGFsd2F5cyBvdmVyIDBcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB1bmxlc3MgdXNlciBzcGVjaWZpY2FsbHkgc2V0IFwiZW5hYmxlUGFnaW5hdGlvblwiIHRvIEZhbHNlLCB3ZSdsbCB1cGRhdGUgcGFnaW5hdGlvbiBvcHRpb25zIGluIGV2ZXJ5IG90aGVyIGNhc2VzXHJcbiAgICBpZiAodGhpcy5fZ3JpZE9wdGlvbnMgJiYgKHRoaXMuX2dyaWRPcHRpb25zLmVuYWJsZVBhZ2luYXRpb24gfHwgIXRoaXMuX2dyaWRPcHRpb25zLmhhc093blByb3BlcnR5KCdlbmFibGVQYWdpbmF0aW9uJykpKSB7XHJcbiAgICAgIHRoaXMudXBkYXRlT3B0aW9ucyh7IHBhZ2luYXRpb25PcHRpb25zIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogbG9vcCB0aHJvdWdoIGFsbCBjb2x1bW5zIHRvIGluc3BlY3Qgc29ydGVycyAmIHVwZGF0ZSBiYWNrZW5kIHNlcnZpY2Ugc29ydGluZ09wdGlvbnNcclxuICAgKiBAcGFyYW0gY29sdW1uRmlsdGVyc1xyXG4gICAqL1xyXG4gIHVwZGF0ZVNvcnRlcnMoc29ydENvbHVtbnM/OiBDb2x1bW5Tb3J0W10sIHByZXNldFNvcnRlcnM/OiBDdXJyZW50U29ydGVyW10pIHtcclxuICAgIGxldCBjdXJyZW50U29ydGVyczogQ3VycmVudFNvcnRlcltdID0gW107XHJcbiAgICBjb25zdCBncmFwaHFsU29ydGVyczogR3JhcGhxbFNvcnRpbmdPcHRpb25bXSA9IFtdO1xyXG5cclxuICAgIGlmICghc29ydENvbHVtbnMgJiYgcHJlc2V0U29ydGVycykge1xyXG4gICAgICAvLyBtYWtlIHRoZSBwcmVzZXRzIHRoZSBjdXJyZW50IHNvcnRlcnMsIGFsc28gbWFrZSBzdXJlIHRoYXQgYWxsIGRpcmVjdGlvbiBhcmUgaW4gdXBwZXJjYXNlIGZvciBHcmFwaFFMXHJcbiAgICAgIGN1cnJlbnRTb3J0ZXJzID0gcHJlc2V0U29ydGVycztcclxuICAgICAgY3VycmVudFNvcnRlcnMuZm9yRWFjaCgoc29ydGVyKSA9PiBzb3J0ZXIuZGlyZWN0aW9uID0gc29ydGVyLmRpcmVjdGlvbi50b1VwcGVyQ2FzZSgpIGFzIFNvcnREaXJlY3Rpb25TdHJpbmcpO1xyXG5cclxuICAgICAgLy8gZGlzcGxheSB0aGUgY29ycmVjdCBzb3J0aW5nIGljb25zIG9uIHRoZSBVSSwgZm9yIHRoYXQgaXQgcmVxdWlyZXMgKGNvbHVtbklkLCBzb3J0QXNjKSBwcm9wZXJ0aWVzXHJcbiAgICAgIGNvbnN0IHRtcFNvcnRlckFycmF5ID0gY3VycmVudFNvcnRlcnMubWFwKChzb3J0ZXIpID0+IHtcclxuICAgICAgICBjb25zdCBjb2x1bW5EZWYgPSB0aGlzLl9jb2x1bW5EZWZpbml0aW9ucy5maW5kKChjb2x1bW46IENvbHVtbikgPT4gY29sdW1uLmlkID09PSBzb3J0ZXIuY29sdW1uSWQpO1xyXG5cclxuICAgICAgICBncmFwaHFsU29ydGVycy5wdXNoKHtcclxuICAgICAgICAgIGZpZWxkOiBjb2x1bW5EZWYgPyAoKGNvbHVtbkRlZi5xdWVyeUZpZWxkU29ydGVyIHx8IGNvbHVtbkRlZi5xdWVyeUZpZWxkIHx8IGNvbHVtbkRlZi5maWVsZCkgKyAnJykgOiAoc29ydGVyLmNvbHVtbklkICsgJycpLFxyXG4gICAgICAgICAgZGlyZWN0aW9uOiBzb3J0ZXIuZGlyZWN0aW9uXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIHJldHVybiBvbmx5IHRoZSBjb2x1bW4ocykgZm91bmQgaW4gdGhlIENvbHVtbiBEZWZpbml0aW9ucyBFTFNFIG51bGxcclxuICAgICAgICBpZiAoY29sdW1uRGVmKSB7XHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjb2x1bW5JZDogc29ydGVyLmNvbHVtbklkLFxyXG4gICAgICAgICAgICBzb3J0QXNjOiBzb3J0ZXIuZGlyZWN0aW9uLnRvVXBwZXJDYXNlKCkgPT09IFNvcnREaXJlY3Rpb24uQVNDXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBzZXQgdGhlIHNvcnQgaWNvbnMsIGJ1dCBhbHNvIG1ha2Ugc3VyZSB0byBmaWx0ZXIgb3V0IG51bGwgdmFsdWVzICh0aGF0IGhhcHBlbnMgd2hlbiBjb2x1bW5EZWYgaXMgbm90IGZvdW5kKVxyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0bXBTb3J0ZXJBcnJheSkpIHtcclxuICAgICAgICB0aGlzLl9ncmlkLnNldFNvcnRDb2x1bW5zKHRtcFNvcnRlckFycmF5LmZpbHRlcigoc29ydGVyKSA9PiBzb3J0ZXIpKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChzb3J0Q29sdW1ucyAmJiAhcHJlc2V0U29ydGVycykge1xyXG4gICAgICAvLyBidWlsZCB0aGUgb3JkZXJCeSBhcnJheSwgaXQgY291bGQgYmUgbXVsdGlzb3J0LCBleGFtcGxlXHJcbiAgICAgIC8vIG9yZGVyQnk6W3tmaWVsZDogbGFzdE5hbWUsIGRpcmVjdGlvbjogQVNDfSwge2ZpZWxkOiBmaXJzdE5hbWUsIGRpcmVjdGlvbjogREVTQ31dXHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNvcnRDb2x1bW5zKSAmJiBzb3J0Q29sdW1ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBjb2x1bW4gb2Ygc29ydENvbHVtbnMpIHtcclxuICAgICAgICAgIGlmIChjb2x1bW4gJiYgY29sdW1uLnNvcnRDb2wpIHtcclxuICAgICAgICAgICAgY3VycmVudFNvcnRlcnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgY29sdW1uSWQ6IGNvbHVtbi5zb3J0Q29sLmlkICsgJycsXHJcbiAgICAgICAgICAgICAgZGlyZWN0aW9uOiBjb2x1bW4uc29ydEFzYyA/IFNvcnREaXJlY3Rpb24uQVNDIDogU29ydERpcmVjdGlvbi5ERVNDXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgZmllbGROYW1lID0gKGNvbHVtbi5zb3J0Q29sLnF1ZXJ5RmllbGRTb3J0ZXIgfHwgY29sdW1uLnNvcnRDb2wucXVlcnlGaWVsZCB8fCBjb2x1bW4uc29ydENvbC5maWVsZCB8fCAnJykgKyAnJztcclxuICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSkge1xyXG4gICAgICAgICAgICAgIGdyYXBocWxTb3J0ZXJzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgZmllbGQ6IGZpZWxkTmFtZSxcclxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogY29sdW1uLnNvcnRBc2MgPyBTb3J0RGlyZWN0aW9uLkFTQyA6IFNvcnREaXJlY3Rpb24uREVTQ1xyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8ga2VlcCBjdXJyZW50IFNvcnRlcnMgYW5kIHVwZGF0ZSB0aGUgc2VydmljZSBvcHRpb25zIHdpdGggdGhlIG5ldyBzb3J0aW5nXHJcbiAgICB0aGlzLl9jdXJyZW50U29ydGVycyA9IGN1cnJlbnRTb3J0ZXJzO1xyXG4gICAgdGhpcy51cGRhdGVPcHRpb25zKHsgc29ydGluZ09wdGlvbnM6IGdyYXBocWxTb3J0ZXJzIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQSBmdW5jdGlvbiB3aGljaCB0YWtlcyBhbiBpbnB1dCBzdHJpbmcgYW5kIHJlbW92ZXMgZG91YmxlIHF1b3RlcyBvbmx5XHJcbiAgICogb24gY2VydGFpbiBmaWVsZHMgYXJlIGlkZW50aWZpZWQgYXMgR3JhcGhRTCBlbnVtcyAoZXhjZXB0IGZpZWxkcyB3aXRoIGRvdCBub3RhdGlvbilcclxuICAgKiBGb3IgZXhhbXBsZSBsZXQgc2F5IHdlIGlkZW50aWZpZWQgKFwiZGlyZWN0aW9uOlwiLCBcInNvcnRcIikgYXMgd29yZCB3aGljaCBhcmUgR3JhcGhRTCBlbnVtIGZpZWxkc1xyXG4gICAqIHRoZW4gdGhlIHJlc3VsdCB3aWxsIGJlOlxyXG4gICAqIEZST01cclxuICAgKiBxdWVyeSB7IHVzZXJzIChvcmRlckJ5Olt7ZmllbGQ6XCJmaXJzdE5hbWVcIiwgZGlyZWN0aW9uOlwiQVNDXCJ9IH1dKSB9XHJcbiAgICogVE9cclxuICAgKiBxdWVyeSB7IHVzZXJzIChvcmRlckJ5Olt7ZmllbGQ6IGZpcnN0TmFtZSwgZGlyZWN0aW9uOiBBU0N9fSl9XHJcbiAgICpcclxuICAgKiBFWENFUFRJT05TIChmaWVsZHMgd2l0aCBkb3Qgbm90YXRpb24gXCIuXCIgd2hpY2ggYXJlIGluc2lkZSBhIFwiZmllbGQ6XCIpXHJcbiAgICogdGhlc2UgZmllbGRzIHdpbGwga2VlcCBkb3VibGUgcXVvdGVzIHdoaWxlIGV2ZXJ5dGhpbmcgZWxzZSB3aWxsIGJlIHN0cmlwcGVkIG9mIGRvdWJsZSBxdW90ZXNcclxuICAgKiBxdWVyeSB7IHVzZXJzIChvcmRlckJ5Olt7ZmllbGQ6XCJiaWxsaW5nLnN0cmVldC5uYW1lXCIsIGRpcmVjdGlvbjogXCJBU0NcIn0gfVxyXG4gICAqIFRPXHJcbiAgICogcXVlcnkgeyB1c2VycyAob3JkZXJCeTpbe2ZpZWxkOlwiYmlsbGluZy5zdHJlZXQubmFtZVwiLCBkaXJlY3Rpb246IEFTQ319XHJcbiAgICogQHBhcmFtIGlucHV0U3RyIGlucHV0IHN0cmluZ1xyXG4gICAqIEBwYXJhbSBlbnVtU2VhcmNoV29yZHMgYXJyYXkgb2YgZW51bSB3b3JkcyB0byBmaWx0ZXJcclxuICAgKiBAcmV0dXJucyBvdXRwdXRTdHIgb3V0cHV0IHN0cmluZ1xyXG4gICAqL1xyXG4gIHRyaW1Eb3VibGVRdW90ZXNPbkVudW1GaWVsZChpbnB1dFN0cjogc3RyaW5nLCBlbnVtU2VhcmNoV29yZHM6IHN0cmluZ1tdLCBrZWVwQXJndW1lbnRGaWVsZERvdWJsZVF1b3RlczogYm9vbGVhbikge1xyXG4gICAgY29uc3QgcGF0dGVybldvcmRJblF1b3RlcyA9IGBcXHM/KChmaWVsZDpcXHMqKT9cIi4qP1wiKWA7XHJcbiAgICBsZXQgcGF0dGVyblJlZ2V4ID0gZW51bVNlYXJjaFdvcmRzLmpvaW4ocGF0dGVybldvcmRJblF1b3RlcyArICd8Jyk7XHJcbiAgICBwYXR0ZXJuUmVnZXggKz0gcGF0dGVybldvcmRJblF1b3RlczsgLy8gdGhlIGxhc3Qgb25lIHNob3VsZCBhbHNvIGhhdmUgdGhlIHBhdHRlcm4gYnV0IHdpdGhvdXQgdGhlIHBpcGUgXCJ8XCJcclxuICAgIC8vIGV4YW1wbGUgd2l0aCAoZmllbGQ6ICYgZGlyZWN0aW9uOik6ICAvZmllbGQ6cz8oXCIuKj9cIil8ZGlyZWN0aW9uOnM/KFwiLio/XCIpL1xyXG4gICAgY29uc3QgcmVnID0gbmV3IFJlZ0V4cChwYXR0ZXJuUmVnZXgsICdnJyk7XHJcblxyXG4gICAgcmV0dXJuIGlucHV0U3RyLnJlcGxhY2UocmVnLCAoZ3JvdXAxLCBncm91cDIsIGdyb3VwMykgPT4ge1xyXG4gICAgICAvLyByZW1vdmUgZG91YmxlIHF1b3RlcyBleGNlcHQgd2hlbiB0aGUgc3RyaW5nIHN0YXJ0cyB3aXRoIGEgXCJmaWVsZDpcIlxyXG4gICAgICBsZXQgcmVtb3ZlRG91YmxlUXVvdGVzID0gdHJ1ZTtcclxuICAgICAgaWYgKGdyb3VwMS5zdGFydHNXaXRoKCdmaWVsZDonKSAmJiBrZWVwQXJndW1lbnRGaWVsZERvdWJsZVF1b3Rlcykge1xyXG4gICAgICAgIHJlbW92ZURvdWJsZVF1b3RlcyA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHJlcCA9IHJlbW92ZURvdWJsZVF1b3RlcyA/IGdyb3VwMS5yZXBsYWNlKC9cIi9nLCAnJykgOiBncm91cDE7XHJcbiAgICAgIHJldHVybiByZXA7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vXHJcbiAgLy8gcHJpdmF0ZSBmdW5jdGlvbnNcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLyoqXHJcbiAgICogQ2FzdCBwcm92aWRlZCBmaWx0ZXJzIChjb3VsZCBiZSBpbiBtdWx0aXBsZSBmb3JtYXRzKSBpbnRvIGFuIGFycmF5IG9mIEN1cnJlbnRGaWx0ZXJcclxuICAgKiBAcGFyYW0gY29sdW1uRmlsdGVyc1xyXG4gICAqL1xyXG4gIHByaXZhdGUgY2FzdEZpbHRlclRvQ29sdW1uRmlsdGVycyhjb2x1bW5GaWx0ZXJzOiBDb2x1bW5GaWx0ZXJzIHwgQ3VycmVudEZpbHRlcltdKTogQ3VycmVudEZpbHRlcltdIHtcclxuICAgIC8vIGtlZXAgY3VycmVudCBmaWx0ZXJzICYgYWx3YXlzIHNhdmUgaXQgYXMgYW4gYXJyYXkgKGNvbHVtbkZpbHRlcnMgY2FuIGJlIGFuIG9iamVjdCB3aGVuIGl0IGlzIGRlYWx0IGJ5IFNsaWNrR3JpZCBGaWx0ZXIpXHJcbiAgICBjb25zdCBmaWx0ZXJzQXJyYXk6IENvbHVtbkZpbHRlcltdID0gKHR5cGVvZiBjb2x1bW5GaWx0ZXJzID09PSAnb2JqZWN0JykgPyBPYmplY3Qua2V5cyhjb2x1bW5GaWx0ZXJzKS5tYXAoa2V5ID0+IGNvbHVtbkZpbHRlcnNba2V5XSkgOiBjb2x1bW5GaWx0ZXJzO1xyXG5cclxuICAgIGlmICghQXJyYXkuaXNBcnJheShmaWx0ZXJzQXJyYXkpKSB7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmlsdGVyc0FycmF5Lm1hcCgoZmlsdGVyKSA9PiB7XHJcbiAgICAgIGNvbnN0IHRtcEZpbHRlcjogQ3VycmVudEZpbHRlciA9IHsgY29sdW1uSWQ6IGZpbHRlci5jb2x1bW5JZCB8fCAnJyB9O1xyXG4gICAgICBpZiAoZmlsdGVyLm9wZXJhdG9yKSB7XHJcbiAgICAgICAgdG1wRmlsdGVyLm9wZXJhdG9yID0gZmlsdGVyLm9wZXJhdG9yO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpbHRlci5zZWFyY2hUZXJtcykpIHtcclxuICAgICAgICB0bXBGaWx0ZXIuc2VhcmNoVGVybXMgPSBmaWx0ZXIuc2VhcmNoVGVybXM7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRtcEZpbHRlcjtcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG4iXX0=