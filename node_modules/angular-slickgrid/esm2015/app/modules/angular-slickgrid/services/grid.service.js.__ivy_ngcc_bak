import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import { Subject } from 'rxjs';
import { ExtensionService } from './extension.service';
import { FilterService } from './filter.service';
import { GridStateService } from './gridState.service';
import { SharedService } from './shared.service';
import { SortService } from './sort.service';
import { arrayRemoveItemByIndex } from './utilities';
let highlightTimerEnd;
const GridServiceDeleteOptionDefaults = { triggerEvent: true };
const GridServiceInsertOptionDefaults = { highlightRow: true, position: 'top', resortGrid: false, selectRow: false, triggerEvent: true };
const GridServiceUpdateOptionDefaults = { highlightRow: true, selectRow: false, scrollRowIntoView: false, triggerEvent: true };
const HideColumnOptionDefaults = { autoResizeColumns: true, triggerEvent: true, hideFromColumnPicker: false, hideFromGridMenu: false };
let GridService = class GridService {
    constructor(extensionService, filterService, gridStateService, sharedService, sortService) {
        this.extensionService = extensionService;
        this.filterService = filterService;
        this.gridStateService = gridStateService;
        this.sharedService = sharedService;
        this.sortService = sortService;
        this.onItemAdded = new Subject();
        this.onItemDeleted = new Subject();
        this.onItemUpdated = new Subject();
        this.onItemUpserted = new Subject();
        this.onColumnsChanged = new Subject();
    }
    /** Getter for the Grid Options pulled through the Grid Object */
    get _gridOptions() {
        return (this._grid && this._grid.getOptions) ? this._grid.getOptions() : {};
    }
    dispose() {
        if (this._rowSelectionPlugin && this._rowSelectionPlugin.destroy) {
            this._rowSelectionPlugin.destroy();
        }
    }
    init(grid, dataView) {
        this._grid = grid;
        this._dataView = dataView;
    }
    /** Clear all Filters & Sorts */
    clearAllFiltersAndSorts() {
        // call both clear Filters & Sort but only trigger the last one to avoid sending multiple backend queries
        if (this.sortService && this.sortService.clearSorting) {
            this.sortService.clearSorting(false); // skip event trigger on this one
        }
        if (this.filterService && this.filterService.clearFilters) {
            this.filterService.clearFilters();
        }
    }
    /**
     * Get all column set in the grid, that is all visible/hidden columns
     * and also include any extra columns used by some plugins (like Row Selection, Row Detail, ...)
     */
    getAllColumnDefinitions() {
        return this.sharedService.allColumns;
    }
    /** Get only visible column definitions and also include any extra columns by some plugins (like Row Selection, Row Detail, ...) */
    getVisibleColumnDefinitions() {
        return this.sharedService.visibleColumns;
    }
    /**
     * From a SlickGrid Event triggered get the Column Definition and Item Data Context
     *
     * For example the SlickGrid onClick will return cell arguments when subscribing to it.
     * From these cellArgs, we want to get the Column Definition and Item Data
     * @param cell event args
     * @return object with columnDef and dataContext
     */
    getColumnFromEventArguments(args) {
        if (!args || !args.grid || !args.grid.getColumns || !args.grid.getDataItem) {
            throw new Error('To get the column definition and data, we need to have these arguments passed as objects (row, cell, grid)');
        }
        return {
            row: args.row,
            cell: args.cell,
            columnDef: args.grid.getColumns()[args.cell],
            dataContext: args.grid.getDataItem(args.row),
            dataView: this._dataView,
            grid: this._grid
        };
    }
    /** Get data item by it's row index number */
    getDataItemByRowNumber(rowNumber) {
        if (!this._grid || typeof this._grid.getDataItem !== 'function') {
            throw new Error(`We could not find SlickGrid Grid object or it's "getDataItem" method`);
        }
        return this._grid.getDataItem(rowNumber);
    }
    /** Chain the item Metadata with our implementation of Metadata at given row index */
    getItemRowMetadataToHighlight(previousItemMetadata) {
        return (rowNumber) => {
            const item = this._dataView.getItem(rowNumber);
            let meta = { cssClasses: '' };
            if (typeof previousItemMetadata === 'function') {
                meta = previousItemMetadata(rowNumber);
            }
            if (!meta) {
                meta = { cssClasses: '' };
            }
            if (item && item._dirty) {
                meta.cssClasses = (meta && meta.cssClasses || '') + ' dirty';
            }
            if (item && item.rowClass && meta) {
                meta.cssClasses += ` ${item.rowClass}`;
                meta.cssClasses += ` row${rowNumber}`;
            }
            return meta;
        };
    }
    /**
       * @deprecated Hide a Column from the Grid (the column will just become hidden and will still show up in columnPicker/gridMenu)
       * @see hideColumnById
       * @param column
       */
    hideColumn(column) {
        if (this._grid && this._grid.getColumns && this._grid.setColumns && this._grid.getColumnIndex) {
            const columnIndex = this._grid.getColumnIndex(column.id);
            if (columnIndex >= 0) {
                this.hideColumnByIndex(columnIndex);
            }
        }
    }
    /**
     * @deprecated Hide a Column from the Grid by its column definition index (the column will just become hidden and will still show up in columnPicker/gridMenu)
     * @see hideColumnById Please use "hideColumnById(id)" or "hideColumnByIds([ids])" instead since it has a lot more options
     * @param columnIndex - column definition index
     * @param triggerEvent - do we want to trigger an event (onHeaderMenuColumnsChanged) when column becomes hidden? Defaults to true.
     */
    hideColumnByIndex(columnIndex, triggerEvent = true) {
        if (this._grid && this._grid.getColumns && this._grid.setColumns) {
            const currentColumns = this._grid.getColumns();
            const visibleColumns = arrayRemoveItemByIndex(currentColumns, columnIndex);
            this.sharedService.visibleColumns = visibleColumns;
            this._grid.setColumns(visibleColumns);
            if (triggerEvent) {
                this.onColumnsChanged.next(visibleColumns);
            }
        }
    }
    /**
     * Hide a Column from the Grid by its column definition id, the column will just become hidden and will still show up in columnPicker/gridMenu
     * @param {string | number} columnId - column definition id
     * @param {boolean} triggerEvent - do we want to trigger an event (onHeaderMenuColumnsChanged) when column becomes hidden? Defaults to true.
     * @return {number} columnIndex - column index position when found or -1
     */
    hideColumnById(columnId, options) {
        options = Object.assign({}, HideColumnOptionDefaults, options);
        if (this._grid && this._grid.getColumns && this._grid.setColumns) {
            const currentColumns = this._grid.getColumns();
            const colIndexFound = currentColumns.findIndex(col => col.id === columnId);
            if (colIndexFound >= 0) {
                const visibleColumns = arrayRemoveItemByIndex(currentColumns, colIndexFound);
                this.sharedService.visibleColumns = visibleColumns;
                this._grid.setColumns(visibleColumns);
                const columnIndexFromAllColumns = this.sharedService.allColumns.findIndex(col => col.id === columnId);
                if (columnIndexFromAllColumns) {
                    if (options && options.hideFromColumnPicker) {
                        this.sharedService.allColumns[columnIndexFromAllColumns].excludeFromColumnPicker = true;
                    }
                    if (options && options.hideFromGridMenu) {
                        this.sharedService.allColumns[columnIndexFromAllColumns].excludeFromGridMenu = true;
                    }
                }
                // do we want to auto-resize the columns in the grid after hidding some? most often yes
                if (options && options.autoResizeColumns) {
                    this._grid.autosizeColumns();
                }
                // do we want to trigger an event after hidding
                if (options && options.triggerEvent) {
                    this.onColumnsChanged.next(visibleColumns);
                }
                return colIndexFound;
            }
        }
        return -1;
    }
    /**
     * Hide a Column from the Grid by its column definition id(s), the column will just become hidden and will still show up in columnPicker/gridMenu
     * @param {Array<string | number>} columnIds - column definition ids, can be a single string and an array of strings
     * @param {boolean} triggerEvent - do we want to trigger an event (onHeaderMenuColumnsChanged) when column becomes hidden? Defaults to true.
     */
    hideColumnByIds(columnIds, options) {
        options = Object.assign({}, HideColumnOptionDefaults, options);
        if (Array.isArray(columnIds)) {
            for (const columnId of columnIds) {
                // hide each column by its id but wait after the for loop to auto resize columns in the grid
                this.hideColumnById(columnId, Object.assign({}, options, { triggerEvent: false, autoResizeColumns: false }));
            }
            // do we want to auto-resize the columns in the grid after hidding some? most often yes
            if (options && options.autoResizeColumns) {
                this._grid.autosizeColumns();
            }
            // do we want to trigger an event after hidding
            if (options && options.triggerEvent) {
                this.onColumnsChanged.next(this.sharedService.visibleColumns);
            }
        }
    }
    /**
     * Highlight then fade a row for x seconds.
     * The implementation follows this SO answer: https://stackoverflow.com/a/19985148/1212166
     * @param rowNumber
     * @param fadeDelay
     */
    highlightRow(rowNumber, fadeDelay = 1500, fadeOutDelay = 300) {
        // create a SelectionModel if there's not one yet
        if (!this._grid.getSelectionModel() && Slick && Slick.RowSelectionModel) {
            this._rowSelectionPlugin = new Slick.RowSelectionModel(this._gridOptions.rowSelectionOptions || {});
            this._grid.setSelectionModel(this._rowSelectionPlugin);
        }
        if (Array.isArray(rowNumber)) {
            rowNumber.forEach(row => this.highlightRowByMetadata(row, fadeDelay, fadeOutDelay));
        }
        else {
            this.highlightRowByMetadata(rowNumber, fadeDelay, fadeOutDelay);
        }
    }
    highlightRowByMetadata(rowNumber, fadeDelay = 1500, fadeOutDelay = 300) {
        this._dataView.getItemMetadata = this.getItemRowMetadataToHighlight(this._dataView.getItemMetadata);
        const item = this._dataView.getItem(rowNumber);
        const idPropName = this._gridOptions.datasetIdPropertyName || 'id';
        if (item && item[idPropName]) {
            item.rowClass = 'highlight';
            this._dataView.updateItem(item[idPropName], item);
            this.renderGrid();
            // fade out
            clearTimeout(highlightTimerEnd);
            highlightTimerEnd = setTimeout(() => {
                item.rowClass = 'highlight-end';
                this._dataView.updateItem(item[idPropName], item);
                this.renderGrid();
            }, fadeOutDelay);
            // delete the row's CSS highlight classes once the delay is passed
            setTimeout(() => {
                if (item && item[idPropName]) {
                    delete item.rowClass;
                    if (this._dataView.getIdxById(item[idPropName]) !== undefined) {
                        this._dataView.updateItem(item[idPropName], item);
                        this.renderGrid();
                    }
                }
            }, fadeDelay + fadeOutDelay);
        }
    }
    /** Get the Data Item from a grid row index */
    getDataItemByRowIndex(index) {
        if (!this._grid || typeof this._grid.getDataItem !== 'function') {
            throw new Error('We could not find SlickGrid Grid object and/or "getDataItem" method');
        }
        return this._grid.getDataItem(index);
    }
    /** Get the Data Item from an array of grid row indexes */
    getDataItemByRowIndexes(indexes) {
        if (!this._grid || typeof this._grid.getDataItem !== 'function') {
            throw new Error('We could not find SlickGrid Grid object and/or "getDataItem" method');
        }
        const dataItems = [];
        if (Array.isArray(indexes)) {
            indexes.forEach((idx) => {
                dataItems.push(this._grid.getDataItem(idx));
            });
        }
        return dataItems;
    }
    /** Get the currently selected row indexes */
    getSelectedRows() {
        if (!this._grid || typeof this._grid.getSelectedRows !== 'function') {
            throw new Error('We could not find SlickGrid Grid object and/or "getSelectedRows" method');
        }
        return this._grid.getSelectedRows();
    }
    /** Get the currently selected rows item data */
    getSelectedRowsDataItem() {
        if (!this._grid || typeof this._grid.getSelectedRows !== 'function') {
            throw new Error('We could not find SlickGrid Grid object and/or "getSelectedRows" method');
        }
        const selectedRowIndexes = this._grid.getSelectedRows();
        return this.getDataItemByRowIndexes(selectedRowIndexes);
    }
    /** Select the selected row by a row index */
    setSelectedRow(rowIndex) {
        if (this._grid && this._grid.setSelectedRows) {
            this._grid.setSelectedRows([rowIndex]);
        }
    }
    /** Set selected rows with provided array of row indexes */
    setSelectedRows(rowIndexes) {
        if (this._grid && this._grid.setSelectedRows) {
            this._grid.setSelectedRows(rowIndexes);
        }
    }
    /** Re-Render the Grid */
    renderGrid() {
        if (this._grid && typeof this._grid.invalidate === 'function') {
            this._grid.invalidate();
            this._grid.render();
        }
    }
    /**
     * Reset the grid to it's original state (clear any filters, sorting & pagination if exists) .
     * The column definitions could be passed as argument to reset (this can be used after a Grid State reset)
     * The reset will clear the Filters & Sort, then will reset the Columns to their original state
     */
    resetGrid(columnDefinitions) {
        // reset columns to original states & refresh the grid
        if (this._grid && this._dataView) {
            const originalColumns = this.extensionService.getAllColumns();
            if (Array.isArray(originalColumns) && originalColumns.length > 0) {
                // set the grid columns to it's original column definitions
                this._grid.setColumns(originalColumns);
                if (this._gridOptions && this._gridOptions.enableAutoSizeColumns) {
                    this._grid.autosizeColumns();
                }
                this.gridStateService.resetColumns(columnDefinitions);
            }
        }
        if (this.filterService && this.filterService.clearFilters) {
            this.filterService.clearFilters();
        }
        if (this.sortService && this.sortService.clearSorting) {
            this.sortService.clearSorting();
        }
    }
    /** @deprecated please use "addItem" method instead */
    addItemToDatagrid(item, shouldHighlightRow = true, shouldResortGrid = false, shouldTriggerEvent = true, shouldSelectRow = true) {
        console.warn('[Angular-Slickgrid - GridService] please consider using the new "addItem" method since "addItemToDatagrid" will be deprecated in the future.');
        return this.addItem(item, { highlightRow: shouldHighlightRow, resortGrid: shouldResortGrid, triggerEvent: shouldTriggerEvent, selectRow: shouldSelectRow });
    }
    /** @deprecated please use "addItems" method instead */
    addItemsToDatagrid(items, shouldHighlightRow = true, shouldResortGrid = false, shouldTriggerEvent = true, shouldSelectRow = true) {
        console.warn('[Angular-Slickgrid - GridService] please consider using the new "addItems" method since "addItemsToDatagrid" will be deprecated in the future.');
        return this.addItems(items, { highlightRow: shouldHighlightRow, resortGrid: shouldResortGrid, triggerEvent: shouldTriggerEvent, selectRow: shouldSelectRow });
    }
    /**
     * Add an item (data item) to the datagrid, by default it will highlight (flashing) the inserted row but we can disable it too
     * @param item object which must contain a unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, resortGrid, selectRow, triggerEvent)
     * @return rowIndex: typically index 0 when adding to position "top" or a different number when adding to the "bottom"
     */
    addItem(item, options) {
        options = Object.assign({}, GridServiceInsertOptionDefaults, options);
        if (!this._grid || !this._gridOptions || !this._dataView) {
            throw new Error('We could not find SlickGrid Grid, DataView objects');
        }
        const idPropName = this._gridOptions.datasetIdPropertyName || 'id';
        if (!item || !(idPropName in item)) {
            throw new Error(`Adding an item requires the item to include an "${idPropName}" property`);
        }
        // insert position top/bottom, defaults to top
        // when position is top we'll call insert at index 0, else call addItem which just push to the DataView array
        if (options && options.position === 'bottom') {
            this._dataView.addItem(item);
        }
        else {
            this._dataView.insertItem(0, item); // insert at index 0
        }
        // row number in the grid, by default it will be on first row (top is the default)
        let rowNumber = 0;
        // do we want the item to be sorted in the grid, when set to False it will insert on first row (defaults to false)
        if (options.resortGrid) {
            this._dataView.reSort();
            // find the row number in the grid and if user wanted to see highlighted row
            // we need to do it here after resort and get each row number because it possibly changes after the sort
            rowNumber = this._dataView.getRowById(item[idPropName]);
        }
        else {
            // scroll to row index 0 when inserting on top else scroll to the bottom where it got inserted
            rowNumber = (options && options.position === 'bottom') ? this._dataView.getRowById(item[idPropName]) : 0;
            this._grid.scrollRowIntoView(rowNumber);
        }
        // if highlight is enabled, we'll highlight the row we just added
        if (options.highlightRow) {
            this.highlightRow(rowNumber);
        }
        // if row selection (checkbox selector) is enabled, we'll select the row in the grid
        if (options.selectRow && this._gridOptions && (this._gridOptions.enableCheckboxSelector || this._gridOptions.enableRowSelection)) {
            this.setSelectedRow(rowNumber);
        }
        // do we want to trigger an event after adding the item
        if (options.triggerEvent) {
            this.onItemAdded.next(item);
        }
        return rowNumber;
    }
    /**
     * Add item array (data item) to the datagrid, by default it will highlight (flashing) the inserted row but we can disable it too
     * @param item object arrays, which must contain unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, resortGrid, selectRow, triggerEvent)
     */
    addItems(items, options) {
        options = Object.assign({}, GridServiceInsertOptionDefaults, options);
        const idPropName = this._gridOptions.datasetIdPropertyName || 'id';
        const rowNumbers = [];
        // loop through all items to add
        if (!Array.isArray(items)) {
            return [this.addItem(items, options)];
        }
        else {
            this._dataView.beginUpdate();
            items.forEach((item) => this.addItem(item, Object.assign({}, options, { highlightRow: false, resortGrid: false, triggerEvent: false, selectRow: false })));
            this._dataView.endUpdate();
        }
        // do we want the item to be sorted in the grid, when set to False it will insert on first row (defaults to false)
        if (options.resortGrid) {
            this._dataView.reSort();
        }
        // scroll to row index 0 when inserting on top else scroll to the bottom where it got inserted
        (options && options.position === 'bottom') ? this._grid.navigateBottom() : this._grid.navigateTop();
        // get row numbers of all new inserted items
        // we need to do it after resort and get each row number because it possibly changed after the sort
        items.forEach((item) => rowNumbers.push(this._dataView.getRowById(item[idPropName])));
        // if user wanted to see highlighted row
        if (options.highlightRow) {
            this.highlightRow(rowNumbers);
        }
        // select the row in the grid
        if (options.selectRow && this._gridOptions && (this._gridOptions.enableCheckboxSelector || this._gridOptions.enableRowSelection)) {
            this.setSelectedRows(rowNumbers);
        }
        // do we want to trigger an event after adding the item
        if (options.triggerEvent) {
            this.onItemAdded.next(items);
        }
        return rowNumbers;
    }
    /** @deprecated please use "deleteItem" method instead */
    deleteDataGridItem(item, shouldTriggerEvent = true) {
        console.warn('[Angular-Slickgrid - GridService] please consider using the new "deleteItem" method since "deleteDataGridItem" will be deprecated in the future.');
        this.deleteItem(item, { triggerEvent: shouldTriggerEvent });
    }
    /** @deprecated please use "deleteItems" method instead */
    deleteDataGridItems(items, shouldTriggerEvent = true) {
        console.warn('[Angular-Slickgrid - GridService] please consider using the new "deleteItems" method since "deleteDataGridItems" will be deprecated in the future.');
        this.deleteItems(items, { triggerEvent: shouldTriggerEvent });
    }
    /** @deprecated please use "deleteItemById" method instead */
    deleteDataGridItemById(itemId, shouldTriggerEvent = true) {
        console.warn('[Angular-Slickgrid - GridService] please consider using the new "deleteItemById" method since "deleteDataGridItemById" will be deprecated in the future.');
        this.deleteItemById(itemId, { triggerEvent: shouldTriggerEvent });
    }
    /** @deprecated please use "deleteItemByIds" method instead */
    deleteDataGridItemByIds(itemIds, shouldTriggerEvent = true) {
        console.warn('[Angular-Slickgrid - GridService] please consider using the new "deleteItemByIds" method since "deleteDataGridItemByIds" will be deprecated in the future.');
        this.deleteItemByIds(itemIds, { triggerEvent: shouldTriggerEvent });
    }
    /**
     * Delete an existing item from the datagrid (dataView)
     * @param item object which must contain a unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (triggerEvent)
     * @return item id deleted
     */
    deleteItem(item, options) {
        options = Object.assign({}, GridServiceDeleteOptionDefaults, options);
        const idPropName = this._gridOptions.datasetIdPropertyName || 'id';
        if (!item || !(idPropName in item)) {
            throw new Error(`Deleting an item requires the item to include an "${idPropName}" property`);
        }
        return this.deleteItemById(item[idPropName], options);
    }
    /**
     * Delete an array of existing items from the datagrid
     * @param item object which must contain a unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (triggerEvent)
     * @return item id deleted
     */
    deleteItems(items, options) {
        options = Object.assign({}, GridServiceDeleteOptionDefaults, options);
        const idPropName = this._gridOptions.datasetIdPropertyName || 'id';
        // when it's not an array, we can call directly the single item delete
        if (!Array.isArray(items)) {
            this.deleteItem(items, options);
            return [items[idPropName]];
        }
        this._dataView.beginUpdate();
        const itemIds = [];
        items.forEach((item) => {
            if (item && item[idPropName] !== undefined) {
                itemIds.push(item[idPropName]);
            }
            this.deleteItem(item, Object.assign({}, options, { triggerEvent: false }));
        });
        this._dataView.endUpdate();
        // do we want to trigger an event after deleting the item
        if (options.triggerEvent) {
            this.onItemDeleted.next(items);
        }
        return itemIds;
    }
    /**
     * Delete an existing item from the datagrid (dataView) by it's id
     * @param itemId: item unique id
     * @param options: provide the possibility to do certain actions after or during the upsert (triggerEvent)
     * @return item id deleted
     */
    deleteItemById(itemId, options) {
        options = Object.assign({}, GridServiceDeleteOptionDefaults, options);
        if (itemId === null || itemId === undefined) {
            throw new Error(`Cannot delete a row without a valid "id"`);
        }
        // when user has row selection enabled, we should clear any selection to avoid confusion after a delete
        const isSyncGridSelectionEnabled = this.gridStateService && this.gridStateService.needToPreserveRowSelection() || false;
        if (!isSyncGridSelectionEnabled && this._grid && this._gridOptions && (this._gridOptions.enableCheckboxSelector || this._gridOptions.enableRowSelection)) {
            this.setSelectedRows([]);
        }
        // delete the item from the dataView
        this._dataView.deleteItem(itemId);
        // do we want to trigger an event after deleting the item
        if (options.triggerEvent) {
            this.onItemDeleted.next(itemId);
        }
        return itemId;
    }
    /**
     * Delete an array of existing items from the datagrid
     * @param itemIds array of item unique IDs
     * @param options: provide the possibility to do certain actions after or during the upsert (triggerEvent)
     */
    deleteItemByIds(itemIds, options) {
        options = Object.assign({}, GridServiceDeleteOptionDefaults, options);
        // when it's not an array, we can call directly the single item delete
        if (Array.isArray(itemIds)) {
            this._dataView.beginUpdate();
            for (let i = 0; i < itemIds.length; i++) {
                if (itemIds[i] !== null) {
                    this.deleteItemById(itemIds[i], { triggerEvent: false });
                }
            }
            this._dataView.endUpdate();
            // do we want to trigger an event after deleting the item
            if (options.triggerEvent) {
                this.onItemDeleted.next(itemIds);
            }
            return itemIds;
        }
        return [];
    }
    /** @deprecated please use "updateItem" method instead */
    updateDataGridItem(item, shouldHighlightRow = true, shouldTriggerEvent = true, shouldSelectRow = true) {
        console.warn('[Angular-Slickgrid - GridService] please consider using the new "updateItem" method since "updateDataGridItem" will be deprecated in the future.');
        return this.updateItem(item, { highlightRow: shouldHighlightRow, triggerEvent: shouldTriggerEvent, selectRow: shouldSelectRow });
    }
    /** @deprecated please use "updateItems" method instead */
    updateDataGridItems(items, shouldHighlightRow = true, shouldTriggerEvent = true, shouldSelectRow = true) {
        console.warn('[Angular-Slickgrid - GridService] please consider using the new "updateItems" method since "updateDataGridItems" will be deprecated in the future.');
        return this.updateItems(items, { highlightRow: shouldHighlightRow, triggerEvent: shouldTriggerEvent, selectRow: shouldSelectRow });
    }
    /** @deprecated please use "updateItemById" method instead */
    updateDataGridItemById(itemId, item, shouldHighlightRow = true, shouldTriggerEvent = true, shouldSelectRow = true) {
        console.warn('[Angular-Slickgrid - GridService] please consider using the new "updateItemById" method since "updateDataGridItemById" will be deprecated in the future.');
        return this.updateItemById(itemId, item, { highlightRow: shouldHighlightRow, triggerEvent: shouldTriggerEvent, selectRow: shouldSelectRow });
    }
    /**
     * Update an existing item with new properties inside the datagrid
     * @param item object which must contain a unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, selectRow, triggerEvent)
     * @return grid row index
     */
    updateItem(item, options) {
        options = Object.assign({}, GridServiceUpdateOptionDefaults, options);
        const idPropName = this._gridOptions.datasetIdPropertyName || 'id';
        const itemId = (!item || !(idPropName in item)) ? undefined : item[idPropName];
        if (itemId === undefined) {
            throw new Error(`Calling Update of an item requires the item to include an "${idPropName}" property`);
        }
        return this.updateItemById(itemId, item, options);
    }
    /**
     * Update an array of existing items with new properties inside the datagrid
     * @param item object arrays, which must contain unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, selectRow, triggerEvent)
     * @return grid row indexes
     */
    updateItems(items, options) {
        options = Object.assign({}, GridServiceUpdateOptionDefaults, options);
        // when it's not an array, we can call directly the single item update
        if (!Array.isArray(items)) {
            return [this.updateItem(items, options)];
        }
        this._dataView.beginUpdate();
        const gridRowNumbers = [];
        items.forEach((item) => {
            gridRowNumbers.push(this.updateItem(item, Object.assign({}, options, { highlightRow: false, selectRow: false, triggerEvent: false })));
        });
        this._dataView.endUpdate();
        // only highlight at the end, all at once
        // we have to do this because doing highlight 1 by 1 would only re-select the last highlighted row which is wrong behavior
        if (options.highlightRow) {
            this.highlightRow(gridRowNumbers);
        }
        // select the row in the grid
        if (options.selectRow && this._gridOptions && (this._gridOptions.enableCheckboxSelector || this._gridOptions.enableRowSelection)) {
            this.setSelectedRows(gridRowNumbers);
        }
        // do we want to trigger an event after updating the item
        if (options.triggerEvent) {
            this.onItemUpdated.next(items);
        }
        return gridRowNumbers;
    }
    /**
     * Update an existing item in the datagrid by it's id and new properties
     * @param itemId: item unique id
     * @param item object which must contain a unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, selectRow, triggerEvent)
     * @return grid row number
     */
    updateItemById(itemId, item, options) {
        options = Object.assign({}, GridServiceUpdateOptionDefaults, options);
        if (itemId === undefined) {
            throw new Error(`Cannot update a row without a valid "id"`);
        }
        const rowNumber = this._dataView.getRowById(itemId);
        if (!item || rowNumber === undefined) {
            throw new Error(`The item to update in the grid was not found with id: ${itemId}`);
        }
        if (this._dataView.getIdxById(itemId) !== undefined) {
            // Update the item itself inside the dataView
            this._dataView.updateItem(itemId, item);
            this._grid.updateRow(rowNumber);
            // do we want to scroll to the row so that it shows in the Viewport (UI)
            if (options.scrollRowIntoView) {
                this._grid.scrollRowIntoView(rowNumber);
            }
            // highlight the row we just updated, if defined
            if (options.highlightRow) {
                this.highlightRow(rowNumber);
            }
            // select the row in the grid
            if (options.selectRow && this._gridOptions && (this._gridOptions.enableCheckboxSelector || this._gridOptions.enableRowSelection)) {
                this.setSelectedRow(rowNumber);
            }
            // do we want to trigger an event after updating the item
            if (options.triggerEvent) {
                this.onItemUpdated.next(item);
            }
        }
        return rowNumber;
    }
    /**
     * Insert a row into the grid if it doesn't already exist or update if it does.
     * @param item object which must contain a unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, resortGrid, selectRow, triggerEvent)
     */
    upsertItem(item, options) {
        options = Object.assign({}, GridServiceInsertOptionDefaults, options);
        const idPropName = this._gridOptions.datasetIdPropertyName || 'id';
        const itemId = (!item || !(idPropName in item)) ? undefined : item[idPropName];
        if (itemId === undefined) {
            throw new Error(`Calling Upsert of an item requires the item to include an "${idPropName}" property`);
        }
        return this.upsertItemById(itemId, item, options);
    }
    /**
     * Update an array of existing items with new properties inside the datagrid
     * @param item object arrays, which must contain unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, resortGrid, selectRow, triggerEvent)
     * @return row numbers in the grid
     */
    upsertItems(items, options) {
        options = Object.assign({}, GridServiceInsertOptionDefaults, options);
        // when it's not an array, we can call directly the single item update
        if (!Array.isArray(items)) {
            return [this.upsertItem(items, options)];
        }
        this._dataView.beginUpdate();
        const upsertedRows = [];
        items.forEach((item) => {
            upsertedRows.push(this.upsertItem(item, Object.assign({}, options, { highlightRow: false, resortGrid: false, selectRow: false, triggerEvent: false })));
        });
        this._dataView.endUpdate();
        const rowNumbers = upsertedRows.map((upsertRow) => upsertRow.added !== undefined ? upsertRow.added : upsertRow.updated);
        // only highlight at the end, all at once
        // we have to do this because doing highlight 1 by 1 would only re-select the last highlighted row which is wrong behavior
        if (options.highlightRow) {
            this.highlightRow(rowNumbers);
        }
        // select the row in the grid
        if (options.selectRow && this._gridOptions && (this._gridOptions.enableCheckboxSelector || this._gridOptions.enableRowSelection)) {
            this.setSelectedRows(rowNumbers);
        }
        // do we want to trigger an event after updating the item
        if (options.triggerEvent) {
            this.onItemUpserted.next(items);
            const addedItems = upsertedRows.filter((upsertRow) => upsertRow.added !== undefined);
            if (Array.isArray(addedItems) && addedItems.length > 0) {
                this.onItemAdded.next(addedItems);
            }
            const updatedItems = upsertedRows.filter((upsertRow) => upsertRow.updated !== undefined);
            if (Array.isArray(updatedItems) && updatedItems.length > 0) {
                this.onItemUpdated.next(updatedItems);
            }
        }
        return upsertedRows;
    }
    /**
     * Update an existing item in the datagrid by it's id and new properties
     * @param itemId: item unique id
     * @param item object which must contain a unique "id" property and any other suitable properties
     * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, resortGrid, selectRow, triggerEvent)
     * @return grid row number in the grid
     */
    upsertItemById(itemId, item, options) {
        let isItemAdded = false;
        options = Object.assign({}, GridServiceInsertOptionDefaults, options);
        if (itemId === undefined) {
            throw new Error(`Calling Upsert of an item requires the item to include a valid and unique "id" property`);
        }
        let rowNumberAdded;
        let rowNumberUpdated;
        if (this._dataView.getRowById(itemId) === undefined) {
            rowNumberAdded = this.addItem(item, options);
            isItemAdded = true;
        }
        else {
            rowNumberUpdated = this.updateItem(item, { highlightRow: options.highlightRow, selectRow: options.selectRow, triggerEvent: options.triggerEvent });
            isItemAdded = false;
        }
        // do we want to trigger an event after updating the item
        if (options.triggerEvent) {
            this.onItemUpserted.next(item);
            isItemAdded ? this.onItemAdded.next(item) : this.onItemUpdated.next(item);
        }
        return { added: rowNumberAdded, updated: rowNumberUpdated };
    }
};
GridService.ctorParameters = () => [
    { type: ExtensionService },
    { type: FilterService },
    { type: GridStateService },
    { type: SharedService },
    { type: SortService }
];
GridService = tslib_1.__decorate([
    Injectable()
], GridService);
export { GridService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JpZC5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci1zbGlja2dyaWQvIiwic291cmNlcyI6WyJhcHAvbW9kdWxlcy9hbmd1bGFyLXNsaWNrZ3JpZC9zZXJ2aWNlcy9ncmlkLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQVkvQixPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUN2RCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDakQsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDdkQsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQ2pELE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUM3QyxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFJckQsSUFBSSxpQkFBc0IsQ0FBQztBQUUzQixNQUFNLCtCQUErQixHQUE0QixFQUFFLFlBQVksRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN4RixNQUFNLCtCQUErQixHQUE0QixFQUFFLFlBQVksRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLElBQUksRUFBRSxDQUFDO0FBQ2xLLE1BQU0sK0JBQStCLEdBQTRCLEVBQUUsWUFBWSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLGlCQUFpQixFQUFFLEtBQUssRUFBRSxZQUFZLEVBQUUsSUFBSSxFQUFFLENBQUM7QUFDeEosTUFBTSx3QkFBd0IsR0FBcUIsRUFBRSxpQkFBaUIsRUFBRSxJQUFJLEVBQUUsWUFBWSxFQUFFLElBQUksRUFBRSxvQkFBb0IsRUFBRSxLQUFLLEVBQUUsZ0JBQWdCLEVBQUUsS0FBSyxFQUFFLENBQUM7QUFHekosSUFBYSxXQUFXLEdBQXhCLE1BQWEsV0FBVztJQVV0QixZQUNVLGdCQUFrQyxFQUNsQyxhQUE0QixFQUM1QixnQkFBa0MsRUFDbEMsYUFBNEIsRUFDNUIsV0FBd0I7UUFKeEIscUJBQWdCLEdBQWhCLGdCQUFnQixDQUFrQjtRQUNsQyxrQkFBYSxHQUFiLGFBQWEsQ0FBZTtRQUM1QixxQkFBZ0IsR0FBaEIsZ0JBQWdCLENBQWtCO1FBQ2xDLGtCQUFhLEdBQWIsYUFBYSxDQUFlO1FBQzVCLGdCQUFXLEdBQVgsV0FBVyxDQUFhO1FBWGxDLGdCQUFXLEdBQUcsSUFBSSxPQUFPLEVBQWUsQ0FBQztRQUN6QyxrQkFBYSxHQUFHLElBQUksT0FBTyxFQUFlLENBQUM7UUFDM0Msa0JBQWEsR0FBRyxJQUFJLE9BQU8sRUFBZSxDQUFDO1FBQzNDLG1CQUFjLEdBQUcsSUFBSSxPQUFPLEVBQWUsQ0FBQztRQUM1QyxxQkFBZ0IsR0FBRyxJQUFJLE9BQU8sRUFBWSxDQUFDO0lBUXZDLENBQUM7SUFFTCxpRUFBaUU7SUFDakUsSUFBWSxZQUFZO1FBQ3RCLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztJQUM5RSxDQUFDO0lBRUQsT0FBTztRQUNMLElBQUksSUFBSSxDQUFDLG1CQUFtQixJQUFJLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLEVBQUU7WUFDaEUsSUFBSSxDQUFDLG1CQUFtQixDQUFDLE9BQU8sRUFBRSxDQUFDO1NBQ3BDO0lBQ0gsQ0FBQztJQUVELElBQUksQ0FBQyxJQUFTLEVBQUUsUUFBYTtRQUMzQixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztRQUNsQixJQUFJLENBQUMsU0FBUyxHQUFHLFFBQVEsQ0FBQztJQUM1QixDQUFDO0lBRUQsZ0NBQWdDO0lBQ2hDLHVCQUF1QjtRQUNyQix5R0FBeUc7UUFDekcsSUFBSSxJQUFJLENBQUMsV0FBVyxJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsWUFBWSxFQUFFO1lBQ3JELElBQUksQ0FBQyxXQUFXLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsaUNBQWlDO1NBQ3hFO1FBQ0QsSUFBSSxJQUFJLENBQUMsYUFBYSxJQUFJLElBQUksQ0FBQyxhQUFhLENBQUMsWUFBWSxFQUFFO1lBQ3pELElBQUksQ0FBQyxhQUFhLENBQUMsWUFBWSxFQUFFLENBQUM7U0FDbkM7SUFDSCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsdUJBQXVCO1FBQ3JCLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUM7SUFDdkMsQ0FBQztJQUVELG1JQUFtSTtJQUNuSSwyQkFBMkI7UUFDekIsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLGNBQWMsQ0FBQztJQUMzQyxDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNILDJCQUEyQixDQUFDLElBQWM7UUFDeEMsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFO1lBQzFFLE1BQU0sSUFBSSxLQUFLLENBQUMsNEdBQTRHLENBQUMsQ0FBQztTQUMvSDtRQUVELE9BQU87WUFDTCxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUc7WUFDYixJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUk7WUFDZixTQUFTLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO1lBQzVDLFdBQVcsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDO1lBQzVDLFFBQVEsRUFBRSxJQUFJLENBQUMsU0FBUztZQUN4QixJQUFJLEVBQUUsSUFBSSxDQUFDLEtBQUs7U0FDakIsQ0FBQztJQUNKLENBQUM7SUFFRCw2Q0FBNkM7SUFDN0Msc0JBQXNCLENBQVUsU0FBaUI7UUFDL0MsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLElBQUksT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsS0FBSyxVQUFVLEVBQUU7WUFDL0QsTUFBTSxJQUFJLEtBQUssQ0FBQyxzRUFBc0UsQ0FBQyxDQUFDO1NBQ3pGO1FBQ0QsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUMzQyxDQUFDO0lBRUQscUZBQXFGO0lBQ3JGLDZCQUE2QixDQUFDLG9CQUF5QjtRQUNyRCxPQUFPLENBQUMsU0FBaUIsRUFBRSxFQUFFO1lBQzNCLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQy9DLElBQUksSUFBSSxHQUFHLEVBQUUsVUFBVSxFQUFFLEVBQUUsRUFBRSxDQUFDO1lBQzlCLElBQUksT0FBTyxvQkFBb0IsS0FBSyxVQUFVLEVBQUU7Z0JBQzlDLElBQUksR0FBRyxvQkFBb0IsQ0FBQyxTQUFTLENBQUMsQ0FBQzthQUN4QztZQUVELElBQUksQ0FBQyxJQUFJLEVBQUU7Z0JBQ1QsSUFBSSxHQUFHLEVBQUUsVUFBVSxFQUFFLEVBQUUsRUFBRSxDQUFDO2FBQzNCO1lBRUQsSUFBSSxJQUFJLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRTtnQkFDdkIsSUFBSSxDQUFDLFVBQVUsR0FBRyxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsVUFBVSxJQUFJLEVBQUUsQ0FBQyxHQUFHLFFBQVEsQ0FBQzthQUM5RDtZQUVELElBQUksSUFBSSxJQUFJLElBQUksQ0FBQyxRQUFRLElBQUksSUFBSSxFQUFFO2dCQUNqQyxJQUFJLENBQUMsVUFBVSxJQUFJLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO2dCQUN2QyxJQUFJLENBQUMsVUFBVSxJQUFJLE9BQU8sU0FBUyxFQUFFLENBQUM7YUFDdkM7WUFFRCxPQUFPLElBQUksQ0FBQztRQUNkLENBQUMsQ0FBQztJQUNKLENBQUM7SUFFRDs7OztTQUlLO0lBQ0wsVUFBVSxDQUFDLE1BQWM7UUFDdkIsSUFBSSxJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsY0FBYyxFQUFFO1lBQzdGLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUN6RCxJQUFJLFdBQVcsSUFBSSxDQUFDLEVBQUU7Z0JBQ3BCLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxXQUFXLENBQUMsQ0FBQzthQUNyQztTQUNGO0lBQ0gsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsaUJBQWlCLENBQUMsV0FBbUIsRUFBRSxZQUFZLEdBQUcsSUFBSTtRQUN4RCxJQUFJLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLEVBQUU7WUFDaEUsTUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLEVBQUUsQ0FBQztZQUMvQyxNQUFNLGNBQWMsR0FBRyxzQkFBc0IsQ0FBUyxjQUFjLEVBQUUsV0FBVyxDQUFDLENBQUM7WUFDbkYsSUFBSSxDQUFDLGFBQWEsQ0FBQyxjQUFjLEdBQUcsY0FBYyxDQUFDO1lBQ25ELElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1lBQ3RDLElBQUksWUFBWSxFQUFFO2dCQUNoQixJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO2FBQzVDO1NBQ0Y7SUFDSCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxjQUFjLENBQUMsUUFBeUIsRUFBRSxPQUEwQjtRQUNsRSxPQUFPLHFCQUFRLHdCQUF3QixFQUFLLE9BQU8sQ0FBRSxDQUFDO1FBQ3RELElBQUksSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsRUFBRTtZQUNoRSxNQUFNLGNBQWMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsRUFBRSxDQUFDO1lBQy9DLE1BQU0sYUFBYSxHQUFHLGNBQWMsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxLQUFLLFFBQVEsQ0FBQyxDQUFDO1lBRTNFLElBQUksYUFBYSxJQUFJLENBQUMsRUFBRTtnQkFDdEIsTUFBTSxjQUFjLEdBQUcsc0JBQXNCLENBQVMsY0FBYyxFQUFFLGFBQWEsQ0FBQyxDQUFDO2dCQUNyRixJQUFJLENBQUMsYUFBYSxDQUFDLGNBQWMsR0FBRyxjQUFjLENBQUM7Z0JBQ25ELElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLGNBQWMsQ0FBQyxDQUFDO2dCQUV0QyxNQUFNLHlCQUF5QixHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEtBQUssUUFBUSxDQUFDLENBQUM7Z0JBQ3RHLElBQUkseUJBQXlCLEVBQUU7b0JBQzdCLElBQUksT0FBTyxJQUFJLE9BQU8sQ0FBQyxvQkFBb0IsRUFBRTt3QkFDM0MsSUFBSSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUMseUJBQXlCLENBQUMsQ0FBQyx1QkFBdUIsR0FBRyxJQUFJLENBQUM7cUJBQ3pGO29CQUNELElBQUksT0FBTyxJQUFJLE9BQU8sQ0FBQyxnQkFBZ0IsRUFBRTt3QkFDdkMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUMseUJBQXlCLENBQUMsQ0FBQyxtQkFBbUIsR0FBRyxJQUFJLENBQUM7cUJBQ3JGO2lCQUNGO2dCQUVELHVGQUF1RjtnQkFDdkYsSUFBSSxPQUFPLElBQUksT0FBTyxDQUFDLGlCQUFpQixFQUFFO29CQUN4QyxJQUFJLENBQUMsS0FBSyxDQUFDLGVBQWUsRUFBRSxDQUFDO2lCQUM5QjtnQkFFRCwrQ0FBK0M7Z0JBQy9DLElBQUksT0FBTyxJQUFJLE9BQU8sQ0FBQyxZQUFZLEVBQUU7b0JBQ25DLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7aUJBQzVDO2dCQUNELE9BQU8sYUFBYSxDQUFDO2FBQ3RCO1NBQ0Y7UUFDRCxPQUFPLENBQUMsQ0FBQyxDQUFDO0lBQ1osQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxlQUFlLENBQUMsU0FBaUMsRUFBRSxPQUEwQjtRQUMzRSxPQUFPLHFCQUFRLHdCQUF3QixFQUFLLE9BQU8sQ0FBRSxDQUFDO1FBQ3RELElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsRUFBRTtZQUM1QixLQUFLLE1BQU0sUUFBUSxJQUFJLFNBQVMsRUFBRTtnQkFDaEMsNEZBQTRGO2dCQUM1RixJQUFJLENBQUMsY0FBYyxDQUFDLFFBQVEsb0JBQU8sT0FBTyxJQUFFLFlBQVksRUFBRSxLQUFLLEVBQUUsaUJBQWlCLEVBQUUsS0FBSyxJQUFHLENBQUM7YUFDOUY7WUFDRCx1RkFBdUY7WUFDdkYsSUFBSSxPQUFPLElBQUksT0FBTyxDQUFDLGlCQUFpQixFQUFFO2dCQUN4QyxJQUFJLENBQUMsS0FBSyxDQUFDLGVBQWUsRUFBRSxDQUFDO2FBQzlCO1lBQ0QsK0NBQStDO1lBQy9DLElBQUksT0FBTyxJQUFJLE9BQU8sQ0FBQyxZQUFZLEVBQUU7Z0JBQ25DLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxjQUFjLENBQUMsQ0FBQzthQUMvRDtTQUNGO0lBQ0gsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsWUFBWSxDQUFDLFNBQTRCLEVBQUUsU0FBUyxHQUFHLElBQUksRUFBRSxZQUFZLEdBQUcsR0FBRztRQUM3RSxpREFBaUQ7UUFDakQsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsaUJBQWlCLEVBQUUsSUFBSSxLQUFLLElBQUksS0FBSyxDQUFDLGlCQUFpQixFQUFFO1lBQ3ZFLElBQUksQ0FBQyxtQkFBbUIsR0FBRyxJQUFJLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLG1CQUFtQixJQUFJLEVBQUUsQ0FBQyxDQUFDO1lBQ3BHLElBQUksQ0FBQyxLQUFLLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLENBQUM7U0FDeEQ7UUFFRCxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLEVBQUU7WUFDNUIsU0FBUyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxHQUFHLEVBQUUsU0FBUyxFQUFFLFlBQVksQ0FBQyxDQUFDLENBQUM7U0FDckY7YUFBTTtZQUNMLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxTQUFTLEVBQUUsU0FBUyxFQUFFLFlBQVksQ0FBQyxDQUFDO1NBQ2pFO0lBQ0gsQ0FBQztJQUVELHNCQUFzQixDQUFDLFNBQWlCLEVBQUUsU0FBUyxHQUFHLElBQUksRUFBRSxZQUFZLEdBQUcsR0FBRztRQUM1RSxJQUFJLENBQUMsU0FBUyxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUMsNkJBQTZCLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxlQUFlLENBQUMsQ0FBQztRQUVwRyxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUMvQyxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLHFCQUFxQixJQUFJLElBQUksQ0FBQztRQUVuRSxJQUFJLElBQUksSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUU7WUFDNUIsSUFBSSxDQUFDLFFBQVEsR0FBRyxXQUFXLENBQUM7WUFDNUIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQ2xELElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztZQUVsQixXQUFXO1lBQ1gsWUFBWSxDQUFDLGlCQUFpQixDQUFDLENBQUM7WUFDaEMsaUJBQWlCLEdBQUcsVUFBVSxDQUFDLEdBQUcsRUFBRTtnQkFDbEMsSUFBSSxDQUFDLFFBQVEsR0FBRyxlQUFlLENBQUM7Z0JBQ2hDLElBQUksQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztnQkFDbEQsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1lBQ3BCLENBQUMsRUFBRSxZQUFZLENBQUMsQ0FBQztZQUVqQixrRUFBa0U7WUFDbEUsVUFBVSxDQUFDLEdBQUcsRUFBRTtnQkFDZCxJQUFJLElBQUksSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUU7b0JBQzVCLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQztvQkFDckIsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsS0FBSyxTQUFTLEVBQUU7d0JBQzdELElBQUksQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQzt3QkFDbEQsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO3FCQUNuQjtpQkFDRjtZQUNILENBQUMsRUFBRSxTQUFTLEdBQUcsWUFBWSxDQUFDLENBQUM7U0FDOUI7SUFDSCxDQUFDO0lBRUQsOENBQThDO0lBQzlDLHFCQUFxQixDQUFVLEtBQWE7UUFDMUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLElBQUksT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsS0FBSyxVQUFVLEVBQUU7WUFDL0QsTUFBTSxJQUFJLEtBQUssQ0FBQyxxRUFBcUUsQ0FBQyxDQUFDO1NBQ3hGO1FBRUQsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN2QyxDQUFDO0lBRUQsMERBQTBEO0lBQzFELHVCQUF1QixDQUFVLE9BQWlCO1FBQ2hELElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxJQUFJLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLEtBQUssVUFBVSxFQUFFO1lBQy9ELE1BQU0sSUFBSSxLQUFLLENBQUMscUVBQXFFLENBQUMsQ0FBQztTQUN4RjtRQUVELE1BQU0sU0FBUyxHQUFHLEVBQUUsQ0FBQztRQUVyQixJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEVBQUU7WUFDMUIsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFO2dCQUN0QixTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDOUMsQ0FBQyxDQUFDLENBQUM7U0FDSjtRQUVELE9BQU8sU0FBUyxDQUFDO0lBQ25CLENBQUM7SUFFRCw2Q0FBNkM7SUFDN0MsZUFBZTtRQUNiLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxJQUFJLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxlQUFlLEtBQUssVUFBVSxFQUFFO1lBQ25FLE1BQU0sSUFBSSxLQUFLLENBQUMseUVBQXlFLENBQUMsQ0FBQztTQUM1RjtRQUNELE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxlQUFlLEVBQUUsQ0FBQztJQUN0QyxDQUFDO0lBRUQsZ0RBQWdEO0lBQ2hELHVCQUF1QjtRQUNyQixJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssSUFBSSxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsZUFBZSxLQUFLLFVBQVUsRUFBRTtZQUNuRSxNQUFNLElBQUksS0FBSyxDQUFDLHlFQUF5RSxDQUFDLENBQUM7U0FDNUY7UUFFRCxNQUFNLGtCQUFrQixHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsZUFBZSxFQUFFLENBQUM7UUFDeEQsT0FBTyxJQUFJLENBQUMsdUJBQXVCLENBQUksa0JBQWtCLENBQUMsQ0FBQztJQUM3RCxDQUFDO0lBRUQsNkNBQTZDO0lBQzdDLGNBQWMsQ0FBQyxRQUFnQjtRQUM3QixJQUFJLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxlQUFlLEVBQUU7WUFDNUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxlQUFlLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1NBQ3hDO0lBQ0gsQ0FBQztJQUVELDJEQUEyRDtJQUMzRCxlQUFlLENBQUMsVUFBb0I7UUFDbEMsSUFBSSxJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsZUFBZSxFQUFFO1lBQzVDLElBQUksQ0FBQyxLQUFLLENBQUMsZUFBZSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1NBQ3hDO0lBQ0gsQ0FBQztJQUVELHlCQUF5QjtJQUN6QixVQUFVO1FBQ1IsSUFBSSxJQUFJLENBQUMsS0FBSyxJQUFJLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLEtBQUssVUFBVSxFQUFFO1lBQzdELElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxFQUFFLENBQUM7WUFDeEIsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQztTQUNyQjtJQUNILENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsU0FBUyxDQUFDLGlCQUE0QjtRQUNwQyxzREFBc0Q7UUFDdEQsSUFBSSxJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDaEMsTUFBTSxlQUFlLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLGFBQWEsRUFBRSxDQUFDO1lBRTlELElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxlQUFlLENBQUMsSUFBSSxlQUFlLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtnQkFDaEUsMkRBQTJEO2dCQUMzRCxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxlQUFlLENBQUMsQ0FBQztnQkFDdkMsSUFBSSxJQUFJLENBQUMsWUFBWSxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMscUJBQXFCLEVBQUU7b0JBQ2hFLElBQUksQ0FBQyxLQUFLLENBQUMsZUFBZSxFQUFFLENBQUM7aUJBQzlCO2dCQUNELElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxZQUFZLENBQUMsaUJBQWlCLENBQUMsQ0FBQzthQUN2RDtTQUNGO1FBRUQsSUFBSSxJQUFJLENBQUMsYUFBYSxJQUFJLElBQUksQ0FBQyxhQUFhLENBQUMsWUFBWSxFQUFFO1lBQ3pELElBQUksQ0FBQyxhQUFhLENBQUMsWUFBWSxFQUFFLENBQUM7U0FDbkM7UUFDRCxJQUFJLElBQUksQ0FBQyxXQUFXLElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxZQUFZLEVBQUU7WUFDckQsSUFBSSxDQUFDLFdBQVcsQ0FBQyxZQUFZLEVBQUUsQ0FBQztTQUNqQztJQUNILENBQUM7SUFFRCxzREFBc0Q7SUFDdEQsaUJBQWlCLENBQUMsSUFBUyxFQUFFLGtCQUFrQixHQUFHLElBQUksRUFBRSxnQkFBZ0IsR0FBRyxLQUFLLEVBQUUsa0JBQWtCLEdBQUcsSUFBSSxFQUFFLGVBQWUsR0FBRyxJQUFJO1FBQ2pJLE9BQU8sQ0FBQyxJQUFJLENBQUMsOElBQThJLENBQUMsQ0FBQztRQUM3SixPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLEVBQUUsWUFBWSxFQUFFLGtCQUFrQixFQUFFLFVBQVUsRUFBRSxnQkFBZ0IsRUFBRSxZQUFZLEVBQUUsa0JBQWtCLEVBQUUsU0FBUyxFQUFFLGVBQWUsRUFBRSxDQUFDLENBQUM7SUFDOUosQ0FBQztJQUVELHVEQUF1RDtJQUN2RCxrQkFBa0IsQ0FBQyxLQUFZLEVBQUUsa0JBQWtCLEdBQUcsSUFBSSxFQUFFLGdCQUFnQixHQUFHLEtBQUssRUFBRSxrQkFBa0IsR0FBRyxJQUFJLEVBQUUsZUFBZSxHQUFHLElBQUk7UUFDckksT0FBTyxDQUFDLElBQUksQ0FBQyxnSkFBZ0osQ0FBQyxDQUFDO1FBQy9KLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsRUFBRSxZQUFZLEVBQUUsa0JBQWtCLEVBQUUsVUFBVSxFQUFFLGdCQUFnQixFQUFFLFlBQVksRUFBRSxrQkFBa0IsRUFBRSxTQUFTLEVBQUUsZUFBZSxFQUFFLENBQUMsQ0FBQztJQUNoSyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxPQUFPLENBQVUsSUFBTyxFQUFFLE9BQWlDO1FBQ3pELE9BQU8scUJBQVEsK0JBQStCLEVBQUssT0FBTyxDQUFFLENBQUM7UUFFN0QsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRTtZQUN4RCxNQUFNLElBQUksS0FBSyxDQUFDLG9EQUFvRCxDQUFDLENBQUM7U0FDdkU7UUFDRCxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLHFCQUFxQixJQUFJLElBQUksQ0FBQztRQUNuRSxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxVQUFVLElBQUksSUFBSSxDQUFDLEVBQUU7WUFDbEMsTUFBTSxJQUFJLEtBQUssQ0FBQyxtREFBbUQsVUFBVSxZQUFZLENBQUMsQ0FBQztTQUM1RjtRQUVELDhDQUE4QztRQUM5Qyw2R0FBNkc7UUFDN0csSUFBSSxPQUFPLElBQUksT0FBTyxDQUFDLFFBQVEsS0FBSyxRQUFRLEVBQUU7WUFDNUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDOUI7YUFBTTtZQUNMLElBQUksQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLG9CQUFvQjtTQUN6RDtRQUVELGtGQUFrRjtRQUNsRixJQUFJLFNBQVMsR0FBRyxDQUFDLENBQUM7UUFFbEIsa0hBQWtIO1FBQ2xILElBQUksT0FBTyxDQUFDLFVBQVUsRUFBRTtZQUN0QixJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBRXhCLDRFQUE0RTtZQUM1RSx3R0FBd0c7WUFDeEcsU0FBUyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1NBQ3pEO2FBQU07WUFDTCw4RkFBOEY7WUFDOUYsU0FBUyxHQUFHLENBQUMsT0FBTyxJQUFJLE9BQU8sQ0FBQyxRQUFRLEtBQUssUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDekcsSUFBSSxDQUFDLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsQ0FBQztTQUN6QztRQUVELGlFQUFpRTtRQUNqRSxJQUFJLE9BQU8sQ0FBQyxZQUFZLEVBQUU7WUFDeEIsSUFBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLENBQUMsQ0FBQztTQUM5QjtRQUVELG9GQUFvRjtRQUNwRixJQUFJLE9BQU8sQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLFlBQVksSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsc0JBQXNCLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxrQkFBa0IsQ0FBQyxFQUFFO1lBQ2hJLElBQUksQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDLENBQUM7U0FDaEM7UUFFRCx1REFBdUQ7UUFDdkQsSUFBSSxPQUFPLENBQUMsWUFBWSxFQUFFO1lBQ3hCLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQzdCO1FBRUQsT0FBTyxTQUFTLENBQUM7SUFDbkIsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxRQUFRLENBQVUsS0FBYyxFQUFFLE9BQWlDO1FBQ2pFLE9BQU8scUJBQVEsK0JBQStCLEVBQUssT0FBTyxDQUFFLENBQUM7UUFDN0QsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxxQkFBcUIsSUFBSSxJQUFJLENBQUM7UUFDbkUsTUFBTSxVQUFVLEdBQWEsRUFBRSxDQUFDO1FBRWhDLGdDQUFnQztRQUNoQyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUN6QixPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBSSxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQztTQUMxQzthQUFNO1lBQ0wsSUFBSSxDQUFDLFNBQVMsQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUM3QixLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBTyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFJLElBQUksb0JBQU8sT0FBTyxJQUFFLFlBQVksRUFBRSxLQUFLLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxLQUFLLElBQUcsQ0FBQyxDQUFDO1lBQ2pKLElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxFQUFFLENBQUM7U0FDNUI7UUFFRCxrSEFBa0g7UUFDbEgsSUFBSSxPQUFPLENBQUMsVUFBVSxFQUFFO1lBQ3RCLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxFQUFFLENBQUM7U0FDekI7UUFFRCw4RkFBOEY7UUFDOUYsQ0FBQyxPQUFPLElBQUksT0FBTyxDQUFDLFFBQVEsS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUVwRyw0Q0FBNEM7UUFDNUMsbUdBQW1HO1FBQ25HLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFTLEVBQUUsRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRTNGLHdDQUF3QztRQUN4QyxJQUFJLE9BQU8sQ0FBQyxZQUFZLEVBQUU7WUFDeEIsSUFBSSxDQUFDLFlBQVksQ0FBQyxVQUFVLENBQUMsQ0FBQztTQUMvQjtRQUVELDZCQUE2QjtRQUM3QixJQUFJLE9BQU8sQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLFlBQVksSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsc0JBQXNCLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxrQkFBa0IsQ0FBQyxFQUFFO1lBQ2hJLElBQUksQ0FBQyxlQUFlLENBQUMsVUFBVSxDQUFDLENBQUM7U0FDbEM7UUFFRCx1REFBdUQ7UUFDdkQsSUFBSSxPQUFPLENBQUMsWUFBWSxFQUFFO1lBQ3hCLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQzlCO1FBRUQsT0FBTyxVQUFVLENBQUM7SUFDcEIsQ0FBQztJQUVELHlEQUF5RDtJQUN6RCxrQkFBa0IsQ0FBQyxJQUFTLEVBQUUsa0JBQWtCLEdBQUcsSUFBSTtRQUNyRCxPQUFPLENBQUMsSUFBSSxDQUFDLGtKQUFrSixDQUFDLENBQUM7UUFDakssSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsRUFBRSxZQUFZLEVBQUUsa0JBQWtCLEVBQUUsQ0FBQyxDQUFDO0lBQzlELENBQUM7SUFFRCwwREFBMEQ7SUFDMUQsbUJBQW1CLENBQUMsS0FBWSxFQUFFLGtCQUFrQixHQUFHLElBQUk7UUFDekQsT0FBTyxDQUFDLElBQUksQ0FBQyxvSkFBb0osQ0FBQyxDQUFDO1FBQ25LLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxFQUFFLEVBQUUsWUFBWSxFQUFFLGtCQUFrQixFQUFFLENBQUMsQ0FBQztJQUNoRSxDQUFDO0lBRUQsNkRBQTZEO0lBQzdELHNCQUFzQixDQUFDLE1BQXVCLEVBQUUsa0JBQWtCLEdBQUcsSUFBSTtRQUN2RSxPQUFPLENBQUMsSUFBSSxDQUFDLDBKQUEwSixDQUFDLENBQUM7UUFDekssSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxZQUFZLEVBQUUsa0JBQWtCLEVBQUUsQ0FBQyxDQUFDO0lBQ3BFLENBQUM7SUFFRCw4REFBOEQ7SUFDOUQsdUJBQXVCLENBQUMsT0FBNEIsRUFBRSxrQkFBa0IsR0FBRyxJQUFJO1FBQzdFLE9BQU8sQ0FBQyxJQUFJLENBQUMsNEpBQTRKLENBQUMsQ0FBQztRQUMzSyxJQUFJLENBQUMsZUFBZSxDQUFDLE9BQU8sRUFBRSxFQUFFLFlBQVksRUFBRSxrQkFBa0IsRUFBRSxDQUFDLENBQUM7SUFDdEUsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsVUFBVSxDQUFVLElBQU8sRUFBRSxPQUFpQztRQUM1RCxPQUFPLHFCQUFRLCtCQUErQixFQUFLLE9BQU8sQ0FBRSxDQUFDO1FBQzdELE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMscUJBQXFCLElBQUksSUFBSSxDQUFDO1FBRW5FLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLFVBQVUsSUFBSSxJQUFJLENBQUMsRUFBRTtZQUNsQyxNQUFNLElBQUksS0FBSyxDQUFDLHFEQUFxRCxVQUFVLFlBQVksQ0FBQyxDQUFDO1NBQzlGO1FBQ0QsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUN4RCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxXQUFXLENBQVUsS0FBYyxFQUFFLE9BQWlDO1FBQ3BFLE9BQU8scUJBQVEsK0JBQStCLEVBQUssT0FBTyxDQUFFLENBQUM7UUFDN0QsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxxQkFBcUIsSUFBSSxJQUFJLENBQUM7UUFFbkUsc0VBQXNFO1FBQ3RFLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ3pCLElBQUksQ0FBQyxVQUFVLENBQUksS0FBSyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1lBQ25DLE9BQU8sQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztTQUM1QjtRQUVELElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDN0IsTUFBTSxPQUFPLEdBQUcsRUFBRSxDQUFDO1FBQ25CLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFPLEVBQUUsRUFBRTtZQUN4QixJQUFJLElBQUksSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssU0FBUyxFQUFFO2dCQUMxQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO2FBQ2hDO1lBQ0QsSUFBSSxDQUFDLFVBQVUsQ0FBSSxJQUFJLG9CQUFPLE9BQU8sSUFBRSxZQUFZLEVBQUUsS0FBSyxJQUFHLENBQUM7UUFDaEUsQ0FBQyxDQUFDLENBQUM7UUFDSCxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBRTNCLHlEQUF5RDtRQUN6RCxJQUFJLE9BQU8sQ0FBQyxZQUFZLEVBQUU7WUFDeEIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDaEM7UUFDRCxPQUFPLE9BQU8sQ0FBQztJQUNqQixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxjQUFjLENBQUMsTUFBdUIsRUFBRSxPQUFpQztRQUN2RSxPQUFPLHFCQUFRLCtCQUErQixFQUFLLE9BQU8sQ0FBRSxDQUFDO1FBRTdELElBQUksTUFBTSxLQUFLLElBQUksSUFBSSxNQUFNLEtBQUssU0FBUyxFQUFFO1lBQzNDLE1BQU0sSUFBSSxLQUFLLENBQUMsMENBQTBDLENBQUMsQ0FBQztTQUM3RDtRQUVELHVHQUF1RztRQUN2RyxNQUFNLDBCQUEwQixHQUFHLElBQUksQ0FBQyxnQkFBZ0IsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsMEJBQTBCLEVBQUUsSUFBSSxLQUFLLENBQUM7UUFDeEgsSUFBSSxDQUFDLDBCQUEwQixJQUFJLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLFlBQVksSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsc0JBQXNCLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxrQkFBa0IsQ0FBQyxFQUFFO1lBQ3hKLElBQUksQ0FBQyxlQUFlLENBQUMsRUFBRSxDQUFDLENBQUM7U0FDMUI7UUFFRCxvQ0FBb0M7UUFDcEMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFbEMseURBQXlEO1FBQ3pELElBQUksT0FBTyxDQUFDLFlBQVksRUFBRTtZQUN4QixJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUNqQztRQUNELE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsZUFBZSxDQUFDLE9BQTRCLEVBQUUsT0FBaUM7UUFDN0UsT0FBTyxxQkFBUSwrQkFBK0IsRUFBSyxPQUFPLENBQUUsQ0FBQztRQUU3RCxzRUFBc0U7UUFDdEUsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQzFCLElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxFQUFFLENBQUM7WUFDN0IsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ3ZDLElBQUksT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksRUFBRTtvQkFDdkIsSUFBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQztpQkFDMUQ7YUFDRjtZQUNELElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxFQUFFLENBQUM7WUFFM0IseURBQXlEO1lBQ3pELElBQUksT0FBTyxDQUFDLFlBQVksRUFBRTtnQkFDeEIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7YUFDbEM7WUFDRCxPQUFPLE9BQU8sQ0FBQztTQUNoQjtRQUNELE9BQU8sRUFBRSxDQUFDO0lBQ1osQ0FBQztJQUVELHlEQUF5RDtJQUN6RCxrQkFBa0IsQ0FBQyxJQUFTLEVBQUUsa0JBQWtCLEdBQUcsSUFBSSxFQUFFLGtCQUFrQixHQUFHLElBQUksRUFBRSxlQUFlLEdBQUcsSUFBSTtRQUN4RyxPQUFPLENBQUMsSUFBSSxDQUFDLGtKQUFrSixDQUFDLENBQUM7UUFDakssT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksRUFBRSxFQUFFLFlBQVksRUFBRSxrQkFBa0IsRUFBRSxZQUFZLEVBQUUsa0JBQWtCLEVBQUUsU0FBUyxFQUFFLGVBQWUsRUFBRSxDQUFDLENBQUM7SUFDbkksQ0FBQztJQUVELDBEQUEwRDtJQUMxRCxtQkFBbUIsQ0FBQyxLQUFrQixFQUFFLGtCQUFrQixHQUFHLElBQUksRUFBRSxrQkFBa0IsR0FBRyxJQUFJLEVBQUUsZUFBZSxHQUFHLElBQUk7UUFDbEgsT0FBTyxDQUFDLElBQUksQ0FBQyxvSkFBb0osQ0FBQyxDQUFDO1FBQ25LLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLEVBQUUsRUFBRSxZQUFZLEVBQUUsa0JBQWtCLEVBQUUsWUFBWSxFQUFFLGtCQUFrQixFQUFFLFNBQVMsRUFBRSxlQUFlLEVBQUUsQ0FBQyxDQUFDO0lBQ3JJLENBQUM7SUFFRCw2REFBNkQ7SUFDN0Qsc0JBQXNCLENBQUMsTUFBdUIsRUFBRSxJQUFTLEVBQUUsa0JBQWtCLEdBQUcsSUFBSSxFQUFFLGtCQUFrQixHQUFHLElBQUksRUFBRSxlQUFlLEdBQUcsSUFBSTtRQUNySSxPQUFPLENBQUMsSUFBSSxDQUFDLDBKQUEwSixDQUFDLENBQUM7UUFDekssT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxJQUFJLEVBQUUsRUFBRSxZQUFZLEVBQUUsa0JBQWtCLEVBQUUsWUFBWSxFQUFFLGtCQUFrQixFQUFFLFNBQVMsRUFBRSxlQUFlLEVBQUUsQ0FBQyxDQUFDO0lBQy9JLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILFVBQVUsQ0FBVSxJQUFPLEVBQUUsT0FBaUM7UUFDNUQsT0FBTyxxQkFBUSwrQkFBK0IsRUFBSyxPQUFPLENBQUUsQ0FBQztRQUM3RCxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLHFCQUFxQixJQUFJLElBQUksQ0FBQztRQUNuRSxNQUFNLE1BQU0sR0FBRyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxVQUFVLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7UUFFL0UsSUFBSSxNQUFNLEtBQUssU0FBUyxFQUFFO1lBQ3hCLE1BQU0sSUFBSSxLQUFLLENBQUMsOERBQThELFVBQVUsWUFBWSxDQUFDLENBQUM7U0FDdkc7UUFFRCxPQUFPLElBQUksQ0FBQyxjQUFjLENBQUksTUFBTSxFQUFFLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQztJQUN2RCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxXQUFXLENBQVUsS0FBYyxFQUFFLE9BQWlDO1FBQ3BFLE9BQU8scUJBQVEsK0JBQStCLEVBQUssT0FBTyxDQUFFLENBQUM7UUFFN0Qsc0VBQXNFO1FBQ3RFLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ3pCLE9BQU8sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFJLEtBQUssRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDO1NBQzdDO1FBR0QsSUFBSSxDQUFDLFNBQVMsQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUM3QixNQUFNLGNBQWMsR0FBYSxFQUFFLENBQUM7UUFDcEMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQVMsRUFBRSxFQUFFO1lBQzFCLGNBQWMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBSSxJQUFJLG9CQUFPLE9BQU8sSUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLEtBQUssSUFBRyxDQUFDLENBQUM7UUFDNUgsQ0FBQyxDQUFDLENBQUM7UUFDSCxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBRTNCLHlDQUF5QztRQUN6QywwSEFBMEg7UUFDMUgsSUFBSSxPQUFPLENBQUMsWUFBWSxFQUFFO1lBQ3hCLElBQUksQ0FBQyxZQUFZLENBQUMsY0FBYyxDQUFDLENBQUM7U0FDbkM7UUFFRCw2QkFBNkI7UUFDN0IsSUFBSSxPQUFPLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQyxZQUFZLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLHNCQUFzQixJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsa0JBQWtCLENBQUMsRUFBRTtZQUNoSSxJQUFJLENBQUMsZUFBZSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1NBQ3RDO1FBRUQseURBQXlEO1FBQ3pELElBQUksT0FBTyxDQUFDLFlBQVksRUFBRTtZQUN4QixJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUNoQztRQUVELE9BQU8sY0FBYyxDQUFDO0lBQ3hCLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSCxjQUFjLENBQVUsTUFBdUIsRUFBRSxJQUFPLEVBQUUsT0FBaUM7UUFDekYsT0FBTyxxQkFBUSwrQkFBK0IsRUFBSyxPQUFPLENBQUUsQ0FBQztRQUM3RCxJQUFJLE1BQU0sS0FBSyxTQUFTLEVBQUU7WUFDeEIsTUFBTSxJQUFJLEtBQUssQ0FBQywwQ0FBMEMsQ0FBQyxDQUFDO1NBQzdEO1FBQ0QsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFcEQsSUFBSSxDQUFDLElBQUksSUFBSSxTQUFTLEtBQUssU0FBUyxFQUFFO1lBQ3BDLE1BQU0sSUFBSSxLQUFLLENBQUMseURBQXlELE1BQU0sRUFBRSxDQUFDLENBQUM7U0FDcEY7UUFFRCxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxLQUFLLFNBQVMsRUFBRTtZQUNuRCw2Q0FBNkM7WUFDN0MsSUFBSSxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQ3hDLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBRWhDLHdFQUF3RTtZQUN4RSxJQUFJLE9BQU8sQ0FBQyxpQkFBaUIsRUFBRTtnQkFDN0IsSUFBSSxDQUFDLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsQ0FBQzthQUN6QztZQUVELGdEQUFnRDtZQUNoRCxJQUFJLE9BQU8sQ0FBQyxZQUFZLEVBQUU7Z0JBQ3hCLElBQUksQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDLENBQUM7YUFDOUI7WUFFRCw2QkFBNkI7WUFDN0IsSUFBSSxPQUFPLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQyxZQUFZLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLHNCQUFzQixJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsa0JBQWtCLENBQUMsRUFBRTtnQkFDaEksSUFBSSxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsQ0FBQzthQUNoQztZQUVELHlEQUF5RDtZQUN6RCxJQUFJLE9BQU8sQ0FBQyxZQUFZLEVBQUU7Z0JBQ3hCLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQy9CO1NBQ0Y7UUFDRCxPQUFPLFNBQVMsQ0FBQztJQUNuQixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILFVBQVUsQ0FBVSxJQUFPLEVBQUUsT0FBaUM7UUFDNUQsT0FBTyxxQkFBUSwrQkFBK0IsRUFBSyxPQUFPLENBQUUsQ0FBQztRQUM3RCxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLHFCQUFxQixJQUFJLElBQUksQ0FBQztRQUNuRSxNQUFNLE1BQU0sR0FBRyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxVQUFVLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7UUFFL0UsSUFBSSxNQUFNLEtBQUssU0FBUyxFQUFFO1lBQ3hCLE1BQU0sSUFBSSxLQUFLLENBQUMsOERBQThELFVBQVUsWUFBWSxDQUFDLENBQUM7U0FDdkc7UUFFRCxPQUFPLElBQUksQ0FBQyxjQUFjLENBQUksTUFBTSxFQUFFLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQztJQUN2RCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxXQUFXLENBQVUsS0FBYyxFQUFFLE9BQWlDO1FBQ3BFLE9BQU8scUJBQVEsK0JBQStCLEVBQUssT0FBTyxDQUFFLENBQUM7UUFDN0Qsc0VBQXNFO1FBQ3RFLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ3pCLE9BQU8sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFJLEtBQUssRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDO1NBQzdDO1FBRUQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUM3QixNQUFNLFlBQVksR0FBeUMsRUFBRSxDQUFDO1FBQzlELEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFPLEVBQUUsRUFBRTtZQUN4QixZQUFZLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUksSUFBSSxvQkFBTyxPQUFPLElBQUUsWUFBWSxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLEtBQUssSUFBRyxDQUFDLENBQUM7UUFDN0ksQ0FBQyxDQUFDLENBQUM7UUFDSCxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBRTNCLE1BQU0sVUFBVSxHQUFHLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQyxTQUFTLEVBQUUsRUFBRSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDeEgseUNBQXlDO1FBQ3pDLDBIQUEwSDtRQUMxSCxJQUFJLE9BQU8sQ0FBQyxZQUFZLEVBQUU7WUFDeEIsSUFBSSxDQUFDLFlBQVksQ0FBQyxVQUFVLENBQUMsQ0FBQztTQUMvQjtRQUVELDZCQUE2QjtRQUM3QixJQUFJLE9BQU8sQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLFlBQVksSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsc0JBQXNCLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxrQkFBa0IsQ0FBQyxFQUFFO1lBQ2hJLElBQUksQ0FBQyxlQUFlLENBQUMsVUFBVSxDQUFDLENBQUM7U0FDbEM7UUFFRCx5REFBeUQ7UUFDekQsSUFBSSxPQUFPLENBQUMsWUFBWSxFQUFFO1lBQ3hCLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ2hDLE1BQU0sVUFBVSxHQUFHLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQyxTQUFTLEVBQUUsRUFBRSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEtBQUssU0FBUyxDQUFDLENBQUM7WUFDckYsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO2dCQUN0RCxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQzthQUNuQztZQUNELE1BQU0sWUFBWSxHQUFHLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQyxTQUFTLEVBQUUsRUFBRSxDQUFDLFNBQVMsQ0FBQyxPQUFPLEtBQUssU0FBUyxDQUFDLENBQUM7WUFDekYsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxJQUFJLFlBQVksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO2dCQUMxRCxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQzthQUN2QztTQUNGO1FBQ0QsT0FBTyxZQUFZLENBQUM7SUFDdEIsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILGNBQWMsQ0FBVSxNQUF1QixFQUFFLElBQU8sRUFBRSxPQUFpQztRQUN6RixJQUFJLFdBQVcsR0FBRyxLQUFLLENBQUM7UUFDeEIsT0FBTyxxQkFBUSwrQkFBK0IsRUFBSyxPQUFPLENBQUUsQ0FBQztRQUM3RCxJQUFJLE1BQU0sS0FBSyxTQUFTLEVBQUU7WUFDeEIsTUFBTSxJQUFJLEtBQUssQ0FBQyx5RkFBeUYsQ0FBQyxDQUFDO1NBQzVHO1FBRUQsSUFBSSxjQUFzQixDQUFDO1FBQzNCLElBQUksZ0JBQXdCLENBQUM7UUFDN0IsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsS0FBSyxTQUFTLEVBQUU7WUFDbkQsY0FBYyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUksSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1lBQ2hELFdBQVcsR0FBRyxJQUFJLENBQUM7U0FDcEI7YUFBTTtZQUNMLGdCQUFnQixHQUFHLElBQUksQ0FBQyxVQUFVLENBQUksSUFBSSxFQUFFLEVBQUUsWUFBWSxFQUFFLE9BQU8sQ0FBQyxZQUFZLEVBQUUsU0FBUyxFQUFFLE9BQU8sQ0FBQyxTQUFTLEVBQUUsWUFBWSxFQUFFLE9BQU8sQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDO1lBQ3RKLFdBQVcsR0FBRyxLQUFLLENBQUM7U0FDckI7UUFFRCx5REFBeUQ7UUFDekQsSUFBSSxPQUFPLENBQUMsWUFBWSxFQUFFO1lBQ3hCLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQy9CLFdBQVcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQzNFO1FBQ0QsT0FBTyxFQUFFLEtBQUssRUFBRSxjQUFjLEVBQUUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLENBQUM7SUFDOUQsQ0FBQztDQUNGLENBQUE7O1lBOXlCNkIsZ0JBQWdCO1lBQ25CLGFBQWE7WUFDVixnQkFBZ0I7WUFDbkIsYUFBYTtZQUNmLFdBQVc7O0FBZnZCLFdBQVc7SUFEdkIsVUFBVSxFQUFFO0dBQ0EsV0FBVyxDQXl6QnZCO1NBenpCWSxXQUFXIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XHJcblxyXG5pbXBvcnQge1xyXG4gIENlbGxBcmdzLFxyXG4gIENvbHVtbixcclxuICBHcmlkT3B0aW9uLFxyXG4gIEdyaWRTZXJ2aWNlRGVsZXRlT3B0aW9uLFxyXG4gIEdyaWRTZXJ2aWNlSW5zZXJ0T3B0aW9uLFxyXG4gIEdyaWRTZXJ2aWNlVXBkYXRlT3B0aW9uLFxyXG4gIEhpZGVDb2x1bW5PcHRpb24sXHJcbiAgT25FdmVudEFyZ3NcclxufSBmcm9tICcuLy4uL21vZGVscy9pbmRleCc7XHJcbmltcG9ydCB7IEV4dGVuc2lvblNlcnZpY2UgfSBmcm9tICcuL2V4dGVuc2lvbi5zZXJ2aWNlJztcclxuaW1wb3J0IHsgRmlsdGVyU2VydmljZSB9IGZyb20gJy4vZmlsdGVyLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBHcmlkU3RhdGVTZXJ2aWNlIH0gZnJvbSAnLi9ncmlkU3RhdGUuc2VydmljZSc7XHJcbmltcG9ydCB7IFNoYXJlZFNlcnZpY2UgfSBmcm9tICcuL3NoYXJlZC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgU29ydFNlcnZpY2UgfSBmcm9tICcuL3NvcnQuc2VydmljZSc7XHJcbmltcG9ydCB7IGFycmF5UmVtb3ZlSXRlbUJ5SW5kZXggfSBmcm9tICcuL3V0aWxpdGllcyc7XHJcblxyXG4vLyB1c2luZyBleHRlcm5hbCBub24tdHlwZWQganMgbGlicmFyaWVzXHJcbmRlY2xhcmUgY29uc3QgU2xpY2s6IGFueTtcclxubGV0IGhpZ2hsaWdodFRpbWVyRW5kOiBhbnk7XHJcblxyXG5jb25zdCBHcmlkU2VydmljZURlbGV0ZU9wdGlvbkRlZmF1bHRzOiBHcmlkU2VydmljZURlbGV0ZU9wdGlvbiA9IHsgdHJpZ2dlckV2ZW50OiB0cnVlIH07XHJcbmNvbnN0IEdyaWRTZXJ2aWNlSW5zZXJ0T3B0aW9uRGVmYXVsdHM6IEdyaWRTZXJ2aWNlSW5zZXJ0T3B0aW9uID0geyBoaWdobGlnaHRSb3c6IHRydWUsIHBvc2l0aW9uOiAndG9wJywgcmVzb3J0R3JpZDogZmFsc2UsIHNlbGVjdFJvdzogZmFsc2UsIHRyaWdnZXJFdmVudDogdHJ1ZSB9O1xyXG5jb25zdCBHcmlkU2VydmljZVVwZGF0ZU9wdGlvbkRlZmF1bHRzOiBHcmlkU2VydmljZVVwZGF0ZU9wdGlvbiA9IHsgaGlnaGxpZ2h0Um93OiB0cnVlLCBzZWxlY3RSb3c6IGZhbHNlLCBzY3JvbGxSb3dJbnRvVmlldzogZmFsc2UsIHRyaWdnZXJFdmVudDogdHJ1ZSB9O1xyXG5jb25zdCBIaWRlQ29sdW1uT3B0aW9uRGVmYXVsdHM6IEhpZGVDb2x1bW5PcHRpb24gPSB7IGF1dG9SZXNpemVDb2x1bW5zOiB0cnVlLCB0cmlnZ2VyRXZlbnQ6IHRydWUsIGhpZGVGcm9tQ29sdW1uUGlja2VyOiBmYWxzZSwgaGlkZUZyb21HcmlkTWVudTogZmFsc2UgfTtcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIEdyaWRTZXJ2aWNlIHtcclxuICBwcml2YXRlIF9ncmlkOiBhbnk7XHJcbiAgcHJpdmF0ZSBfZGF0YVZpZXc6IGFueTtcclxuICBwcml2YXRlIF9yb3dTZWxlY3Rpb25QbHVnaW46IGFueTtcclxuICBvbkl0ZW1BZGRlZCA9IG5ldyBTdWJqZWN0PGFueSB8IGFueVtdPigpO1xyXG4gIG9uSXRlbURlbGV0ZWQgPSBuZXcgU3ViamVjdDxhbnkgfCBhbnlbXT4oKTtcclxuICBvbkl0ZW1VcGRhdGVkID0gbmV3IFN1YmplY3Q8YW55IHwgYW55W10+KCk7XHJcbiAgb25JdGVtVXBzZXJ0ZWQgPSBuZXcgU3ViamVjdDxhbnkgfCBhbnlbXT4oKTtcclxuICBvbkNvbHVtbnNDaGFuZ2VkID0gbmV3IFN1YmplY3Q8Q29sdW1uW10+KCk7XHJcblxyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgcHJpdmF0ZSBleHRlbnNpb25TZXJ2aWNlOiBFeHRlbnNpb25TZXJ2aWNlLFxyXG4gICAgcHJpdmF0ZSBmaWx0ZXJTZXJ2aWNlOiBGaWx0ZXJTZXJ2aWNlLFxyXG4gICAgcHJpdmF0ZSBncmlkU3RhdGVTZXJ2aWNlOiBHcmlkU3RhdGVTZXJ2aWNlLFxyXG4gICAgcHJpdmF0ZSBzaGFyZWRTZXJ2aWNlOiBTaGFyZWRTZXJ2aWNlLFxyXG4gICAgcHJpdmF0ZSBzb3J0U2VydmljZTogU29ydFNlcnZpY2VcclxuICApIHsgfVxyXG5cclxuICAvKiogR2V0dGVyIGZvciB0aGUgR3JpZCBPcHRpb25zIHB1bGxlZCB0aHJvdWdoIHRoZSBHcmlkIE9iamVjdCAqL1xyXG4gIHByaXZhdGUgZ2V0IF9ncmlkT3B0aW9ucygpOiBHcmlkT3B0aW9uIHtcclxuICAgIHJldHVybiAodGhpcy5fZ3JpZCAmJiB0aGlzLl9ncmlkLmdldE9wdGlvbnMpID8gdGhpcy5fZ3JpZC5nZXRPcHRpb25zKCkgOiB7fTtcclxuICB9XHJcblxyXG4gIGRpc3Bvc2UoKSB7XHJcbiAgICBpZiAodGhpcy5fcm93U2VsZWN0aW9uUGx1Z2luICYmIHRoaXMuX3Jvd1NlbGVjdGlvblBsdWdpbi5kZXN0cm95KSB7XHJcbiAgICAgIHRoaXMuX3Jvd1NlbGVjdGlvblBsdWdpbi5kZXN0cm95KCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpbml0KGdyaWQ6IGFueSwgZGF0YVZpZXc6IGFueSk6IHZvaWQge1xyXG4gICAgdGhpcy5fZ3JpZCA9IGdyaWQ7XHJcbiAgICB0aGlzLl9kYXRhVmlldyA9IGRhdGFWaWV3O1xyXG4gIH1cclxuXHJcbiAgLyoqIENsZWFyIGFsbCBGaWx0ZXJzICYgU29ydHMgKi9cclxuICBjbGVhckFsbEZpbHRlcnNBbmRTb3J0cygpIHtcclxuICAgIC8vIGNhbGwgYm90aCBjbGVhciBGaWx0ZXJzICYgU29ydCBidXQgb25seSB0cmlnZ2VyIHRoZSBsYXN0IG9uZSB0byBhdm9pZCBzZW5kaW5nIG11bHRpcGxlIGJhY2tlbmQgcXVlcmllc1xyXG4gICAgaWYgKHRoaXMuc29ydFNlcnZpY2UgJiYgdGhpcy5zb3J0U2VydmljZS5jbGVhclNvcnRpbmcpIHtcclxuICAgICAgdGhpcy5zb3J0U2VydmljZS5jbGVhclNvcnRpbmcoZmFsc2UpOyAvLyBza2lwIGV2ZW50IHRyaWdnZXIgb24gdGhpcyBvbmVcclxuICAgIH1cclxuICAgIGlmICh0aGlzLmZpbHRlclNlcnZpY2UgJiYgdGhpcy5maWx0ZXJTZXJ2aWNlLmNsZWFyRmlsdGVycykge1xyXG4gICAgICB0aGlzLmZpbHRlclNlcnZpY2UuY2xlYXJGaWx0ZXJzKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgYWxsIGNvbHVtbiBzZXQgaW4gdGhlIGdyaWQsIHRoYXQgaXMgYWxsIHZpc2libGUvaGlkZGVuIGNvbHVtbnNcclxuICAgKiBhbmQgYWxzbyBpbmNsdWRlIGFueSBleHRyYSBjb2x1bW5zIHVzZWQgYnkgc29tZSBwbHVnaW5zIChsaWtlIFJvdyBTZWxlY3Rpb24sIFJvdyBEZXRhaWwsIC4uLilcclxuICAgKi9cclxuICBnZXRBbGxDb2x1bW5EZWZpbml0aW9ucygpIHtcclxuICAgIHJldHVybiB0aGlzLnNoYXJlZFNlcnZpY2UuYWxsQ29sdW1ucztcclxuICB9XHJcblxyXG4gIC8qKiBHZXQgb25seSB2aXNpYmxlIGNvbHVtbiBkZWZpbml0aW9ucyBhbmQgYWxzbyBpbmNsdWRlIGFueSBleHRyYSBjb2x1bW5zIGJ5IHNvbWUgcGx1Z2lucyAobGlrZSBSb3cgU2VsZWN0aW9uLCBSb3cgRGV0YWlsLCAuLi4pICovXHJcbiAgZ2V0VmlzaWJsZUNvbHVtbkRlZmluaXRpb25zKCk6IENvbHVtbltdIHtcclxuICAgIHJldHVybiB0aGlzLnNoYXJlZFNlcnZpY2UudmlzaWJsZUNvbHVtbnM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGcm9tIGEgU2xpY2tHcmlkIEV2ZW50IHRyaWdnZXJlZCBnZXQgdGhlIENvbHVtbiBEZWZpbml0aW9uIGFuZCBJdGVtIERhdGEgQ29udGV4dFxyXG4gICAqXHJcbiAgICogRm9yIGV4YW1wbGUgdGhlIFNsaWNrR3JpZCBvbkNsaWNrIHdpbGwgcmV0dXJuIGNlbGwgYXJndW1lbnRzIHdoZW4gc3Vic2NyaWJpbmcgdG8gaXQuXHJcbiAgICogRnJvbSB0aGVzZSBjZWxsQXJncywgd2Ugd2FudCB0byBnZXQgdGhlIENvbHVtbiBEZWZpbml0aW9uIGFuZCBJdGVtIERhdGFcclxuICAgKiBAcGFyYW0gY2VsbCBldmVudCBhcmdzXHJcbiAgICogQHJldHVybiBvYmplY3Qgd2l0aCBjb2x1bW5EZWYgYW5kIGRhdGFDb250ZXh0XHJcbiAgICovXHJcbiAgZ2V0Q29sdW1uRnJvbUV2ZW50QXJndW1lbnRzKGFyZ3M6IENlbGxBcmdzKTogT25FdmVudEFyZ3Mge1xyXG4gICAgaWYgKCFhcmdzIHx8ICFhcmdzLmdyaWQgfHwgIWFyZ3MuZ3JpZC5nZXRDb2x1bW5zIHx8ICFhcmdzLmdyaWQuZ2V0RGF0YUl0ZW0pIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUbyBnZXQgdGhlIGNvbHVtbiBkZWZpbml0aW9uIGFuZCBkYXRhLCB3ZSBuZWVkIHRvIGhhdmUgdGhlc2UgYXJndW1lbnRzIHBhc3NlZCBhcyBvYmplY3RzIChyb3csIGNlbGwsIGdyaWQpJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcm93OiBhcmdzLnJvdyxcclxuICAgICAgY2VsbDogYXJncy5jZWxsLFxyXG4gICAgICBjb2x1bW5EZWY6IGFyZ3MuZ3JpZC5nZXRDb2x1bW5zKClbYXJncy5jZWxsXSxcclxuICAgICAgZGF0YUNvbnRleHQ6IGFyZ3MuZ3JpZC5nZXREYXRhSXRlbShhcmdzLnJvdyksXHJcbiAgICAgIGRhdGFWaWV3OiB0aGlzLl9kYXRhVmlldyxcclxuICAgICAgZ3JpZDogdGhpcy5fZ3JpZFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKiBHZXQgZGF0YSBpdGVtIGJ5IGl0J3Mgcm93IGluZGV4IG51bWJlciAqL1xyXG4gIGdldERhdGFJdGVtQnlSb3dOdW1iZXI8VCA9IGFueT4ocm93TnVtYmVyOiBudW1iZXIpOiBUIHtcclxuICAgIGlmICghdGhpcy5fZ3JpZCB8fCB0eXBlb2YgdGhpcy5fZ3JpZC5nZXREYXRhSXRlbSAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFdlIGNvdWxkIG5vdCBmaW5kIFNsaWNrR3JpZCBHcmlkIG9iamVjdCBvciBpdCdzIFwiZ2V0RGF0YUl0ZW1cIiBtZXRob2RgKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLl9ncmlkLmdldERhdGFJdGVtKHJvd051bWJlcik7XHJcbiAgfVxyXG5cclxuICAvKiogQ2hhaW4gdGhlIGl0ZW0gTWV0YWRhdGEgd2l0aCBvdXIgaW1wbGVtZW50YXRpb24gb2YgTWV0YWRhdGEgYXQgZ2l2ZW4gcm93IGluZGV4ICovXHJcbiAgZ2V0SXRlbVJvd01ldGFkYXRhVG9IaWdobGlnaHQocHJldmlvdXNJdGVtTWV0YWRhdGE6IGFueSkge1xyXG4gICAgcmV0dXJuIChyb3dOdW1iZXI6IG51bWJlcikgPT4ge1xyXG4gICAgICBjb25zdCBpdGVtID0gdGhpcy5fZGF0YVZpZXcuZ2V0SXRlbShyb3dOdW1iZXIpO1xyXG4gICAgICBsZXQgbWV0YSA9IHsgY3NzQ2xhc3NlczogJycgfTtcclxuICAgICAgaWYgKHR5cGVvZiBwcmV2aW91c0l0ZW1NZXRhZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIG1ldGEgPSBwcmV2aW91c0l0ZW1NZXRhZGF0YShyb3dOdW1iZXIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIW1ldGEpIHtcclxuICAgICAgICBtZXRhID0geyBjc3NDbGFzc2VzOiAnJyB9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaXRlbSAmJiBpdGVtLl9kaXJ0eSkge1xyXG4gICAgICAgIG1ldGEuY3NzQ2xhc3NlcyA9IChtZXRhICYmIG1ldGEuY3NzQ2xhc3NlcyB8fCAnJykgKyAnIGRpcnR5JztcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5yb3dDbGFzcyAmJiBtZXRhKSB7XHJcbiAgICAgICAgbWV0YS5jc3NDbGFzc2VzICs9IGAgJHtpdGVtLnJvd0NsYXNzfWA7XHJcbiAgICAgICAgbWV0YS5jc3NDbGFzc2VzICs9IGAgcm93JHtyb3dOdW1iZXJ9YDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG1ldGE7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBIaWRlIGEgQ29sdW1uIGZyb20gdGhlIEdyaWQgKHRoZSBjb2x1bW4gd2lsbCBqdXN0IGJlY29tZSBoaWRkZW4gYW5kIHdpbGwgc3RpbGwgc2hvdyB1cCBpbiBjb2x1bW5QaWNrZXIvZ3JpZE1lbnUpXHJcbiAgICAgKiBAc2VlIGhpZGVDb2x1bW5CeUlkXHJcbiAgICAgKiBAcGFyYW0gY29sdW1uXHJcbiAgICAgKi9cclxuICBoaWRlQ29sdW1uKGNvbHVtbjogQ29sdW1uKSB7XHJcbiAgICBpZiAodGhpcy5fZ3JpZCAmJiB0aGlzLl9ncmlkLmdldENvbHVtbnMgJiYgdGhpcy5fZ3JpZC5zZXRDb2x1bW5zICYmIHRoaXMuX2dyaWQuZ2V0Q29sdW1uSW5kZXgpIHtcclxuICAgICAgY29uc3QgY29sdW1uSW5kZXggPSB0aGlzLl9ncmlkLmdldENvbHVtbkluZGV4KGNvbHVtbi5pZCk7XHJcbiAgICAgIGlmIChjb2x1bW5JbmRleCA+PSAwKSB7XHJcbiAgICAgICAgdGhpcy5oaWRlQ29sdW1uQnlJbmRleChjb2x1bW5JbmRleCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBkZXByZWNhdGVkIEhpZGUgYSBDb2x1bW4gZnJvbSB0aGUgR3JpZCBieSBpdHMgY29sdW1uIGRlZmluaXRpb24gaW5kZXggKHRoZSBjb2x1bW4gd2lsbCBqdXN0IGJlY29tZSBoaWRkZW4gYW5kIHdpbGwgc3RpbGwgc2hvdyB1cCBpbiBjb2x1bW5QaWNrZXIvZ3JpZE1lbnUpXHJcbiAgICogQHNlZSBoaWRlQ29sdW1uQnlJZCBQbGVhc2UgdXNlIFwiaGlkZUNvbHVtbkJ5SWQoaWQpXCIgb3IgXCJoaWRlQ29sdW1uQnlJZHMoW2lkc10pXCIgaW5zdGVhZCBzaW5jZSBpdCBoYXMgYSBsb3QgbW9yZSBvcHRpb25zXHJcbiAgICogQHBhcmFtIGNvbHVtbkluZGV4IC0gY29sdW1uIGRlZmluaXRpb24gaW5kZXhcclxuICAgKiBAcGFyYW0gdHJpZ2dlckV2ZW50IC0gZG8gd2Ugd2FudCB0byB0cmlnZ2VyIGFuIGV2ZW50IChvbkhlYWRlck1lbnVDb2x1bW5zQ2hhbmdlZCkgd2hlbiBjb2x1bW4gYmVjb21lcyBoaWRkZW4/IERlZmF1bHRzIHRvIHRydWUuXHJcbiAgICovXHJcbiAgaGlkZUNvbHVtbkJ5SW5kZXgoY29sdW1uSW5kZXg6IG51bWJlciwgdHJpZ2dlckV2ZW50ID0gdHJ1ZSkge1xyXG4gICAgaWYgKHRoaXMuX2dyaWQgJiYgdGhpcy5fZ3JpZC5nZXRDb2x1bW5zICYmIHRoaXMuX2dyaWQuc2V0Q29sdW1ucykge1xyXG4gICAgICBjb25zdCBjdXJyZW50Q29sdW1ucyA9IHRoaXMuX2dyaWQuZ2V0Q29sdW1ucygpO1xyXG4gICAgICBjb25zdCB2aXNpYmxlQ29sdW1ucyA9IGFycmF5UmVtb3ZlSXRlbUJ5SW5kZXg8Q29sdW1uPihjdXJyZW50Q29sdW1ucywgY29sdW1uSW5kZXgpO1xyXG4gICAgICB0aGlzLnNoYXJlZFNlcnZpY2UudmlzaWJsZUNvbHVtbnMgPSB2aXNpYmxlQ29sdW1ucztcclxuICAgICAgdGhpcy5fZ3JpZC5zZXRDb2x1bW5zKHZpc2libGVDb2x1bW5zKTtcclxuICAgICAgaWYgKHRyaWdnZXJFdmVudCkge1xyXG4gICAgICAgIHRoaXMub25Db2x1bW5zQ2hhbmdlZC5uZXh0KHZpc2libGVDb2x1bW5zKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSGlkZSBhIENvbHVtbiBmcm9tIHRoZSBHcmlkIGJ5IGl0cyBjb2x1bW4gZGVmaW5pdGlvbiBpZCwgdGhlIGNvbHVtbiB3aWxsIGp1c3QgYmVjb21lIGhpZGRlbiBhbmQgd2lsbCBzdGlsbCBzaG93IHVwIGluIGNvbHVtblBpY2tlci9ncmlkTWVudVxyXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSBjb2x1bW5JZCAtIGNvbHVtbiBkZWZpbml0aW9uIGlkXHJcbiAgICogQHBhcmFtIHtib29sZWFufSB0cmlnZ2VyRXZlbnQgLSBkbyB3ZSB3YW50IHRvIHRyaWdnZXIgYW4gZXZlbnQgKG9uSGVhZGVyTWVudUNvbHVtbnNDaGFuZ2VkKSB3aGVuIGNvbHVtbiBiZWNvbWVzIGhpZGRlbj8gRGVmYXVsdHMgdG8gdHJ1ZS5cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGNvbHVtbkluZGV4IC0gY29sdW1uIGluZGV4IHBvc2l0aW9uIHdoZW4gZm91bmQgb3IgLTFcclxuICAgKi9cclxuICBoaWRlQ29sdW1uQnlJZChjb2x1bW5JZDogc3RyaW5nIHwgbnVtYmVyLCBvcHRpb25zPzogSGlkZUNvbHVtbk9wdGlvbik6IG51bWJlciB7XHJcbiAgICBvcHRpb25zID0geyAuLi5IaWRlQ29sdW1uT3B0aW9uRGVmYXVsdHMsIC4uLm9wdGlvbnMgfTtcclxuICAgIGlmICh0aGlzLl9ncmlkICYmIHRoaXMuX2dyaWQuZ2V0Q29sdW1ucyAmJiB0aGlzLl9ncmlkLnNldENvbHVtbnMpIHtcclxuICAgICAgY29uc3QgY3VycmVudENvbHVtbnMgPSB0aGlzLl9ncmlkLmdldENvbHVtbnMoKTtcclxuICAgICAgY29uc3QgY29sSW5kZXhGb3VuZCA9IGN1cnJlbnRDb2x1bW5zLmZpbmRJbmRleChjb2wgPT4gY29sLmlkID09PSBjb2x1bW5JZCk7XHJcblxyXG4gICAgICBpZiAoY29sSW5kZXhGb3VuZCA+PSAwKSB7XHJcbiAgICAgICAgY29uc3QgdmlzaWJsZUNvbHVtbnMgPSBhcnJheVJlbW92ZUl0ZW1CeUluZGV4PENvbHVtbj4oY3VycmVudENvbHVtbnMsIGNvbEluZGV4Rm91bmQpO1xyXG4gICAgICAgIHRoaXMuc2hhcmVkU2VydmljZS52aXNpYmxlQ29sdW1ucyA9IHZpc2libGVDb2x1bW5zO1xyXG4gICAgICAgIHRoaXMuX2dyaWQuc2V0Q29sdW1ucyh2aXNpYmxlQ29sdW1ucyk7XHJcblxyXG4gICAgICAgIGNvbnN0IGNvbHVtbkluZGV4RnJvbUFsbENvbHVtbnMgPSB0aGlzLnNoYXJlZFNlcnZpY2UuYWxsQ29sdW1ucy5maW5kSW5kZXgoY29sID0+IGNvbC5pZCA9PT0gY29sdW1uSWQpO1xyXG4gICAgICAgIGlmIChjb2x1bW5JbmRleEZyb21BbGxDb2x1bW5zKSB7XHJcbiAgICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmhpZGVGcm9tQ29sdW1uUGlja2VyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hhcmVkU2VydmljZS5hbGxDb2x1bW5zW2NvbHVtbkluZGV4RnJvbUFsbENvbHVtbnNdLmV4Y2x1ZGVGcm9tQ29sdW1uUGlja2VyID0gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaGlkZUZyb21HcmlkTWVudSkge1xyXG4gICAgICAgICAgICB0aGlzLnNoYXJlZFNlcnZpY2UuYWxsQ29sdW1uc1tjb2x1bW5JbmRleEZyb21BbGxDb2x1bW5zXS5leGNsdWRlRnJvbUdyaWRNZW51ID0gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGRvIHdlIHdhbnQgdG8gYXV0by1yZXNpemUgdGhlIGNvbHVtbnMgaW4gdGhlIGdyaWQgYWZ0ZXIgaGlkZGluZyBzb21lPyBtb3N0IG9mdGVuIHllc1xyXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYXV0b1Jlc2l6ZUNvbHVtbnMpIHtcclxuICAgICAgICAgIHRoaXMuX2dyaWQuYXV0b3NpemVDb2x1bW5zKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBkbyB3ZSB3YW50IHRvIHRyaWdnZXIgYW4gZXZlbnQgYWZ0ZXIgaGlkZGluZ1xyXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMudHJpZ2dlckV2ZW50KSB7XHJcbiAgICAgICAgICB0aGlzLm9uQ29sdW1uc0NoYW5nZWQubmV4dCh2aXNpYmxlQ29sdW1ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb2xJbmRleEZvdW5kO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gLTE7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBIaWRlIGEgQ29sdW1uIGZyb20gdGhlIEdyaWQgYnkgaXRzIGNvbHVtbiBkZWZpbml0aW9uIGlkKHMpLCB0aGUgY29sdW1uIHdpbGwganVzdCBiZWNvbWUgaGlkZGVuIGFuZCB3aWxsIHN0aWxsIHNob3cgdXAgaW4gY29sdW1uUGlja2VyL2dyaWRNZW51XHJcbiAgICogQHBhcmFtIHtBcnJheTxzdHJpbmcgfCBudW1iZXI+fSBjb2x1bW5JZHMgLSBjb2x1bW4gZGVmaW5pdGlvbiBpZHMsIGNhbiBiZSBhIHNpbmdsZSBzdHJpbmcgYW5kIGFuIGFycmF5IG9mIHN0cmluZ3NcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHRyaWdnZXJFdmVudCAtIGRvIHdlIHdhbnQgdG8gdHJpZ2dlciBhbiBldmVudCAob25IZWFkZXJNZW51Q29sdW1uc0NoYW5nZWQpIHdoZW4gY29sdW1uIGJlY29tZXMgaGlkZGVuPyBEZWZhdWx0cyB0byB0cnVlLlxyXG4gICAqL1xyXG4gIGhpZGVDb2x1bW5CeUlkcyhjb2x1bW5JZHM6IEFycmF5PHN0cmluZyB8IG51bWJlcj4sIG9wdGlvbnM/OiBIaWRlQ29sdW1uT3B0aW9uKSB7XHJcbiAgICBvcHRpb25zID0geyAuLi5IaWRlQ29sdW1uT3B0aW9uRGVmYXVsdHMsIC4uLm9wdGlvbnMgfTtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbHVtbklkcykpIHtcclxuICAgICAgZm9yIChjb25zdCBjb2x1bW5JZCBvZiBjb2x1bW5JZHMpIHtcclxuICAgICAgICAvLyBoaWRlIGVhY2ggY29sdW1uIGJ5IGl0cyBpZCBidXQgd2FpdCBhZnRlciB0aGUgZm9yIGxvb3AgdG8gYXV0byByZXNpemUgY29sdW1ucyBpbiB0aGUgZ3JpZFxyXG4gICAgICAgIHRoaXMuaGlkZUNvbHVtbkJ5SWQoY29sdW1uSWQsIHsgLi4ub3B0aW9ucywgdHJpZ2dlckV2ZW50OiBmYWxzZSwgYXV0b1Jlc2l6ZUNvbHVtbnM6IGZhbHNlIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIGRvIHdlIHdhbnQgdG8gYXV0by1yZXNpemUgdGhlIGNvbHVtbnMgaW4gdGhlIGdyaWQgYWZ0ZXIgaGlkZGluZyBzb21lPyBtb3N0IG9mdGVuIHllc1xyXG4gICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmF1dG9SZXNpemVDb2x1bW5zKSB7XHJcbiAgICAgICAgdGhpcy5fZ3JpZC5hdXRvc2l6ZUNvbHVtbnMoKTtcclxuICAgICAgfVxyXG4gICAgICAvLyBkbyB3ZSB3YW50IHRvIHRyaWdnZXIgYW4gZXZlbnQgYWZ0ZXIgaGlkZGluZ1xyXG4gICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnRyaWdnZXJFdmVudCkge1xyXG4gICAgICAgIHRoaXMub25Db2x1bW5zQ2hhbmdlZC5uZXh0KHRoaXMuc2hhcmVkU2VydmljZS52aXNpYmxlQ29sdW1ucyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEhpZ2hsaWdodCB0aGVuIGZhZGUgYSByb3cgZm9yIHggc2Vjb25kcy5cclxuICAgKiBUaGUgaW1wbGVtZW50YXRpb24gZm9sbG93cyB0aGlzIFNPIGFuc3dlcjogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE5OTg1MTQ4LzEyMTIxNjZcclxuICAgKiBAcGFyYW0gcm93TnVtYmVyXHJcbiAgICogQHBhcmFtIGZhZGVEZWxheVxyXG4gICAqL1xyXG4gIGhpZ2hsaWdodFJvdyhyb3dOdW1iZXI6IG51bWJlciB8IG51bWJlcltdLCBmYWRlRGVsYXkgPSAxNTAwLCBmYWRlT3V0RGVsYXkgPSAzMDApIHtcclxuICAgIC8vIGNyZWF0ZSBhIFNlbGVjdGlvbk1vZGVsIGlmIHRoZXJlJ3Mgbm90IG9uZSB5ZXRcclxuICAgIGlmICghdGhpcy5fZ3JpZC5nZXRTZWxlY3Rpb25Nb2RlbCgpICYmIFNsaWNrICYmIFNsaWNrLlJvd1NlbGVjdGlvbk1vZGVsKSB7XHJcbiAgICAgIHRoaXMuX3Jvd1NlbGVjdGlvblBsdWdpbiA9IG5ldyBTbGljay5Sb3dTZWxlY3Rpb25Nb2RlbCh0aGlzLl9ncmlkT3B0aW9ucy5yb3dTZWxlY3Rpb25PcHRpb25zIHx8IHt9KTtcclxuICAgICAgdGhpcy5fZ3JpZC5zZXRTZWxlY3Rpb25Nb2RlbCh0aGlzLl9yb3dTZWxlY3Rpb25QbHVnaW4pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KHJvd051bWJlcikpIHtcclxuICAgICAgcm93TnVtYmVyLmZvckVhY2gocm93ID0+IHRoaXMuaGlnaGxpZ2h0Um93QnlNZXRhZGF0YShyb3csIGZhZGVEZWxheSwgZmFkZU91dERlbGF5KSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmhpZ2hsaWdodFJvd0J5TWV0YWRhdGEocm93TnVtYmVyLCBmYWRlRGVsYXksIGZhZGVPdXREZWxheSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBoaWdobGlnaHRSb3dCeU1ldGFkYXRhKHJvd051bWJlcjogbnVtYmVyLCBmYWRlRGVsYXkgPSAxNTAwLCBmYWRlT3V0RGVsYXkgPSAzMDApIHtcclxuICAgIHRoaXMuX2RhdGFWaWV3LmdldEl0ZW1NZXRhZGF0YSA9IHRoaXMuZ2V0SXRlbVJvd01ldGFkYXRhVG9IaWdobGlnaHQodGhpcy5fZGF0YVZpZXcuZ2V0SXRlbU1ldGFkYXRhKTtcclxuXHJcbiAgICBjb25zdCBpdGVtID0gdGhpcy5fZGF0YVZpZXcuZ2V0SXRlbShyb3dOdW1iZXIpO1xyXG4gICAgY29uc3QgaWRQcm9wTmFtZSA9IHRoaXMuX2dyaWRPcHRpb25zLmRhdGFzZXRJZFByb3BlcnR5TmFtZSB8fCAnaWQnO1xyXG5cclxuICAgIGlmIChpdGVtICYmIGl0ZW1baWRQcm9wTmFtZV0pIHtcclxuICAgICAgaXRlbS5yb3dDbGFzcyA9ICdoaWdobGlnaHQnO1xyXG4gICAgICB0aGlzLl9kYXRhVmlldy51cGRhdGVJdGVtKGl0ZW1baWRQcm9wTmFtZV0sIGl0ZW0pO1xyXG4gICAgICB0aGlzLnJlbmRlckdyaWQoKTtcclxuXHJcbiAgICAgIC8vIGZhZGUgb3V0XHJcbiAgICAgIGNsZWFyVGltZW91dChoaWdobGlnaHRUaW1lckVuZCk7XHJcbiAgICAgIGhpZ2hsaWdodFRpbWVyRW5kID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgaXRlbS5yb3dDbGFzcyA9ICdoaWdobGlnaHQtZW5kJztcclxuICAgICAgICB0aGlzLl9kYXRhVmlldy51cGRhdGVJdGVtKGl0ZW1baWRQcm9wTmFtZV0sIGl0ZW0pO1xyXG4gICAgICAgIHRoaXMucmVuZGVyR3JpZCgpO1xyXG4gICAgICB9LCBmYWRlT3V0RGVsYXkpO1xyXG5cclxuICAgICAgLy8gZGVsZXRlIHRoZSByb3cncyBDU1MgaGlnaGxpZ2h0IGNsYXNzZXMgb25jZSB0aGUgZGVsYXkgaXMgcGFzc2VkXHJcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIGlmIChpdGVtICYmIGl0ZW1baWRQcm9wTmFtZV0pIHtcclxuICAgICAgICAgIGRlbGV0ZSBpdGVtLnJvd0NsYXNzO1xyXG4gICAgICAgICAgaWYgKHRoaXMuX2RhdGFWaWV3LmdldElkeEJ5SWQoaXRlbVtpZFByb3BOYW1lXSkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9kYXRhVmlldy51cGRhdGVJdGVtKGl0ZW1baWRQcm9wTmFtZV0sIGl0ZW0pO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckdyaWQoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0sIGZhZGVEZWxheSArIGZhZGVPdXREZWxheSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogR2V0IHRoZSBEYXRhIEl0ZW0gZnJvbSBhIGdyaWQgcm93IGluZGV4ICovXHJcbiAgZ2V0RGF0YUl0ZW1CeVJvd0luZGV4PFQgPSBhbnk+KGluZGV4OiBudW1iZXIpOiBUIHtcclxuICAgIGlmICghdGhpcy5fZ3JpZCB8fCB0eXBlb2YgdGhpcy5fZ3JpZC5nZXREYXRhSXRlbSAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlIGNvdWxkIG5vdCBmaW5kIFNsaWNrR3JpZCBHcmlkIG9iamVjdCBhbmQvb3IgXCJnZXREYXRhSXRlbVwiIG1ldGhvZCcpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLl9ncmlkLmdldERhdGFJdGVtKGluZGV4KTtcclxuICB9XHJcblxyXG4gIC8qKiBHZXQgdGhlIERhdGEgSXRlbSBmcm9tIGFuIGFycmF5IG9mIGdyaWQgcm93IGluZGV4ZXMgKi9cclxuICBnZXREYXRhSXRlbUJ5Um93SW5kZXhlczxUID0gYW55PihpbmRleGVzOiBudW1iZXJbXSk6IFRbXSB7XHJcbiAgICBpZiAoIXRoaXMuX2dyaWQgfHwgdHlwZW9mIHRoaXMuX2dyaWQuZ2V0RGF0YUl0ZW0gIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZSBjb3VsZCBub3QgZmluZCBTbGlja0dyaWQgR3JpZCBvYmplY3QgYW5kL29yIFwiZ2V0RGF0YUl0ZW1cIiBtZXRob2QnKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBkYXRhSXRlbXMgPSBbXTtcclxuXHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbmRleGVzKSkge1xyXG4gICAgICBpbmRleGVzLmZvckVhY2goKGlkeCkgPT4ge1xyXG4gICAgICAgIGRhdGFJdGVtcy5wdXNoKHRoaXMuX2dyaWQuZ2V0RGF0YUl0ZW0oaWR4KSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkYXRhSXRlbXM7XHJcbiAgfVxyXG5cclxuICAvKiogR2V0IHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgcm93IGluZGV4ZXMgKi9cclxuICBnZXRTZWxlY3RlZFJvd3MoKTogbnVtYmVyW10ge1xyXG4gICAgaWYgKCF0aGlzLl9ncmlkIHx8IHR5cGVvZiB0aGlzLl9ncmlkLmdldFNlbGVjdGVkUm93cyAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlIGNvdWxkIG5vdCBmaW5kIFNsaWNrR3JpZCBHcmlkIG9iamVjdCBhbmQvb3IgXCJnZXRTZWxlY3RlZFJvd3NcIiBtZXRob2QnKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLl9ncmlkLmdldFNlbGVjdGVkUm93cygpO1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHJvd3MgaXRlbSBkYXRhICovXHJcbiAgZ2V0U2VsZWN0ZWRSb3dzRGF0YUl0ZW08VCA9IGFueT4oKTogVFtdIHtcclxuICAgIGlmICghdGhpcy5fZ3JpZCB8fCB0eXBlb2YgdGhpcy5fZ3JpZC5nZXRTZWxlY3RlZFJvd3MgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZSBjb3VsZCBub3QgZmluZCBTbGlja0dyaWQgR3JpZCBvYmplY3QgYW5kL29yIFwiZ2V0U2VsZWN0ZWRSb3dzXCIgbWV0aG9kJyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc2VsZWN0ZWRSb3dJbmRleGVzID0gdGhpcy5fZ3JpZC5nZXRTZWxlY3RlZFJvd3MoKTtcclxuICAgIHJldHVybiB0aGlzLmdldERhdGFJdGVtQnlSb3dJbmRleGVzPFQ+KHNlbGVjdGVkUm93SW5kZXhlcyk7XHJcbiAgfVxyXG5cclxuICAvKiogU2VsZWN0IHRoZSBzZWxlY3RlZCByb3cgYnkgYSByb3cgaW5kZXggKi9cclxuICBzZXRTZWxlY3RlZFJvdyhyb3dJbmRleDogbnVtYmVyKSB7XHJcbiAgICBpZiAodGhpcy5fZ3JpZCAmJiB0aGlzLl9ncmlkLnNldFNlbGVjdGVkUm93cykge1xyXG4gICAgICB0aGlzLl9ncmlkLnNldFNlbGVjdGVkUm93cyhbcm93SW5kZXhdKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKiBTZXQgc2VsZWN0ZWQgcm93cyB3aXRoIHByb3ZpZGVkIGFycmF5IG9mIHJvdyBpbmRleGVzICovXHJcbiAgc2V0U2VsZWN0ZWRSb3dzKHJvd0luZGV4ZXM6IG51bWJlcltdKSB7XHJcbiAgICBpZiAodGhpcy5fZ3JpZCAmJiB0aGlzLl9ncmlkLnNldFNlbGVjdGVkUm93cykge1xyXG4gICAgICB0aGlzLl9ncmlkLnNldFNlbGVjdGVkUm93cyhyb3dJbmRleGVzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKiBSZS1SZW5kZXIgdGhlIEdyaWQgKi9cclxuICByZW5kZXJHcmlkKCkge1xyXG4gICAgaWYgKHRoaXMuX2dyaWQgJiYgdHlwZW9mIHRoaXMuX2dyaWQuaW52YWxpZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aGlzLl9ncmlkLmludmFsaWRhdGUoKTtcclxuICAgICAgdGhpcy5fZ3JpZC5yZW5kZXIoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc2V0IHRoZSBncmlkIHRvIGl0J3Mgb3JpZ2luYWwgc3RhdGUgKGNsZWFyIGFueSBmaWx0ZXJzLCBzb3J0aW5nICYgcGFnaW5hdGlvbiBpZiBleGlzdHMpIC5cclxuICAgKiBUaGUgY29sdW1uIGRlZmluaXRpb25zIGNvdWxkIGJlIHBhc3NlZCBhcyBhcmd1bWVudCB0byByZXNldCAodGhpcyBjYW4gYmUgdXNlZCBhZnRlciBhIEdyaWQgU3RhdGUgcmVzZXQpXHJcbiAgICogVGhlIHJlc2V0IHdpbGwgY2xlYXIgdGhlIEZpbHRlcnMgJiBTb3J0LCB0aGVuIHdpbGwgcmVzZXQgdGhlIENvbHVtbnMgdG8gdGhlaXIgb3JpZ2luYWwgc3RhdGVcclxuICAgKi9cclxuICByZXNldEdyaWQoY29sdW1uRGVmaW5pdGlvbnM/OiBDb2x1bW5bXSkge1xyXG4gICAgLy8gcmVzZXQgY29sdW1ucyB0byBvcmlnaW5hbCBzdGF0ZXMgJiByZWZyZXNoIHRoZSBncmlkXHJcbiAgICBpZiAodGhpcy5fZ3JpZCAmJiB0aGlzLl9kYXRhVmlldykge1xyXG4gICAgICBjb25zdCBvcmlnaW5hbENvbHVtbnMgPSB0aGlzLmV4dGVuc2lvblNlcnZpY2UuZ2V0QWxsQ29sdW1ucygpO1xyXG5cclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3JpZ2luYWxDb2x1bW5zKSAmJiBvcmlnaW5hbENvbHVtbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIC8vIHNldCB0aGUgZ3JpZCBjb2x1bW5zIHRvIGl0J3Mgb3JpZ2luYWwgY29sdW1uIGRlZmluaXRpb25zXHJcbiAgICAgICAgdGhpcy5fZ3JpZC5zZXRDb2x1bW5zKG9yaWdpbmFsQ29sdW1ucyk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2dyaWRPcHRpb25zICYmIHRoaXMuX2dyaWRPcHRpb25zLmVuYWJsZUF1dG9TaXplQ29sdW1ucykge1xyXG4gICAgICAgICAgdGhpcy5fZ3JpZC5hdXRvc2l6ZUNvbHVtbnMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5ncmlkU3RhdGVTZXJ2aWNlLnJlc2V0Q29sdW1ucyhjb2x1bW5EZWZpbml0aW9ucyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5maWx0ZXJTZXJ2aWNlICYmIHRoaXMuZmlsdGVyU2VydmljZS5jbGVhckZpbHRlcnMpIHtcclxuICAgICAgdGhpcy5maWx0ZXJTZXJ2aWNlLmNsZWFyRmlsdGVycygpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuc29ydFNlcnZpY2UgJiYgdGhpcy5zb3J0U2VydmljZS5jbGVhclNvcnRpbmcpIHtcclxuICAgICAgdGhpcy5zb3J0U2VydmljZS5jbGVhclNvcnRpbmcoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKiBAZGVwcmVjYXRlZCBwbGVhc2UgdXNlIFwiYWRkSXRlbVwiIG1ldGhvZCBpbnN0ZWFkICovXHJcbiAgYWRkSXRlbVRvRGF0YWdyaWQoaXRlbTogYW55LCBzaG91bGRIaWdobGlnaHRSb3cgPSB0cnVlLCBzaG91bGRSZXNvcnRHcmlkID0gZmFsc2UsIHNob3VsZFRyaWdnZXJFdmVudCA9IHRydWUsIHNob3VsZFNlbGVjdFJvdyA9IHRydWUpOiBudW1iZXIge1xyXG4gICAgY29uc29sZS53YXJuKCdbQW5ndWxhci1TbGlja2dyaWQgLSBHcmlkU2VydmljZV0gcGxlYXNlIGNvbnNpZGVyIHVzaW5nIHRoZSBuZXcgXCJhZGRJdGVtXCIgbWV0aG9kIHNpbmNlIFwiYWRkSXRlbVRvRGF0YWdyaWRcIiB3aWxsIGJlIGRlcHJlY2F0ZWQgaW4gdGhlIGZ1dHVyZS4nKTtcclxuICAgIHJldHVybiB0aGlzLmFkZEl0ZW0oaXRlbSwgeyBoaWdobGlnaHRSb3c6IHNob3VsZEhpZ2hsaWdodFJvdywgcmVzb3J0R3JpZDogc2hvdWxkUmVzb3J0R3JpZCwgdHJpZ2dlckV2ZW50OiBzaG91bGRUcmlnZ2VyRXZlbnQsIHNlbGVjdFJvdzogc2hvdWxkU2VsZWN0Um93IH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqIEBkZXByZWNhdGVkIHBsZWFzZSB1c2UgXCJhZGRJdGVtc1wiIG1ldGhvZCBpbnN0ZWFkICovXHJcbiAgYWRkSXRlbXNUb0RhdGFncmlkKGl0ZW1zOiBhbnlbXSwgc2hvdWxkSGlnaGxpZ2h0Um93ID0gdHJ1ZSwgc2hvdWxkUmVzb3J0R3JpZCA9IGZhbHNlLCBzaG91bGRUcmlnZ2VyRXZlbnQgPSB0cnVlLCBzaG91bGRTZWxlY3RSb3cgPSB0cnVlKTogbnVtYmVyW10ge1xyXG4gICAgY29uc29sZS53YXJuKCdbQW5ndWxhci1TbGlja2dyaWQgLSBHcmlkU2VydmljZV0gcGxlYXNlIGNvbnNpZGVyIHVzaW5nIHRoZSBuZXcgXCJhZGRJdGVtc1wiIG1ldGhvZCBzaW5jZSBcImFkZEl0ZW1zVG9EYXRhZ3JpZFwiIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiB0aGUgZnV0dXJlLicpO1xyXG4gICAgcmV0dXJuIHRoaXMuYWRkSXRlbXMoaXRlbXMsIHsgaGlnaGxpZ2h0Um93OiBzaG91bGRIaWdobGlnaHRSb3csIHJlc29ydEdyaWQ6IHNob3VsZFJlc29ydEdyaWQsIHRyaWdnZXJFdmVudDogc2hvdWxkVHJpZ2dlckV2ZW50LCBzZWxlY3RSb3c6IHNob3VsZFNlbGVjdFJvdyB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZCBhbiBpdGVtIChkYXRhIGl0ZW0pIHRvIHRoZSBkYXRhZ3JpZCwgYnkgZGVmYXVsdCBpdCB3aWxsIGhpZ2hsaWdodCAoZmxhc2hpbmcpIHRoZSBpbnNlcnRlZCByb3cgYnV0IHdlIGNhbiBkaXNhYmxlIGl0IHRvb1xyXG4gICAqIEBwYXJhbSBpdGVtIG9iamVjdCB3aGljaCBtdXN0IGNvbnRhaW4gYSB1bmlxdWUgXCJpZFwiIHByb3BlcnR5IGFuZCBhbnkgb3RoZXIgc3VpdGFibGUgcHJvcGVydGllc1xyXG4gICAqIEBwYXJhbSBvcHRpb25zOiBwcm92aWRlIHRoZSBwb3NzaWJpbGl0eSB0byBkbyBjZXJ0YWluIGFjdGlvbnMgYWZ0ZXIgb3IgZHVyaW5nIHRoZSB1cHNlcnQgKGhpZ2hsaWdodFJvdywgcmVzb3J0R3JpZCwgc2VsZWN0Um93LCB0cmlnZ2VyRXZlbnQpXHJcbiAgICogQHJldHVybiByb3dJbmRleDogdHlwaWNhbGx5IGluZGV4IDAgd2hlbiBhZGRpbmcgdG8gcG9zaXRpb24gXCJ0b3BcIiBvciBhIGRpZmZlcmVudCBudW1iZXIgd2hlbiBhZGRpbmcgdG8gdGhlIFwiYm90dG9tXCJcclxuICAgKi9cclxuICBhZGRJdGVtPFQgPSBhbnk+KGl0ZW06IFQsIG9wdGlvbnM/OiBHcmlkU2VydmljZUluc2VydE9wdGlvbik6IG51bWJlciB7XHJcbiAgICBvcHRpb25zID0geyAuLi5HcmlkU2VydmljZUluc2VydE9wdGlvbkRlZmF1bHRzLCAuLi5vcHRpb25zIH07XHJcblxyXG4gICAgaWYgKCF0aGlzLl9ncmlkIHx8ICF0aGlzLl9ncmlkT3B0aW9ucyB8fCAhdGhpcy5fZGF0YVZpZXcpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZSBjb3VsZCBub3QgZmluZCBTbGlja0dyaWQgR3JpZCwgRGF0YVZpZXcgb2JqZWN0cycpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaWRQcm9wTmFtZSA9IHRoaXMuX2dyaWRPcHRpb25zLmRhdGFzZXRJZFByb3BlcnR5TmFtZSB8fCAnaWQnO1xyXG4gICAgaWYgKCFpdGVtIHx8ICEoaWRQcm9wTmFtZSBpbiBpdGVtKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFkZGluZyBhbiBpdGVtIHJlcXVpcmVzIHRoZSBpdGVtIHRvIGluY2x1ZGUgYW4gXCIke2lkUHJvcE5hbWV9XCIgcHJvcGVydHlgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBpbnNlcnQgcG9zaXRpb24gdG9wL2JvdHRvbSwgZGVmYXVsdHMgdG8gdG9wXHJcbiAgICAvLyB3aGVuIHBvc2l0aW9uIGlzIHRvcCB3ZSdsbCBjYWxsIGluc2VydCBhdCBpbmRleCAwLCBlbHNlIGNhbGwgYWRkSXRlbSB3aGljaCBqdXN0IHB1c2ggdG8gdGhlIERhdGFWaWV3IGFycmF5XHJcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnBvc2l0aW9uID09PSAnYm90dG9tJykge1xyXG4gICAgICB0aGlzLl9kYXRhVmlldy5hZGRJdGVtKGl0ZW0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5fZGF0YVZpZXcuaW5zZXJ0SXRlbSgwLCBpdGVtKTsgLy8gaW5zZXJ0IGF0IGluZGV4IDBcclxuICAgIH1cclxuXHJcbiAgICAvLyByb3cgbnVtYmVyIGluIHRoZSBncmlkLCBieSBkZWZhdWx0IGl0IHdpbGwgYmUgb24gZmlyc3Qgcm93ICh0b3AgaXMgdGhlIGRlZmF1bHQpXHJcbiAgICBsZXQgcm93TnVtYmVyID0gMDtcclxuXHJcbiAgICAvLyBkbyB3ZSB3YW50IHRoZSBpdGVtIHRvIGJlIHNvcnRlZCBpbiB0aGUgZ3JpZCwgd2hlbiBzZXQgdG8gRmFsc2UgaXQgd2lsbCBpbnNlcnQgb24gZmlyc3Qgcm93IChkZWZhdWx0cyB0byBmYWxzZSlcclxuICAgIGlmIChvcHRpb25zLnJlc29ydEdyaWQpIHtcclxuICAgICAgdGhpcy5fZGF0YVZpZXcucmVTb3J0KCk7XHJcblxyXG4gICAgICAvLyBmaW5kIHRoZSByb3cgbnVtYmVyIGluIHRoZSBncmlkIGFuZCBpZiB1c2VyIHdhbnRlZCB0byBzZWUgaGlnaGxpZ2h0ZWQgcm93XHJcbiAgICAgIC8vIHdlIG5lZWQgdG8gZG8gaXQgaGVyZSBhZnRlciByZXNvcnQgYW5kIGdldCBlYWNoIHJvdyBudW1iZXIgYmVjYXVzZSBpdCBwb3NzaWJseSBjaGFuZ2VzIGFmdGVyIHRoZSBzb3J0XHJcbiAgICAgIHJvd051bWJlciA9IHRoaXMuX2RhdGFWaWV3LmdldFJvd0J5SWQoaXRlbVtpZFByb3BOYW1lXSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBzY3JvbGwgdG8gcm93IGluZGV4IDAgd2hlbiBpbnNlcnRpbmcgb24gdG9wIGVsc2Ugc2Nyb2xsIHRvIHRoZSBib3R0b20gd2hlcmUgaXQgZ290IGluc2VydGVkXHJcbiAgICAgIHJvd051bWJlciA9IChvcHRpb25zICYmIG9wdGlvbnMucG9zaXRpb24gPT09ICdib3R0b20nKSA/IHRoaXMuX2RhdGFWaWV3LmdldFJvd0J5SWQoaXRlbVtpZFByb3BOYW1lXSkgOiAwO1xyXG4gICAgICB0aGlzLl9ncmlkLnNjcm9sbFJvd0ludG9WaWV3KHJvd051bWJlcik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaWYgaGlnaGxpZ2h0IGlzIGVuYWJsZWQsIHdlJ2xsIGhpZ2hsaWdodCB0aGUgcm93IHdlIGp1c3QgYWRkZWRcclxuICAgIGlmIChvcHRpb25zLmhpZ2hsaWdodFJvdykge1xyXG4gICAgICB0aGlzLmhpZ2hsaWdodFJvdyhyb3dOdW1iZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGlmIHJvdyBzZWxlY3Rpb24gKGNoZWNrYm94IHNlbGVjdG9yKSBpcyBlbmFibGVkLCB3ZSdsbCBzZWxlY3QgdGhlIHJvdyBpbiB0aGUgZ3JpZFxyXG4gICAgaWYgKG9wdGlvbnMuc2VsZWN0Um93ICYmIHRoaXMuX2dyaWRPcHRpb25zICYmICh0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVDaGVja2JveFNlbGVjdG9yIHx8IHRoaXMuX2dyaWRPcHRpb25zLmVuYWJsZVJvd1NlbGVjdGlvbikpIHtcclxuICAgICAgdGhpcy5zZXRTZWxlY3RlZFJvdyhyb3dOdW1iZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGRvIHdlIHdhbnQgdG8gdHJpZ2dlciBhbiBldmVudCBhZnRlciBhZGRpbmcgdGhlIGl0ZW1cclxuICAgIGlmIChvcHRpb25zLnRyaWdnZXJFdmVudCkge1xyXG4gICAgICB0aGlzLm9uSXRlbUFkZGVkLm5leHQoaXRlbSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJvd051bWJlcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZCBpdGVtIGFycmF5IChkYXRhIGl0ZW0pIHRvIHRoZSBkYXRhZ3JpZCwgYnkgZGVmYXVsdCBpdCB3aWxsIGhpZ2hsaWdodCAoZmxhc2hpbmcpIHRoZSBpbnNlcnRlZCByb3cgYnV0IHdlIGNhbiBkaXNhYmxlIGl0IHRvb1xyXG4gICAqIEBwYXJhbSBpdGVtIG9iamVjdCBhcnJheXMsIHdoaWNoIG11c3QgY29udGFpbiB1bmlxdWUgXCJpZFwiIHByb3BlcnR5IGFuZCBhbnkgb3RoZXIgc3VpdGFibGUgcHJvcGVydGllc1xyXG4gICAqIEBwYXJhbSBvcHRpb25zOiBwcm92aWRlIHRoZSBwb3NzaWJpbGl0eSB0byBkbyBjZXJ0YWluIGFjdGlvbnMgYWZ0ZXIgb3IgZHVyaW5nIHRoZSB1cHNlcnQgKGhpZ2hsaWdodFJvdywgcmVzb3J0R3JpZCwgc2VsZWN0Um93LCB0cmlnZ2VyRXZlbnQpXHJcbiAgICovXHJcbiAgYWRkSXRlbXM8VCA9IGFueT4oaXRlbXM6IFQgfCBUW10sIG9wdGlvbnM/OiBHcmlkU2VydmljZUluc2VydE9wdGlvbik6IG51bWJlcltdIHtcclxuICAgIG9wdGlvbnMgPSB7IC4uLkdyaWRTZXJ2aWNlSW5zZXJ0T3B0aW9uRGVmYXVsdHMsIC4uLm9wdGlvbnMgfTtcclxuICAgIGNvbnN0IGlkUHJvcE5hbWUgPSB0aGlzLl9ncmlkT3B0aW9ucy5kYXRhc2V0SWRQcm9wZXJ0eU5hbWUgfHwgJ2lkJztcclxuICAgIGNvbnN0IHJvd051bWJlcnM6IG51bWJlcltdID0gW107XHJcblxyXG4gICAgLy8gbG9vcCB0aHJvdWdoIGFsbCBpdGVtcyB0byBhZGRcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShpdGVtcykpIHtcclxuICAgICAgcmV0dXJuIFt0aGlzLmFkZEl0ZW08VD4oaXRlbXMsIG9wdGlvbnMpXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX2RhdGFWaWV3LmJlZ2luVXBkYXRlKCk7XHJcbiAgICAgIGl0ZW1zLmZvckVhY2goKGl0ZW06IFQpID0+IHRoaXMuYWRkSXRlbTxUPihpdGVtLCB7IC4uLm9wdGlvbnMsIGhpZ2hsaWdodFJvdzogZmFsc2UsIHJlc29ydEdyaWQ6IGZhbHNlLCB0cmlnZ2VyRXZlbnQ6IGZhbHNlLCBzZWxlY3RSb3c6IGZhbHNlIH0pKTtcclxuICAgICAgdGhpcy5fZGF0YVZpZXcuZW5kVXBkYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZG8gd2Ugd2FudCB0aGUgaXRlbSB0byBiZSBzb3J0ZWQgaW4gdGhlIGdyaWQsIHdoZW4gc2V0IHRvIEZhbHNlIGl0IHdpbGwgaW5zZXJ0IG9uIGZpcnN0IHJvdyAoZGVmYXVsdHMgdG8gZmFsc2UpXHJcbiAgICBpZiAob3B0aW9ucy5yZXNvcnRHcmlkKSB7XHJcbiAgICAgIHRoaXMuX2RhdGFWaWV3LnJlU29ydCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHNjcm9sbCB0byByb3cgaW5kZXggMCB3aGVuIGluc2VydGluZyBvbiB0b3AgZWxzZSBzY3JvbGwgdG8gdGhlIGJvdHRvbSB3aGVyZSBpdCBnb3QgaW5zZXJ0ZWRcclxuICAgIChvcHRpb25zICYmIG9wdGlvbnMucG9zaXRpb24gPT09ICdib3R0b20nKSA/IHRoaXMuX2dyaWQubmF2aWdhdGVCb3R0b20oKSA6IHRoaXMuX2dyaWQubmF2aWdhdGVUb3AoKTtcclxuXHJcbiAgICAvLyBnZXQgcm93IG51bWJlcnMgb2YgYWxsIG5ldyBpbnNlcnRlZCBpdGVtc1xyXG4gICAgLy8gd2UgbmVlZCB0byBkbyBpdCBhZnRlciByZXNvcnQgYW5kIGdldCBlYWNoIHJvdyBudW1iZXIgYmVjYXVzZSBpdCBwb3NzaWJseSBjaGFuZ2VkIGFmdGVyIHRoZSBzb3J0XHJcbiAgICBpdGVtcy5mb3JFYWNoKChpdGVtOiBhbnkpID0+IHJvd051bWJlcnMucHVzaCh0aGlzLl9kYXRhVmlldy5nZXRSb3dCeUlkKGl0ZW1baWRQcm9wTmFtZV0pKSk7XHJcblxyXG4gICAgLy8gaWYgdXNlciB3YW50ZWQgdG8gc2VlIGhpZ2hsaWdodGVkIHJvd1xyXG4gICAgaWYgKG9wdGlvbnMuaGlnaGxpZ2h0Um93KSB7XHJcbiAgICAgIHRoaXMuaGlnaGxpZ2h0Um93KHJvd051bWJlcnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHNlbGVjdCB0aGUgcm93IGluIHRoZSBncmlkXHJcbiAgICBpZiAob3B0aW9ucy5zZWxlY3RSb3cgJiYgdGhpcy5fZ3JpZE9wdGlvbnMgJiYgKHRoaXMuX2dyaWRPcHRpb25zLmVuYWJsZUNoZWNrYm94U2VsZWN0b3IgfHwgdGhpcy5fZ3JpZE9wdGlvbnMuZW5hYmxlUm93U2VsZWN0aW9uKSkge1xyXG4gICAgICB0aGlzLnNldFNlbGVjdGVkUm93cyhyb3dOdW1iZXJzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBkbyB3ZSB3YW50IHRvIHRyaWdnZXIgYW4gZXZlbnQgYWZ0ZXIgYWRkaW5nIHRoZSBpdGVtXHJcbiAgICBpZiAob3B0aW9ucy50cmlnZ2VyRXZlbnQpIHtcclxuICAgICAgdGhpcy5vbkl0ZW1BZGRlZC5uZXh0KGl0ZW1zKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcm93TnVtYmVycztcclxuICB9XHJcblxyXG4gIC8qKiBAZGVwcmVjYXRlZCBwbGVhc2UgdXNlIFwiZGVsZXRlSXRlbVwiIG1ldGhvZCBpbnN0ZWFkICovXHJcbiAgZGVsZXRlRGF0YUdyaWRJdGVtKGl0ZW06IGFueSwgc2hvdWxkVHJpZ2dlckV2ZW50ID0gdHJ1ZSkge1xyXG4gICAgY29uc29sZS53YXJuKCdbQW5ndWxhci1TbGlja2dyaWQgLSBHcmlkU2VydmljZV0gcGxlYXNlIGNvbnNpZGVyIHVzaW5nIHRoZSBuZXcgXCJkZWxldGVJdGVtXCIgbWV0aG9kIHNpbmNlIFwiZGVsZXRlRGF0YUdyaWRJdGVtXCIgd2lsbCBiZSBkZXByZWNhdGVkIGluIHRoZSBmdXR1cmUuJyk7XHJcbiAgICB0aGlzLmRlbGV0ZUl0ZW0oaXRlbSwgeyB0cmlnZ2VyRXZlbnQ6IHNob3VsZFRyaWdnZXJFdmVudCB9KTtcclxuICB9XHJcblxyXG4gIC8qKiBAZGVwcmVjYXRlZCBwbGVhc2UgdXNlIFwiZGVsZXRlSXRlbXNcIiBtZXRob2QgaW5zdGVhZCAqL1xyXG4gIGRlbGV0ZURhdGFHcmlkSXRlbXMoaXRlbXM6IGFueVtdLCBzaG91bGRUcmlnZ2VyRXZlbnQgPSB0cnVlKSB7XHJcbiAgICBjb25zb2xlLndhcm4oJ1tBbmd1bGFyLVNsaWNrZ3JpZCAtIEdyaWRTZXJ2aWNlXSBwbGVhc2UgY29uc2lkZXIgdXNpbmcgdGhlIG5ldyBcImRlbGV0ZUl0ZW1zXCIgbWV0aG9kIHNpbmNlIFwiZGVsZXRlRGF0YUdyaWRJdGVtc1wiIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiB0aGUgZnV0dXJlLicpO1xyXG4gICAgdGhpcy5kZWxldGVJdGVtcyhpdGVtcywgeyB0cmlnZ2VyRXZlbnQ6IHNob3VsZFRyaWdnZXJFdmVudCB9KTtcclxuICB9XHJcblxyXG4gIC8qKiBAZGVwcmVjYXRlZCBwbGVhc2UgdXNlIFwiZGVsZXRlSXRlbUJ5SWRcIiBtZXRob2QgaW5zdGVhZCAqL1xyXG4gIGRlbGV0ZURhdGFHcmlkSXRlbUJ5SWQoaXRlbUlkOiBzdHJpbmcgfCBudW1iZXIsIHNob3VsZFRyaWdnZXJFdmVudCA9IHRydWUpIHtcclxuICAgIGNvbnNvbGUud2FybignW0FuZ3VsYXItU2xpY2tncmlkIC0gR3JpZFNlcnZpY2VdIHBsZWFzZSBjb25zaWRlciB1c2luZyB0aGUgbmV3IFwiZGVsZXRlSXRlbUJ5SWRcIiBtZXRob2Qgc2luY2UgXCJkZWxldGVEYXRhR3JpZEl0ZW1CeUlkXCIgd2lsbCBiZSBkZXByZWNhdGVkIGluIHRoZSBmdXR1cmUuJyk7XHJcbiAgICB0aGlzLmRlbGV0ZUl0ZW1CeUlkKGl0ZW1JZCwgeyB0cmlnZ2VyRXZlbnQ6IHNob3VsZFRyaWdnZXJFdmVudCB9KTtcclxuICB9XHJcblxyXG4gIC8qKiBAZGVwcmVjYXRlZCBwbGVhc2UgdXNlIFwiZGVsZXRlSXRlbUJ5SWRzXCIgbWV0aG9kIGluc3RlYWQgKi9cclxuICBkZWxldGVEYXRhR3JpZEl0ZW1CeUlkcyhpdGVtSWRzOiBudW1iZXJbXSB8IHN0cmluZ1tdLCBzaG91bGRUcmlnZ2VyRXZlbnQgPSB0cnVlKSB7XHJcbiAgICBjb25zb2xlLndhcm4oJ1tBbmd1bGFyLVNsaWNrZ3JpZCAtIEdyaWRTZXJ2aWNlXSBwbGVhc2UgY29uc2lkZXIgdXNpbmcgdGhlIG5ldyBcImRlbGV0ZUl0ZW1CeUlkc1wiIG1ldGhvZCBzaW5jZSBcImRlbGV0ZURhdGFHcmlkSXRlbUJ5SWRzXCIgd2lsbCBiZSBkZXByZWNhdGVkIGluIHRoZSBmdXR1cmUuJyk7XHJcbiAgICB0aGlzLmRlbGV0ZUl0ZW1CeUlkcyhpdGVtSWRzLCB7IHRyaWdnZXJFdmVudDogc2hvdWxkVHJpZ2dlckV2ZW50IH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVsZXRlIGFuIGV4aXN0aW5nIGl0ZW0gZnJvbSB0aGUgZGF0YWdyaWQgKGRhdGFWaWV3KVxyXG4gICAqIEBwYXJhbSBpdGVtIG9iamVjdCB3aGljaCBtdXN0IGNvbnRhaW4gYSB1bmlxdWUgXCJpZFwiIHByb3BlcnR5IGFuZCBhbnkgb3RoZXIgc3VpdGFibGUgcHJvcGVydGllc1xyXG4gICAqIEBwYXJhbSBvcHRpb25zOiBwcm92aWRlIHRoZSBwb3NzaWJpbGl0eSB0byBkbyBjZXJ0YWluIGFjdGlvbnMgYWZ0ZXIgb3IgZHVyaW5nIHRoZSB1cHNlcnQgKHRyaWdnZXJFdmVudClcclxuICAgKiBAcmV0dXJuIGl0ZW0gaWQgZGVsZXRlZFxyXG4gICAqL1xyXG4gIGRlbGV0ZUl0ZW08VCA9IGFueT4oaXRlbTogVCwgb3B0aW9ucz86IEdyaWRTZXJ2aWNlRGVsZXRlT3B0aW9uKTogbnVtYmVyIHwgc3RyaW5nIHtcclxuICAgIG9wdGlvbnMgPSB7IC4uLkdyaWRTZXJ2aWNlRGVsZXRlT3B0aW9uRGVmYXVsdHMsIC4uLm9wdGlvbnMgfTtcclxuICAgIGNvbnN0IGlkUHJvcE5hbWUgPSB0aGlzLl9ncmlkT3B0aW9ucy5kYXRhc2V0SWRQcm9wZXJ0eU5hbWUgfHwgJ2lkJztcclxuXHJcbiAgICBpZiAoIWl0ZW0gfHwgIShpZFByb3BOYW1lIGluIGl0ZW0pKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRGVsZXRpbmcgYW4gaXRlbSByZXF1aXJlcyB0aGUgaXRlbSB0byBpbmNsdWRlIGFuIFwiJHtpZFByb3BOYW1lfVwiIHByb3BlcnR5YCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5kZWxldGVJdGVtQnlJZChpdGVtW2lkUHJvcE5hbWVdLCBvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlbGV0ZSBhbiBhcnJheSBvZiBleGlzdGluZyBpdGVtcyBmcm9tIHRoZSBkYXRhZ3JpZFxyXG4gICAqIEBwYXJhbSBpdGVtIG9iamVjdCB3aGljaCBtdXN0IGNvbnRhaW4gYSB1bmlxdWUgXCJpZFwiIHByb3BlcnR5IGFuZCBhbnkgb3RoZXIgc3VpdGFibGUgcHJvcGVydGllc1xyXG4gICAqIEBwYXJhbSBvcHRpb25zOiBwcm92aWRlIHRoZSBwb3NzaWJpbGl0eSB0byBkbyBjZXJ0YWluIGFjdGlvbnMgYWZ0ZXIgb3IgZHVyaW5nIHRoZSB1cHNlcnQgKHRyaWdnZXJFdmVudClcclxuICAgKiBAcmV0dXJuIGl0ZW0gaWQgZGVsZXRlZFxyXG4gICAqL1xyXG4gIGRlbGV0ZUl0ZW1zPFQgPSBhbnk+KGl0ZW1zOiBUIHwgVFtdLCBvcHRpb25zPzogR3JpZFNlcnZpY2VEZWxldGVPcHRpb24pOiBudW1iZXJbXSB8IHN0cmluZ1tdIHtcclxuICAgIG9wdGlvbnMgPSB7IC4uLkdyaWRTZXJ2aWNlRGVsZXRlT3B0aW9uRGVmYXVsdHMsIC4uLm9wdGlvbnMgfTtcclxuICAgIGNvbnN0IGlkUHJvcE5hbWUgPSB0aGlzLl9ncmlkT3B0aW9ucy5kYXRhc2V0SWRQcm9wZXJ0eU5hbWUgfHwgJ2lkJztcclxuXHJcbiAgICAvLyB3aGVuIGl0J3Mgbm90IGFuIGFycmF5LCB3ZSBjYW4gY2FsbCBkaXJlY3RseSB0aGUgc2luZ2xlIGl0ZW0gZGVsZXRlXHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XHJcbiAgICAgIHRoaXMuZGVsZXRlSXRlbTxUPihpdGVtcywgb3B0aW9ucyk7XHJcbiAgICAgIHJldHVybiBbaXRlbXNbaWRQcm9wTmFtZV1dO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2RhdGFWaWV3LmJlZ2luVXBkYXRlKCk7XHJcbiAgICBjb25zdCBpdGVtSWRzID0gW107XHJcbiAgICBpdGVtcy5mb3JFYWNoKChpdGVtOiBUKSA9PiB7XHJcbiAgICAgIGlmIChpdGVtICYmIGl0ZW1baWRQcm9wTmFtZV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGl0ZW1JZHMucHVzaChpdGVtW2lkUHJvcE5hbWVdKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmRlbGV0ZUl0ZW08VD4oaXRlbSwgeyAuLi5vcHRpb25zLCB0cmlnZ2VyRXZlbnQ6IGZhbHNlIH0pO1xyXG4gICAgfSk7XHJcbiAgICB0aGlzLl9kYXRhVmlldy5lbmRVcGRhdGUoKTtcclxuXHJcbiAgICAvLyBkbyB3ZSB3YW50IHRvIHRyaWdnZXIgYW4gZXZlbnQgYWZ0ZXIgZGVsZXRpbmcgdGhlIGl0ZW1cclxuICAgIGlmIChvcHRpb25zLnRyaWdnZXJFdmVudCkge1xyXG4gICAgICB0aGlzLm9uSXRlbURlbGV0ZWQubmV4dChpdGVtcyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXRlbUlkcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlbGV0ZSBhbiBleGlzdGluZyBpdGVtIGZyb20gdGhlIGRhdGFncmlkIChkYXRhVmlldykgYnkgaXQncyBpZFxyXG4gICAqIEBwYXJhbSBpdGVtSWQ6IGl0ZW0gdW5pcXVlIGlkXHJcbiAgICogQHBhcmFtIG9wdGlvbnM6IHByb3ZpZGUgdGhlIHBvc3NpYmlsaXR5IHRvIGRvIGNlcnRhaW4gYWN0aW9ucyBhZnRlciBvciBkdXJpbmcgdGhlIHVwc2VydCAodHJpZ2dlckV2ZW50KVxyXG4gICAqIEByZXR1cm4gaXRlbSBpZCBkZWxldGVkXHJcbiAgICovXHJcbiAgZGVsZXRlSXRlbUJ5SWQoaXRlbUlkOiBzdHJpbmcgfCBudW1iZXIsIG9wdGlvbnM/OiBHcmlkU2VydmljZURlbGV0ZU9wdGlvbik6IG51bWJlciB8IHN0cmluZyB7XHJcbiAgICBvcHRpb25zID0geyAuLi5HcmlkU2VydmljZURlbGV0ZU9wdGlvbkRlZmF1bHRzLCAuLi5vcHRpb25zIH07XHJcblxyXG4gICAgaWYgKGl0ZW1JZCA9PT0gbnVsbCB8fCBpdGVtSWQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBkZWxldGUgYSByb3cgd2l0aG91dCBhIHZhbGlkIFwiaWRcImApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHdoZW4gdXNlciBoYXMgcm93IHNlbGVjdGlvbiBlbmFibGVkLCB3ZSBzaG91bGQgY2xlYXIgYW55IHNlbGVjdGlvbiB0byBhdm9pZCBjb25mdXNpb24gYWZ0ZXIgYSBkZWxldGVcclxuICAgIGNvbnN0IGlzU3luY0dyaWRTZWxlY3Rpb25FbmFibGVkID0gdGhpcy5ncmlkU3RhdGVTZXJ2aWNlICYmIHRoaXMuZ3JpZFN0YXRlU2VydmljZS5uZWVkVG9QcmVzZXJ2ZVJvd1NlbGVjdGlvbigpIHx8IGZhbHNlO1xyXG4gICAgaWYgKCFpc1N5bmNHcmlkU2VsZWN0aW9uRW5hYmxlZCAmJiB0aGlzLl9ncmlkICYmIHRoaXMuX2dyaWRPcHRpb25zICYmICh0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVDaGVja2JveFNlbGVjdG9yIHx8IHRoaXMuX2dyaWRPcHRpb25zLmVuYWJsZVJvd1NlbGVjdGlvbikpIHtcclxuICAgICAgdGhpcy5zZXRTZWxlY3RlZFJvd3MoW10pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGRlbGV0ZSB0aGUgaXRlbSBmcm9tIHRoZSBkYXRhVmlld1xyXG4gICAgdGhpcy5fZGF0YVZpZXcuZGVsZXRlSXRlbShpdGVtSWQpO1xyXG5cclxuICAgIC8vIGRvIHdlIHdhbnQgdG8gdHJpZ2dlciBhbiBldmVudCBhZnRlciBkZWxldGluZyB0aGUgaXRlbVxyXG4gICAgaWYgKG9wdGlvbnMudHJpZ2dlckV2ZW50KSB7XHJcbiAgICAgIHRoaXMub25JdGVtRGVsZXRlZC5uZXh0KGl0ZW1JZCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXRlbUlkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVsZXRlIGFuIGFycmF5IG9mIGV4aXN0aW5nIGl0ZW1zIGZyb20gdGhlIGRhdGFncmlkXHJcbiAgICogQHBhcmFtIGl0ZW1JZHMgYXJyYXkgb2YgaXRlbSB1bmlxdWUgSURzXHJcbiAgICogQHBhcmFtIG9wdGlvbnM6IHByb3ZpZGUgdGhlIHBvc3NpYmlsaXR5IHRvIGRvIGNlcnRhaW4gYWN0aW9ucyBhZnRlciBvciBkdXJpbmcgdGhlIHVwc2VydCAodHJpZ2dlckV2ZW50KVxyXG4gICAqL1xyXG4gIGRlbGV0ZUl0ZW1CeUlkcyhpdGVtSWRzOiBudW1iZXJbXSB8IHN0cmluZ1tdLCBvcHRpb25zPzogR3JpZFNlcnZpY2VEZWxldGVPcHRpb24pOiBudW1iZXJbXSB8IHN0cmluZ1tdIHtcclxuICAgIG9wdGlvbnMgPSB7IC4uLkdyaWRTZXJ2aWNlRGVsZXRlT3B0aW9uRGVmYXVsdHMsIC4uLm9wdGlvbnMgfTtcclxuXHJcbiAgICAvLyB3aGVuIGl0J3Mgbm90IGFuIGFycmF5LCB3ZSBjYW4gY2FsbCBkaXJlY3RseSB0aGUgc2luZ2xlIGl0ZW0gZGVsZXRlXHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtSWRzKSkge1xyXG4gICAgICB0aGlzLl9kYXRhVmlldy5iZWdpblVwZGF0ZSgpO1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1JZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoaXRlbUlkc1tpXSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgdGhpcy5kZWxldGVJdGVtQnlJZChpdGVtSWRzW2ldLCB7IHRyaWdnZXJFdmVudDogZmFsc2UgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2RhdGFWaWV3LmVuZFVwZGF0ZSgpO1xyXG5cclxuICAgICAgLy8gZG8gd2Ugd2FudCB0byB0cmlnZ2VyIGFuIGV2ZW50IGFmdGVyIGRlbGV0aW5nIHRoZSBpdGVtXHJcbiAgICAgIGlmIChvcHRpb25zLnRyaWdnZXJFdmVudCkge1xyXG4gICAgICAgIHRoaXMub25JdGVtRGVsZXRlZC5uZXh0KGl0ZW1JZHMpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBpdGVtSWRzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxuXHJcbiAgLyoqIEBkZXByZWNhdGVkIHBsZWFzZSB1c2UgXCJ1cGRhdGVJdGVtXCIgbWV0aG9kIGluc3RlYWQgKi9cclxuICB1cGRhdGVEYXRhR3JpZEl0ZW0oaXRlbTogYW55LCBzaG91bGRIaWdobGlnaHRSb3cgPSB0cnVlLCBzaG91bGRUcmlnZ2VyRXZlbnQgPSB0cnVlLCBzaG91bGRTZWxlY3RSb3cgPSB0cnVlKTogbnVtYmVyIHtcclxuICAgIGNvbnNvbGUud2FybignW0FuZ3VsYXItU2xpY2tncmlkIC0gR3JpZFNlcnZpY2VdIHBsZWFzZSBjb25zaWRlciB1c2luZyB0aGUgbmV3IFwidXBkYXRlSXRlbVwiIG1ldGhvZCBzaW5jZSBcInVwZGF0ZURhdGFHcmlkSXRlbVwiIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiB0aGUgZnV0dXJlLicpO1xyXG4gICAgcmV0dXJuIHRoaXMudXBkYXRlSXRlbShpdGVtLCB7IGhpZ2hsaWdodFJvdzogc2hvdWxkSGlnaGxpZ2h0Um93LCB0cmlnZ2VyRXZlbnQ6IHNob3VsZFRyaWdnZXJFdmVudCwgc2VsZWN0Um93OiBzaG91bGRTZWxlY3RSb3cgfSk7XHJcbiAgfVxyXG5cclxuICAvKiogQGRlcHJlY2F0ZWQgcGxlYXNlIHVzZSBcInVwZGF0ZUl0ZW1zXCIgbWV0aG9kIGluc3RlYWQgKi9cclxuICB1cGRhdGVEYXRhR3JpZEl0ZW1zKGl0ZW1zOiBhbnkgfCBhbnlbXSwgc2hvdWxkSGlnaGxpZ2h0Um93ID0gdHJ1ZSwgc2hvdWxkVHJpZ2dlckV2ZW50ID0gdHJ1ZSwgc2hvdWxkU2VsZWN0Um93ID0gdHJ1ZSk6IG51bWJlcltdIHtcclxuICAgIGNvbnNvbGUud2FybignW0FuZ3VsYXItU2xpY2tncmlkIC0gR3JpZFNlcnZpY2VdIHBsZWFzZSBjb25zaWRlciB1c2luZyB0aGUgbmV3IFwidXBkYXRlSXRlbXNcIiBtZXRob2Qgc2luY2UgXCJ1cGRhdGVEYXRhR3JpZEl0ZW1zXCIgd2lsbCBiZSBkZXByZWNhdGVkIGluIHRoZSBmdXR1cmUuJyk7XHJcbiAgICByZXR1cm4gdGhpcy51cGRhdGVJdGVtcyhpdGVtcywgeyBoaWdobGlnaHRSb3c6IHNob3VsZEhpZ2hsaWdodFJvdywgdHJpZ2dlckV2ZW50OiBzaG91bGRUcmlnZ2VyRXZlbnQsIHNlbGVjdFJvdzogc2hvdWxkU2VsZWN0Um93IH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqIEBkZXByZWNhdGVkIHBsZWFzZSB1c2UgXCJ1cGRhdGVJdGVtQnlJZFwiIG1ldGhvZCBpbnN0ZWFkICovXHJcbiAgdXBkYXRlRGF0YUdyaWRJdGVtQnlJZChpdGVtSWQ6IG51bWJlciB8IHN0cmluZywgaXRlbTogYW55LCBzaG91bGRIaWdobGlnaHRSb3cgPSB0cnVlLCBzaG91bGRUcmlnZ2VyRXZlbnQgPSB0cnVlLCBzaG91bGRTZWxlY3RSb3cgPSB0cnVlKTogbnVtYmVyIHtcclxuICAgIGNvbnNvbGUud2FybignW0FuZ3VsYXItU2xpY2tncmlkIC0gR3JpZFNlcnZpY2VdIHBsZWFzZSBjb25zaWRlciB1c2luZyB0aGUgbmV3IFwidXBkYXRlSXRlbUJ5SWRcIiBtZXRob2Qgc2luY2UgXCJ1cGRhdGVEYXRhR3JpZEl0ZW1CeUlkXCIgd2lsbCBiZSBkZXByZWNhdGVkIGluIHRoZSBmdXR1cmUuJyk7XHJcbiAgICByZXR1cm4gdGhpcy51cGRhdGVJdGVtQnlJZChpdGVtSWQsIGl0ZW0sIHsgaGlnaGxpZ2h0Um93OiBzaG91bGRIaWdobGlnaHRSb3csIHRyaWdnZXJFdmVudDogc2hvdWxkVHJpZ2dlckV2ZW50LCBzZWxlY3RSb3c6IHNob3VsZFNlbGVjdFJvdyB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBhbiBleGlzdGluZyBpdGVtIHdpdGggbmV3IHByb3BlcnRpZXMgaW5zaWRlIHRoZSBkYXRhZ3JpZFxyXG4gICAqIEBwYXJhbSBpdGVtIG9iamVjdCB3aGljaCBtdXN0IGNvbnRhaW4gYSB1bmlxdWUgXCJpZFwiIHByb3BlcnR5IGFuZCBhbnkgb3RoZXIgc3VpdGFibGUgcHJvcGVydGllc1xyXG4gICAqIEBwYXJhbSBvcHRpb25zOiBwcm92aWRlIHRoZSBwb3NzaWJpbGl0eSB0byBkbyBjZXJ0YWluIGFjdGlvbnMgYWZ0ZXIgb3IgZHVyaW5nIHRoZSB1cHNlcnQgKGhpZ2hsaWdodFJvdywgc2VsZWN0Um93LCB0cmlnZ2VyRXZlbnQpXHJcbiAgICogQHJldHVybiBncmlkIHJvdyBpbmRleFxyXG4gICAqL1xyXG4gIHVwZGF0ZUl0ZW08VCA9IGFueT4oaXRlbTogVCwgb3B0aW9ucz86IEdyaWRTZXJ2aWNlVXBkYXRlT3B0aW9uKTogbnVtYmVyIHtcclxuICAgIG9wdGlvbnMgPSB7IC4uLkdyaWRTZXJ2aWNlVXBkYXRlT3B0aW9uRGVmYXVsdHMsIC4uLm9wdGlvbnMgfTtcclxuICAgIGNvbnN0IGlkUHJvcE5hbWUgPSB0aGlzLl9ncmlkT3B0aW9ucy5kYXRhc2V0SWRQcm9wZXJ0eU5hbWUgfHwgJ2lkJztcclxuICAgIGNvbnN0IGl0ZW1JZCA9ICghaXRlbSB8fCAhKGlkUHJvcE5hbWUgaW4gaXRlbSkpID8gdW5kZWZpbmVkIDogaXRlbVtpZFByb3BOYW1lXTtcclxuXHJcbiAgICBpZiAoaXRlbUlkID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYWxsaW5nIFVwZGF0ZSBvZiBhbiBpdGVtIHJlcXVpcmVzIHRoZSBpdGVtIHRvIGluY2x1ZGUgYW4gXCIke2lkUHJvcE5hbWV9XCIgcHJvcGVydHlgKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy51cGRhdGVJdGVtQnlJZDxUPihpdGVtSWQsIGl0ZW0sIG9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIGFuIGFycmF5IG9mIGV4aXN0aW5nIGl0ZW1zIHdpdGggbmV3IHByb3BlcnRpZXMgaW5zaWRlIHRoZSBkYXRhZ3JpZFxyXG4gICAqIEBwYXJhbSBpdGVtIG9iamVjdCBhcnJheXMsIHdoaWNoIG11c3QgY29udGFpbiB1bmlxdWUgXCJpZFwiIHByb3BlcnR5IGFuZCBhbnkgb3RoZXIgc3VpdGFibGUgcHJvcGVydGllc1xyXG4gICAqIEBwYXJhbSBvcHRpb25zOiBwcm92aWRlIHRoZSBwb3NzaWJpbGl0eSB0byBkbyBjZXJ0YWluIGFjdGlvbnMgYWZ0ZXIgb3IgZHVyaW5nIHRoZSB1cHNlcnQgKGhpZ2hsaWdodFJvdywgc2VsZWN0Um93LCB0cmlnZ2VyRXZlbnQpXHJcbiAgICogQHJldHVybiBncmlkIHJvdyBpbmRleGVzXHJcbiAgICovXHJcbiAgdXBkYXRlSXRlbXM8VCA9IGFueT4oaXRlbXM6IFQgfCBUW10sIG9wdGlvbnM/OiBHcmlkU2VydmljZVVwZGF0ZU9wdGlvbik6IG51bWJlcltdIHtcclxuICAgIG9wdGlvbnMgPSB7IC4uLkdyaWRTZXJ2aWNlVXBkYXRlT3B0aW9uRGVmYXVsdHMsIC4uLm9wdGlvbnMgfTtcclxuXHJcbiAgICAvLyB3aGVuIGl0J3Mgbm90IGFuIGFycmF5LCB3ZSBjYW4gY2FsbCBkaXJlY3RseSB0aGUgc2luZ2xlIGl0ZW0gdXBkYXRlXHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XHJcbiAgICAgIHJldHVybiBbdGhpcy51cGRhdGVJdGVtPFQ+KGl0ZW1zLCBvcHRpb25zKV07XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHRoaXMuX2RhdGFWaWV3LmJlZ2luVXBkYXRlKCk7XHJcbiAgICBjb25zdCBncmlkUm93TnVtYmVyczogbnVtYmVyW10gPSBbXTtcclxuICAgIGl0ZW1zLmZvckVhY2goKGl0ZW06IGFueSkgPT4ge1xyXG4gICAgICBncmlkUm93TnVtYmVycy5wdXNoKHRoaXMudXBkYXRlSXRlbTxUPihpdGVtLCB7IC4uLm9wdGlvbnMsIGhpZ2hsaWdodFJvdzogZmFsc2UsIHNlbGVjdFJvdzogZmFsc2UsIHRyaWdnZXJFdmVudDogZmFsc2UgfSkpO1xyXG4gICAgfSk7XHJcbiAgICB0aGlzLl9kYXRhVmlldy5lbmRVcGRhdGUoKTtcclxuXHJcbiAgICAvLyBvbmx5IGhpZ2hsaWdodCBhdCB0aGUgZW5kLCBhbGwgYXQgb25jZVxyXG4gICAgLy8gd2UgaGF2ZSB0byBkbyB0aGlzIGJlY2F1c2UgZG9pbmcgaGlnaGxpZ2h0IDEgYnkgMSB3b3VsZCBvbmx5IHJlLXNlbGVjdCB0aGUgbGFzdCBoaWdobGlnaHRlZCByb3cgd2hpY2ggaXMgd3JvbmcgYmVoYXZpb3JcclxuICAgIGlmIChvcHRpb25zLmhpZ2hsaWdodFJvdykge1xyXG4gICAgICB0aGlzLmhpZ2hsaWdodFJvdyhncmlkUm93TnVtYmVycyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc2VsZWN0IHRoZSByb3cgaW4gdGhlIGdyaWRcclxuICAgIGlmIChvcHRpb25zLnNlbGVjdFJvdyAmJiB0aGlzLl9ncmlkT3B0aW9ucyAmJiAodGhpcy5fZ3JpZE9wdGlvbnMuZW5hYmxlQ2hlY2tib3hTZWxlY3RvciB8fCB0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVSb3dTZWxlY3Rpb24pKSB7XHJcbiAgICAgIHRoaXMuc2V0U2VsZWN0ZWRSb3dzKGdyaWRSb3dOdW1iZXJzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBkbyB3ZSB3YW50IHRvIHRyaWdnZXIgYW4gZXZlbnQgYWZ0ZXIgdXBkYXRpbmcgdGhlIGl0ZW1cclxuICAgIGlmIChvcHRpb25zLnRyaWdnZXJFdmVudCkge1xyXG4gICAgICB0aGlzLm9uSXRlbVVwZGF0ZWQubmV4dChpdGVtcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGdyaWRSb3dOdW1iZXJzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIGFuIGV4aXN0aW5nIGl0ZW0gaW4gdGhlIGRhdGFncmlkIGJ5IGl0J3MgaWQgYW5kIG5ldyBwcm9wZXJ0aWVzXHJcbiAgICogQHBhcmFtIGl0ZW1JZDogaXRlbSB1bmlxdWUgaWRcclxuICAgKiBAcGFyYW0gaXRlbSBvYmplY3Qgd2hpY2ggbXVzdCBjb250YWluIGEgdW5pcXVlIFwiaWRcIiBwcm9wZXJ0eSBhbmQgYW55IG90aGVyIHN1aXRhYmxlIHByb3BlcnRpZXNcclxuICAgKiBAcGFyYW0gb3B0aW9uczogcHJvdmlkZSB0aGUgcG9zc2liaWxpdHkgdG8gZG8gY2VydGFpbiBhY3Rpb25zIGFmdGVyIG9yIGR1cmluZyB0aGUgdXBzZXJ0IChoaWdobGlnaHRSb3csIHNlbGVjdFJvdywgdHJpZ2dlckV2ZW50KVxyXG4gICAqIEByZXR1cm4gZ3JpZCByb3cgbnVtYmVyXHJcbiAgICovXHJcbiAgdXBkYXRlSXRlbUJ5SWQ8VCA9IGFueT4oaXRlbUlkOiBudW1iZXIgfCBzdHJpbmcsIGl0ZW06IFQsIG9wdGlvbnM/OiBHcmlkU2VydmljZVVwZGF0ZU9wdGlvbik6IG51bWJlciB7XHJcbiAgICBvcHRpb25zID0geyAuLi5HcmlkU2VydmljZVVwZGF0ZU9wdGlvbkRlZmF1bHRzLCAuLi5vcHRpb25zIH07XHJcbiAgICBpZiAoaXRlbUlkID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgdXBkYXRlIGEgcm93IHdpdGhvdXQgYSB2YWxpZCBcImlkXCJgKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHJvd051bWJlciA9IHRoaXMuX2RhdGFWaWV3LmdldFJvd0J5SWQoaXRlbUlkKTtcclxuXHJcbiAgICBpZiAoIWl0ZW0gfHwgcm93TnVtYmVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgaXRlbSB0byB1cGRhdGUgaW4gdGhlIGdyaWQgd2FzIG5vdCBmb3VuZCB3aXRoIGlkOiAke2l0ZW1JZH1gKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fZGF0YVZpZXcuZ2V0SWR4QnlJZChpdGVtSWQpICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgLy8gVXBkYXRlIHRoZSBpdGVtIGl0c2VsZiBpbnNpZGUgdGhlIGRhdGFWaWV3XHJcbiAgICAgIHRoaXMuX2RhdGFWaWV3LnVwZGF0ZUl0ZW0oaXRlbUlkLCBpdGVtKTtcclxuICAgICAgdGhpcy5fZ3JpZC51cGRhdGVSb3cocm93TnVtYmVyKTtcclxuXHJcbiAgICAgIC8vIGRvIHdlIHdhbnQgdG8gc2Nyb2xsIHRvIHRoZSByb3cgc28gdGhhdCBpdCBzaG93cyBpbiB0aGUgVmlld3BvcnQgKFVJKVxyXG4gICAgICBpZiAob3B0aW9ucy5zY3JvbGxSb3dJbnRvVmlldykge1xyXG4gICAgICAgIHRoaXMuX2dyaWQuc2Nyb2xsUm93SW50b1ZpZXcocm93TnVtYmVyKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gaGlnaGxpZ2h0IHRoZSByb3cgd2UganVzdCB1cGRhdGVkLCBpZiBkZWZpbmVkXHJcbiAgICAgIGlmIChvcHRpb25zLmhpZ2hsaWdodFJvdykge1xyXG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0Um93KHJvd051bWJlcik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHNlbGVjdCB0aGUgcm93IGluIHRoZSBncmlkXHJcbiAgICAgIGlmIChvcHRpb25zLnNlbGVjdFJvdyAmJiB0aGlzLl9ncmlkT3B0aW9ucyAmJiAodGhpcy5fZ3JpZE9wdGlvbnMuZW5hYmxlQ2hlY2tib3hTZWxlY3RvciB8fCB0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVSb3dTZWxlY3Rpb24pKSB7XHJcbiAgICAgICAgdGhpcy5zZXRTZWxlY3RlZFJvdyhyb3dOdW1iZXIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBkbyB3ZSB3YW50IHRvIHRyaWdnZXIgYW4gZXZlbnQgYWZ0ZXIgdXBkYXRpbmcgdGhlIGl0ZW1cclxuICAgICAgaWYgKG9wdGlvbnMudHJpZ2dlckV2ZW50KSB7XHJcbiAgICAgICAgdGhpcy5vbkl0ZW1VcGRhdGVkLm5leHQoaXRlbSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByb3dOdW1iZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbnNlcnQgYSByb3cgaW50byB0aGUgZ3JpZCBpZiBpdCBkb2Vzbid0IGFscmVhZHkgZXhpc3Qgb3IgdXBkYXRlIGlmIGl0IGRvZXMuXHJcbiAgICogQHBhcmFtIGl0ZW0gb2JqZWN0IHdoaWNoIG11c3QgY29udGFpbiBhIHVuaXF1ZSBcImlkXCIgcHJvcGVydHkgYW5kIGFueSBvdGhlciBzdWl0YWJsZSBwcm9wZXJ0aWVzXHJcbiAgICogQHBhcmFtIG9wdGlvbnM6IHByb3ZpZGUgdGhlIHBvc3NpYmlsaXR5IHRvIGRvIGNlcnRhaW4gYWN0aW9ucyBhZnRlciBvciBkdXJpbmcgdGhlIHVwc2VydCAoaGlnaGxpZ2h0Um93LCByZXNvcnRHcmlkLCBzZWxlY3RSb3csIHRyaWdnZXJFdmVudClcclxuICAgKi9cclxuICB1cHNlcnRJdGVtPFQgPSBhbnk+KGl0ZW06IFQsIG9wdGlvbnM/OiBHcmlkU2VydmljZUluc2VydE9wdGlvbik6IHsgYWRkZWQ6IG51bWJlciwgdXBkYXRlZDogbnVtYmVyIH0ge1xyXG4gICAgb3B0aW9ucyA9IHsgLi4uR3JpZFNlcnZpY2VJbnNlcnRPcHRpb25EZWZhdWx0cywgLi4ub3B0aW9ucyB9O1xyXG4gICAgY29uc3QgaWRQcm9wTmFtZSA9IHRoaXMuX2dyaWRPcHRpb25zLmRhdGFzZXRJZFByb3BlcnR5TmFtZSB8fCAnaWQnO1xyXG4gICAgY29uc3QgaXRlbUlkID0gKCFpdGVtIHx8ICEoaWRQcm9wTmFtZSBpbiBpdGVtKSkgPyB1bmRlZmluZWQgOiBpdGVtW2lkUHJvcE5hbWVdO1xyXG5cclxuICAgIGlmIChpdGVtSWQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbGxpbmcgVXBzZXJ0IG9mIGFuIGl0ZW0gcmVxdWlyZXMgdGhlIGl0ZW0gdG8gaW5jbHVkZSBhbiBcIiR7aWRQcm9wTmFtZX1cIiBwcm9wZXJ0eWApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLnVwc2VydEl0ZW1CeUlkPFQ+KGl0ZW1JZCwgaXRlbSwgb3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgYW4gYXJyYXkgb2YgZXhpc3RpbmcgaXRlbXMgd2l0aCBuZXcgcHJvcGVydGllcyBpbnNpZGUgdGhlIGRhdGFncmlkXHJcbiAgICogQHBhcmFtIGl0ZW0gb2JqZWN0IGFycmF5cywgd2hpY2ggbXVzdCBjb250YWluIHVuaXF1ZSBcImlkXCIgcHJvcGVydHkgYW5kIGFueSBvdGhlciBzdWl0YWJsZSBwcm9wZXJ0aWVzXHJcbiAgICogQHBhcmFtIG9wdGlvbnM6IHByb3ZpZGUgdGhlIHBvc3NpYmlsaXR5IHRvIGRvIGNlcnRhaW4gYWN0aW9ucyBhZnRlciBvciBkdXJpbmcgdGhlIHVwc2VydCAoaGlnaGxpZ2h0Um93LCByZXNvcnRHcmlkLCBzZWxlY3RSb3csIHRyaWdnZXJFdmVudClcclxuICAgKiBAcmV0dXJuIHJvdyBudW1iZXJzIGluIHRoZSBncmlkXHJcbiAgICovXHJcbiAgdXBzZXJ0SXRlbXM8VCA9IGFueT4oaXRlbXM6IFQgfCBUW10sIG9wdGlvbnM/OiBHcmlkU2VydmljZUluc2VydE9wdGlvbik6IHsgYWRkZWQ6IG51bWJlciwgdXBkYXRlZDogbnVtYmVyIH1bXSB7XHJcbiAgICBvcHRpb25zID0geyAuLi5HcmlkU2VydmljZUluc2VydE9wdGlvbkRlZmF1bHRzLCAuLi5vcHRpb25zIH07XHJcbiAgICAvLyB3aGVuIGl0J3Mgbm90IGFuIGFycmF5LCB3ZSBjYW4gY2FsbCBkaXJlY3RseSB0aGUgc2luZ2xlIGl0ZW0gdXBkYXRlXHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XHJcbiAgICAgIHJldHVybiBbdGhpcy51cHNlcnRJdGVtPFQ+KGl0ZW1zLCBvcHRpb25zKV07XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fZGF0YVZpZXcuYmVnaW5VcGRhdGUoKTtcclxuICAgIGNvbnN0IHVwc2VydGVkUm93czogeyBhZGRlZDogbnVtYmVyLCB1cGRhdGVkOiBudW1iZXIgfVtdID0gW107XHJcbiAgICBpdGVtcy5mb3JFYWNoKChpdGVtOiBUKSA9PiB7XHJcbiAgICAgIHVwc2VydGVkUm93cy5wdXNoKHRoaXMudXBzZXJ0SXRlbTxUPihpdGVtLCB7IC4uLm9wdGlvbnMsIGhpZ2hsaWdodFJvdzogZmFsc2UsIHJlc29ydEdyaWQ6IGZhbHNlLCBzZWxlY3RSb3c6IGZhbHNlLCB0cmlnZ2VyRXZlbnQ6IGZhbHNlIH0pKTtcclxuICAgIH0pO1xyXG4gICAgdGhpcy5fZGF0YVZpZXcuZW5kVXBkYXRlKCk7XHJcblxyXG4gICAgY29uc3Qgcm93TnVtYmVycyA9IHVwc2VydGVkUm93cy5tYXAoKHVwc2VydFJvdykgPT4gdXBzZXJ0Um93LmFkZGVkICE9PSB1bmRlZmluZWQgPyB1cHNlcnRSb3cuYWRkZWQgOiB1cHNlcnRSb3cudXBkYXRlZCk7XHJcbiAgICAvLyBvbmx5IGhpZ2hsaWdodCBhdCB0aGUgZW5kLCBhbGwgYXQgb25jZVxyXG4gICAgLy8gd2UgaGF2ZSB0byBkbyB0aGlzIGJlY2F1c2UgZG9pbmcgaGlnaGxpZ2h0IDEgYnkgMSB3b3VsZCBvbmx5IHJlLXNlbGVjdCB0aGUgbGFzdCBoaWdobGlnaHRlZCByb3cgd2hpY2ggaXMgd3JvbmcgYmVoYXZpb3JcclxuICAgIGlmIChvcHRpb25zLmhpZ2hsaWdodFJvdykge1xyXG4gICAgICB0aGlzLmhpZ2hsaWdodFJvdyhyb3dOdW1iZXJzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBzZWxlY3QgdGhlIHJvdyBpbiB0aGUgZ3JpZFxyXG4gICAgaWYgKG9wdGlvbnMuc2VsZWN0Um93ICYmIHRoaXMuX2dyaWRPcHRpb25zICYmICh0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVDaGVja2JveFNlbGVjdG9yIHx8IHRoaXMuX2dyaWRPcHRpb25zLmVuYWJsZVJvd1NlbGVjdGlvbikpIHtcclxuICAgICAgdGhpcy5zZXRTZWxlY3RlZFJvd3Mocm93TnVtYmVycyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZG8gd2Ugd2FudCB0byB0cmlnZ2VyIGFuIGV2ZW50IGFmdGVyIHVwZGF0aW5nIHRoZSBpdGVtXHJcbiAgICBpZiAob3B0aW9ucy50cmlnZ2VyRXZlbnQpIHtcclxuICAgICAgdGhpcy5vbkl0ZW1VcHNlcnRlZC5uZXh0KGl0ZW1zKTtcclxuICAgICAgY29uc3QgYWRkZWRJdGVtcyA9IHVwc2VydGVkUm93cy5maWx0ZXIoKHVwc2VydFJvdykgPT4gdXBzZXJ0Um93LmFkZGVkICE9PSB1bmRlZmluZWQpO1xyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhZGRlZEl0ZW1zKSAmJiBhZGRlZEl0ZW1zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB0aGlzLm9uSXRlbUFkZGVkLm5leHQoYWRkZWRJdGVtcyk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgdXBkYXRlZEl0ZW1zID0gdXBzZXJ0ZWRSb3dzLmZpbHRlcigodXBzZXJ0Um93KSA9PiB1cHNlcnRSb3cudXBkYXRlZCAhPT0gdW5kZWZpbmVkKTtcclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodXBkYXRlZEl0ZW1zKSAmJiB1cGRhdGVkSXRlbXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHRoaXMub25JdGVtVXBkYXRlZC5uZXh0KHVwZGF0ZWRJdGVtcyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB1cHNlcnRlZFJvd3M7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgYW4gZXhpc3RpbmcgaXRlbSBpbiB0aGUgZGF0YWdyaWQgYnkgaXQncyBpZCBhbmQgbmV3IHByb3BlcnRpZXNcclxuICAgKiBAcGFyYW0gaXRlbUlkOiBpdGVtIHVuaXF1ZSBpZFxyXG4gICAqIEBwYXJhbSBpdGVtIG9iamVjdCB3aGljaCBtdXN0IGNvbnRhaW4gYSB1bmlxdWUgXCJpZFwiIHByb3BlcnR5IGFuZCBhbnkgb3RoZXIgc3VpdGFibGUgcHJvcGVydGllc1xyXG4gICAqIEBwYXJhbSBvcHRpb25zOiBwcm92aWRlIHRoZSBwb3NzaWJpbGl0eSB0byBkbyBjZXJ0YWluIGFjdGlvbnMgYWZ0ZXIgb3IgZHVyaW5nIHRoZSB1cHNlcnQgKGhpZ2hsaWdodFJvdywgcmVzb3J0R3JpZCwgc2VsZWN0Um93LCB0cmlnZ2VyRXZlbnQpXHJcbiAgICogQHJldHVybiBncmlkIHJvdyBudW1iZXIgaW4gdGhlIGdyaWRcclxuICAgKi9cclxuICB1cHNlcnRJdGVtQnlJZDxUID0gYW55PihpdGVtSWQ6IG51bWJlciB8IHN0cmluZywgaXRlbTogVCwgb3B0aW9ucz86IEdyaWRTZXJ2aWNlSW5zZXJ0T3B0aW9uKTogeyBhZGRlZDogbnVtYmVyLCB1cGRhdGVkOiBudW1iZXIgfSB7XHJcbiAgICBsZXQgaXNJdGVtQWRkZWQgPSBmYWxzZTtcclxuICAgIG9wdGlvbnMgPSB7IC4uLkdyaWRTZXJ2aWNlSW5zZXJ0T3B0aW9uRGVmYXVsdHMsIC4uLm9wdGlvbnMgfTtcclxuICAgIGlmIChpdGVtSWQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbGxpbmcgVXBzZXJ0IG9mIGFuIGl0ZW0gcmVxdWlyZXMgdGhlIGl0ZW0gdG8gaW5jbHVkZSBhIHZhbGlkIGFuZCB1bmlxdWUgXCJpZFwiIHByb3BlcnR5YCk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHJvd051bWJlckFkZGVkOiBudW1iZXI7XHJcbiAgICBsZXQgcm93TnVtYmVyVXBkYXRlZDogbnVtYmVyO1xyXG4gICAgaWYgKHRoaXMuX2RhdGFWaWV3LmdldFJvd0J5SWQoaXRlbUlkKSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJvd051bWJlckFkZGVkID0gdGhpcy5hZGRJdGVtPFQ+KGl0ZW0sIG9wdGlvbnMpO1xyXG4gICAgICBpc0l0ZW1BZGRlZCA9IHRydWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByb3dOdW1iZXJVcGRhdGVkID0gdGhpcy51cGRhdGVJdGVtPFQ+KGl0ZW0sIHsgaGlnaGxpZ2h0Um93OiBvcHRpb25zLmhpZ2hsaWdodFJvdywgc2VsZWN0Um93OiBvcHRpb25zLnNlbGVjdFJvdywgdHJpZ2dlckV2ZW50OiBvcHRpb25zLnRyaWdnZXJFdmVudCB9KTtcclxuICAgICAgaXNJdGVtQWRkZWQgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBkbyB3ZSB3YW50IHRvIHRyaWdnZXIgYW4gZXZlbnQgYWZ0ZXIgdXBkYXRpbmcgdGhlIGl0ZW1cclxuICAgIGlmIChvcHRpb25zLnRyaWdnZXJFdmVudCkge1xyXG4gICAgICB0aGlzLm9uSXRlbVVwc2VydGVkLm5leHQoaXRlbSk7XHJcbiAgICAgIGlzSXRlbUFkZGVkID8gdGhpcy5vbkl0ZW1BZGRlZC5uZXh0KGl0ZW0pIDogdGhpcy5vbkl0ZW1VcGRhdGVkLm5leHQoaXRlbSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBhZGRlZDogcm93TnVtYmVyQWRkZWQsIHVwZGF0ZWQ6IHJvd051bWJlclVwZGF0ZWQgfTtcclxuICB9XHJcbn1cclxuIl19