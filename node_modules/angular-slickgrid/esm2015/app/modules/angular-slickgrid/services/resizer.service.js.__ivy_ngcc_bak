import { Subject } from 'rxjs';
// global constants, height/width are in pixels
const DATAGRID_MIN_HEIGHT = 180;
const DATAGRID_MIN_WIDTH = 300;
const DATAGRID_BOTTOM_PADDING = 20;
const DATAGRID_FOOTER_HEIGHT = 20;
const DATAGRID_PAGINATION_HEIGHT = 35;
export class ResizerService {
    constructor() {
        this._resizePaused = false;
        this.onGridAfterResize = new Subject();
        this.onGridBeforeResize = new Subject();
    }
    /** Getter for the Grid Options pulled through the Grid Object */
    get _gridOptions() {
        return (this._grid && this._grid.getOptions) ? this._grid.getOptions() : {};
    }
    get _gridUid() {
        return (this._grid && this._grid.getUID) ? this._grid.getUID() : this._gridOptions && this._gridOptions.gridId;
    }
    init(grid, fixedDimensions) {
        if (!grid || !this._gridOptions) {
            throw new Error(`
      Angular-Slickgrid resizer requires a valid Grid object and Grid Options defined.
      You can fix this by setting your gridOption to use "enableAutoResize" or create an instance of the ResizerService by calling bindAutoResizeDataGrid()`);
        }
        this._grid = grid;
        const containerNode = grid && grid.getContainerNode && grid.getContainerNode() || '';
        this._gridDomElm = $(containerNode);
        const autoResizeOptions = this._gridOptions && this._gridOptions.autoResize || {};
        this._gridContainerElm = (autoResizeOptions && autoResizeOptions.containerId) ? $(`#${autoResizeOptions.containerId}`) : $(`#${this._gridOptions.gridContainerId}`);
        if (fixedDimensions) {
            this._fixedHeight = fixedDimensions.height;
            this._fixedWidth = fixedDimensions.width;
        }
    }
    /** Bind an auto resize trigger on the datagrid, if that is enable then it will resize itself to the available space
     * Options: we could also provide a % factor to resize on each height/width independently
     */
    bindAutoResizeDataGrid(newSizes) {
        // if we can't find the grid to resize, return without binding anything
        if (this._gridDomElm === undefined || this._gridDomElm.offset() === undefined) {
            return null;
        }
        // -- 1st resize the datagrid size at first load (we need this because the .on event is not triggered on first load)
        // -- also we add a slight delay (in ms) so that we resize after the grid render is done
        this.resizeGrid(10, newSizes);
        // -- 2nd bind a trigger on the Window DOM element, so that it happens also when resizing after first load
        // -- bind auto-resize to Window object only if it exist
        $(window).on(`resize.grid.${this._gridUid}`, this.handleResizeGrid.bind(this, newSizes));
    }
    handleResizeGrid(newSizes, event) {
        this.onGridBeforeResize.next(event);
        if (!this._resizePaused) {
            // for some yet unknown reason, calling the resize twice removes any stuttering/flickering
            // when changing the height and makes it much smoother experience
            this.resizeGrid(0, newSizes);
            this.resizeGrid(0, newSizes);
        }
    }
    /**
     * Calculate the datagrid new height/width from the available space, also consider that a % factor might be applied to calculation
     * object gridOptions
     */
    calculateGridNewDimensions(gridOptions) {
        const autoResizeOptions = gridOptions && gridOptions.autoResize || {};
        if (!window || this._gridContainerElm === undefined || this._gridDomElm.offset() === undefined) {
            return null;
        }
        // calculate bottom padding
        // if using pagination, we need to add the pagination height to this bottom padding
        let bottomPadding = (autoResizeOptions && autoResizeOptions.bottomPadding !== undefined) ? autoResizeOptions.bottomPadding : DATAGRID_BOTTOM_PADDING;
        if (bottomPadding && gridOptions.enablePagination) {
            bottomPadding += DATAGRID_PAGINATION_HEIGHT;
        }
        // optionally show a custom footer with the data metrics (dataset length and last updated timestamp)
        if (bottomPadding && gridOptions.showCustomFooter) {
            bottomPadding += gridOptions.customFooterOptions && gridOptions.customFooterOptions.footerHeight || DATAGRID_FOOTER_HEIGHT;
        }
        let gridHeight = 0;
        let gridOffsetTop = 0;
        // which DOM element are we using to calculate the available size for the grid?
        if (autoResizeOptions.calculateAvailableSizeBy === 'container') {
            // uses the container's height to calculate grid height without any top offset
            gridHeight = this._gridContainerElm.height() || 0;
        }
        else {
            // uses the browser's window height with its top offset to calculate grid height
            gridHeight = window.innerHeight || 0;
            const coordOffsetTop = this._gridDomElm.offset();
            gridOffsetTop = (coordOffsetTop !== undefined) ? coordOffsetTop.top : 0;
        }
        const availableHeight = gridHeight - gridOffsetTop - bottomPadding;
        const availableWidth = this._gridContainerElm.width() || window.innerWidth || 0;
        const maxHeight = autoResizeOptions && autoResizeOptions.maxHeight || undefined;
        const minHeight = (autoResizeOptions && autoResizeOptions.minHeight !== undefined) ? autoResizeOptions.minHeight : DATAGRID_MIN_HEIGHT;
        const maxWidth = autoResizeOptions && autoResizeOptions.maxWidth || undefined;
        const minWidth = (autoResizeOptions && autoResizeOptions.minWidth !== undefined) ? autoResizeOptions.minWidth : DATAGRID_MIN_WIDTH;
        let newHeight = availableHeight;
        let newWidth = (autoResizeOptions && autoResizeOptions.sidePadding) ? availableWidth - autoResizeOptions.sidePadding : availableWidth;
        // optionally (when defined), make sure that grid height & width are within their thresholds
        if (newHeight < minHeight) {
            newHeight = minHeight;
        }
        if (maxHeight && newHeight > maxHeight) {
            newHeight = maxHeight;
        }
        if (newWidth < minWidth) {
            newWidth = minWidth;
        }
        if (maxWidth && newWidth > maxWidth) {
            newWidth = maxWidth;
        }
        // return the new dimensions unless a fixed height/width was defined
        return {
            height: this._fixedHeight || newHeight,
            width: this._fixedWidth || newWidth
        };
    }
    /**
     * Dispose function when element is destroyed
     */
    dispose() {
        $(window).off(`resize.grid.${this._gridUid}`);
    }
    /**
     * Return the last resize dimensions used by the service
     * @return last dimensions
     */
    getLastResizeDimensions() {
        return this._lastDimensions;
    }
    /** Provide the possibility to pause the resizer for some time, until user decides to re-enabled it later if he wish to. */
    pauseResizer(isResizePaused) {
        this._resizePaused = isResizePaused;
    }
    /** Resize the datagrid to fit the browser height & width */
    resizeGrid(delay = 10, newSizes) {
        return new Promise((resolve) => {
            // because of the javascript async nature, we might want to delay the resize a little bit
            delay = delay || 0;
            if (delay > 0) {
                clearTimeout(this._timer);
                this._timer = setTimeout(() => resolve(this.resizeGridCallback(newSizes)), delay);
            }
            else {
                resolve(this.resizeGridCallback(newSizes));
            }
        });
    }
    resizeGridCallback(newSizes) {
        const lastDimensions = this.resizeGridWithDimensions(newSizes);
        this.onGridAfterResize.next(lastDimensions);
        return lastDimensions;
    }
    resizeGridWithDimensions(newSizes) {
        // calculate the available sizes with minimum height defined as a constant
        const availableDimensions = this.calculateGridNewDimensions(this._gridOptions);
        const gridContainerElm = $(`#${this._gridOptions.gridContainerId}`) || {};
        if ((newSizes || availableDimensions) && this._gridDomElm.length > 0) {
            // get the new sizes, if new sizes are passed (not 0), we will use them else use available space
            // basically if user passes 1 of the dimension, let say he passes just the height,
            // we will use the height as a fixed height but the width will be resized by it's available space
            const newHeight = (newSizes && newSizes.height) ? newSizes.height : availableDimensions.height;
            const newWidth = (newSizes && newSizes.width) ? newSizes.width : availableDimensions.width;
            // apply these new height/width to the datagrid
            if (!this._gridOptions.autoHeight) {
                this._gridDomElm.height(newHeight);
                gridContainerElm.height(newHeight);
            }
            this._gridDomElm.width(newWidth);
            gridContainerElm.width(newWidth);
            // resize the slickgrid canvas on all browser except some IE versions
            // exclude all IE below IE11
            // IE11 wants to be a better standard (W3C) follower (finally) they even changed their appName output to also have 'Netscape'
            if (new RegExp('MSIE [6-8]').exec(navigator.userAgent) === null && this._grid && this._grid.resizeCanvas) {
                this._grid.resizeCanvas();
            }
            // also call the grid auto-size columns so that it takes available space when going bigger
            if (this._gridOptions && this._gridOptions.enableAutoSizeColumns && this._grid.autosizeColumns) {
                // make sure that the grid still exist (by looking if the Grid UID is found in the DOM tree) to avoid SlickGrid error "missing stylesheet"
                if (this._gridUid && $(`.${this._gridUid}`).length > 0) {
                    this._grid.autosizeColumns();
                }
            }
            // keep last resized dimensions & resolve them to the Promise
            this._lastDimensions = {
                height: newHeight,
                width: newWidth
            };
            if ((this._gridOptions.enablePagination || this._gridOptions.backendServiceApi)) {
                this._lastDimensions.heightWithPagination = newHeight + DATAGRID_PAGINATION_HEIGHT;
            }
        }
        return this._lastDimensions;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzaXplci5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci1zbGlja2dyaWQvIiwic291cmNlcyI6WyJhcHAvbW9kdWxlcy9hbmd1bGFyLXNsaWNrZ3JpZC9zZXJ2aWNlcy9yZXNpemVyLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUsvQiwrQ0FBK0M7QUFDL0MsTUFBTSxtQkFBbUIsR0FBRyxHQUFHLENBQUM7QUFDaEMsTUFBTSxrQkFBa0IsR0FBRyxHQUFHLENBQUM7QUFDL0IsTUFBTSx1QkFBdUIsR0FBRyxFQUFFLENBQUM7QUFDbkMsTUFBTSxzQkFBc0IsR0FBRyxFQUFFLENBQUM7QUFDbEMsTUFBTSwwQkFBMEIsR0FBRyxFQUFFLENBQUM7QUFRdEMsTUFBTSxPQUFPLGNBQWM7SUFBM0I7UUFRVSxrQkFBYSxHQUFHLEtBQUssQ0FBQztRQUM5QixzQkFBaUIsR0FBRyxJQUFJLE9BQU8sRUFBaUIsQ0FBQztRQUNqRCx1QkFBa0IsR0FBRyxJQUFJLE9BQU8sRUFBUyxDQUFDO0lBc041QyxDQUFDO0lBcE5DLGlFQUFpRTtJQUNqRSxJQUFZLFlBQVk7UUFDdEIsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO0lBQzlFLENBQUM7SUFFRCxJQUFZLFFBQVE7UUFDbEIsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FB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LEVBQUUsQ0FBQzthQUMzQjtZQUVELDBGQUEwRjtZQUMxRixJQUFJLElBQUksQ0FBQyxZQUFZLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxxQkFBcUIsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLGVBQWUsRUFBRTtnQkFDOUYsMElBQTBJO2dCQUMxSSxJQUFJLElBQUksQ0FBQyxRQUFRLElBQUksQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtvQkFDdEQsSUFBSSxDQUFDLEtBQUssQ0FBQyxlQUFlLEVBQUUsQ0FBQztpQkFDOUI7YUFDRjtZQUVELDZEQUE2RDtZQUM3RCxJQUFJLENBQUMsZUFBZSxHQUFHO2dCQUNyQixNQUFNLEVBQUUsU0FBUztnQkFDakIsS0FBSyxFQUFFLFFBQVE7YUFDaEIsQ0FBQztZQUVGLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLGdCQUFnQixJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsaUJBQWlCLENBQUMsRUFBRTtnQkFDL0UsSUFBSSxDQUFDLGVBQWUsQ0FBQyxvQkFBb0IsR0FBRyxTQUFTLEdBQUcsMEJBQTBCLENBQUM7YUFDcEY7U0FDRjtRQUVELE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQztJQUM5QixDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBHcmlkT3B0aW9uIH0gZnJvbSAnLi8uLi9tb2RlbHMvaW5kZXgnO1xyXG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XHJcblxyXG4vLyB1c2luZyBleHRlcm5hbCBub24tdHlwZWQganMgbGlicmFyaWVzXHJcbmRlY2xhcmUgY29uc3QgJDogYW55O1xyXG5cclxuLy8gZ2xvYmFsIGNvbnN0YW50cywgaGVpZ2h0L3dpZHRoIGFyZSBpbiBwaXhlbHNcclxuY29uc3QgREFUQUdSSURfTUlOX0hFSUdIVCA9IDE4MDtcclxuY29uc3QgREFUQUdSSURfTUlOX1dJRFRIID0gMzAwO1xyXG5jb25zdCBEQVRBR1JJRF9CT1RUT01fUEFERElORyA9IDIwO1xyXG5jb25zdCBEQVRBR1JJRF9GT09URVJfSEVJR0hUID0gMjA7XHJcbmNvbnN0IERBVEFHUklEX1BBR0lOQVRJT05fSEVJR0hUID0gMzU7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEdyaWREaW1lbnNpb24ge1xyXG4gIGhlaWdodD86IG51bWJlcjtcclxuICB3aWR0aD86IG51bWJlcjtcclxuICBoZWlnaHRXaXRoUGFnaW5hdGlvbj86IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFJlc2l6ZXJTZXJ2aWNlIHtcclxuICBwcml2YXRlIF9maXhlZEhlaWdodDogbnVtYmVyIHwgbnVsbDtcclxuICBwcml2YXRlIF9maXhlZFdpZHRoOiBudW1iZXIgfCBudWxsO1xyXG4gIHByaXZhdGUgX2dyaWQ6IGFueTtcclxuICBwcml2YXRlIF9ncmlkRG9tRWxtOiBhbnk7XHJcbiAgcHJpdmF0ZSBfZ3JpZENvbnRhaW5lckVsbTogYW55O1xyXG4gIHByaXZhdGUgX2xhc3REaW1lbnNpb25zOiBHcmlkRGltZW5zaW9uO1xyXG4gIHByaXZhdGUgX3RpbWVyOiBhbnk7XHJcbiAgcHJpdmF0ZSBfcmVzaXplUGF1c2VkID0gZmFsc2U7XHJcbiAgb25HcmlkQWZ0ZXJSZXNpemUgPSBuZXcgU3ViamVjdDxHcmlkRGltZW5zaW9uPigpO1xyXG4gIG9uR3JpZEJlZm9yZVJlc2l6ZSA9IG5ldyBTdWJqZWN0PEV2ZW50PigpO1xyXG5cclxuICAvKiogR2V0dGVyIGZvciB0aGUgR3JpZCBPcHRpb25zIHB1bGxlZCB0aHJvdWdoIHRoZSBHcmlkIE9iamVjdCAqL1xyXG4gIHByaXZhdGUgZ2V0IF9ncmlkT3B0aW9ucygpOiBHcmlkT3B0aW9uIHtcclxuICAgIHJldHVybiAodGhpcy5fZ3JpZCAmJiB0aGlzLl9ncmlkLmdldE9wdGlvbnMpID8gdGhpcy5fZ3JpZC5nZXRPcHRpb25zKCkgOiB7fTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZ2V0IF9ncmlkVWlkKCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gKHRoaXMuX2dyaWQgJiYgdGhpcy5fZ3JpZC5nZXRVSUQpID8gdGhpcy5fZ3JpZC5nZXRVSUQoKSA6IHRoaXMuX2dyaWRPcHRpb25zICYmIHRoaXMuX2dyaWRPcHRpb25zLmdyaWRJZDtcclxuICB9XHJcblxyXG4gIGluaXQoZ3JpZDogYW55LCBmaXhlZERpbWVuc2lvbnM/OiBHcmlkRGltZW5zaW9uKTogdm9pZCB7XHJcbiAgICBpZiAoIWdyaWQgfHwgIXRoaXMuX2dyaWRPcHRpb25zKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgXHJcbiAgICAgIEFuZ3VsYXItU2xpY2tncmlkIHJlc2l6ZXIgcmVxdWlyZXMgYSB2YWxpZCBHcmlkIG9iamVjdCBhbmQgR3JpZCBPcHRpb25zIGRlZmluZWQuXHJcbiAgICAgIFlvdSBjYW4gZml4IHRoaXMgYnkgc2V0dGluZyB5b3VyIGdyaWRPcHRpb24gdG8gdXNlIFwiZW5hYmxlQXV0b1Jlc2l6ZVwiIG9yIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGUgUmVzaXplclNlcnZpY2UgYnkgY2FsbGluZyBiaW5kQXV0b1Jlc2l6ZURhdGFHcmlkKClgKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9ncmlkID0gZ3JpZDtcclxuICAgIGNvbnN0IGNvbnRhaW5lck5vZGUgPSBncmlkICYmIGdyaWQuZ2V0Q29udGFpbmVyTm9kZSAmJiBncmlkLmdldENvbnRhaW5lck5vZGUoKSB8fCAnJztcclxuICAgIHRoaXMuX2dyaWREb21FbG0gPSAkKGNvbnRhaW5lck5vZGUpO1xyXG4gICAgY29uc3QgYXV0b1Jlc2l6ZU9wdGlvbnMgPSB0aGlzLl9ncmlkT3B0aW9ucyAmJiB0aGlzLl9ncmlkT3B0aW9ucy5hdXRvUmVzaXplIHx8IHt9O1xyXG4gICAgdGhpcy5fZ3JpZENvbnRhaW5lckVsbSA9IChhdXRvUmVzaXplT3B0aW9ucyAmJiBhdXRvUmVzaXplT3B0aW9ucy5jb250YWluZXJJZCkgPyAkKGAjJHthdXRvUmVzaXplT3B0aW9ucy5jb250YWluZXJJZH1gKSA6ICQoYCMke3RoaXMuX2dyaWRPcHRpb25zLmdyaWRDb250YWluZXJJZH1gKTtcclxuXHJcbiAgICBpZiAoZml4ZWREaW1lbnNpb25zKSB7XHJcbiAgICAgIHRoaXMuX2ZpeGVkSGVpZ2h0ID0gZml4ZWREaW1lbnNpb25zLmhlaWdodDtcclxuICAgICAgdGhpcy5fZml4ZWRXaWR0aCA9IGZpeGVkRGltZW5zaW9ucy53aWR0aDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKiBCaW5kIGFuIGF1dG8gcmVzaXplIHRyaWdnZXIgb24gdGhlIGRhdGFncmlkLCBpZiB0aGF0IGlzIGVuYWJsZSB0aGVuIGl0IHdpbGwgcmVzaXplIGl0c2VsZiB0byB0aGUgYXZhaWxhYmxlIHNwYWNlXHJcbiAgICogT3B0aW9uczogd2UgY291bGQgYWxzbyBwcm92aWRlIGEgJSBmYWN0b3IgdG8gcmVzaXplIG9uIGVhY2ggaGVpZ2h0L3dpZHRoIGluZGVwZW5kZW50bHlcclxuICAgKi9cclxuICBiaW5kQXV0b1Jlc2l6ZURhdGFHcmlkKG5ld1NpemVzPzogR3JpZERpbWVuc2lvbikge1xyXG4gICAgLy8gaWYgd2UgY2FuJ3QgZmluZCB0aGUgZ3JpZCB0byByZXNpemUsIHJldHVybiB3aXRob3V0IGJpbmRpbmcgYW55dGhpbmdcclxuICAgIGlmICh0aGlzLl9ncmlkRG9tRWxtID09PSB1bmRlZmluZWQgfHwgdGhpcy5fZ3JpZERvbUVsbS5vZmZzZXQoKSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIC0tIDFzdCByZXNpemUgdGhlIGRhdGFncmlkIHNpemUgYXQgZmlyc3QgbG9hZCAod2UgbmVlZCB0aGlzIGJlY2F1c2UgdGhlIC5vbiBldmVudCBpcyBub3QgdHJpZ2dlcmVkIG9uIGZpcnN0IGxvYWQpXHJcbiAgICAvLyAtLSBhbHNvIHdlIGFkZCBhIHNsaWdodCBkZWxheSAoaW4gbXMpIHNvIHRoYXQgd2UgcmVzaXplIGFmdGVyIHRoZSBncmlkIHJlbmRlciBpcyBkb25lXHJcbiAgICB0aGlzLnJlc2l6ZUdyaWQoMTAsIG5ld1NpemVzKTtcclxuXHJcbiAgICAvLyAtLSAybmQgYmluZCBhIHRyaWdnZXIgb24gdGhlIFdpbmRvdyBET00gZWxlbWVudCwgc28gdGhhdCBpdCBoYXBwZW5zIGFsc28gd2hlbiByZXNpemluZyBhZnRlciBmaXJzdCBsb2FkXHJcbiAgICAvLyAtLSBiaW5kIGF1dG8tcmVzaXplIHRvIFdpbmRvdyBvYmplY3Qgb25seSBpZiBpdCBleGlzdFxyXG4gICAgJCh3aW5kb3cpLm9uKGByZXNpemUuZ3JpZC4ke3RoaXMuX2dyaWRVaWR9YCwgdGhpcy5oYW5kbGVSZXNpemVHcmlkLmJpbmQodGhpcywgbmV3U2l6ZXMpKTtcclxuICB9XHJcblxyXG4gIGhhbmRsZVJlc2l6ZUdyaWQobmV3U2l6ZXM6IEdyaWREaW1lbnNpb24sIGV2ZW50OiBFdmVudCkge1xyXG4gICAgdGhpcy5vbkdyaWRCZWZvcmVSZXNpemUubmV4dChldmVudCk7XHJcbiAgICBpZiAoIXRoaXMuX3Jlc2l6ZVBhdXNlZCkge1xyXG4gICAgICAvLyBmb3Igc29tZSB5ZXQgdW5rbm93biByZWFzb24sIGNhbGxpbmcgdGhlIHJlc2l6ZSB0d2ljZSByZW1vdmVzIGFueSBzdHV0dGVyaW5nL2ZsaWNrZXJpbmdcclxuICAgICAgLy8gd2hlbiBjaGFuZ2luZyB0aGUgaGVpZ2h0IGFuZCBtYWtlcyBpdCBtdWNoIHNtb290aGVyIGV4cGVyaWVuY2VcclxuICAgICAgdGhpcy5yZXNpemVHcmlkKDAsIG5ld1NpemVzKTtcclxuICAgICAgdGhpcy5yZXNpemVHcmlkKDAsIG5ld1NpemVzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZSB0aGUgZGF0YWdyaWQgbmV3IGhlaWdodC93aWR0aCBmcm9tIHRoZSBhdmFpbGFibGUgc3BhY2UsIGFsc28gY29uc2lkZXIgdGhhdCBhICUgZmFjdG9yIG1pZ2h0IGJlIGFwcGxpZWQgdG8gY2FsY3VsYXRpb25cclxuICAgKiBvYmplY3QgZ3JpZE9wdGlvbnNcclxuICAgKi9cclxuICBjYWxjdWxhdGVHcmlkTmV3RGltZW5zaW9ucyhncmlkT3B0aW9uczogR3JpZE9wdGlvbik6IEdyaWREaW1lbnNpb24gfCBudWxsIHtcclxuICAgIGNvbnN0IGF1dG9SZXNpemVPcHRpb25zID0gZ3JpZE9wdGlvbnMgJiYgZ3JpZE9wdGlvbnMuYXV0b1Jlc2l6ZSB8fCB7fTtcclxuICAgIGlmICghd2luZG93IHx8IHRoaXMuX2dyaWRDb250YWluZXJFbG0gPT09IHVuZGVmaW5lZCB8fCB0aGlzLl9ncmlkRG9tRWxtLm9mZnNldCgpID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY2FsY3VsYXRlIGJvdHRvbSBwYWRkaW5nXHJcbiAgICAvLyBpZiB1c2luZyBwYWdpbmF0aW9uLCB3ZSBuZWVkIHRvIGFkZCB0aGUgcGFnaW5hdGlvbiBoZWlnaHQgdG8gdGhpcyBib3R0b20gcGFkZGluZ1xyXG4gICAgbGV0IGJvdHRvbVBhZGRpbmcgPSAoYXV0b1Jlc2l6ZU9wdGlvbnMgJiYgYXV0b1Jlc2l6ZU9wdGlvbnMuYm90dG9tUGFkZGluZyAhPT0gdW5kZWZpbmVkKSA/IGF1dG9SZXNpemVPcHRpb25zLmJvdHRvbVBhZGRpbmcgOiBEQVRBR1JJRF9CT1RUT01fUEFERElORztcclxuICAgIGlmIChib3R0b21QYWRkaW5nICYmIGdyaWRPcHRpb25zLmVuYWJsZVBhZ2luYXRpb24pIHtcclxuICAgICAgYm90dG9tUGFkZGluZyArPSBEQVRBR1JJRF9QQUdJTkFUSU9OX0hFSUdIVDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBvcHRpb25hbGx5IHNob3cgYSBjdXN0b20gZm9vdGVyIHdpdGggdGhlIGRhdGEgbWV0cmljcyAoZGF0YXNldCBsZW5ndGggYW5kIGxhc3QgdXBkYXRlZCB0aW1lc3RhbXApXHJcbiAgICBpZiAoYm90dG9tUGFkZGluZyAmJiBncmlkT3B0aW9ucy5zaG93Q3VzdG9tRm9vdGVyKSB7XHJcbiAgICAgIGJvdHRvbVBhZGRpbmcgKz0gZ3JpZE9wdGlvbnMuY3VzdG9tRm9vdGVyT3B0aW9ucyAmJiBncmlkT3B0aW9ucy5jdXN0b21Gb290ZXJPcHRpb25zLmZvb3RlckhlaWdodCB8fCBEQVRBR1JJRF9GT09URVJfSEVJR0hUO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBncmlkSGVpZ2h0ID0gMDtcclxuICAgIGxldCBncmlkT2Zmc2V0VG9wID0gMDtcclxuXHJcbiAgICAvLyB3aGljaCBET00gZWxlbWVudCBhcmUgd2UgdXNpbmcgdG8gY2FsY3VsYXRlIHRoZSBhdmFpbGFibGUgc2l6ZSBmb3IgdGhlIGdyaWQ/XHJcbiAgICBpZiAoYXV0b1Jlc2l6ZU9wdGlvbnMuY2FsY3VsYXRlQXZhaWxhYmxlU2l6ZUJ5ID09PSAnY29udGFpbmVyJykge1xyXG4gICAgICAvLyB1c2VzIHRoZSBjb250YWluZXIncyBoZWlnaHQgdG8gY2FsY3VsYXRlIGdyaWQgaGVpZ2h0IHdpdGhvdXQgYW55IHRvcCBvZmZzZXRcclxuICAgICAgZ3JpZEhlaWdodCA9IHRoaXMuX2dyaWRDb250YWluZXJFbG0uaGVpZ2h0KCkgfHwgMDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIHVzZXMgdGhlIGJyb3dzZXIncyB3aW5kb3cgaGVpZ2h0IHdpdGggaXRzIHRvcCBvZmZzZXQgdG8gY2FsY3VsYXRlIGdyaWQgaGVpZ2h0XHJcbiAgICAgIGdyaWRIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgMDtcclxuICAgICAgY29uc3QgY29vcmRPZmZzZXRUb3AgPSB0aGlzLl9ncmlkRG9tRWxtLm9mZnNldCgpO1xyXG4gICAgICBncmlkT2Zmc2V0VG9wID0gKGNvb3JkT2Zmc2V0VG9wICE9PSB1bmRlZmluZWQpID8gY29vcmRPZmZzZXRUb3AudG9wIDogMDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBhdmFpbGFibGVIZWlnaHQgPSBncmlkSGVpZ2h0IC0gZ3JpZE9mZnNldFRvcCAtIGJvdHRvbVBhZGRpbmc7XHJcbiAgICBjb25zdCBhdmFpbGFibGVXaWR0aCA9IHRoaXMuX2dyaWRDb250YWluZXJFbG0ud2lkdGgoKSB8fCB3aW5kb3cuaW5uZXJXaWR0aCB8fCAwO1xyXG4gICAgY29uc3QgbWF4SGVpZ2h0ID0gYXV0b1Jlc2l6ZU9wdGlvbnMgJiYgYXV0b1Jlc2l6ZU9wdGlvbnMubWF4SGVpZ2h0IHx8IHVuZGVmaW5lZDtcclxuICAgIGNvbnN0IG1pbkhlaWdodCA9IChhdXRvUmVzaXplT3B0aW9ucyAmJiBhdXRvUmVzaXplT3B0aW9ucy5taW5IZWlnaHQgIT09IHVuZGVmaW5lZCkgPyBhdXRvUmVzaXplT3B0aW9ucy5taW5IZWlnaHQgOiBEQVRBR1JJRF9NSU5fSEVJR0hUO1xyXG4gICAgY29uc3QgbWF4V2lkdGggPSBhdXRvUmVzaXplT3B0aW9ucyAmJiBhdXRvUmVzaXplT3B0aW9ucy5tYXhXaWR0aCB8fCB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBtaW5XaWR0aCA9IChhdXRvUmVzaXplT3B0aW9ucyAmJiBhdXRvUmVzaXplT3B0aW9ucy5taW5XaWR0aCAhPT0gdW5kZWZpbmVkKSA/IGF1dG9SZXNpemVPcHRpb25zLm1pbldpZHRoIDogREFUQUdSSURfTUlOX1dJRFRIO1xyXG5cclxuICAgIGxldCBuZXdIZWlnaHQgPSBhdmFpbGFibGVIZWlnaHQ7XHJcbiAgICBsZXQgbmV3V2lkdGggPSAoYXV0b1Jlc2l6ZU9wdGlvbnMgJiYgYXV0b1Jlc2l6ZU9wdGlvbnMuc2lkZVBhZGRpbmcpID8gYXZhaWxhYmxlV2lkdGggLSBhdXRvUmVzaXplT3B0aW9ucy5zaWRlUGFkZGluZyA6IGF2YWlsYWJsZVdpZHRoO1xyXG5cclxuICAgIC8vIG9wdGlvbmFsbHkgKHdoZW4gZGVmaW5lZCksIG1ha2Ugc3VyZSB0aGF0IGdyaWQgaGVpZ2h0ICYgd2lkdGggYXJlIHdpdGhpbiB0aGVpciB0aHJlc2hvbGRzXHJcbiAgICBpZiAobmV3SGVpZ2h0IDwgbWluSGVpZ2h0KSB7XHJcbiAgICAgIG5ld0hlaWdodCA9IG1pbkhlaWdodDtcclxuICAgIH1cclxuICAgIGlmIChtYXhIZWlnaHQgJiYgbmV3SGVpZ2h0ID4gbWF4SGVpZ2h0KSB7XHJcbiAgICAgIG5ld0hlaWdodCA9IG1heEhlaWdodDtcclxuICAgIH1cclxuICAgIGlmIChuZXdXaWR0aCA8IG1pbldpZHRoKSB7XHJcbiAgICAgIG5ld1dpZHRoID0gbWluV2lkdGg7XHJcbiAgICB9XHJcbiAgICBpZiAobWF4V2lkdGggJiYgbmV3V2lkdGggPiBtYXhXaWR0aCkge1xyXG4gICAgICBuZXdXaWR0aCA9IG1heFdpZHRoO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHJldHVybiB0aGUgbmV3IGRpbWVuc2lvbnMgdW5sZXNzIGEgZml4ZWQgaGVpZ2h0L3dpZHRoIHdhcyBkZWZpbmVkXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBoZWlnaHQ6IHRoaXMuX2ZpeGVkSGVpZ2h0IHx8IG5ld0hlaWdodCxcclxuICAgICAgd2lkdGg6IHRoaXMuX2ZpeGVkV2lkdGggfHwgbmV3V2lkdGhcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEaXNwb3NlIGZ1bmN0aW9uIHdoZW4gZWxlbWVudCBpcyBkZXN0cm95ZWRcclxuICAgKi9cclxuICBkaXNwb3NlKCkge1xyXG4gICAgJCh3aW5kb3cpLm9mZihgcmVzaXplLmdyaWQuJHt0aGlzLl9ncmlkVWlkfWApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIHRoZSBsYXN0IHJlc2l6ZSBkaW1lbnNpb25zIHVzZWQgYnkgdGhlIHNlcnZpY2VcclxuICAgKiBAcmV0dXJuIGxhc3QgZGltZW5zaW9uc1xyXG4gICAqL1xyXG4gIGdldExhc3RSZXNpemVEaW1lbnNpb25zKCk6IEdyaWREaW1lbnNpb24ge1xyXG4gICAgcmV0dXJuIHRoaXMuX2xhc3REaW1lbnNpb25zO1xyXG4gIH1cclxuXHJcbiAgLyoqIFByb3ZpZGUgdGhlIHBvc3NpYmlsaXR5IHRvIHBhdXNlIHRoZSByZXNpemVyIGZvciBzb21lIHRpbWUsIHVudGlsIHVzZXIgZGVjaWRlcyB0byByZS1lbmFibGVkIGl0IGxhdGVyIGlmIGhlIHdpc2ggdG8uICovXHJcbiAgcGF1c2VSZXNpemVyKGlzUmVzaXplUGF1c2VkOiBib29sZWFuKSB7XHJcbiAgICB0aGlzLl9yZXNpemVQYXVzZWQgPSBpc1Jlc2l6ZVBhdXNlZDtcclxuICB9XHJcblxyXG4gIC8qKiBSZXNpemUgdGhlIGRhdGFncmlkIHRvIGZpdCB0aGUgYnJvd3NlciBoZWlnaHQgJiB3aWR0aCAqL1xyXG4gIHJlc2l6ZUdyaWQoZGVsYXkgPSAxMCwgbmV3U2l6ZXM/OiBHcmlkRGltZW5zaW9uKTogUHJvbWlzZTxHcmlkRGltZW5zaW9uPiB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgLy8gYmVjYXVzZSBvZiB0aGUgamF2YXNjcmlwdCBhc3luYyBuYXR1cmUsIHdlIG1pZ2h0IHdhbnQgdG8gZGVsYXkgdGhlIHJlc2l6ZSBhIGxpdHRsZSBiaXRcclxuICAgICAgZGVsYXkgPSBkZWxheSB8fCAwO1xyXG5cclxuICAgICAgaWYgKGRlbGF5ID4gMCkge1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XHJcbiAgICAgICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHJlc29sdmUodGhpcy5yZXNpemVHcmlkQ2FsbGJhY2sobmV3U2l6ZXMpKSwgZGVsYXkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJlc29sdmUodGhpcy5yZXNpemVHcmlkQ2FsbGJhY2sobmV3U2l6ZXMpKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICByZXNpemVHcmlkQ2FsbGJhY2sobmV3U2l6ZXM6IEdyaWREaW1lbnNpb24pIHtcclxuICAgIGNvbnN0IGxhc3REaW1lbnNpb25zID0gdGhpcy5yZXNpemVHcmlkV2l0aERpbWVuc2lvbnMobmV3U2l6ZXMpO1xyXG4gICAgdGhpcy5vbkdyaWRBZnRlclJlc2l6ZS5uZXh0KGxhc3REaW1lbnNpb25zKTtcclxuICAgIHJldHVybiBsYXN0RGltZW5zaW9ucztcclxuICB9XHJcblxyXG4gIHJlc2l6ZUdyaWRXaXRoRGltZW5zaW9ucyhuZXdTaXplcz86IEdyaWREaW1lbnNpb24pOiBHcmlkRGltZW5zaW9uIHtcclxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgYXZhaWxhYmxlIHNpemVzIHdpdGggbWluaW11bSBoZWlnaHQgZGVmaW5lZCBhcyBhIGNvbnN0YW50XHJcbiAgICBjb25zdCBhdmFpbGFibGVEaW1lbnNpb25zID0gdGhpcy5jYWxjdWxhdGVHcmlkTmV3RGltZW5zaW9ucyh0aGlzLl9ncmlkT3B0aW9ucyk7XHJcbiAgICBjb25zdCBncmlkQ29udGFpbmVyRWxtID0gJChgIyR7dGhpcy5fZ3JpZE9wdGlvbnMuZ3JpZENvbnRhaW5lcklkfWApIHx8IHt9O1xyXG5cclxuICAgIGlmICgobmV3U2l6ZXMgfHwgYXZhaWxhYmxlRGltZW5zaW9ucykgJiYgdGhpcy5fZ3JpZERvbUVsbS5sZW5ndGggPiAwKSB7XHJcbiAgICAgIC8vIGdldCB0aGUgbmV3IHNpemVzLCBpZiBuZXcgc2l6ZXMgYXJlIHBhc3NlZCAobm90IDApLCB3ZSB3aWxsIHVzZSB0aGVtIGVsc2UgdXNlIGF2YWlsYWJsZSBzcGFjZVxyXG4gICAgICAvLyBiYXNpY2FsbHkgaWYgdXNlciBwYXNzZXMgMSBvZiB0aGUgZGltZW5zaW9uLCBsZXQgc2F5IGhlIHBhc3NlcyBqdXN0IHRoZSBoZWlnaHQsXHJcbiAgICAgIC8vIHdlIHdpbGwgdXNlIHRoZSBoZWlnaHQgYXMgYSBmaXhlZCBoZWlnaHQgYnV0IHRoZSB3aWR0aCB3aWxsIGJlIHJlc2l6ZWQgYnkgaXQncyBhdmFpbGFibGUgc3BhY2VcclxuICAgICAgY29uc3QgbmV3SGVpZ2h0ID0gKG5ld1NpemVzICYmIG5ld1NpemVzLmhlaWdodCkgPyBuZXdTaXplcy5oZWlnaHQgOiBhdmFpbGFibGVEaW1lbnNpb25zLmhlaWdodDtcclxuICAgICAgY29uc3QgbmV3V2lkdGggPSAobmV3U2l6ZXMgJiYgbmV3U2l6ZXMud2lkdGgpID8gbmV3U2l6ZXMud2lkdGggOiBhdmFpbGFibGVEaW1lbnNpb25zLndpZHRoO1xyXG5cclxuICAgICAgLy8gYXBwbHkgdGhlc2UgbmV3IGhlaWdodC93aWR0aCB0byB0aGUgZGF0YWdyaWRcclxuICAgICAgaWYgKCF0aGlzLl9ncmlkT3B0aW9ucy5hdXRvSGVpZ2h0KSB7XHJcbiAgICAgICAgdGhpcy5fZ3JpZERvbUVsbS5oZWlnaHQobmV3SGVpZ2h0KTtcclxuICAgICAgICBncmlkQ29udGFpbmVyRWxtLmhlaWdodChuZXdIZWlnaHQpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2dyaWREb21FbG0ud2lkdGgobmV3V2lkdGgpO1xyXG4gICAgICBncmlkQ29udGFpbmVyRWxtLndpZHRoKG5ld1dpZHRoKTtcclxuXHJcbiAgICAgIC8vIHJlc2l6ZSB0aGUgc2xpY2tncmlkIGNhbnZhcyBvbiBhbGwgYnJvd3NlciBleGNlcHQgc29tZSBJRSB2ZXJzaW9uc1xyXG4gICAgICAvLyBleGNsdWRlIGFsbCBJRSBiZWxvdyBJRTExXHJcbiAgICAgIC8vIElFMTEgd2FudHMgdG8gYmUgYSBiZXR0ZXIgc3RhbmRhcmQgKFczQykgZm9sbG93ZXIgKGZpbmFsbHkpIHRoZXkgZXZlbiBjaGFuZ2VkIHRoZWlyIGFwcE5hbWUgb3V0cHV0IHRvIGFsc28gaGF2ZSAnTmV0c2NhcGUnXHJcbiAgICAgIGlmIChuZXcgUmVnRXhwKCdNU0lFIFs2LThdJykuZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KSA9PT0gbnVsbCAmJiB0aGlzLl9ncmlkICYmIHRoaXMuX2dyaWQucmVzaXplQ2FudmFzKSB7XHJcbiAgICAgICAgdGhpcy5fZ3JpZC5yZXNpemVDYW52YXMoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gYWxzbyBjYWxsIHRoZSBncmlkIGF1dG8tc2l6ZSBjb2x1bW5zIHNvIHRoYXQgaXQgdGFrZXMgYXZhaWxhYmxlIHNwYWNlIHdoZW4gZ29pbmcgYmlnZ2VyXHJcbiAgICAgIGlmICh0aGlzLl9ncmlkT3B0aW9ucyAmJiB0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVBdXRvU2l6ZUNvbHVtbnMgJiYgdGhpcy5fZ3JpZC5hdXRvc2l6ZUNvbHVtbnMpIHtcclxuICAgICAgICAvLyBtYWtlIHN1cmUgdGhhdCB0aGUgZ3JpZCBzdGlsbCBleGlzdCAoYnkgbG9va2luZyBpZiB0aGUgR3JpZCBVSUQgaXMgZm91bmQgaW4gdGhlIERPTSB0cmVlKSB0byBhdm9pZCBTbGlja0dyaWQgZXJyb3IgXCJtaXNzaW5nIHN0eWxlc2hlZXRcIlxyXG4gICAgICAgIGlmICh0aGlzLl9ncmlkVWlkICYmICQoYC4ke3RoaXMuX2dyaWRVaWR9YCkubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgdGhpcy5fZ3JpZC5hdXRvc2l6ZUNvbHVtbnMoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGtlZXAgbGFzdCByZXNpemVkIGRpbWVuc2lvbnMgJiByZXNvbHZlIHRoZW0gdG8gdGhlIFByb21pc2VcclxuICAgICAgdGhpcy5fbGFzdERpbWVuc2lvbnMgPSB7XHJcbiAgICAgICAgaGVpZ2h0OiBuZXdIZWlnaHQsXHJcbiAgICAgICAgd2lkdGg6IG5ld1dpZHRoXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBpZiAoKHRoaXMuX2dyaWRPcHRpb25zLmVuYWJsZVBhZ2luYXRpb24gfHwgdGhpcy5fZ3JpZE9wdGlvbnMuYmFja2VuZFNlcnZpY2VBcGkpKSB7XHJcbiAgICAgICAgdGhpcy5fbGFzdERpbWVuc2lvbnMuaGVpZ2h0V2l0aFBhZ2luYXRpb24gPSBuZXdIZWlnaHQgKyBEQVRBR1JJRF9QQUdJTkFUSU9OX0hFSUdIVDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLl9sYXN0RGltZW5zaW9ucztcclxuICB9XHJcbn1cclxuIl19