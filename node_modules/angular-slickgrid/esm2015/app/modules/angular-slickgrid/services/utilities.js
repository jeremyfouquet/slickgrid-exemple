import { Observable } from 'rxjs';
import { first } from 'rxjs/operators';
import * as moment_ from 'moment-mini';
const moment = moment_; // patch to fix rollup "moment has no default export" issue, document here https://github.com/rollup/rollup/issues/670
import { FieldType, OperatorType } from '../models/index';
/**
 * Add an item to an array only when the item does not exists, when the item is an object we will be using their "id" to compare
 * @param inputArray
 * @param inputItem
 * @param itemIdPropName
 */
export function addToArrayWhenNotExists(inputArray, inputItem, itemIdPropName = 'id') {
    let arrayRowIndex = -1;
    if (typeof inputItem === 'object' && inputItem.hasOwnProperty(itemIdPropName)) {
        arrayRowIndex = inputArray.findIndex((item) => item[itemIdPropName] === inputItem[itemIdPropName]);
    }
    else {
        arrayRowIndex = inputArray.findIndex((item) => item === inputItem);
    }
    if (arrayRowIndex < 0) {
        inputArray.push(inputItem);
    }
}
/**
 * Simple function to which will loop and create as demanded the number of white spaces,
 * this is used in the CSV export
 * @param int nbSpaces: number of white spaces to create
 */
export function addWhiteSpaces(nbSpaces) {
    let result = '';
    for (let i = 0; i < nbSpaces; i++) {
        result += ' ';
    }
    return result;
}
/**
 * Remove a column from the grid by it's index in the grid
 * @param array input
 * @param index
 */
export function arrayRemoveItemByIndex(array, index) {
    return array.filter((_el, i) => index !== i);
}
/**
 * Convert a flat array (with "parentId" references) into a hierarchical dataset structure (where children are array(s) inside their parent objects)
 * @param flatArray input array (flat dataset)
 * @param options you can provide the following options:: "parentPropName" (defaults to "parent"), "childrenPropName" (defaults to "children") and "identifierPropName" (defaults to "id")
 * @return roots - hierarchical data view array
 */
export function convertParentChildArrayToHierarchicalView(flatArray, options) {
    const childrenPropName = options && options.childrenPropName || 'children';
    const parentPropName = options && options.parentPropName || '__parentId';
    const identifierPropName = options && options.identifierPropName || 'id';
    const hasChildrenFlagPropName = '__hasChildren';
    const treeLevelPropName = '__treeLevel';
    const inputArray = $.extend(true, [], flatArray);
    const roots = []; // things without parent
    // make them accessible by guid on this map
    const all = {};
    inputArray.forEach((item) => all[item[identifierPropName]] = item);
    // connect childrens to its parent, and split roots apart
    Object.keys(all).forEach((id) => {
        const item = all[id];
        if (item[parentPropName] === null || !item.hasOwnProperty(parentPropName)) {
            delete item[parentPropName];
            roots.push(item);
        }
        else if (item[parentPropName] in all) {
            const p = all[item[parentPropName]];
            if (!(childrenPropName in p)) {
                p[childrenPropName] = [];
            }
            delete item[parentPropName];
            p[childrenPropName].push(item);
        }
        // delete any unnecessary properties that were possibly created in the flat array but shouldn't be part of the tree data
        delete item[treeLevelPropName];
        delete item[hasChildrenFlagPropName];
    });
    return roots;
}
/**
 * Convert a hierarchical array (with children) into a flat array structure array (where the children are pushed as next indexed item in the array)
 * @param hierarchicalArray - input hierarchical array
 * @param options - you can provide "childrenPropName" (defaults to "children")
 * @return output - Parent/Child array
 */
export function convertHierarchicalViewToParentChildArray(hierarchicalArray, options) {
    const outputArray = [];
    convertHierarchicalViewToParentChildArrayByReference($.extend(true, [], hierarchicalArray), outputArray, options, 0);
    // the output array is the one passed as reference
    return outputArray;
}
/**
 * Convert a hierarchical array (with children) into a flat array structure array but using the array as the output (the array is the pointer reference)
 * @param hierarchicalArray - input hierarchical array
 * @param outputArrayRef - output array passed (and modified) by reference
 * @param options - you can provide "childrenPropName" (defaults to "children")
 * @param treeLevel - tree level number
 * @param parentId - parent ID
 */
export function convertHierarchicalViewToParentChildArrayByReference(hierarchicalArray, outputArrayRef, options, treeLevel = 0, parentId) {
    const childrenPropName = options && options.childrenPropName || 'children';
    const identifierPropName = options && options.identifierPropName || 'id';
    const hasChildrenFlagPropName = options && options.hasChildrenFlagPropName || '__hasChildren';
    const treeLevelPropName = options && options.treeLevelPropName || '__treeLevel';
    const parentPropName = options && options.parentPropName || '__parentId';
    if (Array.isArray(hierarchicalArray)) {
        for (const item of hierarchicalArray) {
            if (item) {
                const itemExist = outputArrayRef.find((itm) => itm[identifierPropName] === item[identifierPropName]);
                if (!itemExist) {
                    item[treeLevelPropName] = treeLevel; // save tree level ref
                    item[parentPropName] = parentId || null;
                    outputArrayRef.push(item);
                }
                if (Array.isArray(item[childrenPropName])) {
                    treeLevel++;
                    convertHierarchicalViewToParentChildArrayByReference(item[childrenPropName], outputArrayRef, options, treeLevel, item[identifierPropName]);
                    treeLevel--;
                    item[hasChildrenFlagPropName] = true;
                    delete item[childrenPropName]; // remove the children property
                }
            }
        }
    }
}
/**
 * Create an immutable clone of an array or object
 * (c) 2019 Chris Ferdinandi, MIT License, https://gomakethings.com
 * @param  {Array|Object} obj The array or object to copy
 * @return {Array|Object}     The clone of the array or object
 */
export function deepCopy(obj) {
    /**
     * Create an immutable copy of an object
     * @return {Object}
     */
    const cloneObj = () => {
        // Create new object
        const clone = {};
        // Loop through each item in the original
        // Recursively copy it's value and add to the clone
        for (const key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                clone[key] = deepCopy(obj[key]);
            }
        }
        return clone;
    };
    /**
     * Create an immutable copy of an array
     * @return {Array}
     */
    const cloneArr = () => {
        return obj.map((item) => deepCopy(item));
    };
    // -- init --//
    // Get object type
    const type = Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();
    // If an object
    if (type === 'object') {
        return cloneObj();
    }
    // If an array
    if (type === 'array') {
        return cloneArr();
    }
    // Otherwise, return it as-is
    return obj;
}
/**
 * Find an item from a hierarchical view structure (a parent that can have children array which themseleves can children and so on)
 * @param hierarchicalArray
 * @param predicate
 * @param childrenPropertyName
 */
export function findItemInHierarchicalStructure(hierarchicalArray, predicate, childrenPropertyName) {
    if (!childrenPropertyName) {
        throw new Error('findRecursive requires parameter "childrenPropertyName"');
    }
    const initialFind = hierarchicalArray.find(predicate);
    const elementsWithChildren = hierarchicalArray.filter((x) => x.hasOwnProperty(childrenPropertyName) && x[childrenPropertyName]);
    if (initialFind) {
        return initialFind;
    }
    else if (elementsWithChildren.length) {
        const childElements = [];
        elementsWithChildren.forEach((item) => {
            if (item.hasOwnProperty(childrenPropertyName)) {
                childElements.push(...item[childrenPropertyName]);
            }
        });
        return findItemInHierarchicalStructure(childElements, predicate, childrenPropertyName);
    }
    return undefined;
}
/**
 * HTML decode using jQuery with a <div>
 * Create a in-memory div, set it's inner text(which jQuery automatically encodes)
 * then grab the encoded contents back out.  The div never exists on the page.
*/
export function htmlDecode(encodedStr) {
    const parser = DOMParser && new DOMParser;
    if (parser && parser.parseFromString) {
        const dom = parser.parseFromString('<!doctype html><body>' + encodedStr, 'text/html');
        return dom && dom.body && dom.body.textContent;
    }
    else {
        // for some browsers that might not support DOMParser, use jQuery instead
        return $('<div/>').html(encodedStr).text();
    }
}
/**
 * HTML encode using jQuery with a <div>
 * Create a in-memory div, set it's inner text(which jQuery automatically encodes)
 * then grab the encoded contents back out.  The div never exists on the page.
*/
export function htmlEncode(inputValue) {
    const entityMap = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        '\'': '&#39;'
    };
    // all symbols::  /[&<>"'`=\/]/g
    return (inputValue || '').toString().replace(/[&<>"']/g, (s) => entityMap[s]);
}
/**
 * Decode text into html entity
 * @param string text: input text
 * @param string text: output text
 */
export function htmlEntityDecode(input) {
    return input.replace(/&#(\d+);/g, function (_match, dec) {
        return String.fromCharCode(dec);
    });
}
/**
 * Decode text into html entity
 * @param string text: input text
 * @param string text: output text
 */
export function htmlEntityEncode(input) {
    const buf = [];
    for (let i = input.length - 1; i >= 0; i--) {
        buf.unshift(['&#', input[i].charCodeAt(), ';'].join(''));
    }
    return buf.join('');
}
/**
 * Compares two arrays of characters to determine if all the items are equal
 * @param a first array
 * @param b second array to compare with a
 * @param [orderMatters=false] flag if the order matters, if not arrays will be sorted before comparison
 * @return boolean true if equal, else false
 */
export function charArraysEqual(a, b, orderMatters = false) {
    if (!a || !b || !Array.isArray(a) || !Array.isArray(a)) {
        return false;
    }
    if (a.length !== b.length) {
        return false;
    }
    if (!orderMatters && a.sort && b.sort) {
        a.sort();
        b.sort();
    }
    for (let i = 0; i < a.length; ++i) {
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
}
/**
 * Try casting an input of type Promise | Observable into a Promise type.
 * @param object which could be of type Promise or Observable
 * @param fromServiceName string representing the caller service name and will be used if we throw a casting problem error
 */
export function castToPromise(input, fromServiceName = '') {
    let promise = input;
    if (input instanceof Promise) {
        // if it's already a Promise then return it
        return input;
    }
    else if (input instanceof Observable) {
        promise = input.pipe(first()).toPromise();
    }
    if (!(promise instanceof Promise)) {
        throw new Error(`Something went wrong, Angular-Slickgrid ${fromServiceName} is not able to convert the Observable into a Promise.
      If you are using Angular HttpClient, you could try converting your http call to a Promise with ".toPromise()"
      for example::  this.http.post('graphql', { query: graphqlQuery }).toPromise()
      `);
    }
    return promise;
}
/**
 * Uses the logic function to find an item in an array or returns the default
 * value provided (empty object by default)
 * @param any[] array the array to filter
 * @param function logic the logic to find the item
 * @param any [defaultVal={}] the default value to return
 * @return object the found object or default value
 */
export function findOrDefault(array, logic, defaultVal = {}) {
    return array.find(logic) || defaultVal;
}
/**
 * Encode string to html special char and add html space padding defined
 * @param {string} inputStr - input string
 * @param {number} paddingLength - padding to add
 */
export function htmlEncodedStringWithPadding(inputStr, paddingLength) {
    const inputStrLn = inputStr.length;
    let outputStr = htmlEncode(inputStr);
    if (inputStrLn < paddingLength) {
        for (let i = inputStrLn; i < paddingLength; i++) {
            outputStr += `&nbsp;`;
        }
    }
    return outputStr;
}
/**
  * Take a number (or a string) and display it as a formatted decimal string with defined minimum and maximum decimals
  * @param input
  * @param minDecimal
  * @param maxDecimal
  */
export function decimalFormatted(input, minDecimal, maxDecimal, decimalSeparator = '.', thousandSeparator = '') {
    if (isNaN(+input)) {
        return input;
    }
    const minDec = (minDecimal === undefined) ? 2 : minDecimal;
    const maxDec = (maxDecimal === undefined) ? 2 : maxDecimal;
    let amount = String(Math.round(+input * Math.pow(10, maxDec)) / Math.pow(10, maxDec));
    if ((amount.indexOf('.') < 0) && (minDec > 0)) {
        amount += '.';
    }
    while ((amount.length - amount.indexOf('.')) <= minDec) {
        amount += '0';
    }
    const decimalSplit = amount.split('.');
    let integerNumber;
    let decimalNumber;
    // do we want to display our number with a custom separator in each thousand position
    if (thousandSeparator) {
        integerNumber = decimalSplit.length >= 1 ? thousandSeparatorFormatted(decimalSplit[0], thousandSeparator) : undefined;
    }
    else {
        integerNumber = decimalSplit.length >= 1 ? decimalSplit[0] : amount;
    }
    // when using a separator that is not a dot, replace it with the new separator
    if (decimalSplit.length > 1) {
        decimalNumber = decimalSplit[1];
    }
    let output = '';
    if (integerNumber !== undefined && decimalNumber !== undefined) {
        output = `${integerNumber}${decimalSeparator}${decimalNumber}`;
    }
    else if (integerNumber !== undefined && integerNumber !== null) {
        output = integerNumber;
    }
    return output;
}
/**
 * Loop through all properties of an object and nullify any properties that are instanceof HTMLElement,
 * if we detect an array then use recursion to go inside it and apply same logic
 * @param obj - object containing 1 or more properties with DOM Elements
 */
export function destroyObjectDomElementProps(obj) {
    if (obj) {
        for (const key of Object.keys(obj)) {
            if (Array.isArray(obj[key])) {
                destroyObjectDomElementProps(obj[key]);
            }
            if (obj[key] instanceof HTMLElement) {
                obj[key] = null;
            }
        }
    }
}
/**
 * Format a number following options passed as arguments (decimals, separator, ...)
 * @param input
 * @param minDecimal
 * @param maxDecimal
 * @param displayNegativeNumberWithParentheses
 * @param symbolPrefix
 * @param symbolSuffix
 * @param decimalSeparator
 * @param thousandSeparator
 */
export function formatNumber(input, minDecimal, maxDecimal, displayNegativeNumberWithParentheses, symbolPrefix = '', symbolSuffix = '', decimalSeparator = '.', thousandSeparator = '') {
    if (isNaN(+input)) {
        return input;
    }
    const calculatedValue = ((Math.round(parseFloat(input) * 1000000) / 1000000));
    if (calculatedValue < 0) {
        const absValue = Math.abs(calculatedValue);
        if (displayNegativeNumberWithParentheses) {
            if (!isNaN(minDecimal) || !isNaN(maxDecimal)) {
                return `(${symbolPrefix}${decimalFormatted(absValue, minDecimal, maxDecimal, decimalSeparator, thousandSeparator)}${symbolSuffix})`;
            }
            const formattedValue = thousandSeparatorFormatted(`${absValue}`, thousandSeparator);
            return `(${symbolPrefix}${formattedValue}${symbolSuffix})`;
        }
        else {
            if (!isNaN(minDecimal) || !isNaN(maxDecimal)) {
                return `-${symbolPrefix}${decimalFormatted(absValue, minDecimal, maxDecimal, decimalSeparator, thousandSeparator)}${symbolSuffix}`;
            }
            const formattedValue = thousandSeparatorFormatted(`${absValue}`, thousandSeparator);
            return `-${symbolPrefix}${formattedValue}${symbolSuffix}`;
        }
    }
    else {
        if (!isNaN(minDecimal) || !isNaN(maxDecimal)) {
            return `${symbolPrefix}${decimalFormatted(input, minDecimal, maxDecimal, decimalSeparator, thousandSeparator)}${symbolSuffix}`;
        }
        const formattedValue = thousandSeparatorFormatted(`${input}`, thousandSeparator);
        return `${symbolPrefix}${formattedValue}${symbolSuffix}`;
    }
}
/** From a dot (.) notation path, find and return a property within an object given a path */
export function getDescendantProperty(obj, path) {
    return path.split('.').reduce((acc, part) => acc && acc[part], obj);
}
/** Get HTML Element position offset (without jQuery) */
export function getHtmlElementOffset(element) {
    const rect = element.getBoundingClientRect();
    let top = 0;
    let left = 0;
    if (rect && rect.top !== undefined && rect.left !== undefined) {
        top = rect.top + window.pageYOffset;
        left = rect.left + window.pageXOffset;
    }
    return { top, left };
}
/** Get Translation Prefix, defaults to an empty string */
export function getTranslationPrefix(gridOptions) {
    if (gridOptions && gridOptions.translationNamespace) {
        return gridOptions.translationNamespace + (gridOptions.translationNamespaceSeparator || '');
    }
    return '';
}
/**
 * From a Date FieldType, return it's equivalent moment.js format
 * refer to moment.js for the format standard used: https://momentjs.com/docs/#/parsing/string-format/
 * @param fieldType
 */
export function mapMomentDateFormatWithFieldType(fieldType) {
    let map;
    switch (fieldType) {
        case FieldType.dateTime:
        case FieldType.dateTimeIso:
            map = 'YYYY-MM-DD HH:mm:ss';
            break;
        case FieldType.dateTimeShortIso:
            map = 'YYYY-MM-DD HH:mm';
            break;
        case FieldType.dateTimeIsoAmPm:
            map = 'YYYY-MM-DD hh:mm:ss a';
            break;
        case FieldType.dateTimeIsoAM_PM:
            map = 'YYYY-MM-DD hh:mm:ss A';
            break;
        // all Euro Formats (date/month/year)
        case FieldType.dateEuro:
            map = 'DD/MM/YYYY';
            break;
        case FieldType.dateEuroShort:
            map = 'D/M/YY';
            break;
        case FieldType.dateTimeEuro:
            map = 'DD/MM/YYYY HH:mm:ss';
            break;
        case FieldType.dateTimeShortEuro:
            map = 'DD/MM/YYYY HH:mm';
            break;
        case FieldType.dateTimeEuroAmPm:
            map = 'DD/MM/YYYY hh:mm:ss a';
            break;
        case FieldType.dateTimeEuroAM_PM:
            map = 'DD/MM/YYYY hh:mm:ss A';
            break;
        case FieldType.dateTimeEuroShort:
            map = 'D/M/YY H:m:s';
            break;
        case FieldType.dateTimeEuroShortAmPm:
            map = 'D/M/YY h:m:s a';
            break;
        // all US Formats (month/date/year)
        case FieldType.dateUs:
            map = 'MM/DD/YYYY';
            break;
        case FieldType.dateUsShort:
            map = 'M/D/YY';
            break;
        case FieldType.dateTimeUs:
            map = 'MM/DD/YYYY HH:mm:ss';
            break;
        case FieldType.dateTimeShortUs:
            map = 'MM/DD/YYYY HH:mm';
            break;
        case FieldType.dateTimeUsAmPm:
            map = 'MM/DD/YYYY hh:mm:ss a';
            break;
        case FieldType.dateTimeUsAM_PM:
            map = 'MM/DD/YYYY hh:mm:ss A';
            break;
        case FieldType.dateTimeUsShort:
            map = 'M/D/YY H:m:s';
            break;
        case FieldType.dateTimeUsShortAmPm:
            map = 'M/D/YY h:m:s a';
            break;
        case FieldType.dateUtc:
            map = 'YYYY-MM-DDTHH:mm:ss.SSSZ';
            break;
        case FieldType.date:
        case FieldType.dateIso:
        default:
            map = 'YYYY-MM-DD';
            break;
    }
    return map;
}
/**
 * From a Date FieldType, return it's equivalent Flatpickr format
 * refer to Flatpickr for the format standard used: https://chmln.github.io/flatpickr/formatting/#date-formatting-tokens
 * also note that they seem very similar to PHP format (except for am/pm): http://php.net/manual/en/function.date.php
 * @param fieldType
 */
export function mapFlatpickrDateFormatWithFieldType(fieldType) {
    /*
      d: Day of the month, 2 digits with leading zeros	01 to 31
      D: A textual representation of a day	Mon through Sun
      l: (lowercase 'L')	A full textual representation of the day of the week	Sunday through Saturday
      j: Day of the month without leading zeros	1 to 31
      J: Day of the month without leading zeros and ordinal suffix	1st, 2nd, to 31st
      w: Numeric representation of the day of the week	0 (for Sunday) through 6 (for Saturday)
      F: A full textual representation of a month	January through December
      m: Numeric representation of a month, with leading zero	01 through 12
      n: Numeric representation of a month, without leading zeros	1 through 12
      M: A short textual representation of a month	Jan through Dec
      U: The number of seconds since the Unix Epoch	1413704993
      y: A two digit representation of a year	99 or 03
      Y: A full numeric representation of a year, 4 digits	1999 or 2003
      H: Hours (24 hours)	00 to 23
      h: Hours	1 to 12
      i: Minutes	00 to 59
      S: Seconds, 2 digits	00 to 59
      s: Seconds	0, 1 to 59
      K: AM/PM	AM or PM
    */
    let map;
    switch (fieldType) {
        case FieldType.dateTime:
        case FieldType.dateTimeIso:
            map = 'Y-m-d H:i:S';
            break;
        case FieldType.dateTimeShortIso:
            map = 'Y-m-d H:i';
            break;
        case FieldType.dateTimeIsoAmPm:
        case FieldType.dateTimeIsoAM_PM:
            map = 'Y-m-d h:i:S K'; // there is no lowercase in Flatpickr :(
            break;
        // all Euro Formats (date/month/year)
        case FieldType.dateEuro:
            map = 'd/m/Y';
            break;
        case FieldType.dateEuroShort:
            map = 'd/m/y';
            break;
        case FieldType.dateTimeEuro:
            map = 'd/m/Y H:i:S';
            break;
        case FieldType.dateTimeShortEuro:
            map = 'd/m/y H:i';
            break;
        case FieldType.dateTimeEuroAmPm:
            map = 'd/m/Y h:i:S K'; // there is no lowercase in Flatpickr :(
            break;
        case FieldType.dateTimeEuroAM_PM:
            map = 'd/m/Y h:i:s K';
            break;
        case FieldType.dateTimeEuroShort:
            map = 'd/m/y H:i:s';
            break;
        case FieldType.dateTimeEuroShortAmPm:
            map = 'd/m/y h:i:s K'; // there is no lowercase in Flatpickr :(
            break;
        // all US Formats (month/date/year)
        case FieldType.dateUs:
            map = 'm/d/Y';
            break;
        case FieldType.dateUsShort:
            map = 'm/d/y';
            break;
        case FieldType.dateTimeUs:
            map = 'm/d/Y H:i:S';
            break;
        case FieldType.dateTimeShortUs:
            map = 'm/d/y H:i';
            break;
        case FieldType.dateTimeUsAmPm:
            map = 'm/d/Y h:i:S K'; // there is no lowercase in Flatpickr :(
            break;
        case FieldType.dateTimeUsAM_PM:
            map = 'm/d/Y h:i:s K';
            break;
        case FieldType.dateTimeUsShort:
            map = 'm/d/y H:i:s';
            break;
        case FieldType.dateTimeUsShortAmPm:
            map = 'm/d/y h:i:s K'; // there is no lowercase in Flatpickr :(
            break;
        case FieldType.dateUtc:
            map = 'Z';
            break;
        case FieldType.date:
        case FieldType.dateIso:
        default:
            map = 'Y-m-d';
            break;
    }
    return map;
}
/**
 * Mapper for query operators (ex.: <= is "le", > is "gt")
 * @param string operator
 * @returns string map
 */
export function mapOperatorType(operator) {
    let map;
    switch (operator) {
        case '<':
        case 'LT':
            map = OperatorType.lessThan;
            break;
        case '<=':
        case 'LE':
            map = OperatorType.lessThanOrEqual;
            break;
        case '>':
        case 'GT':
            map = OperatorType.greaterThan;
            break;
        case '>=':
        case 'GE':
            map = OperatorType.greaterThanOrEqual;
            break;
        case '<>':
        case '!=':
        case 'NE':
            map = OperatorType.notEqual;
            break;
        case '*':
        case 'a*':
        case 'StartsWith':
            map = OperatorType.startsWith;
            break;
        case '*z':
        case 'EndsWith':
            map = OperatorType.endsWith;
            break;
        case '=':
        case '==':
        case 'EQ':
            map = OperatorType.equal;
            break;
        case 'IN':
            map = OperatorType.in;
            break;
        case 'NIN':
        case 'NOT_IN':
            map = OperatorType.notIn;
            break;
        case 'Not_Contains':
        case 'NOT_CONTAINS':
            map = OperatorType.notContains;
            break;
        case 'Contains':
        case 'CONTAINS':
        default:
            map = OperatorType.contains;
            break;
    }
    return map;
}
/**
 * Find equivalent short designation of an Operator Type or Operator String.
 * When using a Compound Filter, we use the short designation and so we need the mapped value.
 * For example OperatorType.startsWith short designation is "a*", while OperatorType.greaterThanOrEqual is ">="
 */
export function mapOperatorToShorthandDesignation(operator) {
    let shortOperator = '';
    switch (operator) {
        case OperatorType.greaterThan:
        case '>':
            shortOperator = '>';
            break;
        case OperatorType.greaterThanOrEqual:
        case '>=':
            shortOperator = '>=';
            break;
        case OperatorType.lessThan:
        case '<':
            shortOperator = '<';
            break;
        case OperatorType.lessThanOrEqual:
        case '<=':
            shortOperator = '<=';
            break;
        case OperatorType.notEqual:
        case '<>':
            shortOperator = '<>';
            break;
        case OperatorType.equal:
        case '=':
        case '==':
        case 'EQ':
            shortOperator = '=';
            break;
        case OperatorType.startsWith:
        case 'a*':
        case '*':
            shortOperator = 'a*';
            break;
        case OperatorType.endsWith:
        case '*z':
            shortOperator = '*z';
            break;
        default:
            // any other operator will be considered as already a short expression, so we can return same input operator
            shortOperator = operator;
            break;
    }
    return shortOperator;
}
/**
 * Mapper for query operator by a Filter Type
 * For example a multiple-select typically uses 'IN' operator
 * @param operator
 * @returns string map
 */
export function mapOperatorByFieldType(fieldType) {
    let map;
    switch (fieldType) {
        case FieldType.unknown:
        case FieldType.string:
        case FieldType.text:
        case FieldType.password:
        case FieldType.readonly:
            map = OperatorType.contains;
            break;
        case FieldType.float:
        case FieldType.number:
        case FieldType.date:
        case FieldType.dateIso:
        case FieldType.dateUtc:
        case FieldType.dateTime:
        case FieldType.dateTimeIso:
        case FieldType.dateTimeIsoAmPm:
        case FieldType.dateTimeIsoAM_PM:
        case FieldType.dateEuro:
        case FieldType.dateEuroShort:
        case FieldType.dateTimeEuro:
        case FieldType.dateTimeEuroAmPm:
        case FieldType.dateTimeEuroAM_PM:
        case FieldType.dateTimeEuroShort:
        case FieldType.dateTimeEuroShortAmPm:
        case FieldType.dateTimeEuroShortAM_PM:
        case FieldType.dateUs:
        case FieldType.dateUsShort:
        case FieldType.dateTimeUs:
        case FieldType.dateTimeUsAmPm:
        case FieldType.dateTimeUsAM_PM:
        case FieldType.dateTimeUsShort:
        case FieldType.dateTimeUsShortAmPm:
        case FieldType.dateTimeUsShortAM_PM:
        default:
            map = OperatorType.equal;
            break;
    }
    return map;
}
/** Parse any input (bool, number, string) and return a boolean or False when not possible */
export function parseBoolean(input) {
    return /(true|1)/i.test(input + '');
}
/**
 * Parse a date passed as a string (Date only, without time) and return a Date object (if valid)
 * @param inputDateString
 * @returns string date formatted
 */
export function parseUtcDate(inputDateString, useUtc) {
    let date = null;
    if (/^[0-9\-\/]*$/.test(inputDateString)) {
        // get the UTC datetime with moment.js but we need to decode the value so that it's valid text
        const dateString = decodeURIComponent(inputDateString);
        const dateMoment = moment(new Date(dateString));
        if (dateMoment.isValid() && dateMoment.year().toString().length === 4) {
            date = (useUtc) ? dateMoment.utc().format() : dateMoment.format();
        }
    }
    return date;
}
/**
 * Sanitize, return only the text without HTML tags
 * @input htmlString
 * @return text
 */
export function sanitizeHtmlToText(htmlString) {
    const temp = document.createElement('div');
    temp.innerHTML = htmlString;
    return temp.textContent || temp.innerText || '';
}
/** Set the object value of deeper node from a given dot (.) notation path (e.g.: "user.firstName") */
export function setDeepValue(obj, path, value) {
    if (typeof path === 'string') {
        path = path.split('.');
    }
    if (path.length > 1) {
        const e = path.shift();
        if (obj && e !== undefined) {
            setDeepValue(obj[e] = Object.prototype.toString.call(obj[e]) === '[object Object]' ? obj[e] : {}, path, value);
        }
    }
    else if (obj && path[0]) {
        obj[path[0]] = value;
    }
}
/**
 * Format a number or a string into a string that is separated every thousand,
 * the default separator is a comma but user can optionally pass a different one
 * @param inputValue
 * @param separator default to comma ","
 * @returns string
 */
export function thousandSeparatorFormatted(inputValue, separator = ',') {
    if (inputValue !== null && inputValue !== undefined) {
        const stringValue = `${inputValue}`;
        const decimalSplit = stringValue.split('.');
        if (decimalSplit.length === 2) {
            return `${decimalSplit[0].replace(/\B(?=(\d{3})+(?!\d))/g, separator)}.${decimalSplit[1]}`;
        }
        return stringValue.replace(/\B(?=(\d{3})+(?!\d))/g, separator);
    }
    return inputValue;
}
/**
 * Title case (or capitalize) first char of a string, for example "hello world" will become "Hello world"
 * Change the string to be title case on the complete sentence (upper case first char of each word while changing everything else to lower case)
 * @param inputStr
 * @returns string
 */
export function titleCase(inputStr, caseEveryWords = false) {
    if (typeof inputStr === 'string') {
        if (caseEveryWords) {
            return inputStr.replace(/\w\S*/g, (outputStr) => {
                return outputStr.charAt(0).toUpperCase() + outputStr.substr(1).toLowerCase();
            });
        }
        return inputStr.charAt(0).toUpperCase() + inputStr.slice(1);
    }
    return inputStr;
}
/**
 * Converts a string to camel case (camelCase), for example "hello-world" (or "hellow world") will become "helloWorld"
 * @param inputStr the string to convert
 * @return the string in camel case
 */
export function toCamelCase(inputStr) {
    if (typeof inputStr === 'string') {
        return inputStr.replace(/(?:^\w|[A-Z]|\b\w|[\s+\-_\/])/g, (match, offset) => {
            // remove white space or hypens or underscores
            if (/[\s+\-_\/]/.test(match)) {
                return '';
            }
            return offset === 0 ? match.toLowerCase() : match.toUpperCase();
        });
    }
    return inputStr;
}
/**
 * Converts a string to kebab (hypen) case, for example "helloWorld" will become "hello-world"
 * @param str the string to convert
 * @return the string in kebab case
 */
export function toKebabCase(inputStr) {
    if (typeof inputStr === 'string') {
        return toCamelCase(inputStr).replace(/([A-Z])/g, '-$1').toLowerCase();
    }
    return inputStr;
}
/**
 * Converts a string from camelCase to snake_case (underscore) case, for example "helloWorld" will become "hello_world"
 * @param str the string to convert
 * @return the string in kebab case
 */
export function toSnakeCase(inputStr) {
    if (typeof inputStr === 'string') {
        return toCamelCase(inputStr).replace(/([A-Z])/g, '_$1').toLowerCase();
    }
    return inputStr;
}
/**
 * Takes an input array and makes sure the array has unique values by removing duplicates
 * @param array input with possible duplicates
 * @param objectProperty optionally provide an object property to compare (example: 'id')
 * @return array output without duplicates
 */
export function uniqueArray(arr) {
    if (Array.isArray(arr) && arr.length > 0) {
        return arr.filter((item, index) => {
            return arr.indexOf(item) >= index;
        });
    }
    return arr;
}
/**
 * Takes an input array of objects and makes sure the array has unique object values by removing duplicates
 * it will loop through the array using a property name (or "id" when is not provided) to compare uniqueness
 * @param array input with possible duplicates
 * @param propertyName defaults to "id"
 * @return array output without duplicates
 */
export function uniqueObjectArray(arr, propertyName = 'id') {
    if (Array.isArray(arr) && arr.length > 0) {
        const result = [];
        const map = new Map();
        for (const item of arr) {
            if (!map.has(item[propertyName])) {
                map.set(item[propertyName], true); // set any value to Map
                result.push({
                    id: item[propertyName],
                    name: item.name
                });
            }
        }
        return result;
    }
    return arr;
}
/**
 * Unsubscribe all Observables Subscriptions
 * It will return an empty array if it all went well
 * @param subscriptions
 */
export function unsubscribeAllObservables(subscriptions) {
    if (Array.isArray(subscriptions)) {
        subscriptions.forEach((subscription) => {
            if (subscription && subscription.unsubscribe) {
                subscription.unsubscribe();
            }
        });
        subscriptions = [];
    }
    return subscriptions;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbGl0aWVzLmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci1zbGlja2dyaWQvIiwic291cmNlcyI6WyJhcHAvbW9kdWxlcy9hbmd1bGFyLXNsaWNrZ3JpZC9zZXJ2aWNlcy91dGlsaXRpZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBZ0IsTUFBTSxNQUFNLENBQUM7QUFDaEQsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3ZDLE9BQU8sS0FBSyxPQUFPLE1BQU0sYUFBYSxDQUFDO0FBQ3ZDLE1BQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxDQUFDLHNIQUFzSDtBQUU5SSxPQUFPLEVBQUUsU0FBUyxFQUE4QixZQUFZLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUt0Rjs7Ozs7R0FLRztBQUNILE1BQU0sVUFBVSx1QkFBdUIsQ0FBVSxVQUFlLEVBQUUsU0FBWSxFQUFFLGNBQWMsR0FBRyxJQUFJO0lBQ25HLElBQUksYUFBYSxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ3ZCLElBQUksT0FBTyxTQUFTLEtBQUssUUFBUSxJQUFJLFNBQVMsQ0FBQyxjQUFjLENBQUMsY0FBYyxDQUFDLEVBQUU7UUFDN0UsYUFBYSxHQUFHLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxTQUFTLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQztLQUNwRztTQUFNO1FBQ0wsYUFBYSxHQUFHLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksS0FBSyxTQUFTLENBQUMsQ0FBQztLQUNwRTtJQUVELElBQUksYUFBYSxHQUFHLENBQUMsRUFBRTtRQUNyQixVQUFVLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0tBQzVCO0FBQ0gsQ0FBQztBQUVEOzs7O0dBSUc7QUFDSCxNQUFNLFVBQVUsY0FB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Q0FBQyxJQUFJLEdBQUcsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1FBQ3hDLE1BQU0sTUFBTSxHQUFHLEVBQUUsQ0FBQztRQUNsQixNQUFNLEdBQUcsR0FBRyxJQUFJLEdBQUcsRUFBRSxDQUFDO1FBRXRCLEtBQUssTUFBTSxJQUFJLElBQUksR0FBRyxFQUFFO1lBQ3RCLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxFQUFFO2dCQUNoQyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFJLHVCQUF1QjtnQkFDN0QsTUFBTSxDQUFDLElBQUksQ0FBQztvQkFDVixFQUFFLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQztvQkFDdEIsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJO2lCQUNoQixDQUFDLENBQUM7YUFDSjtTQUNGO1FBQ0QsT0FBTyxNQUFNLENBQUM7S0FDZjtJQUNELE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQztBQUVEOzs7O0dBSUc7QUFDSCxNQUFNLFVBQVUseUJBQXlCLENBQUMsYUFBNkI7SUFDckUsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxFQUFFO1FBQ2hDLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxZQUEwQixFQUFFLEVBQUU7WUFDbkQsSUFBSSxZQUFZLElBQUksWUFBWSxDQUFDLFdBQVcsRUFBRTtnQkFDNUMsWUFBWSxDQUFDLFdBQVcsRUFBRSxDQUFDO2FBQzVCO1FBQ0gsQ0FBQyxDQUFDLENBQUM7UUFDSCxhQUFhLEdBQUcsRUFBRSxDQUFDO0tBQ3BCO0lBRUQsT0FBTyxhQUFhLENBQUM7QUFDdkIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9ic2VydmFibGUsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBmaXJzdCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuaW1wb3J0ICogYXMgbW9tZW50XyBmcm9tICdtb21lbnQtbWluaSc7XHJcbmNvbnN0IG1vbWVudCA9IG1vbWVudF87IC8vIHBhdGNoIHRvIGZpeCByb2xsdXAgXCJtb21lbnQgaGFzIG5vIGRlZmF1bHQgZXhwb3J0XCIgaXNzdWUsIGRvY3VtZW50IGhlcmUgaHR0cHM6Ly9naXRodWIuY29tL3JvbGx1cC9yb2xsdXAvaXNzdWVzLzY3MFxyXG5cclxuaW1wb3J0IHsgRmllbGRUeXBlLCBHcmlkT3B0aW9uLCBPcGVyYXRvclN0cmluZywgT3BlcmF0b3JUeXBlIH0gZnJvbSAnLi4vbW9kZWxzL2luZGV4JztcclxuXHJcbi8vIHVzaW5nIGV4dGVybmFsIG5vbi10eXBlZCBqcyBsaWJyYXJpZXNcclxuZGVjbGFyZSBjb25zdCAkOiBhbnk7XHJcblxyXG4vKipcclxuICogQWRkIGFuIGl0ZW0gdG8gYW4gYXJyYXkgb25seSB3aGVuIHRoZSBpdGVtIGRvZXMgbm90IGV4aXN0cywgd2hlbiB0aGUgaXRlbSBpcyBhbiBvYmplY3Qgd2Ugd2lsbCBiZSB1c2luZyB0aGVpciBcImlkXCIgdG8gY29tcGFyZVxyXG4gKiBAcGFyYW0gaW5wdXRBcnJheVxyXG4gKiBAcGFyYW0gaW5wdXRJdGVtXHJcbiAqIEBwYXJhbSBpdGVtSWRQcm9wTmFtZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFkZFRvQXJyYXlXaGVuTm90RXhpc3RzPFQgPSBhbnk+KGlucHV0QXJyYXk6IFRbXSwgaW5wdXRJdGVtOiBULCBpdGVtSWRQcm9wTmFtZSA9ICdpZCcpIHtcclxuICBsZXQgYXJyYXlSb3dJbmRleCA9IC0xO1xyXG4gIGlmICh0eXBlb2YgaW5wdXRJdGVtID09PSAnb2JqZWN0JyAmJiBpbnB1dEl0ZW0uaGFzT3duUHJvcGVydHkoaXRlbUlkUHJvcE5hbWUpKSB7XHJcbiAgICBhcnJheVJvd0luZGV4ID0gaW5wdXRBcnJheS5maW5kSW5kZXgoKGl0ZW0pID0+IGl0ZW1baXRlbUlkUHJvcE5hbWVdID09PSBpbnB1dEl0ZW1baXRlbUlkUHJvcE5hbWVdKTtcclxuICB9IGVsc2Uge1xyXG4gICAgYXJyYXlSb3dJbmRleCA9IGlucHV0QXJyYXkuZmluZEluZGV4KChpdGVtKSA9PiBpdGVtID09PSBpbnB1dEl0ZW0pO1xyXG4gIH1cclxuXHJcbiAgaWYgKGFycmF5Um93SW5kZXggPCAwKSB7XHJcbiAgICBpbnB1dEFycmF5LnB1c2goaW5wdXRJdGVtKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTaW1wbGUgZnVuY3Rpb24gdG8gd2hpY2ggd2lsbCBsb29wIGFuZCBjcmVhdGUgYXMgZGVtYW5kZWQgdGhlIG51bWJlciBvZiB3aGl0ZSBzcGFjZXMsXHJcbiAqIHRoaXMgaXMgdXNlZCBpbiB0aGUgQ1NWIGV4cG9ydFxyXG4gKiBAcGFyYW0gaW50IG5iU3BhY2VzOiBudW1iZXIgb2Ygd2hpdGUgc3BhY2VzIHRvIGNyZWF0ZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFkZFdoaXRlU3BhY2VzKG5iU3BhY2VzOiBudW1iZXIpOiBzdHJpbmcge1xyXG4gIGxldCByZXN1bHQgPSAnJztcclxuXHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYlNwYWNlczsgaSsrKSB7XHJcbiAgICByZXN1bHQgKz0gJyAnO1xyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG4vKipcclxuICogUmVtb3ZlIGEgY29sdW1uIGZyb20gdGhlIGdyaWQgYnkgaXQncyBpbmRleCBpbiB0aGUgZ3JpZFxyXG4gKiBAcGFyYW0gYXJyYXkgaW5wdXRcclxuICogQHBhcmFtIGluZGV4XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlSZW1vdmVJdGVtQnlJbmRleDxUPihhcnJheTogVFtdLCBpbmRleDogbnVtYmVyKTogVFtdIHtcclxuICByZXR1cm4gYXJyYXkuZmlsdGVyKChfZWw6IFQsIGk6IG51bWJlcikgPT4gaW5kZXggIT09IGkpO1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydCBhIGZsYXQgYXJyYXkgKHdpdGggXCJwYXJlbnRJZFwiIHJlZmVyZW5jZXMpIGludG8gYSBoaWVyYXJjaGljYWwgZGF0YXNldCBzdHJ1Y3R1cmUgKHdoZXJlIGNoaWxkcmVuIGFyZSBhcnJheShzKSBpbnNpZGUgdGhlaXIgcGFyZW50IG9iamVjdHMpXHJcbiAqIEBwYXJhbSBmbGF0QXJyYXkgaW5wdXQgYXJyYXkgKGZsYXQgZGF0YXNldClcclxuICogQHBhcmFtIG9wdGlvbnMgeW91IGNhbiBwcm92aWRlIHRoZSBmb2xsb3dpbmcgb3B0aW9uczo6IFwicGFyZW50UHJvcE5hbWVcIiAoZGVmYXVsdHMgdG8gXCJwYXJlbnRcIiksIFwiY2hpbGRyZW5Qcm9wTmFtZVwiIChkZWZhdWx0cyB0byBcImNoaWxkcmVuXCIpIGFuZCBcImlkZW50aWZpZXJQcm9wTmFtZVwiIChkZWZhdWx0cyB0byBcImlkXCIpXHJcbiAqIEByZXR1cm4gcm9vdHMgLSBoaWVyYXJjaGljYWwgZGF0YSB2aWV3IGFycmF5XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFBhcmVudENoaWxkQXJyYXlUb0hpZXJhcmNoaWNhbFZpZXc8VCA9IGFueT4oZmxhdEFycmF5OiBUW10sIG9wdGlvbnM/OiB7IHBhcmVudFByb3BOYW1lPzogc3RyaW5nOyBjaGlsZHJlblByb3BOYW1lPzogc3RyaW5nOyBpZGVudGlmaWVyUHJvcE5hbWU/OiBzdHJpbmc7IH0pOiBUW10ge1xyXG4gIGNvbnN0IGNoaWxkcmVuUHJvcE5hbWUgPSBvcHRpb25zICYmIG9wdGlvbnMuY2hpbGRyZW5Qcm9wTmFtZSB8fCAnY2hpbGRyZW4nO1xyXG4gIGNvbnN0IHBhcmVudFByb3BOYW1lID0gb3B0aW9ucyAmJiBvcHRpb25zLnBhcmVudFByb3BOYW1lIHx8ICdfX3BhcmVudElkJztcclxuICBjb25zdCBpZGVudGlmaWVyUHJvcE5hbWUgPSBvcHRpb25zICYmIG9wdGlvbnMuaWRlbnRpZmllclByb3BOYW1lIHx8ICdpZCc7XHJcbiAgY29uc3QgaGFzQ2hpbGRyZW5GbGFnUHJvcE5hbWUgPSAnX19oYXNDaGlsZHJlbic7XHJcbiAgY29uc3QgdHJlZUxldmVsUHJvcE5hbWUgPSAnX190cmVlTGV2ZWwnO1xyXG4gIGNvbnN0IGlucHV0QXJyYXk6IFRbXSA9ICQuZXh0ZW5kKHRydWUsIFtdLCBmbGF0QXJyYXkpO1xyXG5cclxuICBjb25zdCByb290czogVFtdID0gW107IC8vIHRoaW5ncyB3aXRob3V0IHBhcmVudFxyXG5cclxuICAvLyBtYWtlIHRoZW0gYWNjZXNzaWJsZSBieSBndWlkIG9uIHRoaXMgbWFwXHJcbiAgY29uc3QgYWxsID0ge307XHJcblxyXG4gIGlucHV0QXJyYXkuZm9yRWFjaCgoaXRlbSkgPT4gYWxsW2l0ZW1baWRlbnRpZmllclByb3BOYW1lXV0gPSBpdGVtKTtcclxuXHJcbiAgLy8gY29ubmVjdCBjaGlsZHJlbnMgdG8gaXRzIHBhcmVudCwgYW5kIHNwbGl0IHJvb3RzIGFwYXJ0XHJcbiAgT2JqZWN0LmtleXMoYWxsKS5mb3JFYWNoKChpZCkgPT4ge1xyXG4gICAgY29uc3QgaXRlbSA9IGFsbFtpZF07XHJcbiAgICBpZiAoaXRlbVtwYXJlbnRQcm9wTmFtZV0gPT09IG51bGwgfHwgIWl0ZW0uaGFzT3duUHJvcGVydHkocGFyZW50UHJvcE5hbWUpKSB7XHJcbiAgICAgIGRlbGV0ZSBpdGVtW3BhcmVudFByb3BOYW1lXTtcclxuICAgICAgcm9vdHMucHVzaChpdGVtKTtcclxuICAgIH0gZWxzZSBpZiAoaXRlbVtwYXJlbnRQcm9wTmFtZV0gaW4gYWxsKSB7XHJcbiAgICAgIGNvbnN0IHAgPSBhbGxbaXRlbVtwYXJlbnRQcm9wTmFtZV1dO1xyXG4gICAgICBpZiAoIShjaGlsZHJlblByb3BOYW1lIGluIHApKSB7XHJcbiAgICAgICAgcFtjaGlsZHJlblByb3BOYW1lXSA9IFtdO1xyXG4gICAgICB9XHJcbiAgICAgIGRlbGV0ZSBpdGVtW3BhcmVudFByb3BOYW1lXTtcclxuICAgICAgcFtjaGlsZHJlblByb3BOYW1lXS5wdXNoKGl0ZW0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGRlbGV0ZSBhbnkgdW5uZWNlc3NhcnkgcHJvcGVydGllcyB0aGF0IHdlcmUgcG9zc2libHkgY3JlYXRlZCBpbiB0aGUgZmxhdCBhcnJheSBidXQgc2hvdWxkbid0IGJlIHBhcnQgb2YgdGhlIHRyZWUgZGF0YVxyXG4gICAgZGVsZXRlIGl0ZW1bdHJlZUxldmVsUHJvcE5hbWVdO1xyXG4gICAgZGVsZXRlIGl0ZW1baGFzQ2hpbGRyZW5GbGFnUHJvcE5hbWVdO1xyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gcm9vdHM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0IGEgaGllcmFyY2hpY2FsIGFycmF5ICh3aXRoIGNoaWxkcmVuKSBpbnRvIGEgZmxhdCBhcnJheSBzdHJ1Y3R1cmUgYXJyYXkgKHdoZXJlIHRoZSBjaGlsZHJlbiBhcmUgcHVzaGVkIGFzIG5leHQgaW5kZXhlZCBpdGVtIGluIHRoZSBhcnJheSlcclxuICogQHBhcmFtIGhpZXJhcmNoaWNhbEFycmF5IC0gaW5wdXQgaGllcmFyY2hpY2FsIGFycmF5XHJcbiAqIEBwYXJhbSBvcHRpb25zIC0geW91IGNhbiBwcm92aWRlIFwiY2hpbGRyZW5Qcm9wTmFtZVwiIChkZWZhdWx0cyB0byBcImNoaWxkcmVuXCIpXHJcbiAqIEByZXR1cm4gb3V0cHV0IC0gUGFyZW50L0NoaWxkIGFycmF5XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29udmVydEhpZXJhcmNoaWNhbFZpZXdUb1BhcmVudENoaWxkQXJyYXk8VCA9IGFueT4oaGllcmFyY2hpY2FsQXJyYXk6IFRbXSwgb3B0aW9ucz86IHsgcGFyZW50UHJvcE5hbWU/OiBzdHJpbmc7IGNoaWxkcmVuUHJvcE5hbWU/OiBzdHJpbmc7IGlkZW50aWZpZXJQcm9wTmFtZT86IHN0cmluZzsgfSk6IFRbXSB7XHJcbiAgY29uc3Qgb3V0cHV0QXJyYXk6IFRbXSA9IFtdO1xyXG4gIGNvbnZlcnRIaWVyYXJjaGljYWxWaWV3VG9QYXJlbnRDaGlsZEFycmF5QnlSZWZlcmVuY2UoJC5leHRlbmQodHJ1ZSwgW10sIGhpZXJhcmNoaWNhbEFycmF5KSwgb3V0cHV0QXJyYXksIG9wdGlvbnMsIDApO1xyXG5cclxuICAvLyB0aGUgb3V0cHV0IGFycmF5IGlzIHRoZSBvbmUgcGFzc2VkIGFzIHJlZmVyZW5jZVxyXG4gIHJldHVybiBvdXRwdXRBcnJheTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgYSBoaWVyYXJjaGljYWwgYXJyYXkgKHdpdGggY2hpbGRyZW4pIGludG8gYSBmbGF0IGFycmF5IHN0cnVjdHVyZSBhcnJheSBidXQgdXNpbmcgdGhlIGFycmF5IGFzIHRoZSBvdXRwdXQgKHRoZSBhcnJheSBpcyB0aGUgcG9pbnRlciByZWZlcmVuY2UpXHJcbiAqIEBwYXJhbSBoaWVyYXJjaGljYWxBcnJheSAtIGlucHV0IGhpZXJhcmNoaWNhbCBhcnJheVxyXG4gKiBAcGFyYW0gb3V0cHV0QXJyYXlSZWYgLSBvdXRwdXQgYXJyYXkgcGFzc2VkIChhbmQgbW9kaWZpZWQpIGJ5IHJlZmVyZW5jZVxyXG4gKiBAcGFyYW0gb3B0aW9ucyAtIHlvdSBjYW4gcHJvdmlkZSBcImNoaWxkcmVuUHJvcE5hbWVcIiAoZGVmYXVsdHMgdG8gXCJjaGlsZHJlblwiKVxyXG4gKiBAcGFyYW0gdHJlZUxldmVsIC0gdHJlZSBsZXZlbCBudW1iZXJcclxuICogQHBhcmFtIHBhcmVudElkIC0gcGFyZW50IElEXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29udmVydEhpZXJhcmNoaWNhbFZpZXdUb1BhcmVudENoaWxkQXJyYXlCeVJlZmVyZW5jZTxUID0gYW55PihoaWVyYXJjaGljYWxBcnJheTogVFtdLCBvdXRwdXRBcnJheVJlZjogVFtdLCBvcHRpb25zPzogeyBjaGlsZHJlblByb3BOYW1lPzogc3RyaW5nOyBwYXJlbnRQcm9wTmFtZT86IHN0cmluZzsgaGFzQ2hpbGRyZW5GbGFnUHJvcE5hbWU/OiBzdHJpbmc7IHRyZWVMZXZlbFByb3BOYW1lPzogc3RyaW5nOyBpZGVudGlmaWVyUHJvcE5hbWU/OiBzdHJpbmc7IH0sIHRyZWVMZXZlbCA9IDAsIHBhcmVudElkPzogc3RyaW5nKSB7XHJcbiAgY29uc3QgY2hpbGRyZW5Qcm9wTmFtZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jaGlsZHJlblByb3BOYW1lIHx8ICdjaGlsZHJlbic7XHJcbiAgY29uc3QgaWRlbnRpZmllclByb3BOYW1lID0gb3B0aW9ucyAmJiBvcHRpb25zLmlkZW50aWZpZXJQcm9wTmFtZSB8fCAnaWQnO1xyXG4gIGNvbnN0IGhhc0NoaWxkcmVuRmxhZ1Byb3BOYW1lID0gb3B0aW9ucyAmJiBvcHRpb25zLmhhc0NoaWxkcmVuRmxhZ1Byb3BOYW1lIHx8ICdfX2hhc0NoaWxkcmVuJztcclxuICBjb25zdCB0cmVlTGV2ZWxQcm9wTmFtZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy50cmVlTGV2ZWxQcm9wTmFtZSB8fCAnX190cmVlTGV2ZWwnO1xyXG4gIGNvbnN0IHBhcmVudFByb3BOYW1lID0gb3B0aW9ucyAmJiBvcHRpb25zLnBhcmVudFByb3BOYW1lIHx8ICdfX3BhcmVudElkJztcclxuXHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoaGllcmFyY2hpY2FsQXJyYXkpKSB7XHJcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaGllcmFyY2hpY2FsQXJyYXkpIHtcclxuICAgICAgaWYgKGl0ZW0pIHtcclxuICAgICAgICBjb25zdCBpdGVtRXhpc3QgPSBvdXRwdXRBcnJheVJlZi5maW5kKChpdG06IFQpID0+IGl0bVtpZGVudGlmaWVyUHJvcE5hbWVdID09PSBpdGVtW2lkZW50aWZpZXJQcm9wTmFtZV0pO1xyXG4gICAgICAgIGlmICghaXRlbUV4aXN0KSB7XHJcbiAgICAgICAgICBpdGVtW3RyZWVMZXZlbFByb3BOYW1lXSA9IHRyZWVMZXZlbDsgLy8gc2F2ZSB0cmVlIGxldmVsIHJlZlxyXG4gICAgICAgICAgaXRlbVtwYXJlbnRQcm9wTmFtZV0gPSBwYXJlbnRJZCB8fCBudWxsO1xyXG4gICAgICAgICAgb3V0cHV0QXJyYXlSZWYucHVzaChpdGVtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbVtjaGlsZHJlblByb3BOYW1lXSkpIHtcclxuICAgICAgICAgIHRyZWVMZXZlbCsrO1xyXG4gICAgICAgICAgY29udmVydEhpZXJhcmNoaWNhbFZpZXdUb1BhcmVudENoaWxkQXJyYXlCeVJlZmVyZW5jZShpdGVtW2NoaWxkcmVuUHJvcE5hbWVdLCBvdXRwdXRBcnJheVJlZiwgb3B0aW9ucywgdHJlZUxldmVsLCBpdGVtW2lkZW50aWZpZXJQcm9wTmFtZV0pO1xyXG4gICAgICAgICAgdHJlZUxldmVsLS07XHJcbiAgICAgICAgICBpdGVtW2hhc0NoaWxkcmVuRmxhZ1Byb3BOYW1lXSA9IHRydWU7XHJcbiAgICAgICAgICBkZWxldGUgaXRlbVtjaGlsZHJlblByb3BOYW1lXTsgLy8gcmVtb3ZlIHRoZSBjaGlsZHJlbiBwcm9wZXJ0eVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGUgYW4gaW1tdXRhYmxlIGNsb25lIG9mIGFuIGFycmF5IG9yIG9iamVjdFxyXG4gKiAoYykgMjAxOSBDaHJpcyBGZXJkaW5hbmRpLCBNSVQgTGljZW5zZSwgaHR0cHM6Ly9nb21ha2V0aGluZ3MuY29tXHJcbiAqIEBwYXJhbSAge0FycmF5fE9iamVjdH0gb2JqIFRoZSBhcnJheSBvciBvYmplY3QgdG8gY29weVxyXG4gKiBAcmV0dXJuIHtBcnJheXxPYmplY3R9ICAgICBUaGUgY2xvbmUgb2YgdGhlIGFycmF5IG9yIG9iamVjdFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRlZXBDb3B5KG9iajogYW55KSB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGFuIGltbXV0YWJsZSBjb3B5IG9mIGFuIG9iamVjdFxyXG4gICAqIEByZXR1cm4ge09iamVjdH1cclxuICAgKi9cclxuICBjb25zdCBjbG9uZU9iaiA9ICgpID0+IHtcclxuICAgIC8vIENyZWF0ZSBuZXcgb2JqZWN0XHJcbiAgICBjb25zdCBjbG9uZSA9IHt9O1xyXG5cclxuICAgIC8vIExvb3AgdGhyb3VnaCBlYWNoIGl0ZW0gaW4gdGhlIG9yaWdpbmFsXHJcbiAgICAvLyBSZWN1cnNpdmVseSBjb3B5IGl0J3MgdmFsdWUgYW5kIGFkZCB0byB0aGUgY2xvbmVcclxuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xyXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xyXG4gICAgICAgIGNsb25lW2tleV0gPSBkZWVwQ29weShvYmpba2V5XSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBjbG9uZTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgYW4gaW1tdXRhYmxlIGNvcHkgb2YgYW4gYXJyYXlcclxuICAgKiBAcmV0dXJuIHtBcnJheX1cclxuICAgKi9cclxuICBjb25zdCBjbG9uZUFyciA9ICgpID0+IHtcclxuICAgIHJldHVybiBvYmoubWFwKChpdGVtOiBhbnkpID0+IGRlZXBDb3B5KGl0ZW0pKTtcclxuICB9O1xyXG5cclxuICAvLyAtLSBpbml0IC0tLy9cclxuICAvLyBHZXQgb2JqZWN0IHR5cGVcclxuICBjb25zdCB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikuc2xpY2UoOCwgLTEpLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gIC8vIElmIGFuIG9iamVjdFxyXG4gIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xyXG4gICAgcmV0dXJuIGNsb25lT2JqKCk7XHJcbiAgfVxyXG4gIC8vIElmIGFuIGFycmF5XHJcbiAgaWYgKHR5cGUgPT09ICdhcnJheScpIHtcclxuICAgIHJldHVybiBjbG9uZUFycigpO1xyXG4gIH1cclxuICAvLyBPdGhlcndpc2UsIHJldHVybiBpdCBhcy1pc1xyXG4gIHJldHVybiBvYmo7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGaW5kIGFuIGl0ZW0gZnJvbSBhIGhpZXJhcmNoaWNhbCB2aWV3IHN0cnVjdHVyZSAoYSBwYXJlbnQgdGhhdCBjYW4gaGF2ZSBjaGlsZHJlbiBhcnJheSB3aGljaCB0aGVtc2VsZXZlcyBjYW4gY2hpbGRyZW4gYW5kIHNvIG9uKVxyXG4gKiBAcGFyYW0gaGllcmFyY2hpY2FsQXJyYXlcclxuICogQHBhcmFtIHByZWRpY2F0ZVxyXG4gKiBAcGFyYW0gY2hpbGRyZW5Qcm9wZXJ0eU5hbWVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmaW5kSXRlbUluSGllcmFyY2hpY2FsU3RydWN0dXJlPFQgPSBhbnk+KGhpZXJhcmNoaWNhbEFycmF5OiBUW10sIHByZWRpY2F0ZTogKGl0ZW06IFQpID0+IGJvb2xlYW4sIGNoaWxkcmVuUHJvcGVydHlOYW1lOiBzdHJpbmcpOiBUIHtcclxuICBpZiAoIWNoaWxkcmVuUHJvcGVydHlOYW1lKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpbmRSZWN1cnNpdmUgcmVxdWlyZXMgcGFyYW1ldGVyIFwiY2hpbGRyZW5Qcm9wZXJ0eU5hbWVcIicpO1xyXG4gIH1cclxuICBjb25zdCBpbml0aWFsRmluZCA9IGhpZXJhcmNoaWNhbEFycmF5LmZpbmQocHJlZGljYXRlKTtcclxuICBjb25zdCBlbGVtZW50c1dpdGhDaGlsZHJlbiA9IGhpZXJhcmNoaWNhbEFycmF5LmZpbHRlcigoeDogVCkgPT4geC5oYXNPd25Qcm9wZXJ0eShjaGlsZHJlblByb3BlcnR5TmFtZSkgJiYgeFtjaGlsZHJlblByb3BlcnR5TmFtZV0pO1xyXG4gIGlmIChpbml0aWFsRmluZCkge1xyXG4gICAgcmV0dXJuIGluaXRpYWxGaW5kO1xyXG4gIH0gZWxzZSBpZiAoZWxlbWVudHNXaXRoQ2hpbGRyZW4ubGVuZ3RoKSB7XHJcbiAgICBjb25zdCBjaGlsZEVsZW1lbnRzOiBUW10gPSBbXTtcclxuICAgIGVsZW1lbnRzV2l0aENoaWxkcmVuLmZvckVhY2goKGl0ZW06IFQpID0+IHtcclxuICAgICAgaWYgKGl0ZW0uaGFzT3duUHJvcGVydHkoY2hpbGRyZW5Qcm9wZXJ0eU5hbWUpKSB7XHJcbiAgICAgICAgY2hpbGRFbGVtZW50cy5wdXNoKC4uLml0ZW1bY2hpbGRyZW5Qcm9wZXJ0eU5hbWVdKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gZmluZEl0ZW1JbkhpZXJhcmNoaWNhbFN0cnVjdHVyZTxUPihjaGlsZEVsZW1lbnRzLCBwcmVkaWNhdGUsIGNoaWxkcmVuUHJvcGVydHlOYW1lKTtcclxuICB9XHJcbiAgcmV0dXJuIHVuZGVmaW5lZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEhUTUwgZGVjb2RlIHVzaW5nIGpRdWVyeSB3aXRoIGEgPGRpdj5cclxuICogQ3JlYXRlIGEgaW4tbWVtb3J5IGRpdiwgc2V0IGl0J3MgaW5uZXIgdGV4dCh3aGljaCBqUXVlcnkgYXV0b21hdGljYWxseSBlbmNvZGVzKVxyXG4gKiB0aGVuIGdyYWIgdGhlIGVuY29kZWQgY29udGVudHMgYmFjayBvdXQuICBUaGUgZGl2IG5ldmVyIGV4aXN0cyBvbiB0aGUgcGFnZS5cclxuKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGh0bWxEZWNvZGUoZW5jb2RlZFN0cjogc3RyaW5nKTogc3RyaW5nIHtcclxuICBjb25zdCBwYXJzZXIgPSBET01QYXJzZXIgJiYgbmV3IERPTVBhcnNlcjtcclxuICBpZiAocGFyc2VyICYmIHBhcnNlci5wYXJzZUZyb21TdHJpbmcpIHtcclxuICAgIGNvbnN0IGRvbSA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoXHJcbiAgICAgICc8IWRvY3R5cGUgaHRtbD48Ym9keT4nICsgZW5jb2RlZFN0cixcclxuICAgICAgJ3RleHQvaHRtbCcpO1xyXG4gICAgcmV0dXJuIGRvbSAmJiBkb20uYm9keSAmJiBkb20uYm9keS50ZXh0Q29udGVudDtcclxuICB9IGVsc2Uge1xyXG4gICAgLy8gZm9yIHNvbWUgYnJvd3NlcnMgdGhhdCBtaWdodCBub3Qgc3VwcG9ydCBET01QYXJzZXIsIHVzZSBqUXVlcnkgaW5zdGVhZFxyXG4gICAgcmV0dXJuICQoJzxkaXYvPicpLmh0bWwoZW5jb2RlZFN0cikudGV4dCgpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEhUTUwgZW5jb2RlIHVzaW5nIGpRdWVyeSB3aXRoIGEgPGRpdj5cclxuICogQ3JlYXRlIGEgaW4tbWVtb3J5IGRpdiwgc2V0IGl0J3MgaW5uZXIgdGV4dCh3aGljaCBqUXVlcnkgYXV0b21hdGljYWxseSBlbmNvZGVzKVxyXG4gKiB0aGVuIGdyYWIgdGhlIGVuY29kZWQgY29udGVudHMgYmFjayBvdXQuICBUaGUgZGl2IG5ldmVyIGV4aXN0cyBvbiB0aGUgcGFnZS5cclxuKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGh0bWxFbmNvZGUoaW5wdXRWYWx1ZTogc3RyaW5nKTogc3RyaW5nIHtcclxuICBjb25zdCBlbnRpdHlNYXAgPSB7XHJcbiAgICAnJic6ICcmYW1wOycsXHJcbiAgICAnPCc6ICcmbHQ7JyxcclxuICAgICc+JzogJyZndDsnLFxyXG4gICAgJ1wiJzogJyZxdW90OycsXHJcbiAgICAnXFwnJzogJyYjMzk7J1xyXG4gIH07XHJcbiAgLy8gYWxsIHN5bWJvbHM6OiAgL1smPD5cIidgPVxcL10vZ1xyXG4gIHJldHVybiAoaW5wdXRWYWx1ZSB8fCAnJykudG9TdHJpbmcoKS5yZXBsYWNlKC9bJjw+XCInXS9nLCAocykgPT4gZW50aXR5TWFwW3NdKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIERlY29kZSB0ZXh0IGludG8gaHRtbCBlbnRpdHlcclxuICogQHBhcmFtIHN0cmluZyB0ZXh0OiBpbnB1dCB0ZXh0XHJcbiAqIEBwYXJhbSBzdHJpbmcgdGV4dDogb3V0cHV0IHRleHRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBodG1sRW50aXR5RGVjb2RlKGlucHV0OiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gIHJldHVybiBpbnB1dC5yZXBsYWNlKC8mIyhcXGQrKTsvZywgZnVuY3Rpb24gKF9tYXRjaCwgZGVjKSB7XHJcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShkZWMpO1xyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogRGVjb2RlIHRleHQgaW50byBodG1sIGVudGl0eVxyXG4gKiBAcGFyYW0gc3RyaW5nIHRleHQ6IGlucHV0IHRleHRcclxuICogQHBhcmFtIHN0cmluZyB0ZXh0OiBvdXRwdXQgdGV4dFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGh0bWxFbnRpdHlFbmNvZGUoaW5wdXQ6IGFueSk6IHN0cmluZyB7XHJcbiAgY29uc3QgYnVmID0gW107XHJcbiAgZm9yIChsZXQgaSA9IGlucHV0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICBidWYudW5zaGlmdChbJyYjJywgaW5wdXRbaV0uY2hhckNvZGVBdCgpLCAnOyddLmpvaW4oJycpKTtcclxuICB9XHJcbiAgcmV0dXJuIGJ1Zi5qb2luKCcnKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbXBhcmVzIHR3byBhcnJheXMgb2YgY2hhcmFjdGVycyB0byBkZXRlcm1pbmUgaWYgYWxsIHRoZSBpdGVtcyBhcmUgZXF1YWxcclxuICogQHBhcmFtIGEgZmlyc3QgYXJyYXlcclxuICogQHBhcmFtIGIgc2Vjb25kIGFycmF5IHRvIGNvbXBhcmUgd2l0aCBhXHJcbiAqIEBwYXJhbSBbb3JkZXJNYXR0ZXJzPWZhbHNlXSBmbGFnIGlmIHRoZSBvcmRlciBtYXR0ZXJzLCBpZiBub3QgYXJyYXlzIHdpbGwgYmUgc29ydGVkIGJlZm9yZSBjb21wYXJpc29uXHJcbiAqIEByZXR1cm4gYm9vbGVhbiB0cnVlIGlmIGVxdWFsLCBlbHNlIGZhbHNlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2hhckFycmF5c0VxdWFsPFQgPSBhbnk+KGE6IFRbXSwgYjogVFtdLCBvcmRlck1hdHRlcnM6IGJvb2xlYW4gPSBmYWxzZSk6IGJvb2xlYW4ge1xyXG4gIGlmICghYSB8fCAhYiB8fCAhQXJyYXkuaXNBcnJheShhKSB8fCAhQXJyYXkuaXNBcnJheShhKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgaWYgKCFvcmRlck1hdHRlcnMgJiYgYS5zb3J0ICYmIGIuc29ydCkge1xyXG4gICAgYS5zb3J0KCk7XHJcbiAgICBiLnNvcnQoKTtcclxuICB9XHJcblxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkge1xyXG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUcnkgY2FzdGluZyBhbiBpbnB1dCBvZiB0eXBlIFByb21pc2UgfCBPYnNlcnZhYmxlIGludG8gYSBQcm9taXNlIHR5cGUuXHJcbiAqIEBwYXJhbSBvYmplY3Qgd2hpY2ggY291bGQgYmUgb2YgdHlwZSBQcm9taXNlIG9yIE9ic2VydmFibGVcclxuICogQHBhcmFtIGZyb21TZXJ2aWNlTmFtZSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjYWxsZXIgc2VydmljZSBuYW1lIGFuZCB3aWxsIGJlIHVzZWQgaWYgd2UgdGhyb3cgYSBjYXN0aW5nIHByb2JsZW0gZXJyb3JcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjYXN0VG9Qcm9taXNlPFQ+KGlucHV0OiBQcm9taXNlPFQ+IHwgT2JzZXJ2YWJsZTxUPiwgZnJvbVNlcnZpY2VOYW1lOiBzdHJpbmcgPSAnJyk6IFByb21pc2U8VD4ge1xyXG4gIGxldCBwcm9taXNlOiBhbnkgPSBpbnB1dDtcclxuXHJcbiAgaWYgKGlucHV0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xyXG4gICAgLy8gaWYgaXQncyBhbHJlYWR5IGEgUHJvbWlzZSB0aGVuIHJldHVybiBpdFxyXG4gICAgcmV0dXJuIGlucHV0O1xyXG4gIH0gZWxzZSBpZiAoaW5wdXQgaW5zdGFuY2VvZiBPYnNlcnZhYmxlKSB7XHJcbiAgICBwcm9taXNlID0gaW5wdXQucGlwZShmaXJzdCgpKS50b1Byb21pc2UoKTtcclxuICB9XHJcblxyXG4gIGlmICghKHByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICBgU29tZXRoaW5nIHdlbnQgd3JvbmcsIEFuZ3VsYXItU2xpY2tncmlkICR7ZnJvbVNlcnZpY2VOYW1lfSBpcyBub3QgYWJsZSB0byBjb252ZXJ0IHRoZSBPYnNlcnZhYmxlIGludG8gYSBQcm9taXNlLlxyXG4gICAgICBJZiB5b3UgYXJlIHVzaW5nIEFuZ3VsYXIgSHR0cENsaWVudCwgeW91IGNvdWxkIHRyeSBjb252ZXJ0aW5nIHlvdXIgaHR0cCBjYWxsIHRvIGEgUHJvbWlzZSB3aXRoIFwiLnRvUHJvbWlzZSgpXCJcclxuICAgICAgZm9yIGV4YW1wbGU6OiAgdGhpcy5odHRwLnBvc3QoJ2dyYXBocWwnLCB7IHF1ZXJ5OiBncmFwaHFsUXVlcnkgfSkudG9Qcm9taXNlKClcclxuICAgICAgYCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcHJvbWlzZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFVzZXMgdGhlIGxvZ2ljIGZ1bmN0aW9uIHRvIGZpbmQgYW4gaXRlbSBpbiBhbiBhcnJheSBvciByZXR1cm5zIHRoZSBkZWZhdWx0XHJcbiAqIHZhbHVlIHByb3ZpZGVkIChlbXB0eSBvYmplY3QgYnkgZGVmYXVsdClcclxuICogQHBhcmFtIGFueVtdIGFycmF5IHRoZSBhcnJheSB0byBmaWx0ZXJcclxuICogQHBhcmFtIGZ1bmN0aW9uIGxvZ2ljIHRoZSBsb2dpYyB0byBmaW5kIHRoZSBpdGVtXHJcbiAqIEBwYXJhbSBhbnkgW2RlZmF1bHRWYWw9e31dIHRoZSBkZWZhdWx0IHZhbHVlIHRvIHJldHVyblxyXG4gKiBAcmV0dXJuIG9iamVjdCB0aGUgZm91bmQgb2JqZWN0IG9yIGRlZmF1bHQgdmFsdWVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmaW5kT3JEZWZhdWx0PFQgPSBhbnk+KGFycmF5OiBhbnlbXSwgbG9naWM6IChpdGVtOiBhbnkpID0+IGJvb2xlYW4sIGRlZmF1bHRWYWwgPSB7fSk6IGFueSB7XHJcbiAgcmV0dXJuIGFycmF5LmZpbmQobG9naWMpIHx8IGRlZmF1bHRWYWw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbmNvZGUgc3RyaW5nIHRvIGh0bWwgc3BlY2lhbCBjaGFyIGFuZCBhZGQgaHRtbCBzcGFjZSBwYWRkaW5nIGRlZmluZWRcclxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0U3RyIC0gaW5wdXQgc3RyaW5nXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYWRkaW5nTGVuZ3RoIC0gcGFkZGluZyB0byBhZGRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBodG1sRW5jb2RlZFN0cmluZ1dpdGhQYWRkaW5nKGlucHV0U3RyOiBzdHJpbmcsIHBhZGRpbmdMZW5ndGg6IG51bWJlcik6IHN0cmluZyB7XHJcbiAgY29uc3QgaW5wdXRTdHJMbiA9IGlucHV0U3RyLmxlbmd0aDtcclxuICBsZXQgb3V0cHV0U3RyID0gaHRtbEVuY29kZShpbnB1dFN0cik7XHJcblxyXG4gIGlmIChpbnB1dFN0ckxuIDwgcGFkZGluZ0xlbmd0aCkge1xyXG4gICAgZm9yIChsZXQgaSA9IGlucHV0U3RyTG47IGkgPCBwYWRkaW5nTGVuZ3RoOyBpKyspIHtcclxuICAgICAgb3V0cHV0U3RyICs9IGAmbmJzcDtgO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gb3V0cHV0U3RyO1xyXG59XHJcblxyXG4vKipcclxuICAqIFRha2UgYSBudW1iZXIgKG9yIGEgc3RyaW5nKSBhbmQgZGlzcGxheSBpdCBhcyBhIGZvcm1hdHRlZCBkZWNpbWFsIHN0cmluZyB3aXRoIGRlZmluZWQgbWluaW11bSBhbmQgbWF4aW11bSBkZWNpbWFsc1xyXG4gICogQHBhcmFtIGlucHV0XHJcbiAgKiBAcGFyYW0gbWluRGVjaW1hbFxyXG4gICogQHBhcmFtIG1heERlY2ltYWxcclxuICAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZGVjaW1hbEZvcm1hdHRlZChpbnB1dDogbnVtYmVyIHwgc3RyaW5nLCBtaW5EZWNpbWFsPzogbnVtYmVyLCBtYXhEZWNpbWFsPzogbnVtYmVyLCBkZWNpbWFsU2VwYXJhdG9yOiAnLicgfCAnLCcgPSAnLicsIHRob3VzYW5kU2VwYXJhdG9yOiAnLCcgfCAnXycgfCAnLicgfCAnICcgfCAnJyA9ICcnKTogc3RyaW5nIHtcclxuICBpZiAoaXNOYU4oK2lucHV0KSkge1xyXG4gICAgcmV0dXJuIGlucHV0IGFzIHN0cmluZztcclxuICB9XHJcblxyXG4gIGNvbnN0IG1pbkRlYyA9IChtaW5EZWNpbWFsID09PSB1bmRlZmluZWQpID8gMiA6IG1pbkRlY2ltYWw7XHJcbiAgY29uc3QgbWF4RGVjID0gKG1heERlY2ltYWwgPT09IHVuZGVmaW5lZCkgPyAyIDogbWF4RGVjaW1hbDtcclxuICBsZXQgYW1vdW50ID0gU3RyaW5nKE1hdGgucm91bmQoK2lucHV0ICogTWF0aC5wb3coMTAsIG1heERlYykpIC8gTWF0aC5wb3coMTAsIG1heERlYykpO1xyXG5cclxuICBpZiAoKGFtb3VudC5pbmRleE9mKCcuJykgPCAwKSAmJiAobWluRGVjID4gMCkpIHtcclxuICAgIGFtb3VudCArPSAnLic7XHJcbiAgfVxyXG4gIHdoaWxlICgoYW1vdW50Lmxlbmd0aCAtIGFtb3VudC5pbmRleE9mKCcuJykpIDw9IG1pbkRlYykge1xyXG4gICAgYW1vdW50ICs9ICcwJztcclxuICB9XHJcblxyXG4gIGNvbnN0IGRlY2ltYWxTcGxpdCA9IGFtb3VudC5zcGxpdCgnLicpO1xyXG4gIGxldCBpbnRlZ2VyTnVtYmVyO1xyXG4gIGxldCBkZWNpbWFsTnVtYmVyO1xyXG5cclxuICAvLyBkbyB3ZSB3YW50IHRvIGRpc3BsYXkgb3VyIG51bWJlciB3aXRoIGEgY3VzdG9tIHNlcGFyYXRvciBpbiBlYWNoIHRob3VzYW5kIHBvc2l0aW9uXHJcbiAgaWYgKHRob3VzYW5kU2VwYXJhdG9yKSB7XHJcbiAgICBpbnRlZ2VyTnVtYmVyID0gZGVjaW1hbFNwbGl0Lmxlbmd0aCA+PSAxID8gdGhvdXNhbmRTZXBhcmF0b3JGb3JtYXR0ZWQoZGVjaW1hbFNwbGl0WzBdLCB0aG91c2FuZFNlcGFyYXRvcikgOiB1bmRlZmluZWQ7XHJcbiAgfSBlbHNlIHtcclxuICAgIGludGVnZXJOdW1iZXIgPSBkZWNpbWFsU3BsaXQubGVuZ3RoID49IDEgPyBkZWNpbWFsU3BsaXRbMF0gOiBhbW91bnQ7XHJcbiAgfVxyXG5cclxuICAvLyB3aGVuIHVzaW5nIGEgc2VwYXJhdG9yIHRoYXQgaXMgbm90IGEgZG90LCByZXBsYWNlIGl0IHdpdGggdGhlIG5ldyBzZXBhcmF0b3JcclxuICBpZiAoZGVjaW1hbFNwbGl0Lmxlbmd0aCA+IDEpIHtcclxuICAgIGRlY2ltYWxOdW1iZXIgPSBkZWNpbWFsU3BsaXRbMV07XHJcbiAgfVxyXG5cclxuICBsZXQgb3V0cHV0ID0gJyc7XHJcbiAgaWYgKGludGVnZXJOdW1iZXIgIT09IHVuZGVmaW5lZCAmJiBkZWNpbWFsTnVtYmVyICE9PSB1bmRlZmluZWQpIHtcclxuICAgIG91dHB1dCA9IGAke2ludGVnZXJOdW1iZXJ9JHtkZWNpbWFsU2VwYXJhdG9yfSR7ZGVjaW1hbE51bWJlcn1gO1xyXG4gIH0gZWxzZSBpZiAoaW50ZWdlck51bWJlciAhPT0gdW5kZWZpbmVkICYmIGludGVnZXJOdW1iZXIgIT09IG51bGwpIHtcclxuICAgIG91dHB1dCA9IGludGVnZXJOdW1iZXI7XHJcbiAgfVxyXG4gIHJldHVybiBvdXRwdXQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMb29wIHRocm91Z2ggYWxsIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0IGFuZCBudWxsaWZ5IGFueSBwcm9wZXJ0aWVzIHRoYXQgYXJlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQsXHJcbiAqIGlmIHdlIGRldGVjdCBhbiBhcnJheSB0aGVuIHVzZSByZWN1cnNpb24gdG8gZ28gaW5zaWRlIGl0IGFuZCBhcHBseSBzYW1lIGxvZ2ljXHJcbiAqIEBwYXJhbSBvYmogLSBvYmplY3QgY29udGFpbmluZyAxIG9yIG1vcmUgcHJvcGVydGllcyB3aXRoIERPTSBFbGVtZW50c1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRlc3Ryb3lPYmplY3REb21FbGVtZW50UHJvcHMob2JqOiBhbnkpIHtcclxuICBpZiAob2JqKSB7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvYmopKSB7XHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ialtrZXldKSkge1xyXG4gICAgICAgIGRlc3Ryb3lPYmplY3REb21FbGVtZW50UHJvcHMob2JqW2tleV0pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChvYmpba2V5XSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XHJcbiAgICAgICAgb2JqW2tleV0gPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogRm9ybWF0IGEgbnVtYmVyIGZvbGxvd2luZyBvcHRpb25zIHBhc3NlZCBhcyBhcmd1bWVudHMgKGRlY2ltYWxzLCBzZXBhcmF0b3IsIC4uLilcclxuICogQHBhcmFtIGlucHV0XHJcbiAqIEBwYXJhbSBtaW5EZWNpbWFsXHJcbiAqIEBwYXJhbSBtYXhEZWNpbWFsXHJcbiAqIEBwYXJhbSBkaXNwbGF5TmVnYXRpdmVOdW1iZXJXaXRoUGFyZW50aGVzZXNcclxuICogQHBhcmFtIHN5bWJvbFByZWZpeFxyXG4gKiBAcGFyYW0gc3ltYm9sU3VmZml4XHJcbiAqIEBwYXJhbSBkZWNpbWFsU2VwYXJhdG9yXHJcbiAqIEBwYXJhbSB0aG91c2FuZFNlcGFyYXRvclxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdE51bWJlcihpbnB1dDogbnVtYmVyIHwgc3RyaW5nLCBtaW5EZWNpbWFsPzogbnVtYmVyLCBtYXhEZWNpbWFsPzogbnVtYmVyLCBkaXNwbGF5TmVnYXRpdmVOdW1iZXJXaXRoUGFyZW50aGVzZXM/OiBib29sZWFuLCBzeW1ib2xQcmVmaXggPSAnJywgc3ltYm9sU3VmZml4ID0gJycsIGRlY2ltYWxTZXBhcmF0b3I6ICcuJyB8ICcsJyA9ICcuJywgdGhvdXNhbmRTZXBhcmF0b3I6ICcsJyB8ICdfJyB8ICcuJyB8ICcgJyB8ICcnID0gJycpOiBzdHJpbmcge1xyXG4gIGlmIChpc05hTigraW5wdXQpKSB7XHJcbiAgICByZXR1cm4gaW5wdXQgYXMgc3RyaW5nO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgY2FsY3VsYXRlZFZhbHVlID0gKChNYXRoLnJvdW5kKHBhcnNlRmxvYXQoaW5wdXQgYXMgc3RyaW5nKSAqIDEwMDAwMDApIC8gMTAwMDAwMCkpO1xyXG5cclxuICBpZiAoY2FsY3VsYXRlZFZhbHVlIDwgMCkge1xyXG4gICAgY29uc3QgYWJzVmFsdWUgPSBNYXRoLmFicyhjYWxjdWxhdGVkVmFsdWUpO1xyXG4gICAgaWYgKGRpc3BsYXlOZWdhdGl2ZU51bWJlcldpdGhQYXJlbnRoZXNlcykge1xyXG4gICAgICBpZiAoIWlzTmFOKG1pbkRlY2ltYWwpIHx8ICFpc05hTihtYXhEZWNpbWFsKSkge1xyXG4gICAgICAgIHJldHVybiBgKCR7c3ltYm9sUHJlZml4fSR7ZGVjaW1hbEZvcm1hdHRlZChhYnNWYWx1ZSwgbWluRGVjaW1hbCwgbWF4RGVjaW1hbCwgZGVjaW1hbFNlcGFyYXRvciwgdGhvdXNhbmRTZXBhcmF0b3IpfSR7c3ltYm9sU3VmZml4fSlgO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGZvcm1hdHRlZFZhbHVlID0gdGhvdXNhbmRTZXBhcmF0b3JGb3JtYXR0ZWQoYCR7YWJzVmFsdWV9YCwgdGhvdXNhbmRTZXBhcmF0b3IpO1xyXG4gICAgICByZXR1cm4gYCgke3N5bWJvbFByZWZpeH0ke2Zvcm1hdHRlZFZhbHVlfSR7c3ltYm9sU3VmZml4fSlgO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKCFpc05hTihtaW5EZWNpbWFsKSB8fCAhaXNOYU4obWF4RGVjaW1hbCkpIHtcclxuICAgICAgICByZXR1cm4gYC0ke3N5bWJvbFByZWZpeH0ke2RlY2ltYWxGb3JtYXR0ZWQoYWJzVmFsdWUsIG1pbkRlY2ltYWwsIG1heERlY2ltYWwsIGRlY2ltYWxTZXBhcmF0b3IsIHRob3VzYW5kU2VwYXJhdG9yKX0ke3N5bWJvbFN1ZmZpeH1gO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGZvcm1hdHRlZFZhbHVlID0gdGhvdXNhbmRTZXBhcmF0b3JGb3JtYXR0ZWQoYCR7YWJzVmFsdWV9YCwgdGhvdXNhbmRTZXBhcmF0b3IpO1xyXG4gICAgICByZXR1cm4gYC0ke3N5bWJvbFByZWZpeH0ke2Zvcm1hdHRlZFZhbHVlfSR7c3ltYm9sU3VmZml4fWA7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIGlmICghaXNOYU4obWluRGVjaW1hbCkgfHwgIWlzTmFOKG1heERlY2ltYWwpKSB7XHJcbiAgICAgIHJldHVybiBgJHtzeW1ib2xQcmVmaXh9JHtkZWNpbWFsRm9ybWF0dGVkKGlucHV0LCBtaW5EZWNpbWFsLCBtYXhEZWNpbWFsLCBkZWNpbWFsU2VwYXJhdG9yLCB0aG91c2FuZFNlcGFyYXRvcil9JHtzeW1ib2xTdWZmaXh9YDtcclxuICAgIH1cclxuICAgIGNvbnN0IGZvcm1hdHRlZFZhbHVlID0gdGhvdXNhbmRTZXBhcmF0b3JGb3JtYXR0ZWQoYCR7aW5wdXR9YCwgdGhvdXNhbmRTZXBhcmF0b3IpO1xyXG4gICAgcmV0dXJuIGAke3N5bWJvbFByZWZpeH0ke2Zvcm1hdHRlZFZhbHVlfSR7c3ltYm9sU3VmZml4fWA7XHJcbiAgfVxyXG59XHJcblxyXG4vKiogRnJvbSBhIGRvdCAoLikgbm90YXRpb24gcGF0aCwgZmluZCBhbmQgcmV0dXJuIGEgcHJvcGVydHkgd2l0aGluIGFuIG9iamVjdCBnaXZlbiBhIHBhdGggKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldERlc2NlbmRhbnRQcm9wZXJ0eTxUID0gYW55PihvYmo6IFQsIHBhdGg6IHN0cmluZyk6IGFueSB7XHJcbiAgcmV0dXJuIHBhdGguc3BsaXQoJy4nKS5yZWR1Y2UoKGFjYywgcGFydCkgPT4gYWNjICYmIGFjY1twYXJ0XSwgb2JqKTtcclxufVxyXG5cclxuLyoqIEdldCBIVE1MIEVsZW1lbnQgcG9zaXRpb24gb2Zmc2V0ICh3aXRob3V0IGpRdWVyeSkgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEh0bWxFbGVtZW50T2Zmc2V0KGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogeyB0b3A6IG51bWJlcjsgbGVmdDogbnVtYmVyOyB9IHtcclxuICBjb25zdCByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICBsZXQgdG9wID0gMDtcclxuICBsZXQgbGVmdCA9IDA7XHJcblxyXG4gIGlmIChyZWN0ICYmIHJlY3QudG9wICE9PSB1bmRlZmluZWQgJiYgcmVjdC5sZWZ0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgIHRvcCA9IHJlY3QudG9wICsgd2luZG93LnBhZ2VZT2Zmc2V0O1xyXG4gICAgbGVmdCA9IHJlY3QubGVmdCArIHdpbmRvdy5wYWdlWE9mZnNldDtcclxuICB9XHJcbiAgcmV0dXJuIHsgdG9wLCBsZWZ0IH07XHJcbn1cclxuXHJcbi8qKiBHZXQgVHJhbnNsYXRpb24gUHJlZml4LCBkZWZhdWx0cyB0byBhbiBlbXB0eSBzdHJpbmcgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFRyYW5zbGF0aW9uUHJlZml4KGdyaWRPcHRpb25zPzogR3JpZE9wdGlvbik6IHN0cmluZyB7XHJcbiAgaWYgKGdyaWRPcHRpb25zICYmIGdyaWRPcHRpb25zLnRyYW5zbGF0aW9uTmFtZXNwYWNlKSB7XHJcbiAgICByZXR1cm4gZ3JpZE9wdGlvbnMudHJhbnNsYXRpb25OYW1lc3BhY2UgKyAoZ3JpZE9wdGlvbnMudHJhbnNsYXRpb25OYW1lc3BhY2VTZXBhcmF0b3IgfHwgJycpO1xyXG4gIH1cclxuICByZXR1cm4gJyc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGcm9tIGEgRGF0ZSBGaWVsZFR5cGUsIHJldHVybiBpdCdzIGVxdWl2YWxlbnQgbW9tZW50LmpzIGZvcm1hdFxyXG4gKiByZWZlciB0byBtb21lbnQuanMgZm9yIHRoZSBmb3JtYXQgc3RhbmRhcmQgdXNlZDogaHR0cHM6Ly9tb21lbnRqcy5jb20vZG9jcy8jL3BhcnNpbmcvc3RyaW5nLWZvcm1hdC9cclxuICogQHBhcmFtIGZpZWxkVHlwZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG1hcE1vbWVudERhdGVGb3JtYXRXaXRoRmllbGRUeXBlKGZpZWxkVHlwZTogRmllbGRUeXBlKTogc3RyaW5nIHtcclxuICBsZXQgbWFwOiBzdHJpbmc7XHJcbiAgc3dpdGNoIChmaWVsZFR5cGUpIHtcclxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lOlxyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVJc286XHJcbiAgICAgIG1hcCA9ICdZWVlZLU1NLUREIEhIOm1tOnNzJztcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZVNob3J0SXNvOlxyXG4gICAgICBtYXAgPSAnWVlZWS1NTS1ERCBISDptbSc7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVJc29BbVBtOlxyXG4gICAgICBtYXAgPSAnWVlZWS1NTS1ERCBoaDptbTpzcyBhJztcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZUlzb0FNX1BNOlxyXG4gICAgICBtYXAgPSAnWVlZWS1NTS1ERCBoaDptbTpzcyBBJztcclxuICAgICAgYnJlYWs7XHJcbiAgICAvLyBhbGwgRXVybyBGb3JtYXRzIChkYXRlL21vbnRoL3llYXIpXHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlRXVybzpcclxuICAgICAgbWFwID0gJ0REL01NL1lZWVknO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVFdXJvU2hvcnQ6XHJcbiAgICAgIG1hcCA9ICdEL00vWVknO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lRXVybzpcclxuICAgICAgbWFwID0gJ0REL01NL1lZWVkgSEg6bW06c3MnO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lU2hvcnRFdXJvOlxyXG4gICAgICBtYXAgPSAnREQvTU0vWVlZWSBISDptbSc7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVFdXJvQW1QbTpcclxuICAgICAgbWFwID0gJ0REL01NL1lZWVkgaGg6bW06c3MgYSc7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVFdXJvQU1fUE06XHJcbiAgICAgIG1hcCA9ICdERC9NTS9ZWVlZIGhoOm1tOnNzIEEnO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lRXVyb1Nob3J0OlxyXG4gICAgICBtYXAgPSAnRC9NL1lZIEg6bTpzJztcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZUV1cm9TaG9ydEFtUG06XHJcbiAgICAgIG1hcCA9ICdEL00vWVkgaDptOnMgYSc7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgLy8gYWxsIFVTIEZvcm1hdHMgKG1vbnRoL2RhdGUveWVhcilcclxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVVczpcclxuICAgICAgbWFwID0gJ01NL0REL1lZWVknO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVVc1Nob3J0OlxyXG4gICAgICBtYXAgPSAnTS9EL1lZJztcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZVVzOlxyXG4gICAgICBtYXAgPSAnTU0vREQvWVlZWSBISDptbTpzcyc7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVTaG9ydFVzOlxyXG4gICAgICBtYXAgPSAnTU0vREQvWVlZWSBISDptbSc7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVVc0FtUG06XHJcbiAgICAgIG1hcCA9ICdNTS9ERC9ZWVlZIGhoOm1tOnNzIGEnO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lVXNBTV9QTTpcclxuICAgICAgbWFwID0gJ01NL0REL1lZWVkgaGg6bW06c3MgQSc7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVVc1Nob3J0OlxyXG4gICAgICBtYXAgPSAnTS9EL1lZIEg6bTpzJztcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZVVzU2hvcnRBbVBtOlxyXG4gICAgICBtYXAgPSAnTS9EL1lZIGg6bTpzIGEnO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVVdGM6XHJcbiAgICAgIG1hcCA9ICdZWVlZLU1NLUREVEhIOm1tOnNzLlNTU1onO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGU6XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlSXNvOlxyXG4gICAgZGVmYXVsdDpcclxuICAgICAgbWFwID0gJ1lZWVktTU0tREQnO1xyXG4gICAgICBicmVhaztcclxuICB9XHJcbiAgcmV0dXJuIG1hcDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEZyb20gYSBEYXRlIEZpZWxkVHlwZSwgcmV0dXJuIGl0J3MgZXF1aXZhbGVudCBGbGF0cGlja3IgZm9ybWF0XHJcbiAqIHJlZmVyIHRvIEZsYXRwaWNrciBmb3IgdGhlIGZvcm1hdCBzdGFuZGFyZCB1c2VkOiBodHRwczovL2NobWxuLmdpdGh1Yi5pby9mbGF0cGlja3IvZm9ybWF0dGluZy8jZGF0ZS1mb3JtYXR0aW5nLXRva2Vuc1xyXG4gKiBhbHNvIG5vdGUgdGhhdCB0aGV5IHNlZW0gdmVyeSBzaW1pbGFyIHRvIFBIUCBmb3JtYXQgKGV4Y2VwdCBmb3IgYW0vcG0pOiBodHRwOi8vcGhwLm5ldC9tYW51YWwvZW4vZnVuY3Rpb24uZGF0ZS5waHBcclxuICogQHBhcmFtIGZpZWxkVHlwZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG1hcEZsYXRwaWNrckRhdGVGb3JtYXRXaXRoRmllbGRUeXBlKGZpZWxkVHlwZTogRmllbGRUeXBlKTogc3RyaW5nIHtcclxuICAvKlxyXG4gICAgZDogRGF5IG9mIHRoZSBtb250aCwgMiBkaWdpdHMgd2l0aCBsZWFkaW5nIHplcm9zXHQwMSB0byAzMVxyXG4gICAgRDogQSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIGEgZGF5XHRNb24gdGhyb3VnaCBTdW5cclxuICAgIGw6IChsb3dlcmNhc2UgJ0wnKVx0QSBmdWxsIHRleHR1YWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIGRheSBvZiB0aGUgd2Vla1x0U3VuZGF5IHRocm91Z2ggU2F0dXJkYXlcclxuICAgIGo6IERheSBvZiB0aGUgbW9udGggd2l0aG91dCBsZWFkaW5nIHplcm9zXHQxIHRvIDMxXHJcbiAgICBKOiBEYXkgb2YgdGhlIG1vbnRoIHdpdGhvdXQgbGVhZGluZyB6ZXJvcyBhbmQgb3JkaW5hbCBzdWZmaXhcdDFzdCwgMm5kLCB0byAzMXN0XHJcbiAgICB3OiBOdW1lcmljIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBkYXkgb2YgdGhlIHdlZWtcdDAgKGZvciBTdW5kYXkpIHRocm91Z2ggNiAoZm9yIFNhdHVyZGF5KVxyXG4gICAgRjogQSBmdWxsIHRleHR1YWwgcmVwcmVzZW50YXRpb24gb2YgYSBtb250aFx0SmFudWFyeSB0aHJvdWdoIERlY2VtYmVyXHJcbiAgICBtOiBOdW1lcmljIHJlcHJlc2VudGF0aW9uIG9mIGEgbW9udGgsIHdpdGggbGVhZGluZyB6ZXJvXHQwMSB0aHJvdWdoIDEyXHJcbiAgICBuOiBOdW1lcmljIHJlcHJlc2VudGF0aW9uIG9mIGEgbW9udGgsIHdpdGhvdXQgbGVhZGluZyB6ZXJvc1x0MSB0aHJvdWdoIDEyXHJcbiAgICBNOiBBIHNob3J0IHRleHR1YWwgcmVwcmVzZW50YXRpb24gb2YgYSBtb250aFx0SmFuIHRocm91Z2ggRGVjXHJcbiAgICBVOiBUaGUgbnVtYmVyIG9mIHNlY29uZHMgc2luY2UgdGhlIFVuaXggRXBvY2hcdDE0MTM3MDQ5OTNcclxuICAgIHk6IEEgdHdvIGRpZ2l0IHJlcHJlc2VudGF0aW9uIG9mIGEgeWVhclx0OTkgb3IgMDNcclxuICAgIFk6IEEgZnVsbCBudW1lcmljIHJlcHJlc2VudGF0aW9uIG9mIGEgeWVhciwgNCBkaWdpdHNcdDE5OTkgb3IgMjAwM1xyXG4gICAgSDogSG91cnMgKDI0IGhvdXJzKVx0MDAgdG8gMjNcclxuICAgIGg6IEhvdXJzXHQxIHRvIDEyXHJcbiAgICBpOiBNaW51dGVzXHQwMCB0byA1OVxyXG4gICAgUzogU2Vjb25kcywgMiBkaWdpdHNcdDAwIHRvIDU5XHJcbiAgICBzOiBTZWNvbmRzXHQwLCAxIHRvIDU5XHJcbiAgICBLOiBBTS9QTVx0QU0gb3IgUE1cclxuICAqL1xyXG4gIGxldCBtYXA6IHN0cmluZztcclxuICBzd2l0Y2ggKGZpZWxkVHlwZSkge1xyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWU6XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZUlzbzpcclxuICAgICAgbWFwID0gJ1ktbS1kIEg6aTpTJztcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZVNob3J0SXNvOlxyXG4gICAgICBtYXAgPSAnWS1tLWQgSDppJztcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZUlzb0FtUG06XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZUlzb0FNX1BNOlxyXG4gICAgICBtYXAgPSAnWS1tLWQgaDppOlMgSyc7IC8vIHRoZXJlIGlzIG5vIGxvd2VyY2FzZSBpbiBGbGF0cGlja3IgOihcclxuICAgICAgYnJlYWs7XHJcbiAgICAvLyBhbGwgRXVybyBGb3JtYXRzIChkYXRlL21vbnRoL3llYXIpXHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlRXVybzpcclxuICAgICAgbWFwID0gJ2QvbS9ZJztcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlRXVyb1Nob3J0OlxyXG4gICAgICBtYXAgPSAnZC9tL3knO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lRXVybzpcclxuICAgICAgbWFwID0gJ2QvbS9ZIEg6aTpTJztcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZVNob3J0RXVybzpcclxuICAgICAgbWFwID0gJ2QvbS95IEg6aSc7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVFdXJvQW1QbTpcclxuICAgICAgbWFwID0gJ2QvbS9ZIGg6aTpTIEsnOyAvLyB0aGVyZSBpcyBubyBsb3dlcmNhc2UgaW4gRmxhdHBpY2tyIDooXHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVFdXJvQU1fUE06XHJcbiAgICAgIG1hcCA9ICdkL20vWSBoOmk6cyBLJztcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZUV1cm9TaG9ydDpcclxuICAgICAgbWFwID0gJ2QvbS95IEg6aTpzJztcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZUV1cm9TaG9ydEFtUG06XHJcbiAgICAgIG1hcCA9ICdkL20veSBoOmk6cyBLJzsgLy8gdGhlcmUgaXMgbm8gbG93ZXJjYXNlIGluIEZsYXRwaWNrciA6KFxyXG4gICAgICBicmVhaztcclxuICAgIC8vIGFsbCBVUyBGb3JtYXRzIChtb250aC9kYXRlL3llYXIpXHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVXM6XHJcbiAgICAgIG1hcCA9ICdtL2QvWSc7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVVzU2hvcnQ6XHJcbiAgICAgIG1hcCA9ICdtL2QveSc7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVVczpcclxuICAgICAgbWFwID0gJ20vZC9ZIEg6aTpTJztcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZVNob3J0VXM6XHJcbiAgICAgIG1hcCA9ICdtL2QveSBIOmknO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lVXNBbVBtOlxyXG4gICAgICBtYXAgPSAnbS9kL1kgaDppOlMgSyc7IC8vIHRoZXJlIGlzIG5vIGxvd2VyY2FzZSBpbiBGbGF0cGlja3IgOihcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZVVzQU1fUE06XHJcbiAgICAgIG1hcCA9ICdtL2QvWSBoOmk6cyBLJztcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZVVzU2hvcnQ6XHJcbiAgICAgIG1hcCA9ICdtL2QveSBIOmk6cyc7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVVc1Nob3J0QW1QbTpcclxuICAgICAgbWFwID0gJ20vZC95IGg6aTpzIEsnOyAvLyB0aGVyZSBpcyBubyBsb3dlcmNhc2UgaW4gRmxhdHBpY2tyIDooXHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVV0YzpcclxuICAgICAgbWFwID0gJ1onO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGU6XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlSXNvOlxyXG4gICAgZGVmYXVsdDpcclxuICAgICAgbWFwID0gJ1ktbS1kJztcclxuICAgICAgYnJlYWs7XHJcbiAgfVxyXG4gIHJldHVybiBtYXA7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNYXBwZXIgZm9yIHF1ZXJ5IG9wZXJhdG9ycyAoZXguOiA8PSBpcyBcImxlXCIsID4gaXMgXCJndFwiKVxyXG4gKiBAcGFyYW0gc3RyaW5nIG9wZXJhdG9yXHJcbiAqIEByZXR1cm5zIHN0cmluZyBtYXBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBtYXBPcGVyYXRvclR5cGUob3BlcmF0b3I6IE9wZXJhdG9yVHlwZSB8IE9wZXJhdG9yU3RyaW5nKTogT3BlcmF0b3JUeXBlIHtcclxuICBsZXQgbWFwOiBPcGVyYXRvclR5cGU7XHJcblxyXG4gIHN3aXRjaCAob3BlcmF0b3IpIHtcclxuICAgIGNhc2UgJzwnOlxyXG4gICAgY2FzZSAnTFQnOlxyXG4gICAgICBtYXAgPSBPcGVyYXRvclR5cGUubGVzc1RoYW47XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAnPD0nOlxyXG4gICAgY2FzZSAnTEUnOlxyXG4gICAgICBtYXAgPSBPcGVyYXRvclR5cGUubGVzc1RoYW5PckVxdWFsO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgJz4nOlxyXG4gICAgY2FzZSAnR1QnOlxyXG4gICAgICBtYXAgPSBPcGVyYXRvclR5cGUuZ3JlYXRlclRoYW47XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAnPj0nOlxyXG4gICAgY2FzZSAnR0UnOlxyXG4gICAgICBtYXAgPSBPcGVyYXRvclR5cGUuZ3JlYXRlclRoYW5PckVxdWFsO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgJzw+JzpcclxuICAgIGNhc2UgJyE9JzpcclxuICAgIGNhc2UgJ05FJzpcclxuICAgICAgbWFwID0gT3BlcmF0b3JUeXBlLm5vdEVxdWFsO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgJyonOlxyXG4gICAgY2FzZSAnYSonOlxyXG4gICAgY2FzZSAnU3RhcnRzV2l0aCc6XHJcbiAgICAgIG1hcCA9IE9wZXJhdG9yVHlwZS5zdGFydHNXaXRoO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgJyp6JzpcclxuICAgIGNhc2UgJ0VuZHNXaXRoJzpcclxuICAgICAgbWFwID0gT3BlcmF0b3JUeXBlLmVuZHNXaXRoO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgJz0nOlxyXG4gICAgY2FzZSAnPT0nOlxyXG4gICAgY2FzZSAnRVEnOlxyXG4gICAgICBtYXAgPSBPcGVyYXRvclR5cGUuZXF1YWw7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAnSU4nOlxyXG4gICAgICBtYXAgPSBPcGVyYXRvclR5cGUuaW47XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAnTklOJzpcclxuICAgIGNhc2UgJ05PVF9JTic6XHJcbiAgICAgIG1hcCA9IE9wZXJhdG9yVHlwZS5ub3RJbjtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlICdOb3RfQ29udGFpbnMnOlxyXG4gICAgY2FzZSAnTk9UX0NPTlRBSU5TJzpcclxuICAgICAgbWFwID0gT3BlcmF0b3JUeXBlLm5vdENvbnRhaW5zO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgJ0NvbnRhaW5zJzpcclxuICAgIGNhc2UgJ0NPTlRBSU5TJzpcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIG1hcCA9IE9wZXJhdG9yVHlwZS5jb250YWlucztcclxuICAgICAgYnJlYWs7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbWFwO1xyXG59XHJcblxyXG4vKipcclxuICogRmluZCBlcXVpdmFsZW50IHNob3J0IGRlc2lnbmF0aW9uIG9mIGFuIE9wZXJhdG9yIFR5cGUgb3IgT3BlcmF0b3IgU3RyaW5nLlxyXG4gKiBXaGVuIHVzaW5nIGEgQ29tcG91bmQgRmlsdGVyLCB3ZSB1c2UgdGhlIHNob3J0IGRlc2lnbmF0aW9uIGFuZCBzbyB3ZSBuZWVkIHRoZSBtYXBwZWQgdmFsdWUuXHJcbiAqIEZvciBleGFtcGxlIE9wZXJhdG9yVHlwZS5zdGFydHNXaXRoIHNob3J0IGRlc2lnbmF0aW9uIGlzIFwiYSpcIiwgd2hpbGUgT3BlcmF0b3JUeXBlLmdyZWF0ZXJUaGFuT3JFcXVhbCBpcyBcIj49XCJcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBtYXBPcGVyYXRvclRvU2hvcnRoYW5kRGVzaWduYXRpb24ob3BlcmF0b3I6IE9wZXJhdG9yVHlwZSB8IE9wZXJhdG9yU3RyaW5nKTogT3BlcmF0b3JTdHJpbmcge1xyXG4gIGxldCBzaG9ydE9wZXJhdG9yOiBPcGVyYXRvclN0cmluZyA9ICcnO1xyXG5cclxuICBzd2l0Y2ggKG9wZXJhdG9yKSB7XHJcbiAgICBjYXNlIE9wZXJhdG9yVHlwZS5ncmVhdGVyVGhhbjpcclxuICAgIGNhc2UgJz4nOlxyXG4gICAgICBzaG9ydE9wZXJhdG9yID0gJz4nO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgT3BlcmF0b3JUeXBlLmdyZWF0ZXJUaGFuT3JFcXVhbDpcclxuICAgIGNhc2UgJz49JzpcclxuICAgICAgc2hvcnRPcGVyYXRvciA9ICc+PSc7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBPcGVyYXRvclR5cGUubGVzc1RoYW46XHJcbiAgICBjYXNlICc8JzpcclxuICAgICAgc2hvcnRPcGVyYXRvciA9ICc8JztcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIE9wZXJhdG9yVHlwZS5sZXNzVGhhbk9yRXF1YWw6XHJcbiAgICBjYXNlICc8PSc6XHJcbiAgICAgIHNob3J0T3BlcmF0b3IgPSAnPD0nO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgT3BlcmF0b3JUeXBlLm5vdEVxdWFsOlxyXG4gICAgY2FzZSAnPD4nOlxyXG4gICAgICBzaG9ydE9wZXJhdG9yID0gJzw+JztcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIE9wZXJhdG9yVHlwZS5lcXVhbDpcclxuICAgIGNhc2UgJz0nOlxyXG4gICAgY2FzZSAnPT0nOlxyXG4gICAgY2FzZSAnRVEnOlxyXG4gICAgICBzaG9ydE9wZXJhdG9yID0gJz0nO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgT3BlcmF0b3JUeXBlLnN0YXJ0c1dpdGg6XHJcbiAgICBjYXNlICdhKic6XHJcbiAgICBjYXNlICcqJzpcclxuICAgICAgc2hvcnRPcGVyYXRvciA9ICdhKic7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBPcGVyYXRvclR5cGUuZW5kc1dpdGg6XHJcbiAgICBjYXNlICcqeic6XHJcbiAgICAgIHNob3J0T3BlcmF0b3IgPSAnKnonO1xyXG4gICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIC8vIGFueSBvdGhlciBvcGVyYXRvciB3aWxsIGJlIGNvbnNpZGVyZWQgYXMgYWxyZWFkeSBhIHNob3J0IGV4cHJlc3Npb24sIHNvIHdlIGNhbiByZXR1cm4gc2FtZSBpbnB1dCBvcGVyYXRvclxyXG4gICAgICBzaG9ydE9wZXJhdG9yID0gb3BlcmF0b3I7XHJcbiAgICAgIGJyZWFrO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHNob3J0T3BlcmF0b3I7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNYXBwZXIgZm9yIHF1ZXJ5IG9wZXJhdG9yIGJ5IGEgRmlsdGVyIFR5cGVcclxuICogRm9yIGV4YW1wbGUgYSBtdWx0aXBsZS1zZWxlY3QgdHlwaWNhbGx5IHVzZXMgJ0lOJyBvcGVyYXRvclxyXG4gKiBAcGFyYW0gb3BlcmF0b3JcclxuICogQHJldHVybnMgc3RyaW5nIG1hcFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG1hcE9wZXJhdG9yQnlGaWVsZFR5cGUoZmllbGRUeXBlOiBGaWVsZFR5cGUgfCBzdHJpbmcpOiBPcGVyYXRvclR5cGUge1xyXG4gIGxldCBtYXA6IE9wZXJhdG9yVHlwZTtcclxuXHJcbiAgc3dpdGNoIChmaWVsZFR5cGUpIHtcclxuICAgIGNhc2UgRmllbGRUeXBlLnVua25vd246XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5zdHJpbmc6XHJcbiAgICBjYXNlIEZpZWxkVHlwZS50ZXh0OlxyXG4gICAgY2FzZSBGaWVsZFR5cGUucGFzc3dvcmQ6XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5yZWFkb25seTpcclxuICAgICAgbWFwID0gT3BlcmF0b3JUeXBlLmNvbnRhaW5zO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgRmllbGRUeXBlLmZsb2F0OlxyXG4gICAgY2FzZSBGaWVsZFR5cGUubnVtYmVyOlxyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZTpcclxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVJc286XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVXRjOlxyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWU6XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZUlzbzpcclxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lSXNvQW1QbTpcclxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lSXNvQU1fUE06XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlRXVybzpcclxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVFdXJvU2hvcnQ6XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZUV1cm86XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZUV1cm9BbVBtOlxyXG4gICAgY2FzZSBGaWVsZFR5cGUuZGF0ZVRpbWVFdXJvQU1fUE06XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZUV1cm9TaG9ydDpcclxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lRXVyb1Nob3J0QW1QbTpcclxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lRXVyb1Nob3J0QU1fUE06XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVXM6XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVXNTaG9ydDpcclxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lVXM6XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZVVzQW1QbTpcclxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lVXNBTV9QTTpcclxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lVXNTaG9ydDpcclxuICAgIGNhc2UgRmllbGRUeXBlLmRhdGVUaW1lVXNTaG9ydEFtUG06XHJcbiAgICBjYXNlIEZpZWxkVHlwZS5kYXRlVGltZVVzU2hvcnRBTV9QTTpcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIG1hcCA9IE9wZXJhdG9yVHlwZS5lcXVhbDtcclxuICAgICAgYnJlYWs7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbWFwO1xyXG59XHJcblxyXG4vKiogUGFyc2UgYW55IGlucHV0IChib29sLCBudW1iZXIsIHN0cmluZykgYW5kIHJldHVybiBhIGJvb2xlYW4gb3IgRmFsc2Ugd2hlbiBub3QgcG9zc2libGUgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQm9vbGVhbihpbnB1dDogYW55KTogYm9vbGVhbiB7XHJcbiAgcmV0dXJuIC8odHJ1ZXwxKS9pLnRlc3QoaW5wdXQgKyAnJyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXJzZSBhIGRhdGUgcGFzc2VkIGFzIGEgc3RyaW5nIChEYXRlIG9ubHksIHdpdGhvdXQgdGltZSkgYW5kIHJldHVybiBhIERhdGUgb2JqZWN0IChpZiB2YWxpZClcclxuICogQHBhcmFtIGlucHV0RGF0ZVN0cmluZ1xyXG4gKiBAcmV0dXJucyBzdHJpbmcgZGF0ZSBmb3JtYXR0ZWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVV0Y0RhdGUoaW5wdXREYXRlU3RyaW5nOiBzdHJpbmcsIHVzZVV0Yz86IGJvb2xlYW4pOiBzdHJpbmcgfCBudWxsIHtcclxuICBsZXQgZGF0ZSA9IG51bGw7XHJcblxyXG4gIGlmICgvXlswLTlcXC1cXC9dKiQvLnRlc3QoaW5wdXREYXRlU3RyaW5nKSkge1xyXG4gICAgLy8gZ2V0IHRoZSBVVEMgZGF0ZXRpbWUgd2l0aCBtb21lbnQuanMgYnV0IHdlIG5lZWQgdG8gZGVjb2RlIHRoZSB2YWx1ZSBzbyB0aGF0IGl0J3MgdmFsaWQgdGV4dFxyXG4gICAgY29uc3QgZGF0ZVN0cmluZyA9IGRlY29kZVVSSUNvbXBvbmVudChpbnB1dERhdGVTdHJpbmcpO1xyXG4gICAgY29uc3QgZGF0ZU1vbWVudCA9IG1vbWVudChuZXcgRGF0ZShkYXRlU3RyaW5nKSk7XHJcbiAgICBpZiAoZGF0ZU1vbWVudC5pc1ZhbGlkKCkgJiYgZGF0ZU1vbWVudC55ZWFyKCkudG9TdHJpbmcoKS5sZW5ndGggPT09IDQpIHtcclxuICAgICAgZGF0ZSA9ICh1c2VVdGMpID8gZGF0ZU1vbWVudC51dGMoKS5mb3JtYXQoKSA6IGRhdGVNb21lbnQuZm9ybWF0KCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZGF0ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNhbml0aXplLCByZXR1cm4gb25seSB0aGUgdGV4dCB3aXRob3V0IEhUTUwgdGFnc1xyXG4gKiBAaW5wdXQgaHRtbFN0cmluZ1xyXG4gKiBAcmV0dXJuIHRleHRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzYW5pdGl6ZUh0bWxUb1RleHQoaHRtbFN0cmluZzogc3RyaW5nKSB7XHJcbiAgY29uc3QgdGVtcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gIHRlbXAuaW5uZXJIVE1MID0gaHRtbFN0cmluZztcclxuICByZXR1cm4gdGVtcC50ZXh0Q29udGVudCB8fCB0ZW1wLmlubmVyVGV4dCB8fCAnJztcclxufVxyXG5cclxuLyoqIFNldCB0aGUgb2JqZWN0IHZhbHVlIG9mIGRlZXBlciBub2RlIGZyb20gYSBnaXZlbiBkb3QgKC4pIG5vdGF0aW9uIHBhdGggKGUuZy46IFwidXNlci5maXJzdE5hbWVcIikgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNldERlZXBWYWx1ZTxUID0gYW55PihvYmo6IFQsIHBhdGg6IHN0cmluZyB8IHN0cmluZ1tdLCB2YWx1ZTogYW55KSB7XHJcbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xyXG4gICAgcGF0aCA9IHBhdGguc3BsaXQoJy4nKTtcclxuICB9XHJcblxyXG4gIGlmIChwYXRoLmxlbmd0aCA+IDEpIHtcclxuICAgIGNvbnN0IGUgPSBwYXRoLnNoaWZ0KCk7XHJcbiAgICBpZiAob2JqICYmIGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBzZXREZWVwVmFsdWUoXHJcbiAgICAgICAgb2JqW2VdID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9ialtlXSkgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gb2JqW2VdIDoge30sXHJcbiAgICAgICAgcGF0aCxcclxuICAgICAgICB2YWx1ZVxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAob2JqICYmIHBhdGhbMF0pIHtcclxuICAgIG9ialtwYXRoWzBdXSA9IHZhbHVlO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEZvcm1hdCBhIG51bWJlciBvciBhIHN0cmluZyBpbnRvIGEgc3RyaW5nIHRoYXQgaXMgc2VwYXJhdGVkIGV2ZXJ5IHRob3VzYW5kLFxyXG4gKiB0aGUgZGVmYXVsdCBzZXBhcmF0b3IgaXMgYSBjb21tYSBidXQgdXNlciBjYW4gb3B0aW9uYWxseSBwYXNzIGEgZGlmZmVyZW50IG9uZVxyXG4gKiBAcGFyYW0gaW5wdXRWYWx1ZVxyXG4gKiBAcGFyYW0gc2VwYXJhdG9yIGRlZmF1bHQgdG8gY29tbWEgXCIsXCJcclxuICogQHJldHVybnMgc3RyaW5nXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdGhvdXNhbmRTZXBhcmF0b3JGb3JtYXR0ZWQoaW5wdXRWYWx1ZTogc3RyaW5nIHwgbnVtYmVyIHwgbnVsbCwgc2VwYXJhdG9yOiAnLCcgfCAnXycgfCAnLicgfCAnICcgfCAnJyA9ICcsJyk6IHN0cmluZyB8IG51bGwge1xyXG4gIGlmIChpbnB1dFZhbHVlICE9PSBudWxsICYmIGlucHV0VmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgY29uc3Qgc3RyaW5nVmFsdWUgPSBgJHtpbnB1dFZhbHVlfWA7XHJcbiAgICBjb25zdCBkZWNpbWFsU3BsaXQgPSBzdHJpbmdWYWx1ZS5zcGxpdCgnLicpO1xyXG4gICAgaWYgKGRlY2ltYWxTcGxpdC5sZW5ndGggPT09IDIpIHtcclxuICAgICAgcmV0dXJuIGAke2RlY2ltYWxTcGxpdFswXS5yZXBsYWNlKC9cXEIoPz0oXFxkezN9KSsoPyFcXGQpKS9nLCBzZXBhcmF0b3IpfS4ke2RlY2ltYWxTcGxpdFsxXX1gO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN0cmluZ1ZhbHVlLnJlcGxhY2UoL1xcQig/PShcXGR7M30pKyg/IVxcZCkpL2csIHNlcGFyYXRvcik7XHJcbiAgfVxyXG4gIHJldHVybiBpbnB1dFZhbHVlIGFzIG51bGw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaXRsZSBjYXNlIChvciBjYXBpdGFsaXplKSBmaXJzdCBjaGFyIG9mIGEgc3RyaW5nLCBmb3IgZXhhbXBsZSBcImhlbGxvIHdvcmxkXCIgd2lsbCBiZWNvbWUgXCJIZWxsbyB3b3JsZFwiXHJcbiAqIENoYW5nZSB0aGUgc3RyaW5nIHRvIGJlIHRpdGxlIGNhc2Ugb24gdGhlIGNvbXBsZXRlIHNlbnRlbmNlICh1cHBlciBjYXNlIGZpcnN0IGNoYXIgb2YgZWFjaCB3b3JkIHdoaWxlIGNoYW5naW5nIGV2ZXJ5dGhpbmcgZWxzZSB0byBsb3dlciBjYXNlKVxyXG4gKiBAcGFyYW0gaW5wdXRTdHJcclxuICogQHJldHVybnMgc3RyaW5nXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdGl0bGVDYXNlKGlucHV0U3RyOiBzdHJpbmcsIGNhc2VFdmVyeVdvcmRzID0gZmFsc2UpOiBzdHJpbmcge1xyXG4gIGlmICh0eXBlb2YgaW5wdXRTdHIgPT09ICdzdHJpbmcnKSB7XHJcbiAgICBpZiAoY2FzZUV2ZXJ5V29yZHMpIHtcclxuICAgICAgcmV0dXJuIGlucHV0U3RyLnJlcGxhY2UoL1xcd1xcUyovZywgKG91dHB1dFN0cikgPT4ge1xyXG4gICAgICAgIHJldHVybiBvdXRwdXRTdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBvdXRwdXRTdHIuc3Vic3RyKDEpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGlucHV0U3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgaW5wdXRTdHIuc2xpY2UoMSk7XHJcbiAgfVxyXG4gIHJldHVybiBpbnB1dFN0cjtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIGEgc3RyaW5nIHRvIGNhbWVsIGNhc2UgKGNhbWVsQ2FzZSksIGZvciBleGFtcGxlIFwiaGVsbG8td29ybGRcIiAob3IgXCJoZWxsb3cgd29ybGRcIikgd2lsbCBiZWNvbWUgXCJoZWxsb1dvcmxkXCJcclxuICogQHBhcmFtIGlucHV0U3RyIHRoZSBzdHJpbmcgdG8gY29udmVydFxyXG4gKiBAcmV0dXJuIHRoZSBzdHJpbmcgaW4gY2FtZWwgY2FzZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRvQ2FtZWxDYXNlKGlucHV0U3RyOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gIGlmICh0eXBlb2YgaW5wdXRTdHIgPT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm4gaW5wdXRTdHIucmVwbGFjZSgvKD86Xlxcd3xbQS1aXXxcXGJcXHd8W1xccytcXC1fXFwvXSkvZywgKG1hdGNoOiBzdHJpbmcsIG9mZnNldDogbnVtYmVyKSA9PiB7XHJcbiAgICAgIC8vIHJlbW92ZSB3aGl0ZSBzcGFjZSBvciBoeXBlbnMgb3IgdW5kZXJzY29yZXNcclxuICAgICAgaWYgKC9bXFxzK1xcLV9cXC9dLy50ZXN0KG1hdGNoKSkge1xyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG9mZnNldCA9PT0gMCA/IG1hdGNoLnRvTG93ZXJDYXNlKCkgOiBtYXRjaC50b1VwcGVyQ2FzZSgpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHJldHVybiBpbnB1dFN0cjtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIGEgc3RyaW5nIHRvIGtlYmFiIChoeXBlbikgY2FzZSwgZm9yIGV4YW1wbGUgXCJoZWxsb1dvcmxkXCIgd2lsbCBiZWNvbWUgXCJoZWxsby13b3JsZFwiXHJcbiAqIEBwYXJhbSBzdHIgdGhlIHN0cmluZyB0byBjb252ZXJ0XHJcbiAqIEByZXR1cm4gdGhlIHN0cmluZyBpbiBrZWJhYiBjYXNlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdG9LZWJhYkNhc2UoaW5wdXRTdHI6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgaWYgKHR5cGVvZiBpbnB1dFN0ciA9PT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVybiB0b0NhbWVsQ2FzZShpbnB1dFN0cikucmVwbGFjZSgvKFtBLVpdKS9nLCAnLSQxJykudG9Mb3dlckNhc2UoKTtcclxuICB9XHJcbiAgcmV0dXJuIGlucHV0U3RyO1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydHMgYSBzdHJpbmcgZnJvbSBjYW1lbENhc2UgdG8gc25ha2VfY2FzZSAodW5kZXJzY29yZSkgY2FzZSwgZm9yIGV4YW1wbGUgXCJoZWxsb1dvcmxkXCIgd2lsbCBiZWNvbWUgXCJoZWxsb193b3JsZFwiXHJcbiAqIEBwYXJhbSBzdHIgdGhlIHN0cmluZyB0byBjb252ZXJ0XHJcbiAqIEByZXR1cm4gdGhlIHN0cmluZyBpbiBrZWJhYiBjYXNlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdG9TbmFrZUNhc2UoaW5wdXRTdHI6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgaWYgKHR5cGVvZiBpbnB1dFN0ciA9PT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVybiB0b0NhbWVsQ2FzZShpbnB1dFN0cikucmVwbGFjZSgvKFtBLVpdKS9nLCAnXyQxJykudG9Mb3dlckNhc2UoKTtcclxuICB9XHJcbiAgcmV0dXJuIGlucHV0U3RyO1xyXG59XHJcblxyXG4vKipcclxuICogVGFrZXMgYW4gaW5wdXQgYXJyYXkgYW5kIG1ha2VzIHN1cmUgdGhlIGFycmF5IGhhcyB1bmlxdWUgdmFsdWVzIGJ5IHJlbW92aW5nIGR1cGxpY2F0ZXNcclxuICogQHBhcmFtIGFycmF5IGlucHV0IHdpdGggcG9zc2libGUgZHVwbGljYXRlc1xyXG4gKiBAcGFyYW0gb2JqZWN0UHJvcGVydHkgb3B0aW9uYWxseSBwcm92aWRlIGFuIG9iamVjdCBwcm9wZXJ0eSB0byBjb21wYXJlIChleGFtcGxlOiAnaWQnKVxyXG4gKiBAcmV0dXJuIGFycmF5IG91dHB1dCB3aXRob3V0IGR1cGxpY2F0ZXNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1bmlxdWVBcnJheTxUID0gYW55PihhcnI6IFRbXSk6IFRbXSB7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSAmJiBhcnIubGVuZ3RoID4gMCkge1xyXG4gICAgcmV0dXJuIGFyci5maWx0ZXIoKGl0ZW06IFQsIGluZGV4OiBudW1iZXIpID0+IHtcclxuICAgICAgcmV0dXJuIGFyci5pbmRleE9mKGl0ZW0pID49IGluZGV4O1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHJldHVybiBhcnI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUYWtlcyBhbiBpbnB1dCBhcnJheSBvZiBvYmplY3RzIGFuZCBtYWtlcyBzdXJlIHRoZSBhcnJheSBoYXMgdW5pcXVlIG9iamVjdCB2YWx1ZXMgYnkgcmVtb3ZpbmcgZHVwbGljYXRlc1xyXG4gKiBpdCB3aWxsIGxvb3AgdGhyb3VnaCB0aGUgYXJyYXkgdXNpbmcgYSBwcm9wZXJ0eSBuYW1lIChvciBcImlkXCIgd2hlbiBpcyBub3QgcHJvdmlkZWQpIHRvIGNvbXBhcmUgdW5pcXVlbmVzc1xyXG4gKiBAcGFyYW0gYXJyYXkgaW5wdXQgd2l0aCBwb3NzaWJsZSBkdXBsaWNhdGVzXHJcbiAqIEBwYXJhbSBwcm9wZXJ0eU5hbWUgZGVmYXVsdHMgdG8gXCJpZFwiXHJcbiAqIEByZXR1cm4gYXJyYXkgb3V0cHV0IHdpdGhvdXQgZHVwbGljYXRlc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVuaXF1ZU9iamVjdEFycmF5KGFycjogYW55W10sIHByb3BlcnR5TmFtZSA9ICdpZCcpOiBhbnlbXSB7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSAmJiBhcnIubGVuZ3RoID4gMCkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XHJcblxyXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGFycikge1xyXG4gICAgICBpZiAoIW1hcC5oYXMoaXRlbVtwcm9wZXJ0eU5hbWVdKSkge1xyXG4gICAgICAgIG1hcC5zZXQoaXRlbVtwcm9wZXJ0eU5hbWVdLCB0cnVlKTsgICAgLy8gc2V0IGFueSB2YWx1ZSB0byBNYXBcclxuICAgICAgICByZXN1bHQucHVzaCh7XHJcbiAgICAgICAgICBpZDogaXRlbVtwcm9wZXJ0eU5hbWVdLFxyXG4gICAgICAgICAgbmFtZTogaXRlbS5uYW1lXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG4gIHJldHVybiBhcnI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBVbnN1YnNjcmliZSBhbGwgT2JzZXJ2YWJsZXMgU3Vic2NyaXB0aW9uc1xyXG4gKiBJdCB3aWxsIHJldHVybiBhbiBlbXB0eSBhcnJheSBpZiBpdCBhbGwgd2VudCB3ZWxsXHJcbiAqIEBwYXJhbSBzdWJzY3JpcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdW5zdWJzY3JpYmVBbGxPYnNlcnZhYmxlcyhzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSk6IFN1YnNjcmlwdGlvbltdIHtcclxuICBpZiAoQXJyYXkuaXNBcnJheShzdWJzY3JpcHRpb25zKSkge1xyXG4gICAgc3Vic2NyaXB0aW9ucy5mb3JFYWNoKChzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbikgPT4ge1xyXG4gICAgICBpZiAoc3Vic2NyaXB0aW9uICYmIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSkge1xyXG4gICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHN1YnNjcmlwdGlvbnMgPSBbXTtcclxuICB9XHJcblxyXG4gIHJldHVybiBzdWJzY3JpcHRpb25zO1xyXG59XHJcbiJdfQ==