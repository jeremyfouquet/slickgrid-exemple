import * as tslib_1 from "tslib";
import * as isequal_ from 'lodash.isequal';
const isequal = isequal_; // patch to fix rollup to work
import { ExtensionName, GridStateType, } from './../models/index';
import { ExtensionService } from './extension.service';
import { FilterService } from './filter.service';
import { SortService } from './sort.service';
import { Subject } from 'rxjs';
import { unsubscribeAllObservables } from './utilities';
import { SharedService } from './shared.service';
import { Injectable } from '@angular/core';
let GridStateService = class GridStateService {
    constructor(extensionService, filterService, sharedService, sortService) {
        this.extensionService = extensionService;
        this.filterService = filterService;
        this.sharedService = sharedService;
        this.sortService = sortService;
        this._columns = [];
        this._currentColumns = [];
        this._subscriptions = [];
        this._selectedRowDataContextIds = []; // used with row selection
        this._selectedFilteredRowDataContextIds = []; // used with row selection
        this._wasRecheckedAfterPageChange = true; // used with row selection & pagination
        this.onGridStateChanged = new Subject();
        this._eventHandler = new Slick.EventHandler();
    }
    /** Getter for the Grid Options pulled through the Grid Object */
    get _gridOptions() {
        return (this._grid && this._grid.getOptions) ? this._grid.getOptions() : {};
    }
    get datasetIdPropName() {
        return this._gridOptions.datasetIdPropertyName || 'id';
    }
    /** Getter of the selected data context object IDs */
    get selectedRowDataContextIds() {
        return this._selectedRowDataContextIds;
    }
    /** Setter of the selected data context object IDs */
    set selectedRowDataContextIds(dataContextIds) {
        this._selectedRowDataContextIds = dataContextIds;
        // since this is coming from a preset, we also need to update the filtered IDs
        this._selectedFilteredRowDataContextIds = dataContextIds;
    }
    /**
     * Initialize the Grid State Service
     * @param grid
     */
    init(grid, dataView) {
        this._grid = grid;
        this._dataView = dataView;
        this.subscribeToAllGridChanges(grid);
    }
    /** Dispose of all the SlickGrid & Angular subscriptions */
    dispose() {
        // unsubscribe all SlickGrid events
        this._eventHandler.unsubscribeAll();
        // also unsubscribe all Angular Subscriptions
        this._subscriptions = unsubscribeAllObservables(this._subscriptions);
        this._currentColumns = [];
        this._columns = [];
    }
    /**
     * Get the current grid state (filters/sorters/pagination)
     * @return grid state
     */
    getCurrentGridState(args) {
        const gridState = {
            columns: this.getCurrentColumns(),
            filters: this.getCurrentFilters(),
            sorters: this.getCurrentSorters(),
        };
        const currentPagination = this.getCurrentPagination();
        if (currentPagination) {
            gridState.pagination = currentPagination;
        }
        if (this.hasRowSelectionEnabled()) {
            const currentRowSelection = this.getCurrentRowSelections(args && args.requestRefreshRowFilteredRow);
            if (currentRowSelection) {
                gridState.rowSelection = currentRowSelection;
            }
        }
        return gridState;
    }
    /**
     * Get the Columns (and their state: visibility/position) that are currently applied in the grid
     * @return current columns
     */
    getColumns() {
        return this._columns;
    }
    /**
     * From an array of Grid Column Definitions, get the associated Current Columns
     * @param gridColumns
     */
    getAssociatedCurrentColumns(gridColumns) {
        const currentColumns = [];
        if (gridColumns && Array.isArray(gridColumns)) {
            gridColumns.forEach((column, index) => {
                if (column && column.id) {
                    currentColumns.push({
                        columnId: column.id,
                        cssClass: column.cssClass || '',
                        headerCssClass: column.headerCssClass || '',
                        width: column.width || 0
                    });
                }
            });
        }
        this._currentColumns = currentColumns;
        return currentColumns;
    }
    /**
     * From an array of Current Columns, get the associated Grid Column Definitions
     * @param grid
     * @param currentColumns
     */
    getAssociatedGridColumns(grid, currentColumns) {
        const columns = [];
        const gridColumns = grid.getColumns();
        if (currentColumns && Array.isArray(currentColumns)) {
            currentColumns.forEach((currentColumn, index) => {
                const gridColumn = gridColumns.find((c) => c.id === currentColumn.columnId);
                if (gridColumn && gridColumn.id) {
                    columns.push(Object.assign({}, gridColumn, { cssClass: currentColumn.cssClass, headerCssClass: currentColumn.headerCssClass, width: currentColumn.width }));
                }
            });
        }
        this._columns = columns;
        return columns;
    }
    /**
     * Get the Columns (and their states: visibility/position/width) that are currently applied in the grid
     * @return current columns
     */
    getCurrentColumns() {
        let currentColumns = [];
        if (this._currentColumns && Array.isArray(this._currentColumns) && this._currentColumns.length > 0) {
            currentColumns = this._currentColumns;
        }
        else {
            currentColumns = this.getAssociatedCurrentColumns(this._grid.getColumns());
        }
        return currentColumns;
    }
    /**
     * Get the Filters (and their state, columnId, searchTerm(s)) that are currently applied in the grid
     * @return current filters
     */
    getCurrentFilters() {
        if (this._gridOptions && this._gridOptions.backendServiceApi) {
            const backendService = this._gridOptions.backendServiceApi.service;
            if (backendService && backendService.getCurrentFilters) {
                return backendService.getCurrentFilters();
            }
        }
        else if (this.filterService && this.filterService.getCurrentLocalFilters) {
            return this.filterService.getCurrentLocalFilters();
        }
        return null;
    }
    /**
     * Get current Pagination (and its state, pageNumber, pageSize) that are currently applied in the grid
     * @return current pagination state
     */
    getCurrentPagination() {
        if (this._gridOptions.enablePagination) {
            if (this._gridOptions && this._gridOptions.backendServiceApi) {
                const backendService = this._gridOptions.backendServiceApi.service;
                if (backendService && backendService.getCurrentPagination) {
                    return backendService.getCurrentPagination();
                }
            }
            else {
                return this.sharedService.currentPagination;
            }
        }
        return null;
    }
    /**
     * Get the current Row Selections (and its state, gridRowIndexes, dataContextIds, filteredDataContextIds) that are currently applied in the grid
     * @return current row selection
     */
    getCurrentRowSelections(requestRefreshFilteredRow = true) {
        if (this._grid && this._gridOptions && this._dataView && this.hasRowSelectionEnabled()) {
            if (this._grid.getSelectedRows && this._dataView.mapRowsToIds) {
                let filteredDataContextIds = [];
                const gridRowIndexes = this._dataView.mapIdsToRows(this._selectedRowDataContextIds || []); // note that this will return only what is visible in current page
                const dataContextIds = this._selectedRowDataContextIds;
                // user might request to refresh the filtered selection dataset
                // typically always True, except when "reEvaluateRowSelectionAfterFilterChange" is called and we don't need to refresh the filtered dataset twice
                if (requestRefreshFilteredRow === true) {
                    filteredDataContextIds = this.refreshFilteredRowSelections();
                }
                filteredDataContextIds = this._selectedFilteredRowDataContextIds;
                return { gridRowIndexes, dataContextIds, filteredDataContextIds };
            }
        }
        return null;
    }
    /**
     * Get the current Sorters (and their state, columnId, direction) that are currently applied in the grid
     * @return current sorters
     */
    getCurrentSorters() {
        if (this._gridOptions && this._gridOptions.backendServiceApi) {
            const backendService = this._gridOptions.backendServiceApi.service;
            if (backendService && backendService.getCurrentSorters) {
                return backendService.getCurrentSorters();
            }
        }
        else if (this.sortService && this.sortService.getCurrentLocalSorters) {
            return this.sortService.getCurrentLocalSorters();
        }
        return null;
    }
    /** Check whether the row selection needs to be preserved */
    needToPreserveRowSelection() {
        let preservedRowSelection = false;
        if (this._gridOptions && this._gridOptions.dataView && this._gridOptions.dataView.hasOwnProperty('syncGridSelection')) {
            const syncGridSelection = this._gridOptions.dataView.syncGridSelection;
            if (typeof syncGridSelection === 'boolean') {
                preservedRowSelection = this._gridOptions.dataView.syncGridSelection;
            }
            else {
                preservedRowSelection = syncGridSelection.preserveHidden;
            }
            // if the result is True but the grid is using a Backend Service, we will do an extra flag check the reason is because it might have some unintended behaviors
            // with the BackendServiceApi because technically the data in the page changes the DataView on every page.
            if (preservedRowSelection && this._gridOptions.backendServiceApi && this._gridOptions.dataView.hasOwnProperty('syncGridSelectionWithBackendService')) {
                preservedRowSelection = this._gridOptions.dataView.syncGridSelectionWithBackendService;
            }
        }
        return preservedRowSelection;
    }
    resetColumns(columnDefinitions) {
        const columns = columnDefinitions || this._columns;
        const currentColumns = this.getAssociatedCurrentColumns(columns);
        this.onGridStateChanged.next({ change: { newValues: currentColumns, type: GridStateType.columns }, gridState: this.getCurrentGridState() });
    }
    /** if we use Row Selection or the Checkbox Selector, we need to reset any selection */
    resetRowSelectionWhenRequired() {
        if (!this.needToPreserveRowSelection() && (this._gridOptions.enableRowSelection || this._gridOptions.enableCheckboxSelector)) {
            // this also requires the Row Selection Model to be registered as well
            const rowSelectionExtension = this.extensionService && this.extensionService.getExtensionByName && this.extensionService.getExtensionByName(ExtensionName.rowSelection);
            if (rowSelectionExtension && rowSelectionExtension.instance) {
                this._grid.setSelectedRows([]);
            }
        }
    }
    /**
     * Subscribe to all necessary SlickGrid or Service Events that deals with a Grid change,
     * when triggered, we will publish a Grid State Event with current Grid State
     */
    subscribeToAllGridChanges(grid) {
        // Subscribe to Event Emitter of Filter changed
        this._subscriptions.push(this.filterService.onFilterChanged.subscribe((currentFilters) => {
            this.resetRowSelectionWhenRequired();
            // trigger a Grid State filter change, however don't reevaluate the filtered row selections, we'll do that on the next Grid State change below
            this.onGridStateChanged.next({ change: { newValues: currentFilters, type: GridStateType.filter }, gridState: this.getCurrentGridState({ requestRefreshRowFilteredRow: !this.hasRowSelectionEnabled() }) });
            // when Row Selection is enabled, we also need to re-evaluate the row selection with the leftover filtered dataset
            if (this.hasRowSelectionEnabled()) {
                this.reEvaluateRowSelectionAfterFilterChange();
            }
        }));
        // Subscribe to Event Emitter of Filter cleared
        this._subscriptions.push(this.filterService.onFilterCleared.subscribe(() => {
            this.resetRowSelectionWhenRequired();
            this.onGridStateChanged.next({ change: { newValues: [], type: GridStateType.filter }, gridState: this.getCurrentGridState() });
        }));
        // Subscribe to Event Emitter of Sort changed
        this._subscriptions.push(this.sortService.onSortChanged.subscribe((currentSorters) => {
            this.resetRowSelectionWhenRequired();
            this.onGridStateChanged.next({ change: { newValues: currentSorters, type: GridStateType.sorter }, gridState: this.getCurrentGridState() });
        }));
        // Subscribe to Event Emitter of Sort cleared
        this._subscriptions.push(this.sortService.onSortCleared.subscribe(() => {
            this.resetRowSelectionWhenRequired();
            this.onGridStateChanged.next({ change: { newValues: [], type: GridStateType.sorter }, gridState: this.getCurrentGridState() });
        }));
        // Subscribe to ColumnPicker and/or GridMenu for show/hide Columns visibility changes
        this.bindExtensionAddonEventToGridStateChange(ExtensionName.columnPicker, 'onColumnsChanged');
        this.bindExtensionAddonEventToGridStateChange(ExtensionName.gridMenu, 'onColumnsChanged');
        // subscribe to Column Resize & Reordering
        this.bindSlickGridColumnChangeEventToGridStateChange('onColumnsReordered', grid);
        this.bindSlickGridColumnChangeEventToGridStateChange('onColumnsResized', grid);
        // subscribe to Row Selection changes (when enabled)
        if (this._gridOptions.enableRowSelection || this._gridOptions.enableCheckboxSelector) {
            this.bindSlickGridRowSelectionToGridStateChange();
        }
        // subscribe to HeaderMenu (hide column)
        this._subscriptions.push(this.sharedService.onHeaderMenuHideColumns.subscribe((visibleColumns) => {
            const currentColumns = this.getAssociatedCurrentColumns(visibleColumns);
            this.onGridStateChanged.next({ change: { newValues: currentColumns, type: GridStateType.columns }, gridState: this.getCurrentGridState() });
        }));
    }
    // --
    // private methods
    // ------------------
    /**
     * Bind a SlickGrid Extension Event to a Grid State change event
     * @param extension name
     * @param grid
     */
    bindExtensionAddonEventToGridStateChange(extensionName, eventName) {
        const extension = this.extensionService && this.extensionService.getExtensionByName && this.extensionService.getExtensionByName(extensionName);
        const slickEvent = extension && extension.instance && extension.instance[eventName];
        if (slickEvent && slickEvent.subscribe) {
            this._eventHandler.subscribe(slickEvent, (e, args) => {
                const columns = args && args.columns;
                const currentColumns = this.getAssociatedCurrentColumns(columns);
                this.onGridStateChanged.next({ change: { newValues: currentColumns, type: GridStateType.columns }, gridState: this.getCurrentGridState() });
            });
        }
    }
    /**
     * Bind a Grid Event (of Column changes) to a Grid State change event
     * @param event name
     * @param grid
     */
    bindSlickGridColumnChangeEventToGridStateChange(eventName, grid) {
        const slickGridEvent = grid && grid[eventName];
        if (slickGridEvent && slickGridEvent.subscribe) {
            this._eventHandler.subscribe(slickGridEvent, () => {
                const columns = grid.getColumns();
                const currentColumns = this.getAssociatedCurrentColumns(columns);
                this.onGridStateChanged.next({ change: { newValues: currentColumns, type: GridStateType.columns }, gridState: this.getCurrentGridState() });
            });
        }
    }
    /**
     * Bind a Grid Event of Row Selection change to a Grid State change event
     * For the row selection, we can't just use the getSelectedRows() since this will only return the visible rows shown in the UI which is not enough.
     * The process is much more complex, what we have to do instead is the following
     * 1. when changing a row selection, we'll add the new selection if it's not yet in the global array of selected IDs
     * 2. when deleting a row selection, we'll remove the selection from our global array of selected IDs (unless it came from a page change)
     * 3. if we use Pagination and we change page, we'll keep track with a flag (this flag will be used to skip any deletion when we're changing page)
     * 4. after the Page or DataView is changed or updated, we'll do an extra (and delayed) check to make sure that what we have in our global array of selected IDs is displayed on screen
     */
    bindSlickGridRowSelectionToGridStateChange() {
        if (this._grid && this._gridOptions && this._dataView) {
            this._eventHandler.subscribe(this._dataView.onBeforePagingInfoChanged, () => {
                this._wasRecheckedAfterPageChange = false; // reset the page check flag, to skip deletions on page change (used in code below)
            });
            this._eventHandler.subscribe(this._dataView.onPagingInfoChanged, () => {
                // when user changes page, the selected row indexes might not show up
                // we can check to make sure it is but it has to be in a delay so it happens after the first "onSelectedRowsChanged" is triggered
                setTimeout(() => {
                    const shouldBeSelectedRowIndexes = this._dataView.mapIdsToRows(this._selectedRowDataContextIds || []);
                    const currentSelectedRowIndexes = this._grid.getSelectedRows();
                    if (!isequal(shouldBeSelectedRowIndexes, currentSelectedRowIndexes)) {
                        this._grid.setSelectedRows(shouldBeSelectedRowIndexes);
                    }
                });
            });
            this._eventHandler.subscribe(this._grid.onSelectedRowsChanged, (e, args) => {
                if (Array.isArray(args.rows) && Array.isArray(args.previousSelectedRows)) {
                    const newSelectedRows = args.rows;
                    const prevSelectedRows = args.previousSelectedRows;
                    const newSelectedAdditions = newSelectedRows.filter((i) => prevSelectedRows.indexOf(i) < 0);
                    const newSelectedDeletions = prevSelectedRows.filter((i) => newSelectedRows.indexOf(i) < 0);
                    // deletion might happen when user is changing page, if that is the case then skip the deletion since it's only a visual deletion (current page)
                    // if it's not a page change (when the flag is true), then proceed with the deletion in our global array of selected IDs
                    if (this._wasRecheckedAfterPageChange && newSelectedDeletions.length > 0) {
                        const toDeleteDataIds = this._dataView.mapRowsToIds(newSelectedDeletions) || [];
                        toDeleteDataIds.forEach((removeId) => {
                            this._selectedRowDataContextIds.splice(this._selectedRowDataContextIds.indexOf(removeId), 1);
                        });
                    }
                    // if we have newly added selected row(s), let's update our global array of selected IDs
                    if (newSelectedAdditions.length > 0) {
                        const toAddDataIds = this._dataView.mapRowsToIds(newSelectedAdditions) || [];
                        toAddDataIds.forEach((dataId) => {
                            if (this._selectedRowDataContextIds.indexOf(dataId) === -1) {
                                this._selectedRowDataContextIds.push(dataId);
                            }
                        });
                    }
                    // we set this flag which will be used on the 2nd time the "onSelectedRowsChanged" event is called
                    // when it's the first time, we skip deletion and this is what this flag is for
                    this._wasRecheckedAfterPageChange = true;
                    // form our full selected row IDs, let's make sure these indexes are selected in the grid, if not then let's call a reselect
                    // this could happen if the previous step was a page change
                    const shouldBeSelectedRowIndexes = this._dataView.mapIdsToRows(this._selectedRowDataContextIds || []);
                    const currentSelectedRowIndexes = this._grid.getSelectedRows();
                    if (!isequal(shouldBeSelectedRowIndexes, currentSelectedRowIndexes)) {
                        this._grid.setSelectedRows(shouldBeSelectedRowIndexes);
                    }
                    const filteredDataContextIds = this.refreshFilteredRowSelections();
                    const newValues = { gridRowIndexes: this._grid.getSelectedRows(), dataContextIds: this._selectedRowDataContextIds, filteredDataContextIds };
                    this.onGridStateChanged.next({ change: { newValues, type: GridStateType.rowSelection }, gridState: this.getCurrentGridState() });
                }
            });
        }
    }
    /** Check wether the grid has the Row Selection enabled */
    hasRowSelectionEnabled() {
        const selectionModel = this._grid.getSelectionModel();
        const isRowSelectionEnabled = this._gridOptions.enableRowSelection || this._gridOptions.enableCheckboxSelector;
        return (isRowSelectionEnabled && selectionModel);
    }
    reEvaluateRowSelectionAfterFilterChange() {
        const currentSelectedRowIndexes = this._grid.getSelectedRows();
        const previousSelectedFilteredRowDataContextIds = this._selectedFilteredRowDataContextIds.slice();
        const filteredDataContextIds = this.refreshFilteredRowSelections();
        // when selection changed, we'll send a Grid State event with the selection changes
        if (!isequal(this._selectedFilteredRowDataContextIds, previousSelectedFilteredRowDataContextIds)) {
            const newValues = { gridRowIndexes: currentSelectedRowIndexes, dataContextIds: this._selectedRowDataContextIds, filteredDataContextIds };
            this.onGridStateChanged.next({ change: { newValues, type: GridStateType.rowSelection }, gridState: this.getCurrentGridState({ requestRefreshRowFilteredRow: false }) });
        }
    }
    /** When a Filter is triggered or when user request it, we will refresh the filtered selection array and return it */
    refreshFilteredRowSelections() {
        let tmpFilteredArray = [];
        const filteredDataset = this._dataView.getFilteredItems() || [];
        if (Array.isArray(this._selectedRowDataContextIds)) {
            const selectedFilteredRowDataContextIds = [...this._selectedRowDataContextIds]; // take a fresh copy of all selections before filtering the row ids
            tmpFilteredArray = selectedFilteredRowDataContextIds.filter((selectedRowId) => {
                return filteredDataset.findIndex((item) => item[this.datasetIdPropName] === selectedRowId) > -1;
            });
            this._selectedFilteredRowDataContextIds = tmpFilteredArray;
        }
        return tmpFilteredArray;
    }
};
GridStateService.ctorParameters = () => [
    { type: ExtensionService },
    { type: FilterService },
    { type: SharedService },
    { type: SortService }
];
GridStateService = tslib_1.__decorate([
    Injectable()
], GridStateService);
export { GridStateService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JpZFN0YXRlLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9hbmd1bGFyLXNsaWNrZ3JpZC8iLCJzb3VyY2VzIjpbImFwcC9tb2R1bGVzL2FuZ3VsYXItc2xpY2tncmlkL3NlcnZpY2VzL2dyaWRTdGF0ZS5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEtBQUssUUFBUSxNQUFNLGdCQUFnQixDQUFDO0FBQzNDLE1BQU0sT0FBTyxHQUFHLFFBQVEsQ0FBQyxDQUFDLDhCQUE4QjtBQUV4RCxPQUFPLEVBT0wsYUFBYSxFQUliLGFBQWEsR0FFZCxNQUFNLG1CQUFtQixDQUFDO0FBQzNCLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ3ZELE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUNqRCxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDN0MsT0FBTyxFQUFFLE9BQU8sRUFBZ0IsTUFBTSxNQUFNLENBQUM7QUFDN0MsT0FBTyxFQUFFLHlCQUF5QixFQUFFLE1BQU0sYUFBYSxDQUFDO0FBQ3hELE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUNqRCxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBTTNDLElBQWEsZ0JBQWdCLEdBQTdCLE1BQWEsZ0JBQWdCO0lBWTNCLFlBQ1UsZ0JBQWtDLEVBQ2xDLGFBQTRCLEVBQzVCLGFBQTRCLEVBQzVCLFdBQXdCO1FBSHhCLHFCQUFnQixHQUFoQixnQkFBZ0IsQ0FBa0I7UUFDbEMsa0JBQWEsR0FBYixhQUFhLENBQWU7UUFDNUIsa0JBQWEsR0FBYixhQUFhLENBQWU7UUFDNUIsZ0JBQVcsR0FBWCxXQUFXLENBQWE7UUFkMUIsYUFBUSxHQUFhLEVBQUUsQ0FBQztRQUN4QixvQkFBZSxHQUFvQixFQUFFLENBQUM7UUFHdEMsbUJBQWMsR0FBbUIsRUFBRSxDQUFDO1FB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TSxDQUFDLENBQUMsYUFBOEIsRUFBRSxFQUFFO2dCQUM3RixPQUFPLGVBQWUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxJQUFTLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsS0FBSyxhQUFhLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUN2RyxDQUFDLENBQUMsQ0FBQztZQUNILElBQUksQ0FBQyxrQ0FBa0MsR0FBRyxnQkFBZ0IsQ0FBQztTQUM1RDtRQUNELE9BQU8sZ0JBQWdCLENBQUM7SUFDMUIsQ0FBQztDQUNGLENBQUE7O1lBdmQ2QixnQkFBZ0I7WUFDbkIsYUFBYTtZQUNiLGFBQWE7WUFDZixXQUFXOztBQWhCdkIsZ0JBQWdCO0lBRDVCLFVBQVUsRUFBRTtHQUNBLGdCQUFnQixDQW9lNUI7U0FwZVksZ0JBQWdCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgaXNlcXVhbF8gZnJvbSAnbG9kYXNoLmlzZXF1YWwnO1xyXG5jb25zdCBpc2VxdWFsID0gaXNlcXVhbF87IC8vIHBhdGNoIHRvIGZpeCByb2xsdXAgdG8gd29ya1xyXG5cclxuaW1wb3J0IHtcclxuICBDb2x1bW4sXHJcbiAgQ3VycmVudENvbHVtbixcclxuICBDdXJyZW50RmlsdGVyLFxyXG4gIEN1cnJlbnRQYWdpbmF0aW9uLFxyXG4gIEN1cnJlbnRSb3dTZWxlY3Rpb24sXHJcbiAgQ3VycmVudFNvcnRlcixcclxuICBFeHRlbnNpb25OYW1lLFxyXG4gIEdyaWRPcHRpb24sXHJcbiAgR3JpZFN0YXRlLFxyXG4gIEdyaWRTdGF0ZUNoYW5nZSxcclxuICBHcmlkU3RhdGVUeXBlLFxyXG4gIFNsaWNrRXZlbnRIYW5kbGVyLFxyXG59IGZyb20gJy4vLi4vbW9kZWxzL2luZGV4JztcclxuaW1wb3J0IHsgRXh0ZW5zaW9uU2VydmljZSB9IGZyb20gJy4vZXh0ZW5zaW9uLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBGaWx0ZXJTZXJ2aWNlIH0gZnJvbSAnLi9maWx0ZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IFNvcnRTZXJ2aWNlIH0gZnJvbSAnLi9zb3J0LnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBTdWJqZWN0LCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgdW5zdWJzY3JpYmVBbGxPYnNlcnZhYmxlcyB9IGZyb20gJy4vdXRpbGl0aWVzJztcclxuaW1wb3J0IHsgU2hhcmVkU2VydmljZSB9IGZyb20gJy4vc2hhcmVkLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG4vLyB1c2luZyBleHRlcm5hbCBub24tdHlwZWQganMgbGlicmFyaWVzXHJcbmRlY2xhcmUgY29uc3QgU2xpY2s6IGFueTtcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIEdyaWRTdGF0ZVNlcnZpY2Uge1xyXG4gIHByaXZhdGUgX2V2ZW50SGFuZGxlcjogU2xpY2tFdmVudEhhbmRsZXI7XHJcbiAgcHJpdmF0ZSBfY29sdW1uczogQ29sdW1uW10gPSBbXTtcclxuICBwcml2YXRlIF9jdXJyZW50Q29sdW1uczogQ3VycmVudENvbHVtbltdID0gW107XHJcbiAgcHJpdmF0ZSBfZGF0YVZpZXc6IGFueTtcclxuICBwcml2YXRlIF9ncmlkOiBhbnk7XHJcbiAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcclxuICBwcml2YXRlIF9zZWxlY3RlZFJvd0RhdGFDb250ZXh0SWRzOiBBcnJheTxudW1iZXIgfCBzdHJpbmc+IHwgdW5kZWZpbmVkID0gW107IC8vIHVzZWQgd2l0aCByb3cgc2VsZWN0aW9uXHJcbiAgcHJpdmF0ZSBfc2VsZWN0ZWRGaWx0ZXJlZFJvd0RhdGFDb250ZXh0SWRzOiBBcnJheTxudW1iZXIgfCBzdHJpbmc+IHwgdW5kZWZpbmVkID0gW107IC8vIHVzZWQgd2l0aCByb3cgc2VsZWN0aW9uXHJcbiAgcHJpdmF0ZSBfd2FzUmVjaGVja2VkQWZ0ZXJQYWdlQ2hhbmdlID0gdHJ1ZTsgLy8gdXNlZCB3aXRoIHJvdyBzZWxlY3Rpb24gJiBwYWdpbmF0aW9uXHJcbiAgb25HcmlkU3RhdGVDaGFuZ2VkID0gbmV3IFN1YmplY3Q8R3JpZFN0YXRlQ2hhbmdlPigpO1xyXG5cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHByaXZhdGUgZXh0ZW5zaW9uU2VydmljZTogRXh0ZW5zaW9uU2VydmljZSxcclxuICAgIHByaXZhdGUgZmlsdGVyU2VydmljZTogRmlsdGVyU2VydmljZSxcclxuICAgIHByaXZhdGUgc2hhcmVkU2VydmljZTogU2hhcmVkU2VydmljZSxcclxuICAgIHByaXZhdGUgc29ydFNlcnZpY2U6IFNvcnRTZXJ2aWNlXHJcbiAgKSB7XHJcbiAgICB0aGlzLl9ldmVudEhhbmRsZXIgPSBuZXcgU2xpY2suRXZlbnRIYW5kbGVyKCk7XHJcbiAgfVxyXG5cclxuICAvKiogR2V0dGVyIGZvciB0aGUgR3JpZCBPcHRpb25zIHB1bGxlZCB0aHJvdWdoIHRoZSBHcmlkIE9iamVjdCAqL1xyXG4gIHByaXZhdGUgZ2V0IF9ncmlkT3B0aW9ucygpOiBHcmlkT3B0aW9uIHtcclxuICAgIHJldHVybiAodGhpcy5fZ3JpZCAmJiB0aGlzLl9ncmlkLmdldE9wdGlvbnMpID8gdGhpcy5fZ3JpZC5nZXRPcHRpb25zKCkgOiB7fTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZ2V0IGRhdGFzZXRJZFByb3BOYW1lKCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gdGhpcy5fZ3JpZE9wdGlvbnMuZGF0YXNldElkUHJvcGVydHlOYW1lIHx8ICdpZCc7XHJcbiAgfVxyXG5cclxuICAvKiogR2V0dGVyIG9mIHRoZSBzZWxlY3RlZCBkYXRhIGNvbnRleHQgb2JqZWN0IElEcyAqL1xyXG4gIGdldCBzZWxlY3RlZFJvd0RhdGFDb250ZXh0SWRzKCk6IEFycmF5PG51bWJlciB8IHN0cmluZz4gfCB1bmRlZmluZWQge1xyXG4gICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkUm93RGF0YUNvbnRleHRJZHM7XHJcbiAgfVxyXG5cclxuICAvKiogU2V0dGVyIG9mIHRoZSBzZWxlY3RlZCBkYXRhIGNvbnRleHQgb2JqZWN0IElEcyAqL1xyXG4gIHNldCBzZWxlY3RlZFJvd0RhdGFDb250ZXh0SWRzKGRhdGFDb250ZXh0SWRzOiBBcnJheTxudW1iZXIgfCBzdHJpbmc+IHwgdW5kZWZpbmVkKSB7XHJcbiAgICB0aGlzLl9zZWxlY3RlZFJvd0RhdGFDb250ZXh0SWRzID0gZGF0YUNvbnRleHRJZHM7XHJcblxyXG4gICAgLy8gc2luY2UgdGhpcyBpcyBjb21pbmcgZnJvbSBhIHByZXNldCwgd2UgYWxzbyBuZWVkIHRvIHVwZGF0ZSB0aGUgZmlsdGVyZWQgSURzXHJcbiAgICB0aGlzLl9zZWxlY3RlZEZpbHRlcmVkUm93RGF0YUNvbnRleHRJZHMgPSBkYXRhQ29udGV4dElkcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemUgdGhlIEdyaWQgU3RhdGUgU2VydmljZVxyXG4gICAqIEBwYXJhbSBncmlkXHJcbiAgICovXHJcbiAgaW5pdChncmlkOiBhbnksIGRhdGFWaWV3OiBhbnkpOiB2b2lkIHtcclxuICAgIHRoaXMuX2dyaWQgPSBncmlkO1xyXG4gICAgdGhpcy5fZGF0YVZpZXcgPSBkYXRhVmlldztcclxuICAgIHRoaXMuc3Vic2NyaWJlVG9BbGxHcmlkQ2hhbmdlcyhncmlkKTtcclxuICB9XHJcblxyXG4gIC8qKiBEaXNwb3NlIG9mIGFsbCB0aGUgU2xpY2tHcmlkICYgQW5ndWxhciBzdWJzY3JpcHRpb25zICovXHJcbiAgZGlzcG9zZSgpIHtcclxuICAgIC8vIHVuc3Vic2NyaWJlIGFsbCBTbGlja0dyaWQgZXZlbnRzXHJcbiAgICB0aGlzLl9ldmVudEhhbmRsZXIudW5zdWJzY3JpYmVBbGwoKTtcclxuXHJcbiAgICAvLyBhbHNvIHVuc3Vic2NyaWJlIGFsbCBBbmd1bGFyIFN1YnNjcmlwdGlvbnNcclxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMgPSB1bnN1YnNjcmliZUFsbE9ic2VydmFibGVzKHRoaXMuX3N1YnNjcmlwdGlvbnMpO1xyXG5cclxuICAgIHRoaXMuX2N1cnJlbnRDb2x1bW5zID0gW107XHJcbiAgICB0aGlzLl9jb2x1bW5zID0gW107XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIGN1cnJlbnQgZ3JpZCBzdGF0ZSAoZmlsdGVycy9zb3J0ZXJzL3BhZ2luYXRpb24pXHJcbiAgICogQHJldHVybiBncmlkIHN0YXRlXHJcbiAgICovXHJcbiAgZ2V0Q3VycmVudEdyaWRTdGF0ZShhcmdzPzogeyByZXF1ZXN0UmVmcmVzaFJvd0ZpbHRlcmVkUm93PzogYm9vbGVhbiB9KTogR3JpZFN0YXRlIHtcclxuICAgIGNvbnN0IGdyaWRTdGF0ZTogR3JpZFN0YXRlID0ge1xyXG4gICAgICBjb2x1bW5zOiB0aGlzLmdldEN1cnJlbnRDb2x1bW5zKCksXHJcbiAgICAgIGZpbHRlcnM6IHRoaXMuZ2V0Q3VycmVudEZpbHRlcnMoKSxcclxuICAgICAgc29ydGVyczogdGhpcy5nZXRDdXJyZW50U29ydGVycygpLFxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBjdXJyZW50UGFnaW5hdGlvbiA9IHRoaXMuZ2V0Q3VycmVudFBhZ2luYXRpb24oKTtcclxuICAgIGlmIChjdXJyZW50UGFnaW5hdGlvbikge1xyXG4gICAgICBncmlkU3RhdGUucGFnaW5hdGlvbiA9IGN1cnJlbnRQYWdpbmF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmhhc1Jvd1NlbGVjdGlvbkVuYWJsZWQoKSkge1xyXG4gICAgICBjb25zdCBjdXJyZW50Um93U2VsZWN0aW9uID0gdGhpcy5nZXRDdXJyZW50Um93U2VsZWN0aW9ucyhhcmdzICYmIGFyZ3MucmVxdWVzdFJlZnJlc2hSb3dGaWx0ZXJlZFJvdyk7XHJcbiAgICAgIGlmIChjdXJyZW50Um93U2VsZWN0aW9uKSB7XHJcbiAgICAgICAgZ3JpZFN0YXRlLnJvd1NlbGVjdGlvbiA9IGN1cnJlbnRSb3dTZWxlY3Rpb247XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBncmlkU3RhdGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIENvbHVtbnMgKGFuZCB0aGVpciBzdGF0ZTogdmlzaWJpbGl0eS9wb3NpdGlvbikgdGhhdCBhcmUgY3VycmVudGx5IGFwcGxpZWQgaW4gdGhlIGdyaWRcclxuICAgKiBAcmV0dXJuIGN1cnJlbnQgY29sdW1uc1xyXG4gICAqL1xyXG4gIGdldENvbHVtbnMoKTogQ29sdW1uW10ge1xyXG4gICAgcmV0dXJuIHRoaXMuX2NvbHVtbnM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGcm9tIGFuIGFycmF5IG9mIEdyaWQgQ29sdW1uIERlZmluaXRpb25zLCBnZXQgdGhlIGFzc29jaWF0ZWQgQ3VycmVudCBDb2x1bW5zXHJcbiAgICogQHBhcmFtIGdyaWRDb2x1bW5zXHJcbiAgICovXHJcbiAgZ2V0QXNzb2NpYXRlZEN1cnJlbnRDb2x1bW5zKGdyaWRDb2x1bW5zOiBDb2x1bW5bXSk6IEN1cnJlbnRDb2x1bW5bXSB7XHJcbiAgICBjb25zdCBjdXJyZW50Q29sdW1uczogQ3VycmVudENvbHVtbltdID0gW107XHJcblxyXG4gICAgaWYgKGdyaWRDb2x1bW5zICYmIEFycmF5LmlzQXJyYXkoZ3JpZENvbHVtbnMpKSB7XHJcbiAgICAgIGdyaWRDb2x1bW5zLmZvckVhY2goKGNvbHVtbjogQ29sdW1uLCBpbmRleDogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgaWYgKGNvbHVtbiAmJiBjb2x1bW4uaWQpIHtcclxuICAgICAgICAgIGN1cnJlbnRDb2x1bW5zLnB1c2goe1xyXG4gICAgICAgICAgICBjb2x1bW5JZDogY29sdW1uLmlkIGFzIHN0cmluZyxcclxuICAgICAgICAgICAgY3NzQ2xhc3M6IGNvbHVtbi5jc3NDbGFzcyB8fCAnJyxcclxuICAgICAgICAgICAgaGVhZGVyQ3NzQ2xhc3M6IGNvbHVtbi5oZWFkZXJDc3NDbGFzcyB8fCAnJyxcclxuICAgICAgICAgICAgd2lkdGg6IGNvbHVtbi53aWR0aCB8fCAwXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fY3VycmVudENvbHVtbnMgPSBjdXJyZW50Q29sdW1ucztcclxuICAgIHJldHVybiBjdXJyZW50Q29sdW1ucztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZyb20gYW4gYXJyYXkgb2YgQ3VycmVudCBDb2x1bW5zLCBnZXQgdGhlIGFzc29jaWF0ZWQgR3JpZCBDb2x1bW4gRGVmaW5pdGlvbnNcclxuICAgKiBAcGFyYW0gZ3JpZFxyXG4gICAqIEBwYXJhbSBjdXJyZW50Q29sdW1uc1xyXG4gICAqL1xyXG4gIGdldEFzc29jaWF0ZWRHcmlkQ29sdW1ucyhncmlkOiBhbnksIGN1cnJlbnRDb2x1bW5zOiBDdXJyZW50Q29sdW1uW10pOiBDb2x1bW5bXSB7XHJcbiAgICBjb25zdCBjb2x1bW5zOiBDb2x1bW5bXSA9IFtdO1xyXG4gICAgY29uc3QgZ3JpZENvbHVtbnM6IENvbHVtbltdID0gZ3JpZC5nZXRDb2x1bW5zKCk7XHJcblxyXG4gICAgaWYgKGN1cnJlbnRDb2x1bW5zICYmIEFycmF5LmlzQXJyYXkoY3VycmVudENvbHVtbnMpKSB7XHJcbiAgICAgIGN1cnJlbnRDb2x1bW5zLmZvckVhY2goKGN1cnJlbnRDb2x1bW46IEN1cnJlbnRDb2x1bW4sIGluZGV4OiBudW1iZXIpID0+IHtcclxuICAgICAgICBjb25zdCBncmlkQ29sdW1uOiBDb2x1bW4gPSBncmlkQ29sdW1ucy5maW5kKChjOiBDb2x1bW4pID0+IGMuaWQgPT09IGN1cnJlbnRDb2x1bW4uY29sdW1uSWQpO1xyXG4gICAgICAgIGlmIChncmlkQ29sdW1uICYmIGdyaWRDb2x1bW4uaWQpIHtcclxuICAgICAgICAgIGNvbHVtbnMucHVzaCh7XHJcbiAgICAgICAgICAgIC4uLmdyaWRDb2x1bW4sXHJcbiAgICAgICAgICAgIGNzc0NsYXNzOiBjdXJyZW50Q29sdW1uLmNzc0NsYXNzLFxyXG4gICAgICAgICAgICBoZWFkZXJDc3NDbGFzczogY3VycmVudENvbHVtbi5oZWFkZXJDc3NDbGFzcyxcclxuICAgICAgICAgICAgd2lkdGg6IGN1cnJlbnRDb2x1bW4ud2lkdGhcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9jb2x1bW5zID0gY29sdW1ucztcclxuICAgIHJldHVybiBjb2x1bW5zO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBDb2x1bW5zIChhbmQgdGhlaXIgc3RhdGVzOiB2aXNpYmlsaXR5L3Bvc2l0aW9uL3dpZHRoKSB0aGF0IGFyZSBjdXJyZW50bHkgYXBwbGllZCBpbiB0aGUgZ3JpZFxyXG4gICAqIEByZXR1cm4gY3VycmVudCBjb2x1bW5zXHJcbiAgICovXHJcbiAgZ2V0Q3VycmVudENvbHVtbnMoKTogQ3VycmVudENvbHVtbltdIHtcclxuICAgIGxldCBjdXJyZW50Q29sdW1uczogQ3VycmVudENvbHVtbltdID0gW107XHJcbiAgICBpZiAodGhpcy5fY3VycmVudENvbHVtbnMgJiYgQXJyYXkuaXNBcnJheSh0aGlzLl9jdXJyZW50Q29sdW1ucykgJiYgdGhpcy5fY3VycmVudENvbHVtbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICBjdXJyZW50Q29sdW1ucyA9IHRoaXMuX2N1cnJlbnRDb2x1bW5zO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY3VycmVudENvbHVtbnMgPSB0aGlzLmdldEFzc29jaWF0ZWRDdXJyZW50Q29sdW1ucyh0aGlzLl9ncmlkLmdldENvbHVtbnMoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGN1cnJlbnRDb2x1bW5zO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBGaWx0ZXJzIChhbmQgdGhlaXIgc3RhdGUsIGNvbHVtbklkLCBzZWFyY2hUZXJtKHMpKSB0aGF0IGFyZSBjdXJyZW50bHkgYXBwbGllZCBpbiB0aGUgZ3JpZFxyXG4gICAqIEByZXR1cm4gY3VycmVudCBmaWx0ZXJzXHJcbiAgICovXHJcbiAgZ2V0Q3VycmVudEZpbHRlcnMoKTogQ3VycmVudEZpbHRlcltdIHwgbnVsbCB7XHJcbiAgICBpZiAodGhpcy5fZ3JpZE9wdGlvbnMgJiYgdGhpcy5fZ3JpZE9wdGlvbnMuYmFja2VuZFNlcnZpY2VBcGkpIHtcclxuICAgICAgY29uc3QgYmFja2VuZFNlcnZpY2UgPSB0aGlzLl9ncmlkT3B0aW9ucy5iYWNrZW5kU2VydmljZUFwaS5zZXJ2aWNlO1xyXG4gICAgICBpZiAoYmFja2VuZFNlcnZpY2UgJiYgYmFja2VuZFNlcnZpY2UuZ2V0Q3VycmVudEZpbHRlcnMpIHtcclxuICAgICAgICByZXR1cm4gYmFja2VuZFNlcnZpY2UuZ2V0Q3VycmVudEZpbHRlcnMoKSBhcyBDdXJyZW50RmlsdGVyW107XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodGhpcy5maWx0ZXJTZXJ2aWNlICYmIHRoaXMuZmlsdGVyU2VydmljZS5nZXRDdXJyZW50TG9jYWxGaWx0ZXJzKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlclNlcnZpY2UuZ2V0Q3VycmVudExvY2FsRmlsdGVycygpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgY3VycmVudCBQYWdpbmF0aW9uIChhbmQgaXRzIHN0YXRlLCBwYWdlTnVtYmVyLCBwYWdlU2l6ZSkgdGhhdCBhcmUgY3VycmVudGx5IGFwcGxpZWQgaW4gdGhlIGdyaWRcclxuICAgKiBAcmV0dXJuIGN1cnJlbnQgcGFnaW5hdGlvbiBzdGF0ZVxyXG4gICAqL1xyXG4gIGdldEN1cnJlbnRQYWdpbmF0aW9uKCk6IEN1cnJlbnRQYWdpbmF0aW9uIHwgbnVsbCB7XHJcbiAgICBpZiAodGhpcy5fZ3JpZE9wdGlvbnMuZW5hYmxlUGFnaW5hdGlvbikge1xyXG4gICAgICBpZiAodGhpcy5fZ3JpZE9wdGlvbnMgJiYgdGhpcy5fZ3JpZE9wdGlvbnMuYmFja2VuZFNlcnZpY2VBcGkpIHtcclxuICAgICAgICBjb25zdCBiYWNrZW5kU2VydmljZSA9IHRoaXMuX2dyaWRPcHRpb25zLmJhY2tlbmRTZXJ2aWNlQXBpLnNlcnZpY2U7XHJcbiAgICAgICAgaWYgKGJhY2tlbmRTZXJ2aWNlICYmIGJhY2tlbmRTZXJ2aWNlLmdldEN1cnJlbnRQYWdpbmF0aW9uKSB7XHJcbiAgICAgICAgICByZXR1cm4gYmFja2VuZFNlcnZpY2UuZ2V0Q3VycmVudFBhZ2luYXRpb24oKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hhcmVkU2VydmljZS5jdXJyZW50UGFnaW5hdGlvbjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIGN1cnJlbnQgUm93IFNlbGVjdGlvbnMgKGFuZCBpdHMgc3RhdGUsIGdyaWRSb3dJbmRleGVzLCBkYXRhQ29udGV4dElkcywgZmlsdGVyZWREYXRhQ29udGV4dElkcykgdGhhdCBhcmUgY3VycmVudGx5IGFwcGxpZWQgaW4gdGhlIGdyaWRcclxuICAgKiBAcmV0dXJuIGN1cnJlbnQgcm93IHNlbGVjdGlvblxyXG4gICAqL1xyXG4gIGdldEN1cnJlbnRSb3dTZWxlY3Rpb25zKHJlcXVlc3RSZWZyZXNoRmlsdGVyZWRSb3cgPSB0cnVlKTogQ3VycmVudFJvd1NlbGVjdGlvbiB8IG51bGwge1xyXG4gICAgaWYgKHRoaXMuX2dyaWQgJiYgdGhpcy5fZ3JpZE9wdGlvbnMgJiYgdGhpcy5fZGF0YVZpZXcgJiYgdGhpcy5oYXNSb3dTZWxlY3Rpb25FbmFibGVkKCkpIHtcclxuICAgICAgaWYgKHRoaXMuX2dyaWQuZ2V0U2VsZWN0ZWRSb3dzICYmIHRoaXMuX2RhdGFWaWV3Lm1hcFJvd3NUb0lkcykge1xyXG4gICAgICAgIGxldCBmaWx0ZXJlZERhdGFDb250ZXh0SWRzOiBBcnJheTxudW1iZXIgfCBzdHJpbmc+IHwgdW5kZWZpbmVkID0gW107XHJcbiAgICAgICAgY29uc3QgZ3JpZFJvd0luZGV4ZXM6IG51bWJlcltdID0gdGhpcy5fZGF0YVZpZXcubWFwSWRzVG9Sb3dzKHRoaXMuX3NlbGVjdGVkUm93RGF0YUNvbnRleHRJZHMgfHwgW10pOyAvLyBub3RlIHRoYXQgdGhpcyB3aWxsIHJldHVybiBvbmx5IHdoYXQgaXMgdmlzaWJsZSBpbiBjdXJyZW50IHBhZ2VcclxuICAgICAgICBjb25zdCBkYXRhQ29udGV4dElkczogQXJyYXk8bnVtYmVyIHwgc3RyaW5nPiB8IHVuZGVmaW5lZCA9IHRoaXMuX3NlbGVjdGVkUm93RGF0YUNvbnRleHRJZHM7XHJcblxyXG4gICAgICAgIC8vIHVzZXIgbWlnaHQgcmVxdWVzdCB0byByZWZyZXNoIHRoZSBmaWx0ZXJlZCBzZWxlY3Rpb24gZGF0YXNldFxyXG4gICAgICAgIC8vIHR5cGljYWxseSBhbHdheXMgVHJ1ZSwgZXhjZXB0IHdoZW4gXCJyZUV2YWx1YXRlUm93U2VsZWN0aW9uQWZ0ZXJGaWx0ZXJDaGFuZ2VcIiBpcyBjYWxsZWQgYW5kIHdlIGRvbid0IG5lZWQgdG8gcmVmcmVzaCB0aGUgZmlsdGVyZWQgZGF0YXNldCB0d2ljZVxyXG4gICAgICAgIGlmIChyZXF1ZXN0UmVmcmVzaEZpbHRlcmVkUm93ID09PSB0cnVlKSB7XHJcbiAgICAgICAgICBmaWx0ZXJlZERhdGFDb250ZXh0SWRzID0gdGhpcy5yZWZyZXNoRmlsdGVyZWRSb3dTZWxlY3Rpb25zKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbHRlcmVkRGF0YUNvbnRleHRJZHMgPSB0aGlzLl9zZWxlY3RlZEZpbHRlcmVkUm93RGF0YUNvbnRleHRJZHM7XHJcblxyXG4gICAgICAgIHJldHVybiB7IGdyaWRSb3dJbmRleGVzLCBkYXRhQ29udGV4dElkcywgZmlsdGVyZWREYXRhQ29udGV4dElkcyB9O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgY3VycmVudCBTb3J0ZXJzIChhbmQgdGhlaXIgc3RhdGUsIGNvbHVtbklkLCBkaXJlY3Rpb24pIHRoYXQgYXJlIGN1cnJlbnRseSBhcHBsaWVkIGluIHRoZSBncmlkXHJcbiAgICogQHJldHVybiBjdXJyZW50IHNvcnRlcnNcclxuICAgKi9cclxuICBnZXRDdXJyZW50U29ydGVycygpOiBDdXJyZW50U29ydGVyW10gfCBudWxsIHtcclxuICAgIGlmICh0aGlzLl9ncmlkT3B0aW9ucyAmJiB0aGlzLl9ncmlkT3B0aW9ucy5iYWNrZW5kU2VydmljZUFwaSkge1xyXG4gICAgICBjb25zdCBiYWNrZW5kU2VydmljZSA9IHRoaXMuX2dyaWRPcHRpb25zLmJhY2tlbmRTZXJ2aWNlQXBpLnNlcnZpY2U7XHJcbiAgICAgIGlmIChiYWNrZW5kU2VydmljZSAmJiBiYWNrZW5kU2VydmljZS5nZXRDdXJyZW50U29ydGVycykge1xyXG4gICAgICAgIHJldHVybiBiYWNrZW5kU2VydmljZS5nZXRDdXJyZW50U29ydGVycygpIGFzIEN1cnJlbnRTb3J0ZXJbXTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICh0aGlzLnNvcnRTZXJ2aWNlICYmIHRoaXMuc29ydFNlcnZpY2UuZ2V0Q3VycmVudExvY2FsU29ydGVycykge1xyXG4gICAgICByZXR1cm4gdGhpcy5zb3J0U2VydmljZS5nZXRDdXJyZW50TG9jYWxTb3J0ZXJzKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKiBDaGVjayB3aGV0aGVyIHRoZSByb3cgc2VsZWN0aW9uIG5lZWRzIHRvIGJlIHByZXNlcnZlZCAqL1xyXG4gIG5lZWRUb1ByZXNlcnZlUm93U2VsZWN0aW9uKCk6IGJvb2xlYW4ge1xyXG4gICAgbGV0IHByZXNlcnZlZFJvd1NlbGVjdGlvbiA9IGZhbHNlO1xyXG4gICAgaWYgKHRoaXMuX2dyaWRPcHRpb25zICYmIHRoaXMuX2dyaWRPcHRpb25zLmRhdGFWaWV3ICYmIHRoaXMuX2dyaWRPcHRpb25zLmRhdGFWaWV3Lmhhc093blByb3BlcnR5KCdzeW5jR3JpZFNlbGVjdGlvbicpKSB7XHJcbiAgICAgIGNvbnN0IHN5bmNHcmlkU2VsZWN0aW9uID0gdGhpcy5fZ3JpZE9wdGlvbnMuZGF0YVZpZXcuc3luY0dyaWRTZWxlY3Rpb247XHJcbiAgICAgIGlmICh0eXBlb2Ygc3luY0dyaWRTZWxlY3Rpb24gPT09ICdib29sZWFuJykge1xyXG4gICAgICAgIHByZXNlcnZlZFJvd1NlbGVjdGlvbiA9IHRoaXMuX2dyaWRPcHRpb25zLmRhdGFWaWV3LnN5bmNHcmlkU2VsZWN0aW9uIGFzIGJvb2xlYW47XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcHJlc2VydmVkUm93U2VsZWN0aW9uID0gc3luY0dyaWRTZWxlY3Rpb24ucHJlc2VydmVIaWRkZW47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGlmIHRoZSByZXN1bHQgaXMgVHJ1ZSBidXQgdGhlIGdyaWQgaXMgdXNpbmcgYSBCYWNrZW5kIFNlcnZpY2UsIHdlIHdpbGwgZG8gYW4gZXh0cmEgZmxhZyBjaGVjayB0aGUgcmVhc29uIGlzIGJlY2F1c2UgaXQgbWlnaHQgaGF2ZSBzb21lIHVuaW50ZW5kZWQgYmVoYXZpb3JzXHJcbiAgICAgIC8vIHdpdGggdGhlIEJhY2tlbmRTZXJ2aWNlQXBpIGJlY2F1c2UgdGVjaG5pY2FsbHkgdGhlIGRhdGEgaW4gdGhlIHBhZ2UgY2hhbmdlcyB0aGUgRGF0YVZpZXcgb24gZXZlcnkgcGFnZS5cclxuICAgICAgaWYgKHByZXNlcnZlZFJvd1NlbGVjdGlvbiAmJiB0aGlzLl9ncmlkT3B0aW9ucy5iYWNrZW5kU2VydmljZUFwaSAmJiB0aGlzLl9ncmlkT3B0aW9ucy5kYXRhVmlldy5oYXNPd25Qcm9wZXJ0eSgnc3luY0dyaWRTZWxlY3Rpb25XaXRoQmFja2VuZFNlcnZpY2UnKSkge1xyXG4gICAgICAgIHByZXNlcnZlZFJvd1NlbGVjdGlvbiA9IHRoaXMuX2dyaWRPcHRpb25zLmRhdGFWaWV3LnN5bmNHcmlkU2VsZWN0aW9uV2l0aEJhY2tlbmRTZXJ2aWNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJlc2VydmVkUm93U2VsZWN0aW9uO1xyXG4gIH1cclxuXHJcbiAgcmVzZXRDb2x1bW5zKGNvbHVtbkRlZmluaXRpb25zPzogQ29sdW1uW10pIHtcclxuICAgIGNvbnN0IGNvbHVtbnM6IENvbHVtbltdID0gY29sdW1uRGVmaW5pdGlvbnMgfHwgdGhpcy5fY29sdW1ucztcclxuICAgIGNvbnN0IGN1cnJlbnRDb2x1bW5zOiBDdXJyZW50Q29sdW1uW10gPSB0aGlzLmdldEFzc29jaWF0ZWRDdXJyZW50Q29sdW1ucyhjb2x1bW5zKTtcclxuICAgIHRoaXMub25HcmlkU3RhdGVDaGFuZ2VkLm5leHQoeyBjaGFuZ2U6IHsgbmV3VmFsdWVzOiBjdXJyZW50Q29sdW1ucywgdHlwZTogR3JpZFN0YXRlVHlwZS5jb2x1bW5zIH0sIGdyaWRTdGF0ZTogdGhpcy5nZXRDdXJyZW50R3JpZFN0YXRlKCkgfSk7XHJcbiAgfVxyXG5cclxuICAvKiogaWYgd2UgdXNlIFJvdyBTZWxlY3Rpb24gb3IgdGhlIENoZWNrYm94IFNlbGVjdG9yLCB3ZSBuZWVkIHRvIHJlc2V0IGFueSBzZWxlY3Rpb24gKi9cclxuICByZXNldFJvd1NlbGVjdGlvbldoZW5SZXF1aXJlZCgpIHtcclxuICAgIGlmICghdGhpcy5uZWVkVG9QcmVzZXJ2ZVJvd1NlbGVjdGlvbigpICYmICh0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVSb3dTZWxlY3Rpb24gfHwgdGhpcy5fZ3JpZE9wdGlvbnMuZW5hYmxlQ2hlY2tib3hTZWxlY3RvcikpIHtcclxuICAgICAgLy8gdGhpcyBhbHNvIHJlcXVpcmVzIHRoZSBSb3cgU2VsZWN0aW9uIE1vZGVsIHRvIGJlIHJlZ2lzdGVyZWQgYXMgd2VsbFxyXG4gICAgICBjb25zdCByb3dTZWxlY3Rpb25FeHRlbnNpb24gPSB0aGlzLmV4dGVuc2lvblNlcnZpY2UgJiYgdGhpcy5leHRlbnNpb25TZXJ2aWNlLmdldEV4dGVuc2lvbkJ5TmFtZSAmJiB0aGlzLmV4dGVuc2lvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uQnlOYW1lKEV4dGVuc2lvbk5hbWUucm93U2VsZWN0aW9uKTtcclxuICAgICAgaWYgKHJvd1NlbGVjdGlvbkV4dGVuc2lvbiAmJiByb3dTZWxlY3Rpb25FeHRlbnNpb24uaW5zdGFuY2UpIHtcclxuICAgICAgICB0aGlzLl9ncmlkLnNldFNlbGVjdGVkUm93cyhbXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN1YnNjcmliZSB0byBhbGwgbmVjZXNzYXJ5IFNsaWNrR3JpZCBvciBTZXJ2aWNlIEV2ZW50cyB0aGF0IGRlYWxzIHdpdGggYSBHcmlkIGNoYW5nZSxcclxuICAgKiB3aGVuIHRyaWdnZXJlZCwgd2Ugd2lsbCBwdWJsaXNoIGEgR3JpZCBTdGF0ZSBFdmVudCB3aXRoIGN1cnJlbnQgR3JpZCBTdGF0ZVxyXG4gICAqL1xyXG4gIHN1YnNjcmliZVRvQWxsR3JpZENoYW5nZXMoZ3JpZDogYW55KSB7XHJcbiAgICAvLyBTdWJzY3JpYmUgdG8gRXZlbnQgRW1pdHRlciBvZiBGaWx0ZXIgY2hhbmdlZFxyXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5wdXNoKFxyXG4gICAgICB0aGlzLmZpbHRlclNlcnZpY2Uub25GaWx0ZXJDaGFuZ2VkLnN1YnNjcmliZSgoY3VycmVudEZpbHRlcnM6IEN1cnJlbnRGaWx0ZXJbXSkgPT4ge1xyXG4gICAgICAgIHRoaXMucmVzZXRSb3dTZWxlY3Rpb25XaGVuUmVxdWlyZWQoKTtcclxuXHJcbiAgICAgICAgLy8gdHJpZ2dlciBhIEdyaWQgU3RhdGUgZmlsdGVyIGNoYW5nZSwgaG93ZXZlciBkb24ndCByZWV2YWx1YXRlIHRoZSBmaWx0ZXJlZCByb3cgc2VsZWN0aW9ucywgd2UnbGwgZG8gdGhhdCBvbiB0aGUgbmV4dCBHcmlkIFN0YXRlIGNoYW5nZSBiZWxvd1xyXG4gICAgICAgIHRoaXMub25HcmlkU3RhdGVDaGFuZ2VkLm5leHQoeyBjaGFuZ2U6IHsgbmV3VmFsdWVzOiBjdXJyZW50RmlsdGVycywgdHlwZTogR3JpZFN0YXRlVHlwZS5maWx0ZXIgfSwgZ3JpZFN0YXRlOiB0aGlzLmdldEN1cnJlbnRHcmlkU3RhdGUoeyByZXF1ZXN0UmVmcmVzaFJvd0ZpbHRlcmVkUm93OiAhdGhpcy5oYXNSb3dTZWxlY3Rpb25FbmFibGVkKCkgfSkgfSk7XHJcblxyXG4gICAgICAgIC8vIHdoZW4gUm93IFNlbGVjdGlvbiBpcyBlbmFibGVkLCB3ZSBhbHNvIG5lZWQgdG8gcmUtZXZhbHVhdGUgdGhlIHJvdyBzZWxlY3Rpb24gd2l0aCB0aGUgbGVmdG92ZXIgZmlsdGVyZWQgZGF0YXNldFxyXG4gICAgICAgIGlmICh0aGlzLmhhc1Jvd1NlbGVjdGlvbkVuYWJsZWQoKSkge1xyXG4gICAgICAgICAgdGhpcy5yZUV2YWx1YXRlUm93U2VsZWN0aW9uQWZ0ZXJGaWx0ZXJDaGFuZ2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcbiAgICApO1xyXG5cclxuICAgIC8vIFN1YnNjcmliZSB0byBFdmVudCBFbWl0dGVyIG9mIEZpbHRlciBjbGVhcmVkXHJcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zLnB1c2goXHJcbiAgICAgIHRoaXMuZmlsdGVyU2VydmljZS5vbkZpbHRlckNsZWFyZWQuc3Vic2NyaWJlKCgpID0+IHtcclxuICAgICAgICB0aGlzLnJlc2V0Um93U2VsZWN0aW9uV2hlblJlcXVpcmVkKCk7XHJcbiAgICAgICAgdGhpcy5vbkdyaWRTdGF0ZUNoYW5nZWQubmV4dCh7IGNoYW5nZTogeyBuZXdWYWx1ZXM6IFtdLCB0eXBlOiBHcmlkU3RhdGVUeXBlLmZpbHRlciB9LCBncmlkU3RhdGU6IHRoaXMuZ2V0Q3VycmVudEdyaWRTdGF0ZSgpIH0pO1xyXG4gICAgICB9KVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBTdWJzY3JpYmUgdG8gRXZlbnQgRW1pdHRlciBvZiBTb3J0IGNoYW5nZWRcclxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMucHVzaChcclxuICAgICAgdGhpcy5zb3J0U2VydmljZS5vblNvcnRDaGFuZ2VkLnN1YnNjcmliZSgoY3VycmVudFNvcnRlcnM6IEN1cnJlbnRTb3J0ZXJbXSkgPT4ge1xyXG4gICAgICAgIHRoaXMucmVzZXRSb3dTZWxlY3Rpb25XaGVuUmVxdWlyZWQoKTtcclxuICAgICAgICB0aGlzLm9uR3JpZFN0YXRlQ2hhbmdlZC5uZXh0KHsgY2hhbmdlOiB7IG5ld1ZhbHVlczogY3VycmVudFNvcnRlcnMsIHR5cGU6IEdyaWRTdGF0ZVR5cGUuc29ydGVyIH0sIGdyaWRTdGF0ZTogdGhpcy5nZXRDdXJyZW50R3JpZFN0YXRlKCkgfSk7XHJcbiAgICAgIH0pXHJcbiAgICApO1xyXG5cclxuICAgIC8vIFN1YnNjcmliZSB0byBFdmVudCBFbWl0dGVyIG9mIFNvcnQgY2xlYXJlZFxyXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5wdXNoKFxyXG4gICAgICB0aGlzLnNvcnRTZXJ2aWNlLm9uU29ydENsZWFyZWQuc3Vic2NyaWJlKCgpID0+IHtcclxuICAgICAgICB0aGlzLnJlc2V0Um93U2VsZWN0aW9uV2hlblJlcXVpcmVkKCk7XHJcbiAgICAgICAgdGhpcy5vbkdyaWRTdGF0ZUNoYW5nZWQubmV4dCh7IGNoYW5nZTogeyBuZXdWYWx1ZXM6IFtdLCB0eXBlOiBHcmlkU3RhdGVUeXBlLnNvcnRlciB9LCBncmlkU3RhdGU6IHRoaXMuZ2V0Q3VycmVudEdyaWRTdGF0ZSgpIH0pO1xyXG4gICAgICB9KVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBTdWJzY3JpYmUgdG8gQ29sdW1uUGlja2VyIGFuZC9vciBHcmlkTWVudSBmb3Igc2hvdy9oaWRlIENvbHVtbnMgdmlzaWJpbGl0eSBjaGFuZ2VzXHJcbiAgICB0aGlzLmJpbmRFeHRlbnNpb25BZGRvbkV2ZW50VG9HcmlkU3RhdGVDaGFuZ2UoRXh0ZW5zaW9uTmFtZS5jb2x1bW5QaWNrZXIsICdvbkNvbHVtbnNDaGFuZ2VkJyk7XHJcbiAgICB0aGlzLmJpbmRFeHRlbnNpb25BZGRvbkV2ZW50VG9HcmlkU3RhdGVDaGFuZ2UoRXh0ZW5zaW9uTmFtZS5ncmlkTWVudSwgJ29uQ29sdW1uc0NoYW5nZWQnKTtcclxuXHJcbiAgICAvLyBzdWJzY3JpYmUgdG8gQ29sdW1uIFJlc2l6ZSAmIFJlb3JkZXJpbmdcclxuICAgIHRoaXMuYmluZFNsaWNrR3JpZENvbHVtbkNoYW5nZUV2ZW50VG9HcmlkU3RhdGVDaGFuZ2UoJ29uQ29sdW1uc1Jlb3JkZXJlZCcsIGdyaWQpO1xyXG4gICAgdGhpcy5iaW5kU2xpY2tHcmlkQ29sdW1uQ2hhbmdlRXZlbnRUb0dyaWRTdGF0ZUNoYW5nZSgnb25Db2x1bW5zUmVzaXplZCcsIGdyaWQpO1xyXG5cclxuICAgIC8vIHN1YnNjcmliZSB0byBSb3cgU2VsZWN0aW9uIGNoYW5nZXMgKHdoZW4gZW5hYmxlZClcclxuICAgIGlmICh0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVSb3dTZWxlY3Rpb24gfHwgdGhpcy5fZ3JpZE9wdGlvbnMuZW5hYmxlQ2hlY2tib3hTZWxlY3Rvcikge1xyXG4gICAgICB0aGlzLmJpbmRTbGlja0dyaWRSb3dTZWxlY3Rpb25Ub0dyaWRTdGF0ZUNoYW5nZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHN1YnNjcmliZSB0byBIZWFkZXJNZW51IChoaWRlIGNvbHVtbilcclxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMucHVzaChcclxuICAgICAgdGhpcy5zaGFyZWRTZXJ2aWNlLm9uSGVhZGVyTWVudUhpZGVDb2x1bW5zLnN1YnNjcmliZSgodmlzaWJsZUNvbHVtbnM6IENvbHVtbltdKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY3VycmVudENvbHVtbnM6IEN1cnJlbnRDb2x1bW5bXSA9IHRoaXMuZ2V0QXNzb2NpYXRlZEN1cnJlbnRDb2x1bW5zKHZpc2libGVDb2x1bW5zKTtcclxuICAgICAgICB0aGlzLm9uR3JpZFN0YXRlQ2hhbmdlZC5uZXh0KHsgY2hhbmdlOiB7IG5ld1ZhbHVlczogY3VycmVudENvbHVtbnMsIHR5cGU6IEdyaWRTdGF0ZVR5cGUuY29sdW1ucyB9LCBncmlkU3RhdGU6IHRoaXMuZ2V0Q3VycmVudEdyaWRTdGF0ZSgpIH0pO1xyXG4gICAgICB9KVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8vIC0tXHJcbiAgLy8gcHJpdmF0ZSBtZXRob2RzXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8qKlxyXG4gICAqIEJpbmQgYSBTbGlja0dyaWQgRXh0ZW5zaW9uIEV2ZW50IHRvIGEgR3JpZCBTdGF0ZSBjaGFuZ2UgZXZlbnRcclxuICAgKiBAcGFyYW0gZXh0ZW5zaW9uIG5hbWVcclxuICAgKiBAcGFyYW0gZ3JpZFxyXG4gICAqL1xyXG4gIHByaXZhdGUgYmluZEV4dGVuc2lvbkFkZG9uRXZlbnRUb0dyaWRTdGF0ZUNoYW5nZShleHRlbnNpb25OYW1lOiBFeHRlbnNpb25OYW1lLCBldmVudE5hbWU6IHN0cmluZykge1xyXG4gICAgY29uc3QgZXh0ZW5zaW9uID0gdGhpcy5leHRlbnNpb25TZXJ2aWNlICYmIHRoaXMuZXh0ZW5zaW9uU2VydmljZS5nZXRFeHRlbnNpb25CeU5hbWUgJiYgdGhpcy5leHRlbnNpb25TZXJ2aWNlLmdldEV4dGVuc2lvbkJ5TmFtZShleHRlbnNpb25OYW1lKTtcclxuICAgIGNvbnN0IHNsaWNrRXZlbnQgPSBleHRlbnNpb24gJiYgZXh0ZW5zaW9uLmluc3RhbmNlICYmIGV4dGVuc2lvbi5pbnN0YW5jZVtldmVudE5hbWVdO1xyXG5cclxuICAgIGlmIChzbGlja0V2ZW50ICYmIHNsaWNrRXZlbnQuc3Vic2NyaWJlKSB7XHJcbiAgICAgIHRoaXMuX2V2ZW50SGFuZGxlci5zdWJzY3JpYmUoc2xpY2tFdmVudCwgKGU6IEV2ZW50LCBhcmdzOiBhbnkpID0+IHtcclxuICAgICAgICBjb25zdCBjb2x1bW5zOiBDb2x1bW5bXSA9IGFyZ3MgJiYgYXJncy5jb2x1bW5zO1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRDb2x1bW5zOiBDdXJyZW50Q29sdW1uW10gPSB0aGlzLmdldEFzc29jaWF0ZWRDdXJyZW50Q29sdW1ucyhjb2x1bW5zKTtcclxuICAgICAgICB0aGlzLm9uR3JpZFN0YXRlQ2hhbmdlZC5uZXh0KHsgY2hhbmdlOiB7IG5ld1ZhbHVlczogY3VycmVudENvbHVtbnMsIHR5cGU6IEdyaWRTdGF0ZVR5cGUuY29sdW1ucyB9LCBncmlkU3RhdGU6IHRoaXMuZ2V0Q3VycmVudEdyaWRTdGF0ZSgpIH0pO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEJpbmQgYSBHcmlkIEV2ZW50IChvZiBDb2x1bW4gY2hhbmdlcykgdG8gYSBHcmlkIFN0YXRlIGNoYW5nZSBldmVudFxyXG4gICAqIEBwYXJhbSBldmVudCBuYW1lXHJcbiAgICogQHBhcmFtIGdyaWRcclxuICAgKi9cclxuICBwcml2YXRlIGJpbmRTbGlja0dyaWRDb2x1bW5DaGFuZ2VFdmVudFRvR3JpZFN0YXRlQ2hhbmdlKGV2ZW50TmFtZTogc3RyaW5nLCBncmlkOiBhbnkpIHtcclxuICAgIGNvbnN0IHNsaWNrR3JpZEV2ZW50ID0gZ3JpZCAmJiBncmlkW2V2ZW50TmFtZV07XHJcblxyXG4gICAgaWYgKHNsaWNrR3JpZEV2ZW50ICYmIHNsaWNrR3JpZEV2ZW50LnN1YnNjcmliZSkge1xyXG4gICAgICB0aGlzLl9ldmVudEhhbmRsZXIuc3Vic2NyaWJlKHNsaWNrR3JpZEV2ZW50LCAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY29sdW1uczogQ29sdW1uW10gPSBncmlkLmdldENvbHVtbnMoKTtcclxuICAgICAgICBjb25zdCBjdXJyZW50Q29sdW1uczogQ3VycmVudENvbHVtbltdID0gdGhpcy5nZXRBc3NvY2lhdGVkQ3VycmVudENvbHVtbnMoY29sdW1ucyk7XHJcbiAgICAgICAgdGhpcy5vbkdyaWRTdGF0ZUNoYW5nZWQubmV4dCh7IGNoYW5nZTogeyBuZXdWYWx1ZXM6IGN1cnJlbnRDb2x1bW5zLCB0eXBlOiBHcmlkU3RhdGVUeXBlLmNvbHVtbnMgfSwgZ3JpZFN0YXRlOiB0aGlzLmdldEN1cnJlbnRHcmlkU3RhdGUoKSB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBCaW5kIGEgR3JpZCBFdmVudCBvZiBSb3cgU2VsZWN0aW9uIGNoYW5nZSB0byBhIEdyaWQgU3RhdGUgY2hhbmdlIGV2ZW50XHJcbiAgICogRm9yIHRoZSByb3cgc2VsZWN0aW9uLCB3ZSBjYW4ndCBqdXN0IHVzZSB0aGUgZ2V0U2VsZWN0ZWRSb3dzKCkgc2luY2UgdGhpcyB3aWxsIG9ubHkgcmV0dXJuIHRoZSB2aXNpYmxlIHJvd3Mgc2hvd24gaW4gdGhlIFVJIHdoaWNoIGlzIG5vdCBlbm91Z2guXHJcbiAgICogVGhlIHByb2Nlc3MgaXMgbXVjaCBtb3JlIGNvbXBsZXgsIHdoYXQgd2UgaGF2ZSB0byBkbyBpbnN0ZWFkIGlzIHRoZSBmb2xsb3dpbmdcclxuICAgKiAxLiB3aGVuIGNoYW5naW5nIGEgcm93IHNlbGVjdGlvbiwgd2UnbGwgYWRkIHRoZSBuZXcgc2VsZWN0aW9uIGlmIGl0J3Mgbm90IHlldCBpbiB0aGUgZ2xvYmFsIGFycmF5IG9mIHNlbGVjdGVkIElEc1xyXG4gICAqIDIuIHdoZW4gZGVsZXRpbmcgYSByb3cgc2VsZWN0aW9uLCB3ZSdsbCByZW1vdmUgdGhlIHNlbGVjdGlvbiBmcm9tIG91ciBnbG9iYWwgYXJyYXkgb2Ygc2VsZWN0ZWQgSURzICh1bmxlc3MgaXQgY2FtZSBmcm9tIGEgcGFnZSBjaGFuZ2UpXHJcbiAgICogMy4gaWYgd2UgdXNlIFBhZ2luYXRpb24gYW5kIHdlIGNoYW5nZSBwYWdlLCB3ZSdsbCBrZWVwIHRyYWNrIHdpdGggYSBmbGFnICh0aGlzIGZsYWcgd2lsbCBiZSB1c2VkIHRvIHNraXAgYW55IGRlbGV0aW9uIHdoZW4gd2UncmUgY2hhbmdpbmcgcGFnZSlcclxuICAgKiA0LiBhZnRlciB0aGUgUGFnZSBvciBEYXRhVmlldyBpcyBjaGFuZ2VkIG9yIHVwZGF0ZWQsIHdlJ2xsIGRvIGFuIGV4dHJhIChhbmQgZGVsYXllZCkgY2hlY2sgdG8gbWFrZSBzdXJlIHRoYXQgd2hhdCB3ZSBoYXZlIGluIG91ciBnbG9iYWwgYXJyYXkgb2Ygc2VsZWN0ZWQgSURzIGlzIGRpc3BsYXllZCBvbiBzY3JlZW5cclxuICAgKi9cclxuICBwcml2YXRlIGJpbmRTbGlja0dyaWRSb3dTZWxlY3Rpb25Ub0dyaWRTdGF0ZUNoYW5nZSgpIHtcclxuICAgIGlmICh0aGlzLl9ncmlkICYmIHRoaXMuX2dyaWRPcHRpb25zICYmIHRoaXMuX2RhdGFWaWV3KSB7XHJcbiAgICAgIHRoaXMuX2V2ZW50SGFuZGxlci5zdWJzY3JpYmUodGhpcy5fZGF0YVZpZXcub25CZWZvcmVQYWdpbmdJbmZvQ2hhbmdlZCwgKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuX3dhc1JlY2hlY2tlZEFmdGVyUGFnZUNoYW5nZSA9IGZhbHNlOyAvLyByZXNldCB0aGUgcGFnZSBjaGVjayBmbGFnLCB0byBza2lwIGRlbGV0aW9ucyBvbiBwYWdlIGNoYW5nZSAodXNlZCBpbiBjb2RlIGJlbG93KVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMuX2V2ZW50SGFuZGxlci5zdWJzY3JpYmUodGhpcy5fZGF0YVZpZXcub25QYWdpbmdJbmZvQ2hhbmdlZCwgKCkgPT4ge1xyXG4gICAgICAgIC8vIHdoZW4gdXNlciBjaGFuZ2VzIHBhZ2UsIHRoZSBzZWxlY3RlZCByb3cgaW5kZXhlcyBtaWdodCBub3Qgc2hvdyB1cFxyXG4gICAgICAgIC8vIHdlIGNhbiBjaGVjayB0byBtYWtlIHN1cmUgaXQgaXMgYnV0IGl0IGhhcyB0byBiZSBpbiBhIGRlbGF5IHNvIGl0IGhhcHBlbnMgYWZ0ZXIgdGhlIGZpcnN0IFwib25TZWxlY3RlZFJvd3NDaGFuZ2VkXCIgaXMgdHJpZ2dlcmVkXHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBzaG91bGRCZVNlbGVjdGVkUm93SW5kZXhlcyA9IHRoaXMuX2RhdGFWaWV3Lm1hcElkc1RvUm93cyh0aGlzLl9zZWxlY3RlZFJvd0RhdGFDb250ZXh0SWRzIHx8IFtdKTtcclxuICAgICAgICAgIGNvbnN0IGN1cnJlbnRTZWxlY3RlZFJvd0luZGV4ZXMgPSB0aGlzLl9ncmlkLmdldFNlbGVjdGVkUm93cygpO1xyXG4gICAgICAgICAgaWYgKCFpc2VxdWFsKHNob3VsZEJlU2VsZWN0ZWRSb3dJbmRleGVzLCBjdXJyZW50U2VsZWN0ZWRSb3dJbmRleGVzKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9ncmlkLnNldFNlbGVjdGVkUm93cyhzaG91bGRCZVNlbGVjdGVkUm93SW5kZXhlcyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyLnN1YnNjcmliZSh0aGlzLl9ncmlkLm9uU2VsZWN0ZWRSb3dzQ2hhbmdlZCwgKGUsIGFyZ3MpID0+IHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzLnJvd3MpICYmIEFycmF5LmlzQXJyYXkoYXJncy5wcmV2aW91c1NlbGVjdGVkUm93cykpIHtcclxuICAgICAgICAgIGNvbnN0IG5ld1NlbGVjdGVkUm93cyA9IGFyZ3Mucm93cyBhcyBudW1iZXJbXTtcclxuICAgICAgICAgIGNvbnN0IHByZXZTZWxlY3RlZFJvd3MgPSBhcmdzLnByZXZpb3VzU2VsZWN0ZWRSb3dzIGFzIG51bWJlcltdO1xyXG5cclxuICAgICAgICAgIGNvbnN0IG5ld1NlbGVjdGVkQWRkaXRpb25zID0gbmV3U2VsZWN0ZWRSb3dzLmZpbHRlcigoaSkgPT4gcHJldlNlbGVjdGVkUm93cy5pbmRleE9mKGkpIDwgMCk7XHJcbiAgICAgICAgICBjb25zdCBuZXdTZWxlY3RlZERlbGV0aW9ucyA9IHByZXZTZWxlY3RlZFJvd3MuZmlsdGVyKChpKSA9PiBuZXdTZWxlY3RlZFJvd3MuaW5kZXhPZihpKSA8IDApO1xyXG5cclxuICAgICAgICAgIC8vIGRlbGV0aW9uIG1pZ2h0IGhhcHBlbiB3aGVuIHVzZXIgaXMgY2hhbmdpbmcgcGFnZSwgaWYgdGhhdCBpcyB0aGUgY2FzZSB0aGVuIHNraXAgdGhlIGRlbGV0aW9uIHNpbmNlIGl0J3Mgb25seSBhIHZpc3VhbCBkZWxldGlvbiAoY3VycmVudCBwYWdlKVxyXG4gICAgICAgICAgLy8gaWYgaXQncyBub3QgYSBwYWdlIGNoYW5nZSAod2hlbiB0aGUgZmxhZyBpcyB0cnVlKSwgdGhlbiBwcm9jZWVkIHdpdGggdGhlIGRlbGV0aW9uIGluIG91ciBnbG9iYWwgYXJyYXkgb2Ygc2VsZWN0ZWQgSURzXHJcbiAgICAgICAgICBpZiAodGhpcy5fd2FzUmVjaGVja2VkQWZ0ZXJQYWdlQ2hhbmdlICYmIG5ld1NlbGVjdGVkRGVsZXRpb25zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgY29uc3QgdG9EZWxldGVEYXRhSWRzOiBBcnJheTxudW1iZXIgfCBzdHJpbmc+IHwgdW5kZWZpbmVkID0gdGhpcy5fZGF0YVZpZXcubWFwUm93c1RvSWRzKG5ld1NlbGVjdGVkRGVsZXRpb25zKSB8fCBbXTtcclxuICAgICAgICAgICAgdG9EZWxldGVEYXRhSWRzLmZvckVhY2goKHJlbW92ZUlkOiBudW1iZXIgfCBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgICB0aGlzLl9zZWxlY3RlZFJvd0RhdGFDb250ZXh0SWRzLnNwbGljZSgodGhpcy5fc2VsZWN0ZWRSb3dEYXRhQ29udGV4dElkcyBhcyBBcnJheTxudW1iZXIgfCBzdHJpbmc+IHwgdW5kZWZpbmVkKS5pbmRleE9mKHJlbW92ZUlkKSwgMSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIGlmIHdlIGhhdmUgbmV3bHkgYWRkZWQgc2VsZWN0ZWQgcm93KHMpLCBsZXQncyB1cGRhdGUgb3VyIGdsb2JhbCBhcnJheSBvZiBzZWxlY3RlZCBJRHNcclxuICAgICAgICAgIGlmIChuZXdTZWxlY3RlZEFkZGl0aW9ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRvQWRkRGF0YUlkczogQXJyYXk8bnVtYmVyIHwgc3RyaW5nPiB8IHVuZGVmaW5lZCA9IHRoaXMuX2RhdGFWaWV3Lm1hcFJvd3NUb0lkcyhuZXdTZWxlY3RlZEFkZGl0aW9ucykgfHwgW107XHJcbiAgICAgICAgICAgIHRvQWRkRGF0YUlkcy5mb3JFYWNoKChkYXRhSWQ6IG51bWJlciB8IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICAgIGlmICgodGhpcy5fc2VsZWN0ZWRSb3dEYXRhQ29udGV4dElkcyBhcyBBcnJheTxudW1iZXIgfCBzdHJpbmc+IHwgdW5kZWZpbmVkKS5pbmRleE9mKGRhdGFJZCkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAodGhpcy5fc2VsZWN0ZWRSb3dEYXRhQ29udGV4dElkcyBhcyBBcnJheTxudW1iZXIgfCBzdHJpbmc+IHwgdW5kZWZpbmVkKS5wdXNoKGRhdGFJZCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyB3ZSBzZXQgdGhpcyBmbGFnIHdoaWNoIHdpbGwgYmUgdXNlZCBvbiB0aGUgMm5kIHRpbWUgdGhlIFwib25TZWxlY3RlZFJvd3NDaGFuZ2VkXCIgZXZlbnQgaXMgY2FsbGVkXHJcbiAgICAgICAgICAvLyB3aGVuIGl0J3MgdGhlIGZpcnN0IHRpbWUsIHdlIHNraXAgZGVsZXRpb24gYW5kIHRoaXMgaXMgd2hhdCB0aGlzIGZsYWcgaXMgZm9yXHJcbiAgICAgICAgICB0aGlzLl93YXNSZWNoZWNrZWRBZnRlclBhZ2VDaGFuZ2UgPSB0cnVlO1xyXG5cclxuICAgICAgICAgIC8vIGZvcm0gb3VyIGZ1bGwgc2VsZWN0ZWQgcm93IElEcywgbGV0J3MgbWFrZSBzdXJlIHRoZXNlIGluZGV4ZXMgYXJlIHNlbGVjdGVkIGluIHRoZSBncmlkLCBpZiBub3QgdGhlbiBsZXQncyBjYWxsIGEgcmVzZWxlY3RcclxuICAgICAgICAgIC8vIHRoaXMgY291bGQgaGFwcGVuIGlmIHRoZSBwcmV2aW91cyBzdGVwIHdhcyBhIHBhZ2UgY2hhbmdlXHJcbiAgICAgICAgICBjb25zdCBzaG91bGRCZVNlbGVjdGVkUm93SW5kZXhlcyA9IHRoaXMuX2RhdGFWaWV3Lm1hcElkc1RvUm93cyh0aGlzLl9zZWxlY3RlZFJvd0RhdGFDb250ZXh0SWRzIHx8IFtdKTtcclxuICAgICAgICAgIGNvbnN0IGN1cnJlbnRTZWxlY3RlZFJvd0luZGV4ZXMgPSB0aGlzLl9ncmlkLmdldFNlbGVjdGVkUm93cygpO1xyXG4gICAgICAgICAgaWYgKCFpc2VxdWFsKHNob3VsZEJlU2VsZWN0ZWRSb3dJbmRleGVzLCBjdXJyZW50U2VsZWN0ZWRSb3dJbmRleGVzKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9ncmlkLnNldFNlbGVjdGVkUm93cyhzaG91bGRCZVNlbGVjdGVkUm93SW5kZXhlcyk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgY29uc3QgZmlsdGVyZWREYXRhQ29udGV4dElkcyA9IHRoaXMucmVmcmVzaEZpbHRlcmVkUm93U2VsZWN0aW9ucygpO1xyXG4gICAgICAgICAgY29uc3QgbmV3VmFsdWVzID0geyBncmlkUm93SW5kZXhlczogdGhpcy5fZ3JpZC5nZXRTZWxlY3RlZFJvd3MoKSwgZGF0YUNvbnRleHRJZHM6IHRoaXMuX3NlbGVjdGVkUm93RGF0YUNvbnRleHRJZHMsIGZpbHRlcmVkRGF0YUNvbnRleHRJZHMgfSBhcyBDdXJyZW50Um93U2VsZWN0aW9uO1xyXG4gICAgICAgICAgdGhpcy5vbkdyaWRTdGF0ZUNoYW5nZWQubmV4dCh7IGNoYW5nZTogeyBuZXdWYWx1ZXMsIHR5cGU6IEdyaWRTdGF0ZVR5cGUucm93U2VsZWN0aW9uIH0sIGdyaWRTdGF0ZTogdGhpcy5nZXRDdXJyZW50R3JpZFN0YXRlKCkgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKiBDaGVjayB3ZXRoZXIgdGhlIGdyaWQgaGFzIHRoZSBSb3cgU2VsZWN0aW9uIGVuYWJsZWQgKi9cclxuICBwcml2YXRlIGhhc1Jvd1NlbGVjdGlvbkVuYWJsZWQoKSB7XHJcbiAgICBjb25zdCBzZWxlY3Rpb25Nb2RlbCA9IHRoaXMuX2dyaWQuZ2V0U2VsZWN0aW9uTW9kZWwoKTtcclxuICAgIGNvbnN0IGlzUm93U2VsZWN0aW9uRW5hYmxlZCA9IHRoaXMuX2dyaWRPcHRpb25zLmVuYWJsZVJvd1NlbGVjdGlvbiB8fCB0aGlzLl9ncmlkT3B0aW9ucy5lbmFibGVDaGVja2JveFNlbGVjdG9yO1xyXG4gICAgcmV0dXJuIChpc1Jvd1NlbGVjdGlvbkVuYWJsZWQgJiYgc2VsZWN0aW9uTW9kZWwpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSByZUV2YWx1YXRlUm93U2VsZWN0aW9uQWZ0ZXJGaWx0ZXJDaGFuZ2UoKSB7XHJcbiAgICBjb25zdCBjdXJyZW50U2VsZWN0ZWRSb3dJbmRleGVzID0gdGhpcy5fZ3JpZC5nZXRTZWxlY3RlZFJvd3MoKTtcclxuICAgIGNvbnN0IHByZXZpb3VzU2VsZWN0ZWRGaWx0ZXJlZFJvd0RhdGFDb250ZXh0SWRzID0gdGhpcy5fc2VsZWN0ZWRGaWx0ZXJlZFJvd0RhdGFDb250ZXh0SWRzLnNsaWNlKCk7XHJcbiAgICBjb25zdCBmaWx0ZXJlZERhdGFDb250ZXh0SWRzID0gdGhpcy5yZWZyZXNoRmlsdGVyZWRSb3dTZWxlY3Rpb25zKCk7XHJcblxyXG4gICAgLy8gd2hlbiBzZWxlY3Rpb24gY2hhbmdlZCwgd2UnbGwgc2VuZCBhIEdyaWQgU3RhdGUgZXZlbnQgd2l0aCB0aGUgc2VsZWN0aW9uIGNoYW5nZXNcclxuICAgIGlmICghaXNlcXVhbCh0aGlzLl9zZWxlY3RlZEZpbHRlcmVkUm93RGF0YUNvbnRleHRJZHMsIHByZXZpb3VzU2VsZWN0ZWRGaWx0ZXJlZFJvd0RhdGFDb250ZXh0SWRzKSkge1xyXG4gICAgICBjb25zdCBuZXdWYWx1ZXMgPSB7IGdyaWRSb3dJbmRleGVzOiBjdXJyZW50U2VsZWN0ZWRSb3dJbmRleGVzLCBkYXRhQ29udGV4dElkczogdGhpcy5fc2VsZWN0ZWRSb3dEYXRhQ29udGV4dElkcywgZmlsdGVyZWREYXRhQ29udGV4dElkcyB9IGFzIEN1cnJlbnRSb3dTZWxlY3Rpb247XHJcbiAgICAgIHRoaXMub25HcmlkU3RhdGVDaGFuZ2VkLm5leHQoeyBjaGFuZ2U6IHsgbmV3VmFsdWVzLCB0eXBlOiBHcmlkU3RhdGVUeXBlLnJvd1NlbGVjdGlvbiB9LCBncmlkU3RhdGU6IHRoaXMuZ2V0Q3VycmVudEdyaWRTdGF0ZSh7IHJlcXVlc3RSZWZyZXNoUm93RmlsdGVyZWRSb3c6IGZhbHNlIH0pIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqIFdoZW4gYSBGaWx0ZXIgaXMgdHJpZ2dlcmVkIG9yIHdoZW4gdXNlciByZXF1ZXN0IGl0LCB3ZSB3aWxsIHJlZnJlc2ggdGhlIGZpbHRlcmVkIHNlbGVjdGlvbiBhcnJheSBhbmQgcmV0dXJuIGl0ICovXHJcbiAgcHJpdmF0ZSByZWZyZXNoRmlsdGVyZWRSb3dTZWxlY3Rpb25zKCk6IEFycmF5PG51bWJlciB8IHN0cmluZz4gfCB1bmRlZmluZWQge1xyXG4gICAgbGV0IHRtcEZpbHRlcmVkQXJyYXkgPSBbXTtcclxuICAgIGNvbnN0IGZpbHRlcmVkRGF0YXNldCA9IHRoaXMuX2RhdGFWaWV3LmdldEZpbHRlcmVkSXRlbXMoKSB8fCBbXTtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuX3NlbGVjdGVkUm93RGF0YUNvbnRleHRJZHMpKSB7XHJcbiAgICAgIGNvbnN0IHNlbGVjdGVkRmlsdGVyZWRSb3dEYXRhQ29udGV4dElkcyA9IFsuLi50aGlzLl9zZWxlY3RlZFJvd0RhdGFDb250ZXh0SWRzXTsgLy8gdGFrZSBhIGZyZXNoIGNvcHkgb2YgYWxsIHNlbGVjdGlvbnMgYmVmb3JlIGZpbHRlcmluZyB0aGUgcm93IGlkc1xyXG4gICAgICB0bXBGaWx0ZXJlZEFycmF5ID0gc2VsZWN0ZWRGaWx0ZXJlZFJvd0RhdGFDb250ZXh0SWRzLmZpbHRlcigoc2VsZWN0ZWRSb3dJZDogbnVtYmVyIHwgc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGZpbHRlcmVkRGF0YXNldC5maW5kSW5kZXgoKGl0ZW06IGFueSkgPT4gaXRlbVt0aGlzLmRhdGFzZXRJZFByb3BOYW1lXSA9PT0gc2VsZWN0ZWRSb3dJZCkgPiAtMTtcclxuICAgICAgfSk7XHJcbiAgICAgIHRoaXMuX3NlbGVjdGVkRmlsdGVyZWRSb3dEYXRhQ29udGV4dElkcyA9IHRtcEZpbHRlcmVkQXJyYXk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG1wRmlsdGVyZWRBcnJheTtcclxuICB9XHJcbn1cclxuIl19