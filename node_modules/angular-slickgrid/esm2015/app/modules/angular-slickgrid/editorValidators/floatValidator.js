import { Constants } from '../constants';
export function floatValidator(inputValue, options) {
    const floatNumber = !isNaN(inputValue) ? parseFloat(inputValue) : null;
    const decPlaces = options.decimal || 0;
    const isRequired = options.required;
    const minValue = options.minValue;
    const maxValue = options.maxValue;
    const operatorConditionalType = options.operatorConditionalType || 'inclusive';
    const errorMsg = options.errorMessage;
    const mapValidation = {
        '{{minValue}}': minValue,
        '{{maxValue}}': maxValue,
        '{{minDecimal}}': 0,
        '{{maxDecimal}}': decPlaces
    };
    let isValid = true;
    let outputMsg = '';
    if (typeof options.validator === 'function') {
        return options.validator(inputValue, options.editorArgs);
    }
    else if (isRequired && inputValue === '') {
        isValid = false;
        outputMsg = errorMsg || Constants.VALIDATION_REQUIRED_FIELD;
    }
    else if (inputValue !== '' && (isNaN(inputValue) || (decPlaces === 0 && !/^[-+]?(\d*(\.)?(\d)*)$/.test(inputValue)))) {
        // when decimal value is 0 (which is the default), we accept 0 or more decimal values
        isValid = false;
        outputMsg = errorMsg || Constants.VALIDATION_EDITOR_VALID_NUMBER;
    }
    else if (minValue !== undefined && maxValue !== undefined && floatNumber !== null && ((operatorConditionalType === 'exclusive' && (floatNumber <= minValue || floatNumber >= maxValue)) || (operatorConditionalType === 'inclusive' && (floatNumber < minValue || floatNumber > maxValue)))) {
        // MIN & MAX Values provided
        // when decimal value is bigger than 0, we only accept the decimal values as that value set
        // for example if we set decimalPlaces to 2, we will only accept numbers between 0 and 2 decimals
        isValid = false;
        outputMsg = errorMsg || Constants.VALIDATION_EDITOR_NUMBER_BETWEEN.replace(/{{minValue}}|{{maxValue}}/gi, (matched) => mapValidation[matched]);
    }
    else if (minValue !== undefined && floatNumber !== null && ((operatorConditionalType === 'exclusive' && floatNumber <= minValue) || (operatorConditionalType === 'inclusive' && floatNumber < minValue))) {
        // MIN VALUE ONLY
        // when decimal value is bigger than 0, we only accept the decimal values as that value set
        // for example if we set decimalPlaces to 2, we will only accept numbers between 0 and 2 decimals
        isValid = false;
        const defaultErrorMsg = operatorConditionalType === 'inclusive' ? Constants.VALIDATION_EDITOR_NUMBER_MIN_INCLUSIVE : Constants.VALIDATION_EDITOR_NUMBER_MIN;
        outputMsg = errorMsg || defaultErrorMsg.replace(/{{minValue}}/gi, (matched) => mapValidation[matched]);
    }
    else if (maxValue !== undefined && floatNumber !== null && ((operatorConditionalType === 'exclusive' && floatNumber >= maxValue) || (operatorConditionalType === 'inclusive' && floatNumber > maxValue))) {
        // MAX VALUE ONLY
        // when decimal value is bigger than 0, we only accept the decimal values as that value set
        // for example if we set decimalPlaces to 2, we will only accept numbers between 0 and 2 decimals
        isValid = false;
        const defaultErrorMsg = operatorConditionalType === 'inclusive' ? Constants.VALIDATION_EDITOR_NUMBER_MAX_INCLUSIVE : Constants.VALIDATION_EDITOR_NUMBER_MAX;
        outputMsg = errorMsg || defaultErrorMsg.replace(/{{maxValue}}/gi, (matched) => mapValidation[matched]);
    }
    else if ((decPlaces > 0 && !new RegExp(`^[-+]?(\\d*(\\.)?(\\d){0,${decPlaces}})$`).test(inputValue))) {
        // when decimal value is bigger than 0, we only accept the decimal values as that value set
        // for example if we set decimalPlaces to 2, we will only accept numbers between 0 and 2 decimals
        isValid = false;
        outputMsg = errorMsg || Constants.VALIDATION_EDITOR_DECIMAL_BETWEEN.replace(/{{minDecimal}}|{{maxDecimal}}/gi, (matched) => mapValidation[matched]);
    }
    return { valid: isValid, msg: outputMsg };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmxvYXRWYWxpZGF0b3IuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9hbmd1bGFyLXNsaWNrZ3JpZC8iLCJzb3VyY2VzIjpbImFwcC9tb2R1bGVzL2FuZ3VsYXItc2xpY2tncmlkL2VkaXRvclZhbGlkYXRvcnMvZmxvYXRWYWxpZGF0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQWV6QyxNQUFNLFVBQVUsY0FBYyxDQUFDLFVBQWUsRUFBRSxPQUE4QjtJQUM1RSxNQUFNLFdBQVcsR0FBRyxDQUFDLEtBQUssQ0FBQyxVQUFvQixDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO0lBQ2pGLE1BQU0sU0FBUyxHQUFHLE9BQU8sQ0FBQyxPQUFPLElBQUksQ0FBQyxDQUFDO0lBQ3ZDLE1BQU0sVUFBVSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUM7SUFDcEMsTUFBTSxRQUFRLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQztJQUNsQyxNQUFNLFFBQVEsR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDO0lBQ2xDLE1BQU0sdUJBQXVCLEdBQUcsT0FBTyxDQUFDLHVCQUF1QixJQUFJLFdBQVcsQ0FBQztJQUMvRSxNQUFNLFFBQVEsR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDO0lBQ3RDLE1BQU0sYUFBYSxHQUFHO1FBQ3BCLGNBQWMsRUFBRSxRQUFRO1FBQ3hCLGNBQWMsRUFBRSxRQUFRO1FBQ3hCLGdCQUFnQixFQUFFLENBQUM7UUFDbkIsZ0JBQWdCLEVBQUUsU0FBUztLQUM1QixDQUFDO0lBQ0YsSUFBSSxPQUFPLEdBQUcsSUFBSSxDQUFDO0lBQ25CLElBQUksU0FBUyxHQUFHLEVBQUUsQ0FBQztJQUVuQixJQUFJLE9BQU8sT0FBTyxDQUFDLFNBQVMsS0FBSyxVQUFVLEVBQUU7UUFDM0MsT0FBTyxPQUFPLENBQUMsU0FBUyxDQUFDLFVB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QixTQUFTLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxFQUFFO1FBQ3RHLDJGQUEyRjtRQUMzRixpR0FBaUc7UUFDakcsT0FBTyxHQUFHLEtBQUssQ0FBQztRQUNoQixTQUFTLEdBQUcsUUFBUSxJQUFJLFNBQVMsQ0FBQyxpQ0FBaUMsQ0FBQyxPQUFPLENBQUMsaUNBQWlDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO0tBQ3JKO0lBRUQsT0FBTyxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxDQUFDO0FBQzVDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb25zdGFudHMgfSBmcm9tICcuLi9jb25zdGFudHMnO1xyXG5pbXBvcnQgeyBFZGl0b3JWYWxpZGF0b3JPdXRwdXQgfSBmcm9tICcuLi9tb2RlbHMvZWRpdG9yVmFsaWRhdG9yT3V0cHV0LmludGVyZmFjZSc7XHJcbmltcG9ydCB7IEVkaXRvclZhbGlkYXRvciB9IGZyb20gJy4uL21vZGVscy9lZGl0b3JWYWxpZGF0b3IuaW50ZXJmYWNlJztcclxuXHJcbmludGVyZmFjZSBGbG9hdFZhbGlkYXRvck9wdGlvbnMge1xyXG4gIGVkaXRvckFyZ3M6IGFueTtcclxuICBkZWNpbWFsPzogbnVtYmVyO1xyXG4gIGVycm9yTWVzc2FnZT86IHN0cmluZztcclxuICBtaW5WYWx1ZT86IHN0cmluZyB8IG51bWJlcjtcclxuICBtYXhWYWx1ZT86IHN0cmluZyB8IG51bWJlcjtcclxuICBvcGVyYXRvckNvbmRpdGlvbmFsVHlwZT86ICdpbmNsdXNpdmUnIHwgJ2V4Y2x1c2l2ZSc7XHJcbiAgcmVxdWlyZWQ/OiBib29sZWFuO1xyXG4gIHZhbGlkYXRvcj86IEVkaXRvclZhbGlkYXRvcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGZsb2F0VmFsaWRhdG9yKGlucHV0VmFsdWU6IGFueSwgb3B0aW9uczogRmxvYXRWYWxpZGF0b3JPcHRpb25zKTogRWRpdG9yVmFsaWRhdG9yT3V0cHV0IHtcclxuICBjb25zdCBmbG9hdE51bWJlciA9ICFpc05hTihpbnB1dFZhbHVlIGFzIG51bWJlcikgPyBwYXJzZUZsb2F0KGlucHV0VmFsdWUpIDogbnVsbDtcclxuICBjb25zdCBkZWNQbGFjZXMgPSBvcHRpb25zLmRlY2ltYWwgfHwgMDtcclxuICBjb25zdCBpc1JlcXVpcmVkID0gb3B0aW9ucy5yZXF1aXJlZDtcclxuICBjb25zdCBtaW5WYWx1ZSA9IG9wdGlvbnMubWluVmFsdWU7XHJcbiAgY29uc3QgbWF4VmFsdWUgPSBvcHRpb25zLm1heFZhbHVlO1xyXG4gIGNvbnN0IG9wZXJhdG9yQ29uZGl0aW9uYWxUeXBlID0gb3B0aW9ucy5vcGVyYXRvckNvbmRpdGlvbmFsVHlwZSB8fCAnaW5jbHVzaXZlJztcclxuICBjb25zdCBlcnJvck1zZyA9IG9wdGlvbnMuZXJyb3JNZXNzYWdlO1xyXG4gIGNvbnN0IG1hcFZhbGlkYXRpb24gPSB7XHJcbiAgICAne3ttaW5WYWx1ZX19JzogbWluVmFsdWUsXHJcbiAgICAne3ttYXhWYWx1ZX19JzogbWF4VmFsdWUsXHJcbiAgICAne3ttaW5EZWNpbWFsfX0nOiAwLFxyXG4gICAgJ3t7bWF4RGVjaW1hbH19JzogZGVjUGxhY2VzXHJcbiAgfTtcclxuICBsZXQgaXNWYWxpZCA9IHRydWU7XHJcbiAgbGV0IG91dHB1dE1zZyA9ICcnO1xyXG5cclxuICBpZiAodHlwZW9mIG9wdGlvbnMudmFsaWRhdG9yID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICByZXR1cm4gb3B0aW9ucy52YWxpZGF0b3IoaW5wdXRWYWx1ZSwgb3B0aW9ucy5lZGl0b3JBcmdzKTtcclxuICB9IGVsc2UgaWYgKGlzUmVxdWlyZWQgJiYgaW5wdXRWYWx1ZSA9PT0gJycpIHtcclxuICAgIGlzVmFsaWQgPSBmYWxzZTtcclxuICAgIG91dHB1dE1zZyA9IGVycm9yTXNnIHx8IENvbnN0YW50cy5WQUxJREFUSU9OX1JFUVVJUkVEX0ZJRUxEO1xyXG4gIH0gZWxzZSBpZiAoaW5wdXRWYWx1ZSAhPT0gJycgJiYgKGlzTmFOKGlucHV0VmFsdWUgYXMgbnVtYmVyKSB8fCAoZGVjUGxhY2VzID09PSAwICYmICEvXlstK10/KFxcZCooXFwuKT8oXFxkKSopJC8udGVzdChpbnB1dFZhbHVlKSkpKSB7XHJcbiAgICAvLyB3aGVuIGRlY2ltYWwgdmFsdWUgaXMgMCAod2hpY2ggaXMgdGhlIGRlZmF1bHQpLCB3ZSBhY2NlcHQgMCBvciBtb3JlIGRlY2ltYWwgdmFsdWVzXHJcbiAgICBpc1ZhbGlkID0gZmFsc2U7XHJcbiAgICBvdXRwdXRNc2cgPSBlcnJvck1zZyB8fCBDb25zdGFudHMuVkFMSURBVElPTl9FRElUT1JfVkFMSURfTlVNQkVSO1xyXG4gIH0gZWxzZSBpZiAobWluVmFsdWUgIT09IHVuZGVmaW5lZCAmJiBtYXhWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIGZsb2F0TnVtYmVyICE9PSBudWxsICYmICgob3BlcmF0b3JDb25kaXRpb25hbFR5cGUgPT09ICdleGNsdXNpdmUnICYmIChmbG9hdE51bWJlciA8PSBtaW5WYWx1ZSB8fCBmbG9hdE51bWJlciA+PSBtYXhWYWx1ZSkpIHx8IChvcGVyYXRvckNvbmRpdGlvbmFsVHlwZSA9PT0gJ2luY2x1c2l2ZScgJiYgKGZsb2F0TnVtYmVyIDwgbWluVmFsdWUgfHwgZmxvYXROdW1iZXIgPiBtYXhWYWx1ZSkpKSkge1xyXG4gICAgLy8gTUlOICYgTUFYIFZhbHVlcyBwcm92aWRlZFxyXG4gICAgLy8gd2hlbiBkZWNpbWFsIHZhbHVlIGlzIGJpZ2dlciB0aGFuIDAsIHdlIG9ubHkgYWNjZXB0IHRoZSBkZWNpbWFsIHZhbHVlcyBhcyB0aGF0IHZhbHVlIHNldFxyXG4gICAgLy8gZm9yIGV4YW1wbGUgaWYgd2Ugc2V0IGRlY2ltYWxQbGFjZXMgdG8gMiwgd2Ugd2lsbCBvbmx5IGFjY2VwdCBudW1iZXJzIGJldHdlZW4gMCBhbmQgMiBkZWNpbWFsc1xyXG4gICAgaXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgb3V0cHV0TXNnID0gZXJyb3JNc2cgfHwgQ29uc3RhbnRzLlZBTElEQVRJT05fRURJVE9SX05VTUJFUl9CRVRXRUVOLnJlcGxhY2UoL3t7bWluVmFsdWV9fXx7e21heFZhbHVlfX0vZ2ksIChtYXRjaGVkKSA9PiBtYXBWYWxpZGF0aW9uW21hdGNoZWRdKTtcclxuICB9IGVsc2UgaWYgKG1pblZhbHVlICE9PSB1bmRlZmluZWQgJiYgZmxvYXROdW1iZXIgIT09IG51bGwgJiYgKChvcGVyYXRvckNvbmRpdGlvbmFsVHlwZSA9PT0gJ2V4Y2x1c2l2ZScgJiYgZmxvYXROdW1iZXIgPD0gbWluVmFsdWUpIHx8IChvcGVyYXRvckNvbmRpdGlvbmFsVHlwZSA9PT0gJ2luY2x1c2l2ZScgJiYgZmxvYXROdW1iZXIgPCBtaW5WYWx1ZSkpKSB7XHJcbiAgICAvLyBNSU4gVkFMVUUgT05MWVxyXG4gICAgLy8gd2hlbiBkZWNpbWFsIHZhbHVlIGlzIGJpZ2dlciB0aGFuIDAsIHdlIG9ubHkgYWNjZXB0IHRoZSBkZWNpbWFsIHZhbHVlcyBhcyB0aGF0IHZhbHVlIHNldFxyXG4gICAgLy8gZm9yIGV4YW1wbGUgaWYgd2Ugc2V0IGRlY2ltYWxQbGFjZXMgdG8gMiwgd2Ugd2lsbCBvbmx5IGFjY2VwdCBudW1iZXJzIGJldHdlZW4gMCBhbmQgMiBkZWNpbWFsc1xyXG4gICAgaXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgY29uc3QgZGVmYXVsdEVycm9yTXNnID0gb3BlcmF0b3JDb25kaXRpb25hbFR5cGUgPT09ICdpbmNsdXNpdmUnID8gQ29uc3RhbnRzLlZBTElEQVRJT05fRURJVE9SX05VTUJFUl9NSU5fSU5DTFVTSVZFIDogQ29uc3RhbnRzLlZBTElEQVRJT05fRURJVE9SX05VTUJFUl9NSU47XHJcbiAgICBvdXRwdXRNc2cgPSBlcnJvck1zZyB8fCBkZWZhdWx0RXJyb3JNc2cucmVwbGFjZSgve3ttaW5WYWx1ZX19L2dpLCAobWF0Y2hlZCkgPT4gbWFwVmFsaWRhdGlvblttYXRjaGVkXSk7XHJcbiAgfSBlbHNlIGlmIChtYXhWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIGZsb2F0TnVtYmVyICE9PSBudWxsICYmICgob3BlcmF0b3JDb25kaXRpb25hbFR5cGUgPT09ICdleGNsdXNpdmUnICYmIGZsb2F0TnVtYmVyID49IG1heFZhbHVlKSB8fCAob3BlcmF0b3JDb25kaXRpb25hbFR5cGUgPT09ICdpbmNsdXNpdmUnICYmIGZsb2F0TnVtYmVyID4gbWF4VmFsdWUpKSkge1xyXG4gICAgLy8gTUFYIFZBTFVFIE9OTFlcclxuICAgIC8vIHdoZW4gZGVjaW1hbCB2YWx1ZSBpcyBiaWdnZXIgdGhhbiAwLCB3ZSBvbmx5IGFjY2VwdCB0aGUgZGVjaW1hbCB2YWx1ZXMgYXMgdGhhdCB2YWx1ZSBzZXRcclxuICAgIC8vIGZvciBleGFtcGxlIGlmIHdlIHNldCBkZWNpbWFsUGxhY2VzIHRvIDIsIHdlIHdpbGwgb25seSBhY2NlcHQgbnVtYmVycyBiZXR3ZWVuIDAgYW5kIDIgZGVjaW1hbHNcclxuICAgIGlzVmFsaWQgPSBmYWxzZTtcclxuICAgIGNvbnN0IGRlZmF1bHRFcnJvck1zZyA9IG9wZXJhdG9yQ29uZGl0aW9uYWxUeXBlID09PSAnaW5jbHVzaXZlJyA/IENvbnN0YW50cy5WQUxJREFUSU9OX0VESVRPUl9OVU1CRVJfTUFYX0lOQ0xVU0lWRSA6IENvbnN0YW50cy5WQUxJREFUSU9OX0VESVRPUl9OVU1CRVJfTUFYO1xyXG4gICAgb3V0cHV0TXNnID0gZXJyb3JNc2cgfHwgZGVmYXVsdEVycm9yTXNnLnJlcGxhY2UoL3t7bWF4VmFsdWV9fS9naSwgKG1hdGNoZWQpID0+IG1hcFZhbGlkYXRpb25bbWF0Y2hlZF0pO1xyXG4gIH0gZWxzZSBpZiAoKGRlY1BsYWNlcyA+IDAgJiYgIW5ldyBSZWdFeHAoYF5bLStdPyhcXFxcZCooXFxcXC4pPyhcXFxcZCl7MCwke2RlY1BsYWNlc319KSRgKS50ZXN0KGlucHV0VmFsdWUpKSkge1xyXG4gICAgLy8gd2hlbiBkZWNpbWFsIHZhbHVlIGlzIGJpZ2dlciB0aGFuIDAsIHdlIG9ubHkgYWNjZXB0IHRoZSBkZWNpbWFsIHZhbHVlcyBhcyB0aGF0IHZhbHVlIHNldFxyXG4gICAgLy8gZm9yIGV4YW1wbGUgaWYgd2Ugc2V0IGRlY2ltYWxQbGFjZXMgdG8gMiwgd2Ugd2lsbCBvbmx5IGFjY2VwdCBudW1iZXJzIGJldHdlZW4gMCBhbmQgMiBkZWNpbWFsc1xyXG4gICAgaXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgb3V0cHV0TXNnID0gZXJyb3JNc2cgfHwgQ29uc3RhbnRzLlZBTElEQVRJT05fRURJVE9SX0RFQ0lNQUxfQkVUV0VFTi5yZXBsYWNlKC97e21pbkRlY2ltYWx9fXx7e21heERlY2ltYWx9fS9naSwgKG1hdGNoZWQpID0+IG1hcFZhbGlkYXRpb25bbWF0Y2hlZF0pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHsgdmFsaWQ6IGlzVmFsaWQsIG1zZzogb3V0cHV0TXNnIH07XHJcbn1cclxuIl19