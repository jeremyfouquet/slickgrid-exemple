import * as tslib_1 from "tslib";
import { Optional } from '@angular/core';
import Flatpickr from 'flatpickr';
import { Constants } from '../constants';
import { FieldType, OperatorType, } from './../models/index';
import { buildSelectOperatorHtmlString } from './filterUtilities';
import { destroyObjectDomElementProps, getTranslationPrefix, mapFlatpickrDateFormatWithFieldType, mapOperatorToShorthandDesignation } from '../services/utilities';
require('flatpickr');
let CompoundDateFilter = class CompoundDateFilter {
    constructor(translate) {
        this.translate = translate;
        this._clearFilterTriggered = false;
        this._shouldTriggerQuery = true;
    }
    /** Getter for the Grid Options pulled through the Grid Object */
    get gridOptions() {
        return (this.grid && this.grid.getOptions) ? this.grid.getOptions() : {};
    }
    /** Getter for the Column Filter */
    get columnFilter() {
        return this.columnDef && this.columnDef.filter || {};
    }
    /** Getter for the Current Dates selected */
    get currentDate() {
        return this._currentDate;
    }
    /** Getter to know what would be the default operator when none is specified */
    get defaultOperator() {
        return OperatorType.empty;
    }
    /** Getter for the Flatpickr Options */
    get flatpickrOptions() {
        return this._flatpickrOptions || {};
    }
    /** Getter for the single Locale texts provided by the user in main file or else use default English locales via the Constants */
    get locales() {
        return this.gridOptions.locales || Constants.locales;
    }
    /** Getter for the Filter Operator */
    get operator() {
        return this._operator || this.columnFilter.operator || this.defaultOperator;
    }
    /** Setter for the Filter Operator */
    set operator(op) {
        this._operator = op;
    }
    /**
     * Initialize the Filter
     */
    init(args) {
        if (!args) {
            throw new Error('[Angular-SlickGrid] A filter must always have an "init()" with valid arguments.');
        }
        this.grid = args.grid;
        this.callback = args.callback;
        this.columnDef = args.columnDef;
        this.operator = args.operator || '';
        this.searchTerms = (args.hasOwnProperty('searchTerms') ? args.searchTerms : []) || [];
        // date input can only have 1 search term, so we will use the 1st array index if it exist
        const searchTerm = (Array.isArray(this.searchTerms) && this.searchTerms.length >= 0) ? this.searchTerms[0] : '';
        // step 1, create the DOM Element of the filter which contain the compound Operator+Input
        // and initialize it if searchTerm is filled
        this.$filterElm = this.createDomElement(searchTerm);
        // step 3, subscribe to the keyup event and run the callback when that happens
        // also add/remove "filled" class for styling purposes
        this.$filterInputElm.keyup((e) => {
            this.onTriggerEvent(e);
        });
        this.$selectOperatorElm.change((e) => {
            this.onTriggerEvent(e);
        });
    }
    /**
     * Clear the filter value
     */
    clear(shouldTriggerQuery = true) {
        if (this.flatInstance && this.$selectOperatorElm) {
            this._clearFilterTriggered = true;
            this._shouldTriggerQuery = shouldTriggerQuery;
            this.searchTerms = [];
            this.$selectOperatorElm.val(0);
            this.flatInstance.clear();
        }
    }
    /**
     * destroy the filter
     */
    destroy() {
        if (this.flatInstance && typeof this.flatInstance.destroy === 'function') {
            this.flatInstance.destroy();
            if (this.flatInstance.element) {
                destroyObjectDomElementProps(this.flatInstance);
            }
            this.flatInstance = null;
        }
        if (this.$filterElm) {
            this.$filterElm.off('keyup').remove();
        }
        if (this.$selectOperatorElm) {
            this.$selectOperatorElm.off('change').remove();
        }
        this.$filterElm = null;
        this.callback = null;
        this.onTriggerEvent = null;
    }
    hide() {
        if (this.flatInstance && typeof this.flatInstance.close === 'function') {
            this.flatInstance.close();
        }
    }
    show() {
        if (this.flatInstance && typeof this.flatInstance.open === 'function') {
            this.flatInstance.open();
        }
    }
    /** Set value(s) in the DOM element, we can optionally pass an operator and/or trigger a change event */
    setValues(values, operator) {
        if (this.flatInstance && values) {
            const newValue = Array.isArray(values) ? values[0] : values;
            this._currentDate = newValue;
            this.flatInstance.setDate(newValue);
        }
        // set the operator, in the DOM as well, when defined
        this.operator = operator || this.defaultOperator;
        if (operator && this.$selectOperatorElm) {
            const operatorShorthand = mapOperatorToShorthandDesignation(this.operator);
            this.$selectOperatorElm.val(operatorShorthand);
        }
    }
    //
    // private functions
    // ------------------
    buildDatePickerInput(searchTerm) {
        const inputFormat = mapFlatpickrDateFormatWithFieldType(this.columnFilter.type || this.columnDef.type || FieldType.dateIso);
        const outputFormat = mapFlatpickrDateFormatWithFieldType(this.columnDef.outputType || this.columnFilter.type || this.columnDef.type || FieldType.dateUtc);
        const userFilterOptions = (this.columnFilter && this.columnFilter.filterOptions || {});
        // get current locale, if user defined a custom locale just use or get it the Translate Service if it exist else just use English
        let currentLocale = (userFilterOptions && userFilterOptions.locale) || (this.translate && this.translate.currentLang) || this.gridOptions.locale || 'en';
        if (currentLocale && currentLocale.length > 2) {
            currentLocale = currentLocale.substring(0, 2);
        }
        // if we are preloading searchTerms, we'll keep them for reference
        if (searchTerm) {
            this._currentDate = searchTerm;
        }
        const pickerOptions = {
            defaultDate: searchTerm || '',
            altInput: true,
            altFormat: outputFormat,
            dateFormat: inputFormat,
            wrap: true,
            closeOnSelect: true,
            locale: (currentLocale !== 'en') ? this.loadFlatpickrLocale(currentLocale) : 'en',
            onChange: (selectedDates, dateStr) => {
                this._currentValue = dateStr;
                this._currentDate = Array.isArray(selectedDates) && selectedDates[0];
                // when using the time picker, we can simulate a keyup event to avoid multiple backend request
                // since backend request are only executed after user start typing, changing the time should be treated the same way
                let customEvent;
                if (pickerOptions.enableTime) {
                    customEvent = new CustomEvent('keyup');
                }
                this.onTriggerEvent(customEvent);
            }
        };
        // add the time picker when format is UTC (Z) or has the 'h' (meaning hours)
        if (outputFormat && (outputFormat === 'Z' || outputFormat.toLowerCase().includes('h'))) {
            pickerOptions.enableTime = true;
        }
        // merge options with optional user's custom options
        this._flatpickrOptions = Object.assign({}, pickerOptions, userFilterOptions);
        let placeholder = (this.gridOptions) ? (this.gridOptions.defaultFilterPlaceholder || '') : '';
        if (this.columnFilter && this.columnFilter.placeholder) {
            placeholder = this.columnFilter.placeholder;
        }
        const $filterInputElm = $(`<div class="flatpickr"><input type="text" class="form-control" data-input placeholder="${placeholder}"></div>`);
        this.flatInstance = ($filterInputElm[0] && typeof $filterInputElm[0].flatpickr === 'function') ? $filterInputElm[0].flatpickr(this._flatpickrOptions) : Flatpickr($filterInputElm, this._flatpickrOptions);
        return $filterInputElm;
    }
    getOptionValues() {
        return [
            { operator: '', description: '' },
            { operator: '=', description: this.getOutputText('EQUAL_TO', 'TEXT_EQUAL_TO', 'Equal to') },
            { operator: '<', description: this.getOutputText('LESS_THAN', 'TEXT_LESS_THAN', 'Less than') },
            { operator: '<=', description: this.getOutputText('LESS_THAN_OR_EQUAL_TO', 'TEXT_LESS_THAN_OR_EQUAL_TO', 'Less than or equal to') },
            { operator: '>', description: this.getOutputText('GREATER_THAN', 'TEXT_GREATER_THAN', 'Greater than') },
            { operator: '>=', description: this.getOutputText('GREATER_THAN_OR_EQUAL_TO', 'TEXT_GREATER_THAN_OR_EQUAL_TO', 'Greater than or equal to') },
            { operator: '<>', description: this.getOutputText('NOT_EQUAL_TO', 'TEXT_NOT_EQUAL_TO', 'Not equal to') }
        ];
    }
    /** Get Locale, Translated or a Default Text if first two aren't detected */
    getOutputText(translationKey, localeText, defaultText) {
        if (this.gridOptions && this.gridOptions.enableTranslate && this.translate && this.translate.instant) {
            const translationPrefix = getTranslationPrefix(this.gridOptions);
            return this.translate.instant(`${translationPrefix}${translationKey}`);
        }
        return this.locales && this.locales[localeText] || defaultText;
    }
    /**
     * Create the DOM element
     */
    createDomElement(searchTerm) {
        const fieldId = this.columnDef && this.columnDef.id;
        const $headerElm = this.grid.getHeaderRowColumn(fieldId);
        $($headerElm).empty();
        // create the DOM Select dropdown for the Operator
        const selectOperatorHtmlString = buildSelectOperatorHtmlString(this.getOptionValues());
        this.$selectOperatorElm = $(selectOperatorHtmlString);
        this.$filterInputElm = this.buildDatePickerInput(searchTerm);
        const $filterContainerElm = $(`<div class="form-group search-filter filter-${fieldId}"></div>`);
        const $containerInputGroup = $(`<div class="input-group flatpickr"></div>`);
        const $operatorInputGroupAddon = $(`<div class="input-group-addon input-group-prepend operator"></div>`);
        /* the DOM element final structure will be
          <div class="input-group">
            <div class="input-group-addon input-group-prepend operator">
              <select class="form-control"></select>
            </div>
            <div class=flatpickr>
              <input type="text" class="form-control" data-input>
            </div>
          </div>
        */
        $operatorInputGroupAddon.append(this.$selectOperatorElm);
        $containerInputGroup.append($operatorInputGroupAddon);
        $containerInputGroup.append(this.$filterInputElm);
        // create the DOM element & add an ID and filter class
        $filterContainerElm.append($containerInputGroup);
        this.$filterInputElm.data('columnId', fieldId);
        if (this.operator) {
            const operatorShorthand = mapOperatorToShorthandDesignation(this.operator);
            this.$selectOperatorElm.val(operatorShorthand);
        }
        // if there's a search term, we will add the "filled" class for styling purposes
        if (searchTerm && searchTerm !== '') {
            this.$filterInputElm.addClass('filled');
            this._currentDate = searchTerm;
            this._currentValue = searchTerm;
        }
        // append the new DOM element to the header row
        if ($filterContainerElm && typeof $filterContainerElm.appendTo === 'function') {
            $filterContainerElm.appendTo($headerElm);
        }
        return $filterContainerElm;
    }
    /** Load a different set of locales for Flatpickr to be localized */
    loadFlatpickrLocale(language) {
        let locales = 'en';
        try {
            if (language !== 'en') {
                // change locale if needed, Flatpickr reference: https://chmln.github.io/flatpickr/localization/
                const localeDefault = require(`flatpickr/dist/l10n/${language}.js`).default;
                locales = (localeDefault && localeDefault[language]) ? localeDefault[language] : 'en';
            }
        }
        catch (e) {
            console.warn(`[Angular-Slickgrid - CompoundDate Filter] It seems that "${language}" is not a locale supported by Flatpickr, we will use "en" instead. `
                + `To avoid seeing this message, you can specifically set "filter: { filterOptions: { locale: 'en' } }" in your column definition.`);
            return 'en';
        }
        return locales;
    }
    onTriggerEvent(e) {
        if (this._clearFilterTriggered) {
            this.callback(e, { columnDef: this.columnDef, clearFilterTriggered: this._clearFilterTriggered, shouldTriggerQuery: this._shouldTriggerQuery });
            this.$filterElm.removeClass('filled');
        }
        else {
            const selectedOperator = this.$selectOperatorElm.find('option:selected').val();
            (this._currentValue) ? this.$filterElm.addClass('filled') : this.$filterElm.removeClass('filled');
            this.callback(e, { columnDef: this.columnDef, searchTerms: (this._currentValue ? [this._currentValue] : null), operator: selectedOperator || '', shouldTriggerQuery: this._shouldTriggerQuery });
        }
        // reset both flags for next use
        this._clearFilterTriggered = false;
        this._shouldTriggerQuery = true;
    }
};
CompoundDateFilter = tslib_1.__decorate([
    tslib_1.__param(0, Optional())
], CompoundDateFilter);
export { CompoundDateFilter };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcG91bmREYXRlRmlsdGVyLmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci1zbGlja2dyaWQvIiwic291cmNlcyI6WyJhcHAvbW9kdWxlcy9hbmd1bGFyLXNsaWNrZ3JpZC9maWx0ZXJzL2NvbXBvdW5kRGF0ZUZpbHRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUV6QyxPQUFPLFNBQVMsTUFBTSxXQUFXLENBQUM7QUFHbEMsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUN6QyxPQUFPLEVBTUwsU0FBUyxFQUtULFlBQVksR0FFYixNQUFNLG1CQUFtQixDQUFDO0FBQzNCLE9BQU8sRUFBRSw2QkFBNkIsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQ2xFLE9BQU8sRUFBRSw0QkFBNEIsRUFBRSxvQkFBb0IsRUFBRSxtQ0FBbUMsRUFBRSxpQ0FBaUMsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBSW5LLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUtyQixJQUFhLGtCQUFrQixHQUEvQixNQUFhLGtCQUFrQjtJQWdCN0IsWUFBZ0MsU0FBMkI7UUFBM0IsY0FBUyxHQUFULFNBQVMsQ0FBa0I7UUFmbkQsMEJBQXFCLEdBQUcsS0FBSyxDQUFDO1FBRzlCLHdCQUFtQixHQUFHLElBQUksQ0FBQztJQVk0QixDQUFDO0lBRWhFLGlFQUFpRTtJQUNqRSxJQUFZLFdBQVc7UUFDckIsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO0lBQzNFLENBQUM7SUFFRCxtQ0FBbUM7SUFDbkMsSUFBSSxZQUFZO1FBQ2QsT0FBTyxJQUFJLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQyxTQUFT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QWEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLFFBQVEsRUFBRSxnQkFBZ0IsSUFBSSxFQUFFLEVBQUUsa0JBQWtCLEVBQUUsSUFBSSxDQUFDLG1CQUFtQixFQUFFLENBQUMsQ0FBQztTQUNsTTtRQUNELGdDQUFnQztRQUNoQyxJQUFJLENBQUMscUJBQXFCLEdBQUcsS0FBSyxDQUFDO1FBQ25DLElBQUksQ0FBQyxtQkFBbUIsR0FBRyxJQUFJLENBQUM7SUFDbEMsQ0FBQztDQUNGLENBQUE7QUEzVFksa0JBQWtCO0lBZ0JoQixtQkFBQSxRQUFRLEVBQUUsQ0FBQTtHQWhCWixrQkFBa0IsQ0EyVDlCO1NBM1RZLGtCQUFrQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFRyYW5zbGF0ZVNlcnZpY2UgfSBmcm9tICdAbmd4LXRyYW5zbGF0ZS9jb3JlJztcclxuaW1wb3J0IEZsYXRwaWNrciBmcm9tICdmbGF0cGlja3InO1xyXG5pbXBvcnQgeyBCYXNlT3B0aW9ucyBhcyBGbGF0cGlja3JCYXNlT3B0aW9ucyB9IGZyb20gJ2ZsYXRwaWNrci9kaXN0L3R5cGVzL29wdGlvbnMnO1xyXG5cclxuaW1wb3J0IHsgQ29uc3RhbnRzIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcclxuaW1wb3J0IHtcclxuICBDb2x1bW4sXHJcbiAgQ29sdW1uRmlsdGVyLFxyXG4gIEZpbHRlcixcclxuICBGaWx0ZXJBcmd1bWVudHMsXHJcbiAgRmlsdGVyQ2FsbGJhY2ssXHJcbiAgRmllbGRUeXBlLFxyXG4gIEZsYXRwaWNrck9wdGlvbixcclxuICBHcmlkT3B0aW9uLFxyXG4gIExvY2FsZSxcclxuICBPcGVyYXRvclN0cmluZyxcclxuICBPcGVyYXRvclR5cGUsXHJcbiAgU2VhcmNoVGVybSxcclxufSBmcm9tICcuLy4uL21vZGVscy9pbmRleCc7XHJcbmltcG9ydCB7IGJ1aWxkU2VsZWN0T3BlcmF0b3JIdG1sU3RyaW5nIH0gZnJvbSAnLi9maWx0ZXJVdGlsaXRpZXMnO1xyXG5pbXBvcnQgeyBkZXN0cm95T2JqZWN0RG9tRWxlbWVudFByb3BzLCBnZXRUcmFuc2xhdGlvblByZWZpeCwgbWFwRmxhdHBpY2tyRGF0ZUZvcm1hdFdpdGhGaWVsZFR5cGUsIG1hcE9wZXJhdG9yVG9TaG9ydGhhbmREZXNpZ25hdGlvbiB9IGZyb20gJy4uL3NlcnZpY2VzL3V0aWxpdGllcyc7XHJcblxyXG4vLyB1c2UgRmxhdHBpY2tyIGZyb20gaW1wb3J0IG9yICdyZXF1aXJlJywgd2hpY2hldmVyIHdvcmtzIGZpcnN0XHJcbmRlY2xhcmUgZnVuY3Rpb24gcmVxdWlyZShuYW1lOiBzdHJpbmcpOiBhbnk7XHJcbnJlcXVpcmUoJ2ZsYXRwaWNrcicpO1xyXG5cclxuLy8gdXNpbmcgZXh0ZXJuYWwgbm9uLXR5cGVkIGpzIGxpYnJhcmllc1xyXG5kZWNsYXJlIGNvbnN0ICQ6IGFueTtcclxuXHJcbmV4cG9ydCBjbGFzcyBDb21wb3VuZERhdGVGaWx0ZXIgaW1wbGVtZW50cyBGaWx0ZXIge1xyXG4gIHByaXZhdGUgX2NsZWFyRmlsdGVyVHJpZ2dlcmVkID0gZmFsc2U7XHJcbiAgcHJpdmF0ZSBfY3VycmVudERhdGU6IERhdGU7XHJcbiAgcHJpdmF0ZSBfZmxhdHBpY2tyT3B0aW9uczogRmxhdHBpY2tyT3B0aW9uO1xyXG4gIHByaXZhdGUgX3Nob3VsZFRyaWdnZXJRdWVyeSA9IHRydWU7XHJcbiAgcHJpdmF0ZSAkZmlsdGVyRWxtOiBhbnk7XHJcbiAgcHJpdmF0ZSAkZmlsdGVySW5wdXRFbG06IGFueTtcclxuICBwcml2YXRlICRzZWxlY3RPcGVyYXRvckVsbTogYW55O1xyXG4gIHByaXZhdGUgX2N1cnJlbnRWYWx1ZTogc3RyaW5nO1xyXG4gIHByaXZhdGUgX29wZXJhdG9yOiBPcGVyYXRvclR5cGUgfCBPcGVyYXRvclN0cmluZztcclxuICBmbGF0SW5zdGFuY2U6IGFueTtcclxuICBncmlkOiBhbnk7XHJcbiAgc2VhcmNoVGVybXM6IFNlYXJjaFRlcm1bXTtcclxuICBjb2x1bW5EZWY6IENvbHVtbjtcclxuICBjYWxsYmFjazogRmlsdGVyQ2FsbGJhY2s7XHJcblxyXG4gIGNvbnN0cnVjdG9yKEBPcHRpb25hbCgpIHByaXZhdGUgdHJhbnNsYXRlOiBUcmFuc2xhdGVTZXJ2aWNlKSB7IH1cclxuXHJcbiAgLyoqIEdldHRlciBmb3IgdGhlIEdyaWQgT3B0aW9ucyBwdWxsZWQgdGhyb3VnaCB0aGUgR3JpZCBPYmplY3QgKi9cclxuICBwcml2YXRlIGdldCBncmlkT3B0aW9ucygpOiBHcmlkT3B0aW9uIHtcclxuICAgIHJldHVybiAodGhpcy5ncmlkICYmIHRoaXMuZ3JpZC5nZXRPcHRpb25zKSA/IHRoaXMuZ3JpZC5nZXRPcHRpb25zKCkgOiB7fTtcclxuICB9XHJcblxyXG4gIC8qKiBHZXR0ZXIgZm9yIHRoZSBDb2x1bW4gRmlsdGVyICovXHJcbiAgZ2V0IGNvbHVtbkZpbHRlcigpOiBDb2x1bW5GaWx0ZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuY29sdW1uRGVmICYmIHRoaXMuY29sdW1uRGVmLmZpbHRlciB8fCB7fTtcclxuICB9XHJcblxyXG4gIC8qKiBHZXR0ZXIgZm9yIHRoZSBDdXJyZW50IERhdGVzIHNlbGVjdGVkICovXHJcbiAgZ2V0IGN1cnJlbnREYXRlKCk6IERhdGUge1xyXG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnREYXRlO1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldHRlciB0byBrbm93IHdoYXQgd291bGQgYmUgdGhlIGRlZmF1bHQgb3BlcmF0b3Igd2hlbiBub25lIGlzIHNwZWNpZmllZCAqL1xyXG4gIGdldCBkZWZhdWx0T3BlcmF0b3IoKTogT3BlcmF0b3JUeXBlIHwgT3BlcmF0b3JTdHJpbmcge1xyXG4gICAgcmV0dXJuIE9wZXJhdG9yVHlwZS5lbXB0eTtcclxuICB9XHJcblxyXG4gIC8qKiBHZXR0ZXIgZm9yIHRoZSBGbGF0cGlja3IgT3B0aW9ucyAqL1xyXG4gIGdldCBmbGF0cGlja3JPcHRpb25zKCk6IEZsYXRwaWNrck9wdGlvbiB7XHJcbiAgICByZXR1cm4gdGhpcy5fZmxhdHBpY2tyT3B0aW9ucyB8fCB7fTtcclxuICB9XHJcblxyXG4gIC8qKiBHZXR0ZXIgZm9yIHRoZSBzaW5nbGUgTG9jYWxlIHRleHRzIHByb3ZpZGVkIGJ5IHRoZSB1c2VyIGluIG1haW4gZmlsZSBvciBlbHNlIHVzZSBkZWZhdWx0IEVuZ2xpc2ggbG9jYWxlcyB2aWEgdGhlIENvbnN0YW50cyAqL1xyXG4gIGdldCBsb2NhbGVzKCk6IExvY2FsZSB7XHJcbiAgICByZXR1cm4gdGhpcy5ncmlkT3B0aW9ucy5sb2NhbGVzIHx8IENvbnN0YW50cy5sb2NhbGVzO1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldHRlciBmb3IgdGhlIEZpbHRlciBPcGVyYXRvciAqL1xyXG4gIGdldCBvcGVyYXRvcigpOiBPcGVyYXRvclR5cGUgfCBPcGVyYXRvclN0cmluZyB7XHJcbiAgICByZXR1cm4gdGhpcy5fb3BlcmF0b3IgfHwgdGhpcy5jb2x1bW5GaWx0ZXIub3BlcmF0b3IgfHwgdGhpcy5kZWZhdWx0T3BlcmF0b3I7XHJcbiAgfVxyXG5cclxuICAvKiogU2V0dGVyIGZvciB0aGUgRmlsdGVyIE9wZXJhdG9yICovXHJcbiAgc2V0IG9wZXJhdG9yKG9wOiBPcGVyYXRvclR5cGUgfCBPcGVyYXRvclN0cmluZykge1xyXG4gICAgdGhpcy5fb3BlcmF0b3IgPSBvcDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemUgdGhlIEZpbHRlclxyXG4gICAqL1xyXG4gIGluaXQoYXJnczogRmlsdGVyQXJndW1lbnRzKSB7XHJcbiAgICBpZiAoIWFyZ3MpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdbQW5ndWxhci1TbGlja0dyaWRdIEEgZmlsdGVyIG11c3QgYWx3YXlzIGhhdmUgYW4gXCJpbml0KClcIiB3aXRoIHZhbGlkIGFyZ3VtZW50cy4nKTtcclxuICAgIH1cclxuICAgIHRoaXMuZ3JpZCA9IGFyZ3MuZ3JpZDtcclxuICAgIHRoaXMuY2FsbGJhY2sgPSBhcmdzLmNhbGxiYWNrO1xyXG4gICAgdGhpcy5jb2x1bW5EZWYgPSBhcmdzLmNvbHVtbkRlZjtcclxuICAgIHRoaXMub3BlcmF0b3IgPSBhcmdzLm9wZXJhdG9yIHx8ICcnO1xyXG4gICAgdGhpcy5zZWFyY2hUZXJtcyA9IChhcmdzLmhhc093blByb3BlcnR5KCdzZWFyY2hUZXJtcycpID8gYXJncy5zZWFyY2hUZXJtcyA6IFtdKSB8fCBbXTtcclxuXHJcbiAgICAvLyBkYXRlIGlucHV0IGNhbiBvbmx5IGhhdmUgMSBzZWFyY2ggdGVybSwgc28gd2Ugd2lsbCB1c2UgdGhlIDFzdCBhcnJheSBpbmRleCBpZiBpdCBleGlzdFxyXG4gICAgY29uc3Qgc2VhcmNoVGVybSA9IChBcnJheS5pc0FycmF5KHRoaXMuc2VhcmNoVGVybXMpICYmIHRoaXMuc2VhcmNoVGVybXMubGVuZ3RoID49IDApID8gdGhpcy5zZWFyY2hUZXJtc1swXSA6ICcnO1xyXG5cclxuICAgIC8vIHN0ZXAgMSwgY3JlYXRlIHRoZSBET00gRWxlbWVudCBvZiB0aGUgZmlsdGVyIHdoaWNoIGNvbnRhaW4gdGhlIGNvbXBvdW5kIE9wZXJhdG9yK0lucHV0XHJcbiAgICAvLyBhbmQgaW5pdGlhbGl6ZSBpdCBpZiBzZWFyY2hUZXJtIGlzIGZpbGxlZFxyXG4gICAgdGhpcy4kZmlsdGVyRWxtID0gdGhpcy5jcmVhdGVEb21FbGVtZW50KHNlYXJjaFRlcm0pO1xyXG5cclxuICAgIC8vIHN0ZXAgMywgc3Vic2NyaWJlIHRvIHRoZSBrZXl1cCBldmVudCBhbmQgcnVuIHRoZSBjYWxsYmFjayB3aGVuIHRoYXQgaGFwcGVuc1xyXG4gICAgLy8gYWxzbyBhZGQvcmVtb3ZlIFwiZmlsbGVkXCIgY2xhc3MgZm9yIHN0eWxpbmcgcHVycG9zZXNcclxuICAgIHRoaXMuJGZpbHRlcklucHV0RWxtLmtleXVwKChlOiBhbnkpID0+IHtcclxuICAgICAgdGhpcy5vblRyaWdnZXJFdmVudChlKTtcclxuICAgIH0pO1xyXG4gICAgdGhpcy4kc2VsZWN0T3BlcmF0b3JFbG0uY2hhbmdlKChlOiBhbnkpID0+IHtcclxuICAgICAgdGhpcy5vblRyaWdnZXJFdmVudChlKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2xlYXIgdGhlIGZpbHRlciB2YWx1ZVxyXG4gICAqL1xyXG4gIGNsZWFyKHNob3VsZFRyaWdnZXJRdWVyeSA9IHRydWUpIHtcclxuICAgIGlmICh0aGlzLmZsYXRJbnN0YW5jZSAmJiB0aGlzLiRzZWxlY3RPcGVyYXRvckVsbSkge1xyXG4gICAgICB0aGlzLl9jbGVhckZpbHRlclRyaWdnZXJlZCA9IHRydWU7XHJcbiAgICAgIHRoaXMuX3Nob3VsZFRyaWdnZXJRdWVyeSA9IHNob3VsZFRyaWdnZXJRdWVyeTtcclxuICAgICAgdGhpcy5zZWFyY2hUZXJtcyA9IFtdO1xyXG4gICAgICB0aGlzLiRzZWxlY3RPcGVyYXRvckVsbS52YWwoMCk7XHJcbiAgICAgIHRoaXMuZmxhdEluc3RhbmNlLmNsZWFyKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBkZXN0cm95IHRoZSBmaWx0ZXJcclxuICAgKi9cclxuICBkZXN0cm95KCkge1xyXG4gICAgaWYgKHRoaXMuZmxhdEluc3RhbmNlICYmIHR5cGVvZiB0aGlzLmZsYXRJbnN0YW5jZS5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHRoaXMuZmxhdEluc3RhbmNlLmRlc3Ryb3koKTtcclxuICAgICAgaWYgKHRoaXMuZmxhdEluc3RhbmNlLmVsZW1lbnQpIHtcclxuICAgICAgICBkZXN0cm95T2JqZWN0RG9tRWxlbWVudFByb3BzKHRoaXMuZmxhdEluc3RhbmNlKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmZsYXRJbnN0YW5jZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy4kZmlsdGVyRWxtKSB7XHJcbiAgICAgIHRoaXMuJGZpbHRlckVsbS5vZmYoJ2tleXVwJykucmVtb3ZlKCk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy4kc2VsZWN0T3BlcmF0b3JFbG0pIHtcclxuICAgICAgdGhpcy4kc2VsZWN0T3BlcmF0b3JFbG0ub2ZmKCdjaGFuZ2UnKS5yZW1vdmUoKTtcclxuICAgIH1cclxuICAgIHRoaXMuJGZpbHRlckVsbSA9IG51bGw7XHJcbiAgICB0aGlzLmNhbGxiYWNrID0gbnVsbDtcclxuICAgIHRoaXMub25UcmlnZ2VyRXZlbnQgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgaGlkZSgpIHtcclxuICAgIGlmICh0aGlzLmZsYXRJbnN0YW5jZSAmJiB0eXBlb2YgdGhpcy5mbGF0SW5zdGFuY2UuY2xvc2UgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhpcy5mbGF0SW5zdGFuY2UuY2xvc2UoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNob3coKSB7XHJcbiAgICBpZiAodGhpcy5mbGF0SW5zdGFuY2UgJiYgdHlwZW9mIHRoaXMuZmxhdEluc3RhbmNlLm9wZW4gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhpcy5mbGF0SW5zdGFuY2Uub3BlbigpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqIFNldCB2YWx1ZShzKSBpbiB0aGUgRE9NIGVsZW1lbnQsIHdlIGNhbiBvcHRpb25hbGx5IHBhc3MgYW4gb3BlcmF0b3IgYW5kL29yIHRyaWdnZXIgYSBjaGFuZ2UgZXZlbnQgKi9cclxuICBzZXRWYWx1ZXModmFsdWVzOiBTZWFyY2hUZXJtIHwgU2VhcmNoVGVybVtdLCBvcGVyYXRvcj86IE9wZXJhdG9yVHlwZSB8IE9wZXJhdG9yU3RyaW5nKSB7XHJcbiAgICBpZiAodGhpcy5mbGF0SW5zdGFuY2UgJiYgdmFsdWVzKSB7XHJcbiAgICAgIGNvbnN0IG5ld1ZhbHVlID0gQXJyYXkuaXNBcnJheSh2YWx1ZXMpID8gdmFsdWVzWzBdIDogdmFsdWVzO1xyXG4gICAgICB0aGlzLl9jdXJyZW50RGF0ZSA9IG5ld1ZhbHVlIGFzIERhdGU7XHJcbiAgICAgIHRoaXMuZmxhdEluc3RhbmNlLnNldERhdGUobmV3VmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHNldCB0aGUgb3BlcmF0b3IsIGluIHRoZSBET00gYXMgd2VsbCwgd2hlbiBkZWZpbmVkXHJcbiAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3IgfHwgdGhpcy5kZWZhdWx0T3BlcmF0b3I7XHJcbiAgICBpZiAob3BlcmF0b3IgJiYgdGhpcy4kc2VsZWN0T3BlcmF0b3JFbG0pIHtcclxuICAgICAgY29uc3Qgb3BlcmF0b3JTaG9ydGhhbmQgPSBtYXBPcGVyYXRvclRvU2hvcnRoYW5kRGVzaWduYXRpb24odGhpcy5vcGVyYXRvcik7XHJcbiAgICAgIHRoaXMuJHNlbGVjdE9wZXJhdG9yRWxtLnZhbChvcGVyYXRvclNob3J0aGFuZCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvL1xyXG4gIC8vIHByaXZhdGUgZnVuY3Rpb25zXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgcHJpdmF0ZSBidWlsZERhdGVQaWNrZXJJbnB1dChzZWFyY2hUZXJtPzogU2VhcmNoVGVybSkge1xyXG4gICAgY29uc3QgaW5wdXRGb3JtYXQgPSBtYXBGbGF0cGlja3JEYXRlRm9ybWF0V2l0aEZpZWxkVHlwZSh0aGlzLmNvbHVtbkZpbHRlci50eXBlIHx8IHRoaXMuY29sdW1uRGVmLnR5cGUgfHwgRmllbGRUeXBlLmRhdGVJc28pO1xyXG4gICAgY29uc3Qgb3V0cHV0Rm9ybWF0ID0gbWFwRmxhdHBpY2tyRGF0ZUZvcm1hdFdpdGhGaWVsZFR5cGUodGhpcy5jb2x1bW5EZWYub3V0cHV0VHlwZSB8fCB0aGlzLmNvbHVtbkZpbHRlci50eXBlIHx8IHRoaXMuY29sdW1uRGVmLnR5cGUgfHwgRmllbGRUeXBlLmRhdGVVdGMpO1xyXG4gICAgY29uc3QgdXNlckZpbHRlck9wdGlvbnMgPSAodGhpcy5jb2x1bW5GaWx0ZXIgJiYgdGhpcy5jb2x1bW5GaWx0ZXIuZmlsdGVyT3B0aW9ucyB8fCB7fSkgYXMgRmxhdHBpY2tyT3B0aW9uO1xyXG5cclxuICAgIC8vIGdldCBjdXJyZW50IGxvY2FsZSwgaWYgdXNlciBkZWZpbmVkIGEgY3VzdG9tIGxvY2FsZSBqdXN0IHVzZSBvciBnZXQgaXQgdGhlIFRyYW5zbGF0ZSBTZXJ2aWNlIGlmIGl0IGV4aXN0IGVsc2UganVzdCB1c2UgRW5nbGlzaFxyXG4gICAgbGV0IGN1cnJlbnRMb2NhbGUgPSAodXNlckZpbHRlck9wdGlvbnMgJiYgdXNlckZpbHRlck9wdGlvbnMubG9jYWxlKSB8fCAodGhpcy50cmFuc2xhdGUgJiYgdGhpcy50cmFuc2xhdGUuY3VycmVudExhbmcpIHx8IHRoaXMuZ3JpZE9wdGlvbnMubG9jYWxlIHx8ICdlbic7XHJcbiAgICBpZiAoY3VycmVudExvY2FsZSAmJiBjdXJyZW50TG9jYWxlLmxlbmd0aCA+IDIpIHtcclxuICAgICAgY3VycmVudExvY2FsZSA9IGN1cnJlbnRMb2NhbGUuc3Vic3RyaW5nKDAsIDIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGlmIHdlIGFyZSBwcmVsb2FkaW5nIHNlYXJjaFRlcm1zLCB3ZSdsbCBrZWVwIHRoZW0gZm9yIHJlZmVyZW5jZVxyXG4gICAgaWYgKHNlYXJjaFRlcm0pIHtcclxuICAgICAgdGhpcy5fY3VycmVudERhdGUgPSBzZWFyY2hUZXJtIGFzIERhdGU7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcGlja2VyT3B0aW9uczogRmxhdHBpY2tyT3B0aW9uID0ge1xyXG4gICAgICBkZWZhdWx0RGF0ZTogKHNlYXJjaFRlcm0gYXMgc3RyaW5nKSB8fCAnJyxcclxuICAgICAgYWx0SW5wdXQ6IHRydWUsXHJcbiAgICAgIGFsdEZvcm1hdDogb3V0cHV0Rm9ybWF0LFxyXG4gICAgICBkYXRlRm9ybWF0OiBpbnB1dEZvcm1hdCxcclxuICAgICAgd3JhcDogdHJ1ZSxcclxuICAgICAgY2xvc2VPblNlbGVjdDogdHJ1ZSxcclxuICAgICAgbG9jYWxlOiAoY3VycmVudExvY2FsZSAhPT0gJ2VuJykgPyB0aGlzLmxvYWRGbGF0cGlja3JMb2NhbGUoY3VycmVudExvY2FsZSkgOiAnZW4nLFxyXG4gICAgICBvbkNoYW5nZTogKHNlbGVjdGVkRGF0ZXM6IERhdGVbXSB8IERhdGUsIGRhdGVTdHI6IHN0cmluZykgPT4ge1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRWYWx1ZSA9IGRhdGVTdHI7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudERhdGUgPSBBcnJheS5pc0FycmF5KHNlbGVjdGVkRGF0ZXMpICYmIHNlbGVjdGVkRGF0ZXNbMF07XHJcblxyXG4gICAgICAgIC8vIHdoZW4gdXNpbmcgdGhlIHRpbWUgcGlja2VyLCB3ZSBjYW4gc2ltdWxhdGUgYSBrZXl1cCBldmVudCB0byBhdm9pZCBtdWx0aXBsZSBiYWNrZW5kIHJlcXVlc3RcclxuICAgICAgICAvLyBzaW5jZSBiYWNrZW5kIHJlcXVlc3QgYXJlIG9ubHkgZXhlY3V0ZWQgYWZ0ZXIgdXNlciBzdGFydCB0eXBpbmcsIGNoYW5naW5nIHRoZSB0aW1lIHNob3VsZCBiZSB0cmVhdGVkIHRoZSBzYW1lIHdheVxyXG4gICAgICAgIGxldCBjdXN0b21FdmVudDogQ3VzdG9tRXZlbnQgfCB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKHBpY2tlck9wdGlvbnMuZW5hYmxlVGltZSkge1xyXG4gICAgICAgICAgY3VzdG9tRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2tleXVwJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMub25UcmlnZ2VyRXZlbnQoY3VzdG9tRXZlbnQpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIGFkZCB0aGUgdGltZSBwaWNrZXIgd2hlbiBmb3JtYXQgaXMgVVRDIChaKSBvciBoYXMgdGhlICdoJyAobWVhbmluZyBob3VycylcclxuICAgIGlmIChvdXRwdXRGb3JtYXQgJiYgKG91dHB1dEZvcm1hdCA9PT0gJ1onIHx8IG91dHB1dEZvcm1hdC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdoJykpKSB7XHJcbiAgICAgIHBpY2tlck9wdGlvbnMuZW5hYmxlVGltZSA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gbWVyZ2Ugb3B0aW9ucyB3aXRoIG9wdGlvbmFsIHVzZXIncyBjdXN0b20gb3B0aW9uc1xyXG4gICAgdGhpcy5fZmxhdHBpY2tyT3B0aW9ucyA9IHsgLi4ucGlja2VyT3B0aW9ucywgLi4udXNlckZpbHRlck9wdGlvbnMgfTtcclxuXHJcbiAgICBsZXQgcGxhY2Vob2xkZXIgPSAodGhpcy5ncmlkT3B0aW9ucykgPyAodGhpcy5ncmlkT3B0aW9ucy5kZWZhdWx0RmlsdGVyUGxhY2Vob2xkZXIgfHwgJycpIDogJyc7XHJcbiAgICBpZiAodGhpcy5jb2x1bW5GaWx0ZXIgJiYgdGhpcy5jb2x1bW5GaWx0ZXIucGxhY2Vob2xkZXIpIHtcclxuICAgICAgcGxhY2Vob2xkZXIgPSB0aGlzLmNvbHVtbkZpbHRlci5wbGFjZWhvbGRlcjtcclxuICAgIH1cclxuICAgIGNvbnN0ICRmaWx0ZXJJbnB1dEVsbTogYW55ID0gJChgPGRpdiBjbGFzcz1cImZsYXRwaWNrclwiPjxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgZGF0YS1pbnB1dCBwbGFjZWhvbGRlcj1cIiR7cGxhY2Vob2xkZXJ9XCI+PC9kaXY+YCk7XHJcbiAgICB0aGlzLmZsYXRJbnN0YW5jZSA9ICgkZmlsdGVySW5wdXRFbG1bMF0gJiYgdHlwZW9mICRmaWx0ZXJJbnB1dEVsbVswXS5mbGF0cGlja3IgPT09ICdmdW5jdGlvbicpID8gJGZpbHRlcklucHV0RWxtWzBdLmZsYXRwaWNrcih0aGlzLl9mbGF0cGlja3JPcHRpb25zKSA6IEZsYXRwaWNrcigkZmlsdGVySW5wdXRFbG0sIHRoaXMuX2ZsYXRwaWNrck9wdGlvbnMgYXMgdW5rbm93biBhcyBQYXJ0aWFsPEZsYXRwaWNrckJhc2VPcHRpb25zPik7XHJcbiAgICByZXR1cm4gJGZpbHRlcklucHV0RWxtO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBnZXRPcHRpb25WYWx1ZXMoKTogeyBvcGVyYXRvcjogT3BlcmF0b3JTdHJpbmcsIGRlc2NyaXB0aW9uOiBzdHJpbmcgfVtdIHtcclxuICAgIHJldHVybiBbXHJcbiAgICAgIHsgb3BlcmF0b3I6ICcnLCBkZXNjcmlwdGlvbjogJycgfSxcclxuICAgICAgeyBvcGVyYXRvcjogJz0nLCBkZXNjcmlwdGlvbjogdGhpcy5nZXRPdXRwdXRUZXh0KCdFUVVBTF9UTycsICdURVhUX0VRVUFMX1RPJywgJ0VxdWFsIHRvJykgfSxcclxuICAgICAgeyBvcGVyYXRvcjogJzwnLCBkZXNjcmlwdGlvbjogdGhpcy5nZXRPdXRwdXRUZXh0KCdMRVNTX1RIQU4nLCAnVEVYVF9MRVNTX1RIQU4nLCAnTGVzcyB0aGFuJykgfSxcclxuICAgICAgeyBvcGVyYXRvcjogJzw9JywgZGVzY3JpcHRpb246IHRoaXMuZ2V0T3V0cHV0VGV4dCgnTEVTU19USEFOX09SX0VRVUFMX1RPJywgJ1RFWFRfTEVTU19USEFOX09SX0VRVUFMX1RPJywgJ0xlc3MgdGhhbiBvciBlcXVhbCB0bycpIH0sXHJcbiAgICAgIHsgb3BlcmF0b3I6ICc+JywgZGVzY3JpcHRpb246IHRoaXMuZ2V0T3V0cHV0VGV4dCgnR1JFQVRFUl9USEFOJywgJ1RFWFRfR1JFQVRFUl9USEFOJywgJ0dyZWF0ZXIgdGhhbicpIH0sXHJcbiAgICAgIHsgb3BlcmF0b3I6ICc+PScsIGRlc2NyaXB0aW9uOiB0aGlzLmdldE91dHB1dFRleHQoJ0dSRUFURVJfVEhBTl9PUl9FUVVBTF9UTycsICdURVhUX0dSRUFURVJfVEhBTl9PUl9FUVVBTF9UTycsICdHcmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8nKSB9LFxyXG4gICAgICB7IG9wZXJhdG9yOiAnPD4nLCBkZXNjcmlwdGlvbjogdGhpcy5nZXRPdXRwdXRUZXh0KCdOT1RfRVFVQUxfVE8nLCAnVEVYVF9OT1RfRVFVQUxfVE8nLCAnTm90IGVxdWFsIHRvJykgfVxyXG4gICAgXTtcclxuICB9XHJcblxyXG4gIC8qKiBHZXQgTG9jYWxlLCBUcmFuc2xhdGVkIG9yIGEgRGVmYXVsdCBUZXh0IGlmIGZpcnN0IHR3byBhcmVuJ3QgZGV0ZWN0ZWQgKi9cclxuICBwcml2YXRlIGdldE91dHB1dFRleHQodHJhbnNsYXRpb25LZXk6IHN0cmluZywgbG9jYWxlVGV4dDogc3RyaW5nLCBkZWZhdWx0VGV4dDogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgIGlmICh0aGlzLmdyaWRPcHRpb25zICYmIHRoaXMuZ3JpZE9wdGlvbnMuZW5hYmxlVHJhbnNsYXRlICYmIHRoaXMudHJhbnNsYXRlICYmIHRoaXMudHJhbnNsYXRlLmluc3RhbnQpIHtcclxuICAgICAgY29uc3QgdHJhbnNsYXRpb25QcmVmaXggPSBnZXRUcmFuc2xhdGlvblByZWZpeCh0aGlzLmdyaWRPcHRpb25zKTtcclxuICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlLmluc3RhbnQoYCR7dHJhbnNsYXRpb25QcmVmaXh9JHt0cmFuc2xhdGlvbktleX1gKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLmxvY2FsZXMgJiYgdGhpcy5sb2NhbGVzW2xvY2FsZVRleHRdIHx8IGRlZmF1bHRUZXh0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIHRoZSBET00gZWxlbWVudFxyXG4gICAqL1xyXG4gIHByaXZhdGUgY3JlYXRlRG9tRWxlbWVudChzZWFyY2hUZXJtPzogU2VhcmNoVGVybSkge1xyXG4gICAgY29uc3QgZmllbGRJZCA9IHRoaXMuY29sdW1uRGVmICYmIHRoaXMuY29sdW1uRGVmLmlkO1xyXG4gICAgY29uc3QgJGhlYWRlckVsbSA9IHRoaXMuZ3JpZC5nZXRIZWFkZXJSb3dDb2x1bW4oZmllbGRJZCk7XHJcbiAgICAkKCRoZWFkZXJFbG0pLmVtcHR5KCk7XHJcblxyXG4gICAgLy8gY3JlYXRlIHRoZSBET00gU2VsZWN0IGRyb3Bkb3duIGZvciB0aGUgT3BlcmF0b3JcclxuICAgIGNvbnN0IHNlbGVjdE9wZXJhdG9ySHRtbFN0cmluZyA9IGJ1aWxkU2VsZWN0T3BlcmF0b3JIdG1sU3RyaW5nKHRoaXMuZ2V0T3B0aW9uVmFsdWVzKCkpO1xyXG4gICAgdGhpcy4kc2VsZWN0T3BlcmF0b3JFbG0gPSAkKHNlbGVjdE9wZXJhdG9ySHRtbFN0cmluZyk7XHJcbiAgICB0aGlzLiRmaWx0ZXJJbnB1dEVsbSA9IHRoaXMuYnVpbGREYXRlUGlja2VySW5wdXQoc2VhcmNoVGVybSk7XHJcbiAgICBjb25zdCAkZmlsdGVyQ29udGFpbmVyRWxtID0gJChgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAgc2VhcmNoLWZpbHRlciBmaWx0ZXItJHtmaWVsZElkfVwiPjwvZGl2PmApO1xyXG4gICAgY29uc3QgJGNvbnRhaW5lcklucHV0R3JvdXAgPSAkKGA8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXAgZmxhdHBpY2tyXCI+PC9kaXY+YCk7XHJcbiAgICBjb25zdCAkb3BlcmF0b3JJbnB1dEdyb3VwQWRkb24gPSAkKGA8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXAtYWRkb24gaW5wdXQtZ3JvdXAtcHJlcGVuZCBvcGVyYXRvclwiPjwvZGl2PmApO1xyXG5cclxuICAgIC8qIHRoZSBET00gZWxlbWVudCBmaW5hbCBzdHJ1Y3R1cmUgd2lsbCBiZVxyXG4gICAgICA8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXBcIj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXAtYWRkb24gaW5wdXQtZ3JvdXAtcHJlcGVuZCBvcGVyYXRvclwiPlxyXG4gICAgICAgICAgPHNlbGVjdCBjbGFzcz1cImZvcm0tY29udHJvbFwiPjwvc2VsZWN0PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDxkaXYgY2xhc3M9ZmxhdHBpY2tyPlxyXG4gICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBkYXRhLWlucHV0PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICA8L2Rpdj5cclxuICAgICovXHJcbiAgICAkb3BlcmF0b3JJbnB1dEdyb3VwQWRkb24uYXBwZW5kKHRoaXMuJHNlbGVjdE9wZXJhdG9yRWxtKTtcclxuICAgICRjb250YWluZXJJbnB1dEdyb3VwLmFwcGVuZCgkb3BlcmF0b3JJbnB1dEdyb3VwQWRkb24pO1xyXG4gICAgJGNvbnRhaW5lcklucHV0R3JvdXAuYXBwZW5kKHRoaXMuJGZpbHRlcklucHV0RWxtKTtcclxuXHJcbiAgICAvLyBjcmVhdGUgdGhlIERPTSBlbGVtZW50ICYgYWRkIGFuIElEIGFuZCBmaWx0ZXIgY2xhc3NcclxuICAgICRmaWx0ZXJDb250YWluZXJFbG0uYXBwZW5kKCRjb250YWluZXJJbnB1dEdyb3VwKTtcclxuICAgIHRoaXMuJGZpbHRlcklucHV0RWxtLmRhdGEoJ2NvbHVtbklkJywgZmllbGRJZCk7XHJcblxyXG4gICAgaWYgKHRoaXMub3BlcmF0b3IpIHtcclxuICAgICAgY29uc3Qgb3BlcmF0b3JTaG9ydGhhbmQgPSBtYXBPcGVyYXRvclRvU2hvcnRoYW5kRGVzaWduYXRpb24odGhpcy5vcGVyYXRvcik7XHJcbiAgICAgIHRoaXMuJHNlbGVjdE9wZXJhdG9yRWxtLnZhbChvcGVyYXRvclNob3J0aGFuZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaWYgdGhlcmUncyBhIHNlYXJjaCB0ZXJtLCB3ZSB3aWxsIGFkZCB0aGUgXCJmaWxsZWRcIiBjbGFzcyBmb3Igc3R5bGluZyBwdXJwb3Nlc1xyXG4gICAgaWYgKHNlYXJjaFRlcm0gJiYgc2VhcmNoVGVybSAhPT0gJycpIHtcclxuICAgICAgdGhpcy4kZmlsdGVySW5wdXRFbG0uYWRkQ2xhc3MoJ2ZpbGxlZCcpO1xyXG4gICAgICB0aGlzLl9jdXJyZW50RGF0ZSA9IHNlYXJjaFRlcm0gYXMgRGF0ZTtcclxuICAgICAgdGhpcy5fY3VycmVudFZhbHVlID0gc2VhcmNoVGVybSBhcyBzdHJpbmc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYXBwZW5kIHRoZSBuZXcgRE9NIGVsZW1lbnQgdG8gdGhlIGhlYWRlciByb3dcclxuICAgIGlmICgkZmlsdGVyQ29udGFpbmVyRWxtICYmIHR5cGVvZiAkZmlsdGVyQ29udGFpbmVyRWxtLmFwcGVuZFRvID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICRmaWx0ZXJDb250YWluZXJFbG0uYXBwZW5kVG8oJGhlYWRlckVsbSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICRmaWx0ZXJDb250YWluZXJFbG07XHJcbiAgfVxyXG5cclxuICAvKiogTG9hZCBhIGRpZmZlcmVudCBzZXQgb2YgbG9jYWxlcyBmb3IgRmxhdHBpY2tyIHRvIGJlIGxvY2FsaXplZCAqL1xyXG4gIHByaXZhdGUgbG9hZEZsYXRwaWNrckxvY2FsZShsYW5ndWFnZTogc3RyaW5nKSB7XHJcbiAgICBsZXQgbG9jYWxlcyA9ICdlbic7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKGxhbmd1YWdlICE9PSAnZW4nKSB7XHJcbiAgICAgICAgLy8gY2hhbmdlIGxvY2FsZSBpZiBuZWVkZWQsIEZsYXRwaWNrciByZWZlcmVuY2U6IGh0dHBzOi8vY2htbG4uZ2l0aHViLmlvL2ZsYXRwaWNrci9sb2NhbGl6YXRpb24vXHJcbiAgICAgICAgY29uc3QgbG9jYWxlRGVmYXVsdDogYW55ID0gcmVxdWlyZShgZmxhdHBpY2tyL2Rpc3QvbDEwbi8ke2xhbmd1YWdlfS5qc2ApLmRlZmF1bHQ7XHJcbiAgICAgICAgbG9jYWxlcyA9IChsb2NhbGVEZWZhdWx0ICYmIGxvY2FsZURlZmF1bHRbbGFuZ3VhZ2VdKSA/IGxvY2FsZURlZmF1bHRbbGFuZ3VhZ2VdIDogJ2VuJztcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBjb25zb2xlLndhcm4oYFtBbmd1bGFyLVNsaWNrZ3JpZCAtIENvbXBvdW5kRGF0ZSBGaWx0ZXJdIEl0IHNlZW1zIHRoYXQgXCIke2xhbmd1YWdlfVwiIGlzIG5vdCBhIGxvY2FsZSBzdXBwb3J0ZWQgYnkgRmxhdHBpY2tyLCB3ZSB3aWxsIHVzZSBcImVuXCIgaW5zdGVhZC4gYFxyXG4gICAgICAgICsgYFRvIGF2b2lkIHNlZWluZyB0aGlzIG1lc3NhZ2UsIHlvdSBjYW4gc3BlY2lmaWNhbGx5IHNldCBcImZpbHRlcjogeyBmaWx0ZXJPcHRpb25zOiB7IGxvY2FsZTogJ2VuJyB9IH1cIiBpbiB5b3VyIGNvbHVtbiBkZWZpbml0aW9uLmApO1xyXG4gICAgICByZXR1cm4gJ2VuJztcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhbGVzO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBvblRyaWdnZXJFdmVudChlOiBFdmVudCB8IHVuZGVmaW5lZCkge1xyXG4gICAgaWYgKHRoaXMuX2NsZWFyRmlsdGVyVHJpZ2dlcmVkKSB7XHJcbiAgICAgIHRoaXMuY2FsbGJhY2soZSwgeyBjb2x1bW5EZWY6IHRoaXMuY29sdW1uRGVmLCBjbGVhckZpbHRlclRyaWdnZXJlZDogdGhpcy5fY2xlYXJGaWx0ZXJUcmlnZ2VyZWQsIHNob3VsZFRyaWdnZXJRdWVyeTogdGhpcy5fc2hvdWxkVHJpZ2dlclF1ZXJ5IH0pO1xyXG4gICAgICB0aGlzLiRmaWx0ZXJFbG0ucmVtb3ZlQ2xhc3MoJ2ZpbGxlZCcpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3Qgc2VsZWN0ZWRPcGVyYXRvciA9IHRoaXMuJHNlbGVjdE9wZXJhdG9yRWxtLmZpbmQoJ29wdGlvbjpzZWxlY3RlZCcpLnZhbCgpO1xyXG4gICAgICAodGhpcy5fY3VycmVudFZhbHVlKSA/IHRoaXMuJGZpbHRlckVsbS5hZGRDbGFzcygnZmlsbGVkJykgOiB0aGlzLiRmaWx0ZXJFbG0ucmVtb3ZlQ2xhc3MoJ2ZpbGxlZCcpO1xyXG4gICAgICB0aGlzLmNhbGxiYWNrKGUsIHsgY29sdW1uRGVmOiB0aGlzLmNvbHVtbkRlZiwgc2VhcmNoVGVybXM6ICh0aGlzLl9jdXJyZW50VmFsdWUgPyBbdGhpcy5fY3VycmVudFZhbHVlXSA6IG51bGwpLCBvcGVyYXRvcjogc2VsZWN0ZWRPcGVyYXRvciB8fCAnJywgc2hvdWxkVHJpZ2dlclF1ZXJ5OiB0aGlzLl9zaG91bGRUcmlnZ2VyUXVlcnkgfSk7XHJcbiAgICB9XHJcbiAgICAvLyByZXNldCBib3RoIGZsYWdzIGZvciBuZXh0IHVzZVxyXG4gICAgdGhpcy5fY2xlYXJGaWx0ZXJUcmlnZ2VyZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuX3Nob3VsZFRyaWdnZXJRdWVyeSA9IHRydWU7XHJcbiAgfVxyXG59XHJcbiJdfQ==