import { TranslateService } from '@ngx-translate/core';
import * as DOMPurify_ from 'dompurify';
const DOMPurify = DOMPurify_; // patch to fix rollup to work
import { Constants } from '../constants';
import { FieldType, } from './../models/index';
import { CollectionService } from '../services/index';
import { charArraysEqual, findOrDefault, getDescendantProperty, getTranslationPrefix, htmlEncode, setDeepValue } from '../services/utilities';
/**
 * Slickgrid editor class for multiple/single select lists
 */
export class SelectEditor {
    constructor(args, isMultipleSelect) {
        this.args = args;
        this.isMultipleSelect = isMultipleSelect;
        /** Observable Subscriptions */
        this._subscriptions = [];
        // flag to signal that the editor is destroying itself, helps prevent
        // commit changes from being called twice and erroring
        this._destroying = false;
        if (!args) {
            throw new Error('[Angular-SlickGrid] Something is wrong with this grid, an Editor must always have valid arguments.');
        }
        this.grid = args.grid;
        this.gridOptions = (this.grid.getOptions() || {});
        const options = this.gridOptions || this.args.column.params || {};
        if (options && options.i18n instanceof TranslateService) {
            this._translate = options.i18n;
        }
        // get locales provided by user in main file or else use default English locales via the Constants
        this._locales = this.gridOptions.locales || Constants.locales;
        // provide the name attribute to the DOM element which will be needed to auto-adjust drop position (dropup / dropdown)
        const fieldId = this.columnDef && this.columnDef.id;
        this.elementName = `editor-${fieldId}`;
        const libOptions = {
            autoAdjustDropHeight: true,
            autoAdjustDropPosition: true,
            autoAdjustDropWidthByTextSize: true,
            container: 'body',
            filter: false,
            maxHeight: 275,
            name: this.elementName,
            single: true,
            textTemplate: ($elm) => {
                // render HTML code or not, by default it is sanitized and won't be rendered
                const isRenderHtmlEnabled = this.columnDef && this.columnDef.internalColumnEditor && this.columnDef.internalColumnEditor.enableRenderHtml || false;
                return isRenderHtmlEnabled ? $elm.text() : $elm.html();
            },
            onClose: () => this.save(),
        };
        if (isMultipleSelect) {
            libOptions.single = false;
            libOptions.addTitle = true;
            libOptions.okButton = true;
            libOptions.selectAllDelimiter = ['', ''];
            if (this._translate && this._translate.instant && this._translate.currentLang) {
                const translationPrefix = getTranslationPrefix(this.gridOptions);
                libOptions.countSelected = this._translate.instant(`${translationPrefix}X_OF_Y_SELECTED`);
                libOptions.allSelected = this._translate.instant(`${translationPrefix}ALL_SELECTED`);
                libOptions.selectAllText = this._translate.instant(`${translationPrefix}SELECT_ALL`);
                libOptions.okButtonText = this._translate.instant(`${translationPrefix}OK`);
            }
            else {
                libOptions.countSelected = this._locales && this._locales.TEXT_X_OF_Y_SELECTED;
                libOptions.allSelected = this._locales && this._locales.TEXT_ALL_SELECTED;
                libOptions.selectAllText = this._locales && this._locales.TEXT_SELECT_ALL;
                libOptions.okButtonText = this._locales && this._locales.TEXT_OK;
            }
        }
        // assign the multiple select lib options
        this.defaultOptions = libOptions;
        this.init();
    }
    /** Get the Collection */
    get collection() {
        return this.columnDef && this.columnDef.internalColumnEditor.collection || [];
    }
    /** Getter for the Collection Options */
    get collectionOptions() {
        return this.columnDef && this.columnDef.internalColumnEditor && this.columnDef.internalColumnEditor.collectionOptions;
    }
    /** Get Column Definition object */
    get columnDef() {
        return this.args && this.args.column;
    }
    /** Get Column Editor object */
    get columnEditor() {
        return this.columnDef && this.columnDef.internalColumnEditor;
    }
    /** Get the Editor DOM Element */
    get editorDomElement() {
        return this.$editorElm;
    }
    /** Getter for the Custom Structure if exist */
    get customStructure() {
        return this.columnDef && this.columnDef.internalColumnEditor && this.columnDef.internalColumnEditor.customStructure;
    }
    get hasAutoCommitEdit() {
        return this.grid.getOptions().autoCommitEdit;
    }
    /**
     * The current selected values (multiple select) from the collection
     */
    get currentValues() {
        const elmValue = this.$editorElm.val();
        // collection of strings, just return the filtered string that are equals
        if (this.collection.every(x => typeof x === 'string')) {
            return this.collection.filter(c => elmValue.indexOf(c.toString()) !== -1);
        }
        // collection of label/value pair
        const separatorBetweenLabels = this.collectionOptions && this.collectionOptions.separatorBetweenTextLabels || '';
        const isIncludingPrefixSuffix = this.collectionOptions && this.collectionOptions.includePrefixSuffixToSelectedValues || false;
        return this.collection
            .filter(c => elmValue.indexOf(c.hasOwnProperty(this.valueName) && c[this.valueName] !== null && c[this.valueName].toString()) !== -1)
            .map(c => {
            const labelText = c[this.valueName];
            let prefixText = c[this.labelPrefixName] || '';
            let suffixText = c[this.labelSuffixName] || '';
            // when it's a complex object, then pull the object name only, e.g.: "user.firstName" => "user"
            const fieldName = this.columnDef && this.columnDef.field;
            // is the field a complex object, "address.streetNumber"
            const isComplexObject = fieldName && fieldName.indexOf('.') > 0;
            if (isComplexObject && typeof c === 'object') {
                return c;
            }
            // also translate prefix/suffix if enableTranslateLabel is true and text is a string
            prefixText = (this.enableTranslateLabel && prefixText && typeof prefixText === 'string') ? this._translate.instant(prefixText || ' ') : prefixText;
            suffixText = (this.enableTranslateLabel && suffixText && typeof suffixText === 'string') ? this._translate.instant(suffixText || ' ') : suffixText;
            if (isIncludingPrefixSuffix) {
                const tmpOptionArray = [prefixText, labelText, suffixText].filter((text) => text); // add to a temp array for joining purpose and filter out empty text
                return tmpOptionArray.join(separatorBetweenLabels);
            }
            return labelText;
        });
    }
    /**
     * The current selected values (single select) from the collection
     */
    get currentValue() {
        const elmValue = this.$editorElm.val();
        // collection of strings, just return the filtered string that are equals
        if (this.collection.every(x => typeof x === 'string')) {
            return findOrDefault(this.collection, (c) => c.toString() === elmValue);
        }
        // collection of label/value pair
        const separatorBetweenLabels = this.collectionOptions && this.collectionOptions.separatorBetweenTextLabels || '';
        const isIncludingPrefixSuffix = this.collectionOptions && this.collectionOptions.includePrefixSuffixToSelectedValues || false;
        const itemFound = findOrDefault(this.collection, (c) => c.hasOwnProperty(this.valueName) && c[this.valueName] !== null && c[this.valueName].toString() === elmValue);
        // is the field a complex object, "address.streetNumber"
        const fieldName = this.columnDef && this.columnDef.field;
        const isComplexObject = fieldName && fieldName.indexOf('.') > 0;
        if (isComplexObject && typeof itemFound === 'object') {
            return itemFound;
        }
        else if (itemFound && itemFound.hasOwnProperty(this.valueName)) {
            const labelText = itemFound[this.valueName];
            if (isIncludingPrefixSuffix) {
                let prefixText = itemFound[this.labelPrefixName] || '';
                let suffixText = itemFound[this.labelSuffixName] || '';
                // also translate prefix/suffix if enableTranslateLabel is true and text is a string
                prefixText = (this.enableTranslateLabel && prefixText && typeof prefixText === 'string') ? this._translate.instant(prefixText || ' ') : prefixText;
                suffixText = (this.enableTranslateLabel && suffixText && typeof suffixText === 'string') ? this._translate.instant(suffixText || ' ') : suffixText;
                // add to a temp array for joining purpose and filter out empty text
                const tmpOptionArray = [prefixText, labelText, suffixText].filter((text) => text);
                return tmpOptionArray.join(separatorBetweenLabels);
            }
            return labelText;
        }
        return '';
    }
    /** Get the Validator function, can be passed in Editor property or Column Definition */
    get validator() {
        return this.columnEditor.validator || this.columnDef.validator;
    }
    init() {
        if (!this.columnDef || !this.columnDef.internalColumnEditor || (!this.columnDef.internalColumnEditor.collection && !this.columnDef.internalColumnEditor.collectionAsync)) {
            throw new Error(`[Angular-SlickGrid] You need to pass a "collection" (or "collectionAsync") inside Column Definition Editor for the MultipleSelect/SingleSelect Editor to work correctly.
      Also each option should include a value/label pair (or value/labelKey when using Locale).
      For example: { editor: { collection: [{ value: true, label: 'True' },{ value: false, label: 'False'}] } }`);
        }
        this._collectionService = new CollectionService(this._translate);
        this.enableTranslateLabel = (this.columnDef.internalColumnEditor.enableTranslateLabel) ? this.columnDef.internalColumnEditor.enableTranslateLabel : false;
        this.labelName = this.customStructure && this.customStructure.label || 'label';
        this.labelPrefixName = this.customStructure && this.customStructure.labelPrefix || 'labelPrefix';
        this.labelSuffixName = this.customStructure && this.customStructure.labelSuffix || 'labelSuffix';
        this.optionLabel = this.customStructure && this.customStructure.optionLabel || 'value';
        this.valueName = this.customStructure && this.customStructure.value || 'value';
        if (this.enableTranslateLabel && (!this._translate || typeof this._translate.instant !== 'function')) {
            throw new Error('[Angular-Slickgrid] requires "ngx-translate" to be installed and configured when the grid option "enableTranslate" is enabled.');
        }
        // always render the Select (dropdown) DOM element, even if user passed a "collectionAsync",
        // if that is the case, the Select will simply be without any options but we still have to render it (else SlickGrid would throw an error)
        this.renderDomElement(this.collection);
    }
    getValue() {
        return (this.isMultipleSelect) ? this.currentValues : this.currentValue;
    }
    setValue(value) {
        if (this.isMultipleSelect && Array.isArray(value)) {
            this.loadMultipleValues(value);
        }
        else {
            this.loadSingleValue(value);
        }
    }
    hide() {
        if (this.$editorElm && typeof this.$editorElm.multipleSelect === 'function') {
            this.$editorElm.multipleSelect('close');
        }
    }
    show() {
        if (this.$editorElm && typeof this.$editorElm.multipleSelect === 'function') {
            this.$editorElm.multipleSelect('open');
        }
    }
    applyValue(item, state) {
        const fieldName = this.columnDef && this.columnDef.field;
        const fieldType = this.columnDef && this.columnDef.type;
        let newValue = state;
        // when the provided user defined the column field type as a possible number then try parsing the state value as that
        if (fieldType === FieldType.number || fieldType === FieldType.integer || fieldType === FieldType.boolean) {
            newValue = parseFloat(state);
        }
        // when set as a multiple selection, we can assume that the 3rd party lib multiple-select will return a CSV string
        // we need to re-split that into an array to be the same as the original column
        if (this.isMultipleSelect && typeof state === 'string' && state.indexOf(',') >= 0) {
            newValue = state.split(',');
        }
        // is the field a complex object, "user.address.streetNumber"
        const isComplexObject = fieldName && fieldName.indexOf('.') > 0;
        // validate the value before applying it (if not valid we'll set an empty string)
        const validation = this.validate(newValue);
        newValue = (validation && validation.valid) ? newValue : '';
        // set the new value to the item datacontext
        if (isComplexObject) {
            // when it's a complex object, user could override the object path (where the editable object is located)
            // else we use the path provided in the Field Column Definition
            const objectPath = this.columnEditor && this.columnEditor.complexObjectPath || fieldName;
            setDeepValue(item, objectPath, newValue);
        }
        else {
            item[fieldName] = newValue;
        }
    }
    destroy() {
        this._destroying = true;
        if (this.$editorElm && typeof this.$editorElm.multipleSelect === 'function') {
            this.$editorElm.multipleSelect('destroy');
            this.$editorElm.remove();
            const elementClassName = this.elementName.toString().replace('.', '\\.'); // make sure to escape any dot "." from CSS class to avoid console error
            $(`[name=${elementClassName}].ms-drop`).remove();
            this.$editorElm.remove();
            this.$editorElm = null;
        }
    }
    loadValue(item) {
        const fieldName = this.columnDef && this.columnDef.field;
        if (item && fieldName !== undefined) {
            // is the field a complex object, "address.streetNumber"
            const isComplexObject = fieldName && fieldName.indexOf('.') > 0;
            // when it's a complex object, user could override the object path (where the editable object is located)
            // else we use the path provided in the Field Column Definition
            const objectPath = this.columnEditor && this.columnEditor.complexObjectPath || fieldName;
            const currentValue = (isComplexObject) ? getDescendantProperty(item, objectPath) : item[fieldName];
            const value = (isComplexObject && currentValue.hasOwnProperty(this.valueName)) ? currentValue[this.valueName] : currentValue;
            if (this.isMultipleSelect && Array.isArray(value)) {
                this.loadMultipleValues(value);
            }
            else {
                this.loadSingleValue(value);
            }
            this.refresh();
        }
    }
    loadMultipleValues(currentValues) {
        // convert to string because that is how the DOM will return these values
        if (Array.isArray(currentValues)) {
            // keep the default values in memory for references
            this.originalValue = currentValues.map((i) => i);
            // compare all the array values but as string type since multiple-select always return string
            const currentStringValues = currentValues.map((i) => i.toString());
            this.$editorElm.find('option').each((i, $e) => {
                $e.selected = (currentStringValues.indexOf($e.value) !== -1);
            });
        }
    }
    loadSingleValue(currentValue) {
        // keep the default value in memory for references
        this.originalValue = typeof currentValue === 'number' ? `${currentValue}` : currentValue;
        this.$editorElm.val(currentValue);
        // make sure the prop exists first
        this.$editorElm.find('option').each((i, $e) => {
            // check equality after converting originalValue to string since the DOM value will always be of type string
            $e.selected = (`${currentValue}` === $e.value);
        });
    }
    save() {
        const validation = this.validate();
        const isValid = (validation && validation.valid) || false;
        if (!this._destroying && this.hasAutoCommitEdit && isValid) {
            // do not use args.commitChanges() as this sets the focus to the next row.
            // also the select list will stay shown when clicking off the grid
            this.grid.getEditorLock().commitCurrentEdit();
        }
        else {
            this.args.commitChanges();
        }
    }
    serializeValue() {
        return (this.isMultipleSelect) ? this.currentValues : this.currentValue;
    }
    focus() {
        if (this.$editorElm && this.$editorElm.multipleSelect) {
            this.$editorElm.multipleSelect('focus');
        }
    }
    isValueChanged() {
        if (this.isMultipleSelect) {
            return !charArraysEqual(this.$editorElm.val(), this.originalValue);
        }
        return this.$editorElm.val() !== this.originalValue;
    }
    validate(inputValue) {
        const isRequired = this.columnEditor.required;
        const elmValue = (inputValue !== undefined) ? inputValue : this.$editorElm && this.$editorElm.val && this.$editorElm.val();
        const errorMsg = this.columnEditor.errorMessage;
        if (this.validator) {
            const value = (inputValue !== undefined) ? inputValue : (this.isMultipleSelect ? this.currentValues : this.currentValue);
            return this.validator(value, this.args);
        }
        // by default the editor is almost always valid (except when it's required but not provided)
        if (isRequired && (elmValue === '' || (Array.isArray(elmValue) && elmValue.length === 0))) {
            return {
                valid: false,
                msg: errorMsg || Constants.VALIDATION_REQUIRED_FIELD
            };
        }
        return {
            valid: true,
            msg: null
        };
    }
    //
    // protected functions
    // ------------------
    /**
     * user might want to filter certain items of the collection
     * @param inputCollection
     * @return outputCollection filtered and/or sorted collection
     */
    filterCollection(inputCollection) {
        let outputCollection = inputCollection;
        // user might want to filter certain items of the collection
        if (this.columnEditor && this.columnEditor.collectionFilterBy) {
            const filterBy = this.columnEditor.collectionFilterBy;
            const filterCollectionBy = this.columnEditor.collectionOptions && this.columnEditor.collectionOptions.filterResultAfterEachPass || null;
            outputCollection = this._collectionService.filterCollection(outputCollection, filterBy, filterCollectionBy);
        }
        return outputCollection;
    }
    /**
     * user might want to sort the collection in a certain way
     * @param inputCollection
     * @return outputCollection sorted collection
     */
    sortCollection(inputCollection) {
        let outputCollection = inputCollection;
        // user might want to sort the collection
        if (this.columnDef.internalColumnEditor && this.columnDef.internalColumnEditor.collectionSortBy) {
            const sortBy = this.columnDef.internalColumnEditor.collectionSortBy;
            outputCollection = this._collectionService.sortCollection(this.columnDef, outputCollection, sortBy, this.enableTranslateLabel);
        }
        return outputCollection;
    }
    renderDomElement(inputCollection) {
        if (!Array.isArray(inputCollection) && this.collectionOptions && (this.collectionOptions.collectionInsideObjectProperty || this.collectionOptions.collectionInObjectProperty)) {
            const collectionInsideObjectProperty = this.collectionOptions.collectionInsideObjectProperty || this.collectionOptions.collectionInObjectProperty;
            inputCollection = getDescendantProperty(inputCollection, collectionInsideObjectProperty);
        }
        if (!Array.isArray(inputCollection)) {
            throw new Error('The "collection" passed to the Select Editor is not a valid array.');
        }
        // make a copy of the collection so that we don't impact SelectFilter, this could happen when calling "addBlankEntry" or "addCustomFirstEntry"
        let collection = [];
        if (inputCollection.length > 0) {
            collection = [...inputCollection];
        }
        // user can optionally add a blank entry at the beginning of the collection
        // make sure however that it wasn't added more than once
        if (this.collectionOptions && this.collectionOptions.addBlankEntry && Array.isArray(collection) && collection.length > 0 && collection[0][this.valueName] !== '') {
            collection.unshift(this.createBlankEntry());
        }
        // user can optionally add his own custom entry at the beginning of the collection
        if (this.collectionOptions && this.collectionOptions.addCustomFirstEntry && Array.isArray(collection) && collection.length > 0 && collection[0][this.valueName] !== this.collectionOptions.addCustomFirstEntry[this.valueName]) {
            collection.unshift(this.collectionOptions && this.collectionOptions.addCustomFirstEntry);
        }
        // user can optionally add his own custom entry at the end of the collection
        if (this.collectionOptions && this.collectionOptions.addCustomLastEntry && Array.isArray(collection) && collection.length > 0) {
            const lastCollectionIndex = collection.length - 1;
            if (collection[lastCollectionIndex][this.valueName] !== this.collectionOptions.addCustomLastEntry[this.valueName]) {
                collection.push(this.collectionOptions && this.collectionOptions.addCustomLastEntry);
            }
        }
        let newCollection = collection || [];
        // user might want to filter and/or sort certain items of the collection
        newCollection = this.filterCollection(newCollection);
        newCollection = this.sortCollection(newCollection);
        // step 1, create HTML string template
        const editorTemplate = this.buildTemplateHtmlString(newCollection);
        // step 2, create the DOM Element of the editor
        // also subscribe to the onClose event
        this.createDomElement(editorTemplate);
    }
    buildTemplateHtmlString(collection) {
        let options = '';
        const fieldId = this.columnDef && this.columnDef.id;
        const separatorBetweenLabels = this.collectionOptions && this.collectionOptions.separatorBetweenTextLabels || '';
        const isRenderHtmlEnabled = this.columnDef.internalColumnEditor.enableRenderHtml || false;
        const sanitizedOptions = this.gridOptions && this.gridOptions.sanitizeHtmlOptions || {};
        // collection could be an Array of Strings OR Objects
        if (collection.every(x => typeof x === 'string')) {
            collection.forEach((option) => {
                options += `<option value="${option}" label="${option}">${option}</option>`;
            });
        }
        else {
            // array of objects will require a label/value pair unless a customStructure is passed
            collection.forEach((option) => {
                if (!option || (option[this.labelName] === undefined && option.labelKey === undefined)) {
                    throw new Error(`[select-editor] A collection with value/label (or value/labelKey when using Locale) is required to populate the Select list, for example: { collection: [ { value: '1', label: 'One' } ])`);
                }
                const labelKey = (option.labelKey || option[this.labelName]);
                const labelText = ((option.labelKey || this.enableTranslateLabel) && labelKey) ? this._translate.instant(labelKey || ' ') : labelKey;
                let prefixText = option[this.labelPrefixName] || '';
                let suffixText = option[this.labelSuffixName] || '';
                let optionLabel = option[this.optionLabel] || '';
                if (optionLabel && optionLabel.toString) {
                    optionLabel = optionLabel.toString().replace(/\"/g, '\''); // replace double quotes by single quotes to avoid interfering with regular html
                }
                // also translate prefix/suffix if enableTranslateLabel is true and text is a string
                prefixText = (this.enableTranslateLabel && prefixText && typeof prefixText === 'string') ? this._translate.instant(prefixText || ' ') : prefixText;
                suffixText = (this.enableTranslateLabel && suffixText && typeof suffixText === 'string') ? this._translate.instant(suffixText || ' ') : suffixText;
                optionLabel = (this.enableTranslateLabel && optionLabel && typeof optionLabel === 'string') ? this._translate.instant(optionLabel || ' ') : optionLabel;
                // add to a temp array for joining purpose and filter out empty text
                const tmpOptionArray = [prefixText, labelText, suffixText].filter(text => (text !== undefined && text !== ''));
                let optionText = tmpOptionArray.join(separatorBetweenLabels);
                // if user specifically wants to render html text, he needs to opt-in else it will stripped out by default
                // also, the 3rd party lib will saninitze any html code unless it's encoded, so we'll do that
                if (isRenderHtmlEnabled) {
                    // sanitize any unauthorized html tags like script and others
                    // for the remaining allowed tags we'll permit all attributes
                    const sanitizedText = (DOMPurify.sanitize(optionText, sanitizedOptions) || '').toString();
                    optionText = htmlEncode(sanitizedText);
                }
                // html text of each select option
                let optionValue = option[this.valueName];
                if (optionValue === undefined || optionValue === null) {
                    optionValue = '';
                }
                options += `<option value="${optionValue}" label="${optionLabel}">${optionText}</option>`;
            });
        }
        return `<select id="${this.elementName}" class="ms-filter search-filter editor-${fieldId}" ${this.isMultipleSelect ? 'multiple="multiple"' : ''}>${options}</select>`;
    }
    /** Create a blank entry that can be added to the collection. It will also reuse the same customStructure if need be */
    createBlankEntry() {
        const blankEntry = {
            [this.labelName]: '',
            [this.valueName]: ''
        };
        if (this.labelPrefixName) {
            blankEntry[this.labelPrefixName] = '';
        }
        if (this.labelSuffixName) {
            blankEntry[this.labelSuffixName] = '';
        }
        return blankEntry;
    }
    /** Build the template HTML string */
    createDomElement(editorTemplate) {
        this.$editorElm = $(editorTemplate);
        if (this.$editorElm && typeof this.$editorElm.appendTo === 'function') {
            this.$editorElm.appendTo(this.args.container);
        }
        // add placeholder when found
        const placeholder = this.columnEditor && this.columnEditor.placeholder || '';
        this.defaultOptions.placeholder = placeholder || '';
        if (typeof this.$editorElm.multipleSelect === 'function') {
            const elementOptions = (this.columnDef.internalColumnEditor) ? this.columnDef.internalColumnEditor.elementOptions : {};
            const editorOptions = (this.columnDef && this.columnDef.internalColumnEditor) ? this.columnDef.internalColumnEditor.editorOptions : {};
            this.editorElmOptions = Object.assign({}, this.defaultOptions, elementOptions, editorOptions);
            this.$editorElm = this.$editorElm.multipleSelect(this.editorElmOptions);
            setTimeout(() => this.show());
        }
    }
    // refresh the jquery object because the selected checkboxes were already set
    // prior to this method being called
    refresh() {
        if (typeof this.$editorElm.multipleSelect === 'function') {
            this.$editorElm.multipleSelect('refresh');
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsZWN0RWRpdG9yLmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci1zbGlja2dyaWQvIiwic291cmNlcyI6WyJhcHAvbW9kdWxlcy9hbmd1bGFyLXNsaWNrZ3JpZC9lZGl0b3JzL3NlbGVjdEVkaXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUV2RCxPQUFPLEtBQUssVUFBVSxNQUFNLFdBQVcsQ0FBQztBQUN4QyxNQUFNLFNBQVMsR0FBRyxVQUFVLENBQUMsQ0FBQyw4QkFBOEI7QUFFNUQsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUN6QyxPQUFPLEVBU0wsU0FBUyxHQUtWLE1BQU0sbUJBQW1CLENBQUM7QUFDM0IsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDdEQsT0FBTyxFQUFFLGVBQWUsRUFBRSxhQUFhLEVBQUUscUJBQXFCLEVBQUUsb0JBQW9CLEVBQUUsVUFBVSxFQUFFLFlBQVksRUFBNkIsTUFBTSx1QkFBdUIsQ0FBQztBQUt6Szs7R0FFRztBQUNILE1BQU0sT0FBTyxZQUFZO0lBd0R2QixZQUFzQixJQUFxQixFQUFZLGdCQUFnQjtRQUFqRCxTQUFJLEdBQUosSUFBSSxDQUFpQjtRQUFZLHFCQUFnQixHQUFoQixnQkFBZ0IsQ0FBQTtRQWhCdkUsK0JBQStCO1FBQ3JCLG1CQUFjLEdBQW1CLEVBQUUsQ0FBQztRQUU5QyxxRUFBcUU7UUFDckUsc0RBQXNEO1FBQzVDLGdCQUFXLEdBQUcsS0FBSyxDQUFDO1FBWTVCLElBQUksQ0FBQyxJQUFJLEVBQUU7WUFDVCxNQUFNLElBQUksS0FBSyxDQUFDLG9HQUFvRyxDQUFDLENBQUM7U0FDdkg7UUFDRCxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7UUFDdEIsSUFBSSxDQUFDLFdBQVcsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLElBQUksRUFBRSxDQUFlLENBQUM7UUFDaEUsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLFdBQVcsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDO1FBQ2xFLElBQUksT0FBTyxJQUFJLE9BQU8sQ0FBQyxJQUFJLFlBQVksZ0JBQWdCLEVBQUU7WUFDdkQsSUFBSSxDQUFDLFVBQVUsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDO1NBQ2hDO1FBRUQsa0dBQWtHO1FBQ2xHLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLElBQUksU0FBUyxDQUFDLE9BQU8sQ0FBQztRQUU5RCxzSEFBc0g7UUFDdEgsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLFNBQVMsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQztRQUNwRCxJQUFJLENBQUMsV0FBVyxHQUFHLFVBQVUsT0FBTyxFQUFFLENBQUM7UUFFdkMsTUFBTSxVQUFVLEdBQXlCO1lBQ3ZDLG9CQUFvQixFQUFFLElBQUk7WUFDMUIsc0JBQXNCLEVBQUUsSUFBSTtZQUM1Qiw2QkFBNkIsRUFBRSxJQUFJO1lBQ25DLFNBQVMsRUFBRSxNQUFNO1lBQ2pCLE1BQU0sRUFBRSxLQUFLO1lBQ2IsU0FBUyxFQUFFLEdBQUc7WUFDZCxJQUFJLEVBQUUsSUFBSSxDQUFDLFdBQVc7WUFDdEIsTUFBTSxFQUFFLElBQUk7WUFDWixZQUFZLEVBQUUsQ0FBQyxJQUFJLEVBQUUsRUFBRTtnQkFDckIsNEVBQTRFO2dCQUM1RSxNQUFNLG1CQUFtQixHQUFHLElBQUksQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxvQkFBb0IsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLG9CQUFvQixDQUFDLGdCQUFnQixJQUFJLEtBQUssQ0FBQztnQkFDbkosT0FBTyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDekQsQ0FBQztZQUNELE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFO1NBQzNCLENBQUM7UUFFRixJQUFJLGdCQUFnQixFQUFFO1lBQ3BCLFVBQVUsQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO1lBQzFCLFVBQVUsQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO1lBQzNCLFVBQVUsQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO1lBQzNCLFVBQVUsQ0FBQyxrQkFBa0IsR0FBRyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztZQUV6QyxJQUFJLElBQUksQ0FBQyxVQUFVLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxXQUFXLEVBQUU7Z0JBQzdFLE1BQU0saUJBQWlCLEdBQUcsb0JBQW9CLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO2dCQUNqRSxVQUFVLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLEdBQUcsaUJBQWlCLGlCQUFpQixDQUFDLENBQUM7Z0JBQzFGLFVBQVUsQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsR0FBRyxpQkFBaUIsY0FBYyxDQUFDLENBQUM7Z0JBQ3JGLFVBQVUsQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsR0FBRyxpQkFBaUIsWUFBWSxDQUFDLENBQUM7Z0JBQ3JGLFVBQVUsQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsR0FBRyxpQkFBaUIsSUFBSSxDQUFDLENBQUM7YUFDN0U7aUJBQU07Z0JBQ0wsVUFBVSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUMsUUFBUSxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsb0JBQW9CLENBQUM7Z0JBQy9FLFVBQVUsQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLFFBQVEsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLGlCQUFpQixDQUFDO2dCQUMxRSxVQUFVLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQyxRQUFRLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxlQUFlLENBQUM7Z0JBQzFFLFVBQVUsQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLFFBQVEsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQzthQUNsRTtTQUNGO1FBRUQseUNBQXlDO1FBQ3pDLElBQUksQ0FBQyxjQUFjLEdBQUcsVUFBVSxDQUFDO1FBRWpDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUNkLENBQUM7SUFFRCx5QkFBeUI7SUFDekIsSUFBSSxVQUFVO1FBQ1osT0FBTyxJQUFJLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsb0JBQW9CLENBQUMsVUFBVSxJQUFJLEVBQUUsQ0FBQztJQUNoRixDQUFDO0lBR0Qsd0NBQXdDO0lBQ3hDLElBQUksaUJBQWlCO1FBQ25CLE9BQU8sSUFBSSxDQUFDLFNBQVMsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLG9CQUFvQixJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsb0JBQW9CLENBQUMsaUJBQWlCLENBQUM7SUFDeEgsQ0FBQztJQUVELG1DQUFtQztJQUNuQyxJQUFJLFNBQVM7UUFDWCxPQUFPLElBQUksQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUM7SUFDdkMsQ0FBQztJQUVELCtCQUErQjtJQUMvQixJQUFJLFlBQVk7UUFDZCxPQUFPLElBQUksQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxvQkFBb0IsQ0FBQztJQUMvRCxDQUFDO0lBRUQsaUNBQWlDO0lBQ2pDLElBQUksZ0JBQWdCO1FBQ2xCLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQztJQUN6QixDQUFDO0lBRUQsK0NBQStDO0lBQy9DLElBQWMsZUFBZTtRQUMzQixPQUFPLElBQUksQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxvQkFBb0IsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLG9CQUFvQixDQUFDLGVBQWUsQ0FBQztJQUN0SCxDQUFDO0lBRUQsSUFBSSxpQkFBaUI7UUFDbkIsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDLGNBQWMsQ0FBQztJQUMvQyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUFJLGFBQWE7UUFDZixNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBRXZDLHlFQUF5RTtRQUN6RSxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLEtBQUssUUFBUSxDQUFDLEVBQUU7WUFDckQsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUMzRTtRQUVELGlDQUFpQztRQUNqQyxNQUFNLHNCQUFzQixHQUFHLElBQUksQ0FBQyxpQkFBaUIsSUFBSSxJQUFJLENBQUMsaUJBQWlCLENBQUMsMEJBQTBCLElBQUksRUFBRSxDQUFDO1FBQ2pILE1BQU0sdUJBQXVCLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixJQUFJLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxtQ0FBbUMsSUFBSSxLQUFLLENBQUM7UUFFOUgsT0FBTyxJQUFJLENBQUMsVUFBVTthQUNuQixNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQzthQUNwSSxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUU7WUFDUCxNQUFNLFNBQVMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQ3BDLElBQUksVUFBVSxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksRUFBRSxDQUFDO1lBQy9DLElBQUksVUFBVSxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksRUFBRSxDQUFDO1lBRS9DLCtGQUErRjtZQUMvRixNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDO1lBRXpELHdEQUF3RDtZQUN4RCxNQUFNLGVBQWUsR0FBRyxTQUFTLElBQUksU0FBUyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDaEUsSUFBSSxlQUFlLElBQUksT0FBTyxDQUFDLEtBQUssUUFBUSxFQUFFO2dCQUM1QyxPQUFPLENBQUMsQ0FBQzthQUNWO1lBRUQsb0ZBQW9GO1lBQ3BGLFVBQVUsR0FBRyxDQUFDLElBQUksQ0FBQyxvQkFBb0IsSUFBSSxVQUFVLElBQUksT0FBTyxVQUFVLEtBQUssUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLFVBQVUsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDO1lBQ25KLFVBQVUsR0FBRyxDQUFDLElBQUksQ0FBQyxvQkFBb0IsSUFBSSxVQUFVLElBQUksT0FBTyxVQUFVLEtBQUssUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLFVBQVUsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDO1lBRW5KLElBQUksdUJBQXVCLEVBQUU7Z0JBQzNCLE1BQU0sY0FBYyxHQUFHLENBQUMsVUFBVSxFQUFFLFNBQVMsRUFBRSxVQUFVLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsb0VBQW9FO2dCQUN2SixPQUFPLGNBQWMsQ0FBQyxJQUFJLENBQUMsc0JBQXNCLENBQUMsQ0FBQzthQUNwRDtZQUNELE9BQU8sU0FBUyxDQUFDO1FBQ25CLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQUVEOztPQUVHO0lBQ0gsSUFBSSxZQUFZO1FBQ2QsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUV2Qyx5RUFBeUU7UUFDekUsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxLQUFLLFFBQVEsQ0FBQyxFQUFFO1lBQ3JELE9BQU8sYUFBYSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFNLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsS0FBSyxRQUFRLENBQUMsQ0FBQztTQUM5RTtRQUVELGlDQUFpQztRQUNqQyxNQUFNLHNCQUFzQixHQUFHLElBQUksQ0FBQyxpQkFBaUIsSUFBSSxJQUFJLENBQUMsaUJBQWlCLENBQUMsMEJBQTBCLElBQUksRUFBRSxDQUFDO1FBQ2pILE1BQU0sdUJBQXVCLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixJQUFJLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxtQ0FBbUMsSUFBSSxLQUFLLENBQUM7UUFDOUgsTUFBTSxTQUFTLEdBQUcsYUFBYSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFNLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsUUFBUSxFQUFFLEtBQUssUUFBUSxDQUFDLENBQUM7UUFFMUssd0RBQXdEO1FBQ3hELE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUM7UUFDekQsTUFBTSxlQUFlLEdBQUcsU0FBUyxJQUFJLFNBQVMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRWhFLElBQUksZUFBZSxJQUFJLE9BQU8sU0FBUyxLQUFLLFFBQVEsRUFBRTtZQUNwRCxPQUFPLFNBQVMsQ0FBQztTQUNsQjthQUFNLElBQUksU0FBUyxJQUFJLFNBQVMsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFO1lBQ2hFLE1BQU0sU0FBUyxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7WUFFNUMsSUFBSSx1QkFBdUIsRUFBRTtnQkFDM0IsSUFBSSxVQUFVLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxFQUFFLENBQUM7Z0JBQ3ZELElBQUksVUFBVSxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksRUFBRSxDQUFDO2dCQUV2RCxvRkFBb0Y7Z0JBQ3BGLFVBQVUsR0FBRyxDQUFDLElBQUksQ0FBQyxvQkFBb0IsSUFBSSxVQUFVLElBQUksT0FBTyxVQUFVLEtBQUssUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLFVBQVUsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDO2dCQUNuSixVQUFVLEdBQUcsQ0FBQyxJQUFJLENBQUMsb0JBQW9CLElBQUksVUFBVSxJQUFJLE9BQU8sVUFBVSxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxVQUFVLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQztnQkFFbkosb0VBQW9FO2dCQUNwRSxNQUFNLGNBQWMsR0FBRyxDQUFDLFVBQVUsRUFBRSxTQUFTLEVBQUUsVUFBVSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDbEYsT0FBTyxjQUFjLENBQUMsSUFBSSxDQUFDLHNCQUFzQixDQUFDLENBQUM7YUFDcEQ7WUFFRCxPQUFPLFNBQVMsQ0FBQztTQUNsQjtRQUVELE9BQU8sRUFBRSxDQUFDO0lBQ1osQ0FBQztJQUdELHdGQUF3RjtJQUN4RixJQUFJLFNBQVM7UUFDWCxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDO0lBQ2pFLENBQUM7SUFFRCxJQUFJO1FBQ0YsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLG9CQUFvQixJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLG9CQUFvQixDQUFDLFVBQVUsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsb0JBQW9CLENBQUMsZUFBZSxDQUFDLEVBQUU7WUFDeEssTUFBTSxJQUFJLEtBQUssQ0FBQzs7Z0hBRTBGLENBQUMsQ0FBQztTQUM3RztRQUVELElBQUksQ0FBQyxrQkFBa0IsR0FBRyxJQUFJLGlCQUFpQixDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUNqRSxJQUFJLENBQUMsb0JBQW9CLEdBQUcsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLG9CQUFvQixDQUFDLG9CQUFvQixDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsb0JBQW9CLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztRQUMxSixJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxlQUFlLElBQUksSUFBSSxDQUFDLGVBQWUsQ0FBQyxLQUFLLElBQUksT0FBTyxDQUFDO1FBQy9FLElBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDLGVBQWUsSUFBSSxJQUFJLENBQUMsZUFBZSxDQUFDLFdBQVcsSUFBSSxhQUFhLENBQUM7UUFDakcsSUFBSSxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUMsZUFBZSxJQUFJLElBQUksQ0FBQyxlQUFlLENBQUMsV0FBVyxJQUFJLGFBQWEsQ0FBQztRQUNqRyxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxlQUFlLElBQUksSUFBSSxDQUFDLGVBQWUsQ0FBQyxXQUFXLElBQUksT0FBTyxDQUFDO1FBQ3ZGLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLGVBQWUsSUFBSSxJQUFJLENBQUMsZUFBZSxDQUFDLEtBQUssSUFBSSxPQUFPLENBQUM7UUFFL0UsSUFBSSxJQUFJLENBQUMsb0JBQW9CLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLElBQUksT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sS0FBSyxVQUFVLENBQUMsRUFBRTtZQUNwRyxNQUFNLElBQUksS0FBSyxDQUFDLGdJQUFnSSxDQUFDLENBQUM7U0FDbko7UUFFRCw0RkFBNEY7UUFDNUYsMElBQTBJO1FBQzFJLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDekMsQ0FBQztJQUVELFFBQVE7UUFDTixPQUFPLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUM7SUFDMUUsQ0FBQztJQUVELFFBQVEsQ0FBQyxLQUFrQjtRQUN6QixJQUFJLElBQUksQ0FBQyxnQkFBZ0IsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ2pELElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUNoQzthQUFNO1lBQ0wsSUFBSSxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUM3QjtJQUNILENBQUM7SUFFRCxJQUFJO1FBQ0YsSUFBSSxJQUFJLENBQUMsVUFBVSxJQUFJLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxjQUFjLEtBQUssVUFBVSxFQUFFO1lBQzNFLElBQUksQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1NBQ3pDO0lBQ0gsQ0FBQztJQUVELElBQUk7UUFDRixJQUFJLElBQUksQ0FBQyxVQUFVLElBQUksT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLGNBQWMsS0FBSyxVQUFVLEVBQUU7WUFDM0UsSUFBSSxDQUFDLFVBQVUsQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDeEM7SUFDSCxDQUFDO0lBRUQsVUFBVSxDQUFDLElBQVMsRUFBRSxLQUFVO1FBQzlCLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUM7UUFDekQsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLFNBQVMsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQztRQUN4RCxJQUFJLFFBQVEsR0FBRyxLQUFLLENBQUM7UUFFckIscUhBQXFIO1FBQ3JILElBQUksU0FBUyxLQUFLLFNBQVMsQ0FBQyxNQUFNLElBQUksU0FBUyxLQUFLLFNBQVMsQ0FBQyxPQUFPLElBQUksU0FBUyxLQUFLLFNBQVMsQ0FBQyxPQUFPLEVBQUU7WUFDeEcsUUFBUSxHQUFHLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUM5QjtRQUVELGtIQUFrSDtRQUNsSCwrRUFBK0U7UUFDL0UsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ2pGLFFBQVEsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQzdCO1FBRUQsNkRBQTZEO1FBQzdELE1BQU0sZUFBZSxHQUFHLFNBQVMsSUFBSSxTQUFTLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUVoRSxpRkFBaUY7UUFDakYsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUMzQyxRQUFRLEdBQUcsQ0FBQyxVQUFVLElBQUksVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUU1RCw0Q0FBNEM7UUFDNUMsSUFBSSxlQUFlLEVBQUU7WUFDbkIseUdBQXlHO1lBQ3pHLCtEQUErRDtZQUMvRCxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsWUFBWSxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsaUJBQWlCLElBQUksU0FBUyxDQUFDO1lBQ3pGLFlBQVksQ0FBQyxJQUFJLEVBQUUsVUFBVSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1NBQzFDO2FBQU07WUFDTCxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsUUFBUSxDQUFDO1NBQzVCO0lBQ0gsQ0FBQztJQUVELE9BQU87UUFDTCxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQztRQUN4QixJQUFJLElBQUksQ0FBQyxVQUFVLElBQUksT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLGNBQWMsS0FBSyxVQUFVLEVBQUU7WUFDM0UsSUFBSSxDQUFDLFVBQVUsQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDMUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsQ0FBQztZQUN6QixNQUFNLGdCQUFnQixHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxFQUFFLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLHdFQUF3RTtZQUNsSixDQUFDLENBQUMsU0FBUyxnQkFBZ0IsV0FBVyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUM7WUFDakQsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsQ0FBQztZQUN6QixJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQztTQUN4QjtJQUNILENBQUM7SUFFRCxTQUFTLENBQUMsSUFBUztRQUNqQixNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDO1FBRXpELElBQUksSUFBSSxJQUFJLFNBQVMsS0FBSyxTQUFTLEVBQUU7WUFDbkMsd0RBQXdEO1lBQ3hELE1BQU0sZUFBZSxHQUFHLFNBQVMsSUFBSSxTQUFTLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUVoRSx5R0FBeUc7WUFDekcsK0RBQStEO1lBQy9ELE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxZQUFZLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxpQkFBaUIsSUFBSSxTQUFTLENBQUM7WUFDekYsTUFBTSxZQUFZLEdBQUcsQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUMscUJBQXFCLENBQUMsSUFBSSxFQUFFLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDbkcsTUFBTSxLQUFLLEdBQUcsQ0FBQyxlQUFlLElBQUksWUFBWSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDO1lBRTdILElBQUksSUFBSSxDQUFDLGdCQUFnQixJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUU7Z0JBQ2pELElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUNoQztpQkFBTTtnQkFDTCxJQUFJLENBQUMsZUFBZSxDQUFDLEtBQUssQ0FBQyxDQUFDO2FBQzdCO1lBQ0QsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO1NBQ2hCO0lBQ0gsQ0FBQztJQUVELGtCQUFrQixDQUFDLGFBQW9CO1FBQ3JDLHlFQUF5RTtRQUN6RSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLEVBQUU7WUFDaEMsbURBQW1EO1lBQ25ELElBQUksQ0FBQyxhQUFhLEdBQUcsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQU0sRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFFdEQsNkZBQTZGO1lBQzdGLE1BQU0sbUJBQW1CLEdBQUcsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQU0sRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7WUFDeEUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBUyxFQUFFLEVBQU8sRUFBRSxFQUFFO2dCQUN6RCxFQUFFLENBQUMsUUFBUSxHQUFHLENBQUMsbUJBQW1CLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQy9ELENBQUMsQ0FBQyxDQUFDO1NBQ0o7SUFDSCxDQUFDO0lBRUQsZUFBZSxDQUFDLFlBQWlCO1FBQy9CLGtEQUFrRDtRQUNsRCxJQUFJLENBQUMsYUFBYSxHQUFHLE9BQU8sWUFBWSxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxZQUFZLEVBQUUsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDO1FBQ3pGLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBRWxDLGtDQUFrQztRQUNsQyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFTLEVBQUUsRUFBTyxFQUFFLEVBQUU7WUFDekQsNEdBQTRHO1lBQzVHLEVBQUUsQ0FBQyxRQUFRLEdBQUcsQ0FBQyxHQUFHLFlBQVksRUFBRSxLQUFLLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNqRCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRCxJQUFJO1FBQ0YsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ25DLE1BQU0sT0FBTyxHQUFHLENBQUMsVUFBVSxJQUFJLFVBQVUsQ0FBQyxLQUFLLENBQUMsSUFBSSxLQUFLLENBQUM7UUFFMUQsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLElBQUksSUFBSSxDQUFDLGlCQUFpQixJQUFJLE9BQU8sRUFBRTtZQUMxRCwwRUFBMEU7WUFDMUUsa0VBQWtFO1lBQ2xFLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztTQUMvQzthQUFNO1lBQ0wsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztTQUMzQjtJQUNILENBQUM7SUFFRCxjQUFjO1FBQ1osT0FBTyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDO0lBQzFFLENBQUM7SUFFRCxLQUFLO1FBQ0gsSUFBSSxJQUFJLENBQUMsVUFBVSxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsY0FBYyxFQUFFO1lBQ3JELElBQUksQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1NBQ3pDO0lBQ0gsQ0FBQztJQUVELGNBQWM7UUFDWixJQUFJLElBQUksQ0FBQyxnQkFBZ0IsRUFBRTtZQUN6QixPQUFPLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxFQUFFLEVBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1NBQ3BFO1FBQ0QsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsRUFBRSxLQUFLLElBQUksQ0FBQyxhQUFhLENBQUM7SUFDdEQsQ0FBQztJQUVELFFBQVEsQ0FBQyxVQUFnQjtRQUN2QixNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQztRQUM5QyxNQUFNLFFBQVEsR0FBRyxDQUFDLFVBQVUsS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDM0gsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxZQUFZLENBQUM7UUFFaEQsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFO1lBQ2xCLE1BQU0sS0FBSyxHQUFHLENBQUMsVUFBVSxLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7WUFDekgsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDekM7UUFFRCw0RkFBNEY7UUFDNUYsSUFBSSxVQUFVLElBQUksQ0FBQyxRQUFRLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsSUFBSSxRQUFRLENBQUMsTUFBTSxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUU7WUFDekYsT0FBTztnQkFDTCxLQUFLLEVBQUUsS0FBSztnQkFDWixHQUFHLEVBQUUsUUFBUSxJQUFJLFNBQVMsQ0FBQyx5QkFBeUI7YUFDckQsQ0FBQztTQUNIO1FBRUQsT0FBTztZQUNMLEtBQUssRUFBRSxJQUFJO1lBQ1gsR0FBRyxFQUFFLElBQUk7U0FDVixDQUFDO0lBQ0osQ0FBQztJQUVELEVBQUU7SUFDRixzQkFBc0I7SUFDdEIscUJBQXFCO0lBRXJCOzs7O09BSUc7SUFDTyxnQkFBZ0IsQ0FBQyxlQUFlO1FBQ3hDLElBQUksZ0JBQWdCLEdBQUcsZUFBZSxDQUFDO1FBRXZDLDREQUE0RDtRQUM1RCxJQUFJLElBQUksQ0FBQyxZQUFZLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxrQkFBa0IsRUFBRTtZQUM3RCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLGtCQUFrQixDQUFDO1lBQ3RELE1BQU0sa0JBQWtCLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxpQkFBaUIsSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLGlCQUFpQixDQUFDLHlCQUF5QixJQUFJLElBQUksQ0FBQztZQUN4SSxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsZ0JBQWdCLENBQUMsZ0JBQWdCLEVBQUUsUUFBUSxFQUFFLGtCQUFrQixDQUFDLENBQUM7U0FDN0c7UUFFRCxPQUFPLGdCQUFnQixDQUFDO0lBQzFCLENBQUM7SUFFRDs7OztPQUlHO0lBQ08sY0FBYyxDQUFDLGVBQWU7UUFDdEMsSUFBSSxnQkFBZ0IsR0FBRyxlQUFlLENBQUM7UUFFdkMseUNBQXlDO1FBQ3pDLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxvQkFBb0IsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLG9CQUFvQixDQUFDLGdCQUFnQixFQUFFO1lBQy9GLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsb0JBQW9CLENBQUMsZ0JBQWdCLENBQUM7WUFDcEUsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sRUFBRSxJQUFJLENBQUMsb0JBQW9CLENBQUMsQ0FBQztTQUNoSTtRQUVELE9BQU8sZ0JBQWdCLENBQUM7SUFDMUIsQ0FBQztJQUVTLGdCQUFnQixDQUFDLGVBQXNCO1FBQy9DLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLGVBQWUsQ0FBQyxJQUFJLElBQUksQ0FBQyxpQkFBaUIsSUFBSSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyw4QkFBOEIsSUFBSSxJQUFJLENBQUMsaUJBQWlCLENBQUMsMEJBQTBCLENBQUMsRUFBRTtZQUM3SyxNQUFNLDhCQUE4QixHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyw4QkFBOEIsSUFBSSxJQUFJLENBQUMsaUJBQWlCLENBQUMsMEJBQTBCLENBQUM7WUFDbEosZUFBZSxHQUFHLHFCQUFxQixDQUFDLGVBQWUsRUFBRSw4QkFBOEIsQ0FBQyxDQUFDO1NBQzFGO1FBQ0QsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsZUFBZSxDQUFDLEVBQUU7WUFDbkMsTUFBTSxJQUFJLEtBQUssQ0FBQyxvRUFBb0UsQ0FBQyxDQUFDO1NBQ3ZGO1FBRUQsOElBQThJO1FBQzlJLElBQUksVUFBVSxHQUFVLEVBQUUsQ0FBQztRQUMzQixJQUFJLGVBQWUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQzlCLFVBQVUsR0FBRyxDQUFDLEdBQUcsZUFBZSxDQUFDLENBQUM7U0FDbkM7UUFFRCwyRUFBMkU7UUFDM0Usd0RBQXdEO1FBQ3hELElBQUksSUFBSSxDQUFDLGlCQUFpQixJQUFJLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxhQUFhLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsSUFBSSxVQUFVLENBQUMsTUFBTSxHQUFHLENBQUMsSUFBSSxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsRUFBRTtZQUNoSyxVQUFVLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDLENBQUM7U0FDN0M7UUFFRCxrRkFBa0Y7UUFDbEYsSUFBSSxJQUFJLENBQUMsaUJBQWlCLElBQUksSUFBSSxDQUFDLGlCQUFpQixDQUFDLG1CQUFtQixJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLElBQUksVUFBVSxDQUFDLE1BQU0sR0FBRyxDQUFDLElBQUksVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxJQUFJLENBQUMsaUJBQWlCLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFO1lBQzlOLFVBQVUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLGlCQUFpQixJQUFJLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1NBQzFGO1FBRUQsNEVBQTRFO1FBQzVFLElBQUksSUFBSSxDQUFDLGlCQUFpQixJQUFJLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxrQkFBa0IsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQzdILE1BQU0sbUJBQW1CLEdBQUcsVUFBVSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7WUFDbEQsSUFBSSxVQUFVLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssSUFBSSxDQUFDLGlCQUFpQixDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRTtnQkFDakgsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsaUJBQWlCLElBQUksSUFBSSxDQUFDLGlCQUFpQixDQUFDLGtCQUFrQixDQUFDLENBQUM7YUFDdEY7U0FDRjtRQUVELElBQUksYUFBYSxHQUFHLFVBQVUsSUFBSSxFQUFFLENBQUM7UUFFckMsd0VBQXdFO1FBQ3hFLGFBQWEsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDckQsYUFBYSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsYUFBYSxDQUFDLENBQUM7UUFFbkQsc0NBQXNDO1FBQ3RDLE1BQU0sY0FBYyxHQUFHLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUVuRSwrQ0FBK0M7UUFDL0Msc0NBQXNDO1FBQ3RDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxjQUFjLENBQUMsQ0FBQztJQUN4QyxDQUFDO0lBRVMsdUJBQXVCLENBQUMsVUFBaUI7UUFDakQsSUFBSSxPQUFPLEdBQUcsRUFBRSxDQUFDO1FBQ2pCLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUM7UUFDcEQsTUFBTSxzQkFBc0IsR0FBRyxJQUFJLENBQUMsaUJBQWlCLElBQUksSUFBSSxDQUFDLGlCQUFpQixDQUFDLDBCQUEwQixJQUFJLEVBQUUsQ0FBQztRQUNqSCxNQUFNLG1CQUFtQixHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsb0JBQW9CLENBQUMsZ0JBQWdCLElBQUksS0FBSyxDQUFDO1FBQzFGLE1BQU0sZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLFdBQVcsSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLG1CQUFtQixJQUFJLEVBQUUsQ0FBQztRQUV4RixxREFBcUQ7UUFDckQsSUFBSSxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLEtBQUssUUFBUSxDQUFDLEVBQUU7WUFDaEQsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQWMsRUFBRSxFQUFFO2dCQUNwQyxPQUFPLElBQUksa0JBQWtCLE1BQU0sWUFBWSxNQUFNLEtBQUssTUFBTSxXQUFXLENBQUM7WUFDOUUsQ0FBQyxDQUFDLENBQUM7U0FDSjthQUFNO1lBQ0wsc0ZBQXNGO1lBQ3RGLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFvQixFQUFFLEVBQUU7Z0JBQzFDLElBQUksQ0FBQyxNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLFNBQVMsSUFBSSxNQUFNLENBQUMsUUFBUSxLQUFLLFNBQVMsQ0FBQyxFQUFFO29CQUN0RixNQUFNLElBQUksS0FBSyxDQUFDLDJMQUEyTCxDQUFDLENBQUM7aUJBQzlNO2dCQUNELE1BQU0sUUFBUSxHQUFHLENBQUMsTUFBTSxDQUFDLFFBQVEsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFXLENBQUM7Z0JBQ3ZFLE1BQU0sU0FBUyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsUUFBUSxJQUFJLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxRQUFRLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQztnQkFDckksSUFBSSxVQUFVLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxFQUFFLENBQUM7Z0JBQ3BELElBQUksVUFBVSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksRUFBRSxDQUFDO2dCQUNwRCxJQUFJLFdBQVcsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLEVBQUUsQ0FBQztnQkFDakQsSUFBSSxXQUFXLElBQUksV0FBVyxDQUFDLFFBQVEsRUFBRTtvQkFDdkMsV0FBVyxHQUFHLFdBQVcsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsZ0ZBQWdGO2lCQUM1STtnQkFFRCxvRkFBb0Y7Z0JBQ3BGLFVBQVUsR0FBRyxDQUFDLElBQUksQ0FBQyxvQkFBb0IsSUFBSSxVQUFVLElBQUksT0FBTyxVQUFVLEtBQUssUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLFVBQVUsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDO2dCQUNuSixVQUFVLEdBQUcsQ0FBQyxJQUFJLENBQUMsb0JBQW9CLElBQUksVUFBVSxJQUFJLE9BQU8sVUFBVSxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxVQUFVLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQztnQkFDbkosV0FBVyxHQUFHLENBQUMsSUFBSSxDQUFDLG9CQUFvQixJQUFJLFdBQVcsSUFBSSxPQUFPLFdBQVcsS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsV0FBVyxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUM7Z0JBRXhKLG9FQUFvRTtnQkFDcEUsTUFBTSxjQUFjLEdBQUcsQ0FBQyxVQUFVLEVBQUUsU0FBUyxFQUFFLFVBQVUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxLQUFLLFNBQVMsSUFBSSxJQUFJLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFDL0csSUFBSSxVQUFVLEdBQUcsY0FBYyxDQUFDLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO2dCQUU3RCwwR0FBMEc7Z0JBQzFHLDZGQUE2RjtnQkFDN0YsSUFBSSxtQkFBbUIsRUFBRTtvQkFDdkIsNkRBQTZEO29CQUM3RCw2REFBNkQ7b0JBQzdELE1BQU0sYUFBYSxHQUFHLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxVQUFVLEVBQUUsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztvQkFDMUYsVUFBVSxHQUFHLFVBQVUsQ0FBQyxhQUFhLENBQUMsQ0FBQztpQkFDeEM7Z0JBRUQsa0NBQWtDO2dCQUNsQyxJQUFJLFdBQVcsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO2dCQUN6QyxJQUFJLFdBQVcsS0FBSyxTQUFTLElBQUksV0FBVyxLQUFLLElBQUksRUFBRTtvQkFDckQsV0FBVyxHQUFHLEVBQUUsQ0FBQztpQkFDbEI7Z0JBQ0QsT0FBTyxJQUFJLGtCQUFrQixXQUFXLFlBQVksV0FBVyxLQUFLLFVBQVUsV0FBVyxDQUFDO1lBQzVGLENBQUMsQ0FBQyxDQUFDO1NBQ0o7UUFFRCxPQUFPLGVBQWUsSUFBSSxDQUFDLFdBQVcsMkNBQTJDLE9BQU8sS0FBSyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLHFCQUFxQixDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksT0FBTyxXQUFXLENBQUM7SUFDeEssQ0FBQztJQUVELHVIQUF1SDtJQUM3RyxnQkFBZ0I7UUFDeEIsTUFBTSxVQUFVLEdBQUc7WUFDakIsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUUsRUFBRTtZQUNwQixDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxFQUFFO1NBQ3JCLENBQUM7UUFDRixJQUFJLElBQUksQ0FBQyxlQUFlLEVBQUU7WUFDeEIsVUFBVSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsR0FBRyxFQUFFLENBQUM7U0FDdkM7UUFDRCxJQUFJLElBQUksQ0FBQyxlQUFlLEVBQUU7WUFDeEIsVUFBVSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsR0FBRyxFQUFFLENBQUM7U0FDdkM7UUFDRCxPQUFPLFVBQVUsQ0FBQztJQUNwQixDQUFDO0lBRUQscUNBQXFDO0lBQzNCLGdCQUFnQixDQUFDLGNBQXNCO1FBQy9DLElBQUksQ0FBQyxVQUFVLEdBQUcsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBRXBDLElBQUksSUFBSSxDQUFDLFVBQVUsSUFBSSxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxLQUFLLFVBQVUsRUFBRTtZQUNyRSxJQUFJLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1NBQy9DO1FBRUQsNkJBQTZCO1FBQzdCLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxZQUFZLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFXLElBQUksRUFBRSxDQUFDO1FBQzdFLElBQUksQ0FBQyxjQUFjLENBQUMsV0FBVyxHQUFHLFdBQVcsSUFBSSxFQUFFLENBQUM7UUFFcEQsSUFBSSxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsY0FBYyxLQUFLLFVBQVUsRUFBRTtZQUN4RCxNQUFNLGNBQWMsR0FBRyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxvQkFBb0IsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztZQUN2SCxNQUFNLGFBQWEsR0FBRyxDQUFDLElBQUksQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLG9CQUFvQixDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO1lBQ3ZJLElBQUksQ0FBQyxnQkFBZ0IscUJBQVEsSUFBSSxDQUFDLGNBQWMsRUFBSyxjQUFjLEVBQUssYUFBYSxDQUFFLENBQUM7WUFDeEYsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztZQUN4RSxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7U0FDL0I7SUFDSCxDQUFDO0lBRUQsNkVBQTZFO0lBQzdFLG9DQUFvQztJQUMxQixPQUFPO1FBQ2YsSUFBSSxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsY0FBYyxLQUFLLFVBQVUsRUFBRTtZQUN4RCxJQUFJLENBQUMsVUFBVSxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsQ0FBQztTQUMzQztJQUNILENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRyYW5zbGF0ZVNlcnZpY2UgfSBmcm9tICdAbmd4LXRyYW5zbGF0ZS9jb3JlJztcclxuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCAqIGFzIERPTVB1cmlmeV8gZnJvbSAnZG9tcHVyaWZ5JztcclxuY29uc3QgRE9NUHVyaWZ5ID0gRE9NUHVyaWZ5XzsgLy8gcGF0Y2ggdG8gZml4IHJvbGx1cCB0byB3b3JrXHJcblxyXG5pbXBvcnQgeyBDb25zdGFudHMgfSBmcm9tICcuLi9jb25zdGFudHMnO1xyXG5pbXBvcnQge1xyXG4gIENvbGxlY3Rpb25DdXN0b21TdHJ1Y3R1cmUsXHJcbiAgQ29sbGVjdGlvbk9wdGlvbixcclxuICBDb2x1bW4sXHJcbiAgQ29sdW1uRWRpdG9yLFxyXG4gIEVkaXRvcixcclxuICBFZGl0b3JBcmd1bWVudHMsXHJcbiAgRWRpdG9yVmFsaWRhdG9yLFxyXG4gIEVkaXRvclZhbGlkYXRvck91dHB1dCxcclxuICBGaWVsZFR5cGUsXHJcbiAgR3JpZE9wdGlvbixcclxuICBMb2NhbGUsXHJcbiAgTXVsdGlwbGVTZWxlY3RPcHRpb24sXHJcbiAgU2VsZWN0T3B0aW9uLFxyXG59IGZyb20gJy4vLi4vbW9kZWxzL2luZGV4JztcclxuaW1wb3J0IHsgQ29sbGVjdGlvblNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9pbmRleCc7XHJcbmltcG9ydCB7IGNoYXJBcnJheXNFcXVhbCwgZmluZE9yRGVmYXVsdCwgZ2V0RGVzY2VuZGFudFByb3BlcnR5LCBnZXRUcmFuc2xhdGlvblByZWZpeCwgaHRtbEVuY29kZSwgc2V0RGVlcFZhbHVlLCB1bnN1YnNjcmliZUFsbE9ic2VydmFibGVzIH0gZnJvbSAnLi4vc2VydmljZXMvdXRpbGl0aWVzJztcclxuXHJcbi8vIHVzaW5nIGV4dGVybmFsIG5vbi10eXBlZCBqcyBsaWJyYXJpZXNcclxuZGVjbGFyZSBjb25zdCAkOiBhbnk7XHJcblxyXG4vKipcclxuICogU2xpY2tncmlkIGVkaXRvciBjbGFzcyBmb3IgbXVsdGlwbGUvc2luZ2xlIHNlbGVjdCBsaXN0c1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFNlbGVjdEVkaXRvciBpbXBsZW1lbnRzIEVkaXRvciB7XHJcbiAgLyoqIFRoZSBKUXVlcnkgRE9NIGVsZW1lbnQgKi9cclxuICAkZWRpdG9yRWxtOiBhbnk7XHJcblxyXG4gIC8qKiBFZGl0b3IgTXVsdGlwbGUtU2VsZWN0IG9wdGlvbnMgKi9cclxuICBlZGl0b3JFbG1PcHRpb25zOiBNdWx0aXBsZVNlbGVjdE9wdGlvbjtcclxuXHJcbiAgLyoqIERPTSBFbGVtZW50IE5hbWUsIHVzZWZ1bCBmb3IgYXV0by1kZXRlY3RpbmcgcG9zaXRpb25pbmcgKGRyb3B1cCAvIGRyb3Bkb3duKSAqL1xyXG4gIGVsZW1lbnROYW1lOiBzdHJpbmc7XHJcblxyXG4gIC8qKiBUaGUgbXVsdGlwbGUtc2VsZWN0IG9wdGlvbnMgZm9yIGEgbXVsdGlwbGUgc2VsZWN0IGxpc3QgKi9cclxuICBkZWZhdWx0T3B0aW9uczogTXVsdGlwbGVTZWxlY3RPcHRpb247XHJcblxyXG4gIC8qKiBUaGUgb3JpZ2luYWwgaXRlbSB2YWx1ZXMgdGhhdCBhcmUgc2V0IGF0IHRoZSBiZWdpbm5pbmcgKi9cclxuICBvcmlnaW5hbFZhbHVlOiBhbnlbXTtcclxuXHJcbiAgLyoqIFRoZSBwcm9wZXJ0eSBuYW1lIGZvciB2YWx1ZXMgaW4gdGhlIGNvbGxlY3Rpb24gKi9cclxuICB2YWx1ZU5hbWU6IHN0cmluZztcclxuXHJcbiAgLyoqIFRoZSBwcm9wZXJ0eSBuYW1lIGZvciBsYWJlbHMgaW4gdGhlIGNvbGxlY3Rpb24gKi9cclxuICBsYWJlbE5hbWU6IHN0cmluZztcclxuXHJcbiAgLyoqIFRoZSBwcm9wZXJ0eSBuYW1lIGZvciBhIHByZWZpeCB0aGF0IGNhbiBiZSBhZGRlZCB0byB0aGUgbGFiZWxzIGluIHRoZSBjb2xsZWN0aW9uICovXHJcbiAgbGFiZWxQcmVmaXhOYW1lOiBzdHJpbmc7XHJcblxyXG4gIC8qKiBUaGUgcHJvcGVydHkgbmFtZSBmb3IgYSBzdWZmaXggdGhhdCBjYW4gYmUgYWRkZWQgdG8gdGhlIGxhYmVscyBpbiB0aGUgY29sbGVjdGlvbiAqL1xyXG4gIGxhYmVsU3VmZml4TmFtZTogc3RyaW5nO1xyXG5cclxuICAvKiogQSBsYWJlbCB0aGF0IGNhbiBiZSBhZGRlZCB0byBlYWNoIG9wdGlvbiBhbmQgY2FuIGJlIHVzZWQgYXMgYW4gYWx0ZXJuYXRpdmUgdG8gZGlzcGxheSBzZWxlY3RlZCBvcHRpb25zICovXHJcbiAgb3B0aW9uTGFiZWw6IHN0cmluZztcclxuXHJcbiAgLyoqIEdyaWQgb3B0aW9ucyAqL1xyXG4gIGdyaWRPcHRpb25zOiBHcmlkT3B0aW9uO1xyXG5cclxuICAvKiogRG8gd2UgdHJhbnNsYXRlIHRoZSBsYWJlbD8gKi9cclxuICBlbmFibGVUcmFuc2xhdGVMYWJlbDogYm9vbGVhbjtcclxuXHJcbiAgLyoqIExvY2FsZXMgKi9cclxuICBwcm90ZWN0ZWQgX2xvY2FsZXM6IExvY2FsZTtcclxuXHJcbiAgLyoqIE9ic2VydmFibGUgU3Vic2NyaXB0aW9ucyAqL1xyXG4gIHByb3RlY3RlZCBfc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcclxuXHJcbiAgLy8gZmxhZyB0byBzaWduYWwgdGhhdCB0aGUgZWRpdG9yIGlzIGRlc3Ryb3lpbmcgaXRzZWxmLCBoZWxwcyBwcmV2ZW50XHJcbiAgLy8gY29tbWl0IGNoYW5nZXMgZnJvbSBiZWluZyBjYWxsZWQgdHdpY2UgYW5kIGVycm9yaW5nXHJcbiAgcHJvdGVjdGVkIF9kZXN0cm95aW5nID0gZmFsc2U7XHJcblxyXG4gIC8qKiBDb2xsZWN0aW9uIFNlcnZpY2UgKi9cclxuICBwcm90ZWN0ZWQgX2NvbGxlY3Rpb25TZXJ2aWNlOiBDb2xsZWN0aW9uU2VydmljZTtcclxuXHJcbiAgLyoqIFRoZSB0cmFuc2xhdGUgbGlicmFyeSAqL1xyXG4gIHByb3RlY3RlZCBfdHJhbnNsYXRlOiBUcmFuc2xhdGVTZXJ2aWNlO1xyXG5cclxuICAvKiogU2xpY2tHcmlkIEdyaWQgb2JqZWN0ICovXHJcbiAgZ3JpZDogYW55O1xyXG5cclxuICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgYXJnczogRWRpdG9yQXJndW1lbnRzLCBwcm90ZWN0ZWQgaXNNdWx0aXBsZVNlbGVjdCkge1xyXG4gICAgaWYgKCFhcmdzKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignW0FuZ3VsYXItU2xpY2tHcmlkXSBTb21ldGhpbmcgaXMgd3Jvbmcgd2l0aCB0aGlzIGdyaWQsIGFuIEVkaXRvciBtdXN0IGFsd2F5cyBoYXZlIHZhbGlkIGFyZ3VtZW50cy4nKTtcclxuICAgIH1cclxuICAgIHRoaXMuZ3JpZCA9IGFyZ3MuZ3JpZDtcclxuICAgIHRoaXMuZ3JpZE9wdGlvbnMgPSAodGhpcy5ncmlkLmdldE9wdGlvbnMoKSB8fCB7fSkgYXMgR3JpZE9wdGlvbjtcclxuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmdyaWRPcHRpb25zIHx8IHRoaXMuYXJncy5jb2x1bW4ucGFyYW1zIHx8IHt9O1xyXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5pMThuIGluc3RhbmNlb2YgVHJhbnNsYXRlU2VydmljZSkge1xyXG4gICAgICB0aGlzLl90cmFuc2xhdGUgPSBvcHRpb25zLmkxOG47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZ2V0IGxvY2FsZXMgcHJvdmlkZWQgYnkgdXNlciBpbiBtYWluIGZpbGUgb3IgZWxzZSB1c2UgZGVmYXVsdCBFbmdsaXNoIGxvY2FsZXMgdmlhIHRoZSBDb25zdGFudHNcclxuICAgIHRoaXMuX2xvY2FsZXMgPSB0aGlzLmdyaWRPcHRpb25zLmxvY2FsZXMgfHwgQ29uc3RhbnRzLmxvY2FsZXM7XHJcblxyXG4gICAgLy8gcHJvdmlkZSB0aGUgbmFtZSBhdHRyaWJ1dGUgdG8gdGhlIERPTSBlbGVtZW50IHdoaWNoIHdpbGwgYmUgbmVlZGVkIHRvIGF1dG8tYWRqdXN0IGRyb3AgcG9zaXRpb24gKGRyb3B1cCAvIGRyb3Bkb3duKVxyXG4gICAgY29uc3QgZmllbGRJZCA9IHRoaXMuY29sdW1uRGVmICYmIHRoaXMuY29sdW1uRGVmLmlkO1xyXG4gICAgdGhpcy5lbGVtZW50TmFtZSA9IGBlZGl0b3ItJHtmaWVsZElkfWA7XHJcblxyXG4gICAgY29uc3QgbGliT3B0aW9uczogTXVsdGlwbGVTZWxlY3RPcHRpb24gPSB7XHJcbiAgICAgIGF1dG9BZGp1c3REcm9wSGVpZ2h0OiB0cnVlLFxyXG4gICAgICBhdXRvQWRqdXN0RHJvcFBvc2l0aW9uOiB0cnVlLFxyXG4gICAgICBhdXRvQWRqdXN0RHJvcFdpZHRoQnlUZXh0U2l6ZTogdHJ1ZSxcclxuICAgICAgY29udGFpbmVyOiAnYm9keScsXHJcbiAgICAgIGZpbHRlcjogZmFsc2UsXHJcbiAgICAgIG1heEhlaWdodDogMjc1LFxyXG4gICAgICBuYW1lOiB0aGlzLmVsZW1lbnROYW1lLFxyXG4gICAgICBzaW5nbGU6IHRydWUsXHJcbiAgICAgIHRleHRUZW1wbGF0ZTogKCRlbG0pID0+IHtcclxuICAgICAgICAvLyByZW5kZXIgSFRNTCBjb2RlIG9yIG5vdCwgYnkgZGVmYXVsdCBpdCBpcyBzYW5pdGl6ZWQgYW5kIHdvbid0IGJlIHJlbmRlcmVkXHJcbiAgICAgICAgY29uc3QgaXNSZW5kZXJIdG1sRW5hYmxlZCA9IHRoaXMuY29sdW1uRGVmICYmIHRoaXMuY29sdW1uRGVmLmludGVybmFsQ29sdW1uRWRpdG9yICYmIHRoaXMuY29sdW1uRGVmLmludGVybmFsQ29sdW1uRWRpdG9yLmVuYWJsZVJlbmRlckh0bWwgfHwgZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIGlzUmVuZGVySHRtbEVuYWJsZWQgPyAkZWxtLnRleHQoKSA6ICRlbG0uaHRtbCgpO1xyXG4gICAgICB9LFxyXG4gICAgICBvbkNsb3NlOiAoKSA9PiB0aGlzLnNhdmUoKSxcclxuICAgIH07XHJcblxyXG4gICAgaWYgKGlzTXVsdGlwbGVTZWxlY3QpIHtcclxuICAgICAgbGliT3B0aW9ucy5zaW5nbGUgPSBmYWxzZTtcclxuICAgICAgbGliT3B0aW9ucy5hZGRUaXRsZSA9IHRydWU7XHJcbiAgICAgIGxpYk9wdGlvbnMub2tCdXR0b24gPSB0cnVlO1xyXG4gICAgICBsaWJPcHRpb25zLnNlbGVjdEFsbERlbGltaXRlciA9IFsnJywgJyddO1xyXG5cclxuICAgICAgaWYgKHRoaXMuX3RyYW5zbGF0ZSAmJiB0aGlzLl90cmFuc2xhdGUuaW5zdGFudCAmJiB0aGlzLl90cmFuc2xhdGUuY3VycmVudExhbmcpIHtcclxuICAgICAgICBjb25zdCB0cmFuc2xhdGlvblByZWZpeCA9IGdldFRyYW5zbGF0aW9uUHJlZml4KHRoaXMuZ3JpZE9wdGlvbnMpO1xyXG4gICAgICAgIGxpYk9wdGlvbnMuY291bnRTZWxlY3RlZCA9IHRoaXMuX3RyYW5zbGF0ZS5pbnN0YW50KGAke3RyYW5zbGF0aW9uUHJlZml4fVhfT0ZfWV9TRUxFQ1RFRGApO1xyXG4gICAgICAgIGxpYk9wdGlvbnMuYWxsU2VsZWN0ZWQgPSB0aGlzLl90cmFuc2xhdGUuaW5zdGFudChgJHt0cmFuc2xhdGlvblByZWZpeH1BTExfU0VMRUNURURgKTtcclxuICAgICAgICBsaWJPcHRpb25zLnNlbGVjdEFsbFRleHQgPSB0aGlzLl90cmFuc2xhdGUuaW5zdGFudChgJHt0cmFuc2xhdGlvblByZWZpeH1TRUxFQ1RfQUxMYCk7XHJcbiAgICAgICAgbGliT3B0aW9ucy5va0J1dHRvblRleHQgPSB0aGlzLl90cmFuc2xhdGUuaW5zdGFudChgJHt0cmFuc2xhdGlvblByZWZpeH1PS2ApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxpYk9wdGlvbnMuY291bnRTZWxlY3RlZCA9IHRoaXMuX2xvY2FsZXMgJiYgdGhpcy5fbG9jYWxlcy5URVhUX1hfT0ZfWV9TRUxFQ1RFRDtcclxuICAgICAgICBsaWJPcHRpb25zLmFsbFNlbGVjdGVkID0gdGhpcy5fbG9jYWxlcyAmJiB0aGlzLl9sb2NhbGVzLlRFWFRfQUxMX1NFTEVDVEVEO1xyXG4gICAgICAgIGxpYk9wdGlvbnMuc2VsZWN0QWxsVGV4dCA9IHRoaXMuX2xvY2FsZXMgJiYgdGhpcy5fbG9jYWxlcy5URVhUX1NFTEVDVF9BTEw7XHJcbiAgICAgICAgbGliT3B0aW9ucy5va0J1dHRvblRleHQgPSB0aGlzLl9sb2NhbGVzICYmIHRoaXMuX2xvY2FsZXMuVEVYVF9PSztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGFzc2lnbiB0aGUgbXVsdGlwbGUgc2VsZWN0IGxpYiBvcHRpb25zXHJcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0gbGliT3B0aW9ucztcclxuXHJcbiAgICB0aGlzLmluaXQoKTtcclxuICB9XHJcblxyXG4gIC8qKiBHZXQgdGhlIENvbGxlY3Rpb24gKi9cclxuICBnZXQgY29sbGVjdGlvbigpOiBTZWxlY3RPcHRpb25bXSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb2x1bW5EZWYgJiYgdGhpcy5jb2x1bW5EZWYuaW50ZXJuYWxDb2x1bW5FZGl0b3IuY29sbGVjdGlvbiB8fCBbXTtcclxuICB9XHJcblxyXG5cclxuICAvKiogR2V0dGVyIGZvciB0aGUgQ29sbGVjdGlvbiBPcHRpb25zICovXHJcbiAgZ2V0IGNvbGxlY3Rpb25PcHRpb25zKCk6IENvbGxlY3Rpb25PcHRpb24ge1xyXG4gICAgcmV0dXJuIHRoaXMuY29sdW1uRGVmICYmIHRoaXMuY29sdW1uRGVmLmludGVybmFsQ29sdW1uRWRpdG9yICYmIHRoaXMuY29sdW1uRGVmLmludGVybmFsQ29sdW1uRWRpdG9yLmNvbGxlY3Rpb25PcHRpb25zO1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldCBDb2x1bW4gRGVmaW5pdGlvbiBvYmplY3QgKi9cclxuICBnZXQgY29sdW1uRGVmKCk6IENvbHVtbiB8IHVuZGVmaW5lZCB7XHJcbiAgICByZXR1cm4gdGhpcy5hcmdzICYmIHRoaXMuYXJncy5jb2x1bW47XHJcbiAgfVxyXG5cclxuICAvKiogR2V0IENvbHVtbiBFZGl0b3Igb2JqZWN0ICovXHJcbiAgZ2V0IGNvbHVtbkVkaXRvcigpOiBDb2x1bW5FZGl0b3IgfCB1bmRlZmluZWQge1xyXG4gICAgcmV0dXJuIHRoaXMuY29sdW1uRGVmICYmIHRoaXMuY29sdW1uRGVmLmludGVybmFsQ29sdW1uRWRpdG9yO1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldCB0aGUgRWRpdG9yIERPTSBFbGVtZW50ICovXHJcbiAgZ2V0IGVkaXRvckRvbUVsZW1lbnQoKTogYW55IHtcclxuICAgIHJldHVybiB0aGlzLiRlZGl0b3JFbG07XHJcbiAgfVxyXG5cclxuICAvKiogR2V0dGVyIGZvciB0aGUgQ3VzdG9tIFN0cnVjdHVyZSBpZiBleGlzdCAqL1xyXG4gIHByb3RlY3RlZCBnZXQgY3VzdG9tU3RydWN0dXJlKCk6IENvbGxlY3Rpb25DdXN0b21TdHJ1Y3R1cmUge1xyXG4gICAgcmV0dXJuIHRoaXMuY29sdW1uRGVmICYmIHRoaXMuY29sdW1uRGVmLmludGVybmFsQ29sdW1uRWRpdG9yICYmIHRoaXMuY29sdW1uRGVmLmludGVybmFsQ29sdW1uRWRpdG9yLmN1c3RvbVN0cnVjdHVyZTtcclxuICB9XHJcblxyXG4gIGdldCBoYXNBdXRvQ29tbWl0RWRpdCgpIHtcclxuICAgIHJldHVybiB0aGlzLmdyaWQuZ2V0T3B0aW9ucygpLmF1dG9Db21taXRFZGl0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGN1cnJlbnQgc2VsZWN0ZWQgdmFsdWVzIChtdWx0aXBsZSBzZWxlY3QpIGZyb20gdGhlIGNvbGxlY3Rpb25cclxuICAgKi9cclxuICBnZXQgY3VycmVudFZhbHVlcygpIHtcclxuICAgIGNvbnN0IGVsbVZhbHVlID0gdGhpcy4kZWRpdG9yRWxtLnZhbCgpO1xyXG5cclxuICAgIC8vIGNvbGxlY3Rpb24gb2Ygc3RyaW5ncywganVzdCByZXR1cm4gdGhlIGZpbHRlcmVkIHN0cmluZyB0aGF0IGFyZSBlcXVhbHNcclxuICAgIGlmICh0aGlzLmNvbGxlY3Rpb24uZXZlcnkoeCA9PiB0eXBlb2YgeCA9PT0gJ3N0cmluZycpKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNvbGxlY3Rpb24uZmlsdGVyKGMgPT4gZWxtVmFsdWUuaW5kZXhPZihjLnRvU3RyaW5nKCkpICE9PSAtMSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY29sbGVjdGlvbiBvZiBsYWJlbC92YWx1ZSBwYWlyXHJcbiAgICBjb25zdCBzZXBhcmF0b3JCZXR3ZWVuTGFiZWxzID0gdGhpcy5jb2xsZWN0aW9uT3B0aW9ucyAmJiB0aGlzLmNvbGxlY3Rpb25PcHRpb25zLnNlcGFyYXRvckJldHdlZW5UZXh0TGFiZWxzIHx8ICcnO1xyXG4gICAgY29uc3QgaXNJbmNsdWRpbmdQcmVmaXhTdWZmaXggPSB0aGlzLmNvbGxlY3Rpb25PcHRpb25zICYmIHRoaXMuY29sbGVjdGlvbk9wdGlvbnMuaW5jbHVkZVByZWZpeFN1ZmZpeFRvU2VsZWN0ZWRWYWx1ZXMgfHwgZmFsc2U7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdGlvblxyXG4gICAgICAuZmlsdGVyKGMgPT4gZWxtVmFsdWUuaW5kZXhPZihjLmhhc093blByb3BlcnR5KHRoaXMudmFsdWVOYW1lKSAmJiBjW3RoaXMudmFsdWVOYW1lXSAhPT0gbnVsbCAmJiBjW3RoaXMudmFsdWVOYW1lXS50b1N0cmluZygpKSAhPT0gLTEpXHJcbiAgICAgIC5tYXAoYyA9PiB7XHJcbiAgICAgICAgY29uc3QgbGFiZWxUZXh0ID0gY1t0aGlzLnZhbHVlTmFtZV07XHJcbiAgICAgICAgbGV0IHByZWZpeFRleHQgPSBjW3RoaXMubGFiZWxQcmVmaXhOYW1lXSB8fCAnJztcclxuICAgICAgICBsZXQgc3VmZml4VGV4dCA9IGNbdGhpcy5sYWJlbFN1ZmZpeE5hbWVdIHx8ICcnO1xyXG5cclxuICAgICAgICAvLyB3aGVuIGl0J3MgYSBjb21wbGV4IG9iamVjdCwgdGhlbiBwdWxsIHRoZSBvYmplY3QgbmFtZSBvbmx5LCBlLmcuOiBcInVzZXIuZmlyc3ROYW1lXCIgPT4gXCJ1c2VyXCJcclxuICAgICAgICBjb25zdCBmaWVsZE5hbWUgPSB0aGlzLmNvbHVtbkRlZiAmJiB0aGlzLmNvbHVtbkRlZi5maWVsZDtcclxuXHJcbiAgICAgICAgLy8gaXMgdGhlIGZpZWxkIGEgY29tcGxleCBvYmplY3QsIFwiYWRkcmVzcy5zdHJlZXROdW1iZXJcIlxyXG4gICAgICAgIGNvbnN0IGlzQ29tcGxleE9iamVjdCA9IGZpZWxkTmFtZSAmJiBmaWVsZE5hbWUuaW5kZXhPZignLicpID4gMDtcclxuICAgICAgICBpZiAoaXNDb21wbGV4T2JqZWN0ICYmIHR5cGVvZiBjID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgcmV0dXJuIGM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBhbHNvIHRyYW5zbGF0ZSBwcmVmaXgvc3VmZml4IGlmIGVuYWJsZVRyYW5zbGF0ZUxhYmVsIGlzIHRydWUgYW5kIHRleHQgaXMgYSBzdHJpbmdcclxuICAgICAgICBwcmVmaXhUZXh0ID0gKHRoaXMuZW5hYmxlVHJhbnNsYXRlTGFiZWwgJiYgcHJlZml4VGV4dCAmJiB0eXBlb2YgcHJlZml4VGV4dCA9PT0gJ3N0cmluZycpID8gdGhpcy5fdHJhbnNsYXRlLmluc3RhbnQocHJlZml4VGV4dCB8fCAnICcpIDogcHJlZml4VGV4dDtcclxuICAgICAgICBzdWZmaXhUZXh0ID0gKHRoaXMuZW5hYmxlVHJhbnNsYXRlTGFiZWwgJiYgc3VmZml4VGV4dCAmJiB0eXBlb2Ygc3VmZml4VGV4dCA9PT0gJ3N0cmluZycpID8gdGhpcy5fdHJhbnNsYXRlLmluc3RhbnQoc3VmZml4VGV4dCB8fCAnICcpIDogc3VmZml4VGV4dDtcclxuXHJcbiAgICAgICAgaWYgKGlzSW5jbHVkaW5nUHJlZml4U3VmZml4KSB7XHJcbiAgICAgICAgICBjb25zdCB0bXBPcHRpb25BcnJheSA9IFtwcmVmaXhUZXh0LCBsYWJlbFRleHQsIHN1ZmZpeFRleHRdLmZpbHRlcigodGV4dCkgPT4gdGV4dCk7IC8vIGFkZCB0byBhIHRlbXAgYXJyYXkgZm9yIGpvaW5pbmcgcHVycG9zZSBhbmQgZmlsdGVyIG91dCBlbXB0eSB0ZXh0XHJcbiAgICAgICAgICByZXR1cm4gdG1wT3B0aW9uQXJyYXkuam9pbihzZXBhcmF0b3JCZXR3ZWVuTGFiZWxzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGxhYmVsVGV4dDtcclxuICAgICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgY3VycmVudCBzZWxlY3RlZCB2YWx1ZXMgKHNpbmdsZSBzZWxlY3QpIGZyb20gdGhlIGNvbGxlY3Rpb25cclxuICAgKi9cclxuICBnZXQgY3VycmVudFZhbHVlKCkge1xyXG4gICAgY29uc3QgZWxtVmFsdWUgPSB0aGlzLiRlZGl0b3JFbG0udmFsKCk7XHJcblxyXG4gICAgLy8gY29sbGVjdGlvbiBvZiBzdHJpbmdzLCBqdXN0IHJldHVybiB0aGUgZmlsdGVyZWQgc3RyaW5nIHRoYXQgYXJlIGVxdWFsc1xyXG4gICAgaWYgKHRoaXMuY29sbGVjdGlvbi5ldmVyeSh4ID0+IHR5cGVvZiB4ID09PSAnc3RyaW5nJykpIHtcclxuICAgICAgcmV0dXJuIGZpbmRPckRlZmF1bHQodGhpcy5jb2xsZWN0aW9uLCAoYzogYW55KSA9PiBjLnRvU3RyaW5nKCkgPT09IGVsbVZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjb2xsZWN0aW9uIG9mIGxhYmVsL3ZhbHVlIHBhaXJcclxuICAgIGNvbnN0IHNlcGFyYXRvckJldHdlZW5MYWJlbHMgPSB0aGlzLmNvbGxlY3Rpb25PcHRpb25zICYmIHRoaXMuY29sbGVjdGlvbk9wdGlvbnMuc2VwYXJhdG9yQmV0d2VlblRleHRMYWJlbHMgfHwgJyc7XHJcbiAgICBjb25zdCBpc0luY2x1ZGluZ1ByZWZpeFN1ZmZpeCA9IHRoaXMuY29sbGVjdGlvbk9wdGlvbnMgJiYgdGhpcy5jb2xsZWN0aW9uT3B0aW9ucy5pbmNsdWRlUHJlZml4U3VmZml4VG9TZWxlY3RlZFZhbHVlcyB8fCBmYWxzZTtcclxuICAgIGNvbnN0IGl0ZW1Gb3VuZCA9IGZpbmRPckRlZmF1bHQodGhpcy5jb2xsZWN0aW9uLCAoYzogYW55KSA9PiBjLmhhc093blByb3BlcnR5KHRoaXMudmFsdWVOYW1lKSAmJiBjW3RoaXMudmFsdWVOYW1lXSAhPT0gbnVsbCAmJiBjW3RoaXMudmFsdWVOYW1lXS50b1N0cmluZygpID09PSBlbG1WYWx1ZSk7XHJcblxyXG4gICAgLy8gaXMgdGhlIGZpZWxkIGEgY29tcGxleCBvYmplY3QsIFwiYWRkcmVzcy5zdHJlZXROdW1iZXJcIlxyXG4gICAgY29uc3QgZmllbGROYW1lID0gdGhpcy5jb2x1bW5EZWYgJiYgdGhpcy5jb2x1bW5EZWYuZmllbGQ7XHJcbiAgICBjb25zdCBpc0NvbXBsZXhPYmplY3QgPSBmaWVsZE5hbWUgJiYgZmllbGROYW1lLmluZGV4T2YoJy4nKSA+IDA7XHJcblxyXG4gICAgaWYgKGlzQ29tcGxleE9iamVjdCAmJiB0eXBlb2YgaXRlbUZvdW5kID09PSAnb2JqZWN0Jykge1xyXG4gICAgICByZXR1cm4gaXRlbUZvdW5kO1xyXG4gICAgfSBlbHNlIGlmIChpdGVtRm91bmQgJiYgaXRlbUZvdW5kLmhhc093blByb3BlcnR5KHRoaXMudmFsdWVOYW1lKSkge1xyXG4gICAgICBjb25zdCBsYWJlbFRleHQgPSBpdGVtRm91bmRbdGhpcy52YWx1ZU5hbWVdO1xyXG5cclxuICAgICAgaWYgKGlzSW5jbHVkaW5nUHJlZml4U3VmZml4KSB7XHJcbiAgICAgICAgbGV0IHByZWZpeFRleHQgPSBpdGVtRm91bmRbdGhpcy5sYWJlbFByZWZpeE5hbWVdIHx8ICcnO1xyXG4gICAgICAgIGxldCBzdWZmaXhUZXh0ID0gaXRlbUZvdW5kW3RoaXMubGFiZWxTdWZmaXhOYW1lXSB8fCAnJztcclxuXHJcbiAgICAgICAgLy8gYWxzbyB0cmFuc2xhdGUgcHJlZml4L3N1ZmZpeCBpZiBlbmFibGVUcmFuc2xhdGVMYWJlbCBpcyB0cnVlIGFuZCB0ZXh0IGlzIGEgc3RyaW5nXHJcbiAgICAgICAgcHJlZml4VGV4dCA9ICh0aGlzLmVuYWJsZVRyYW5zbGF0ZUxhYmVsICYmIHByZWZpeFRleHQgJiYgdHlwZW9mIHByZWZpeFRleHQgPT09ICdzdHJpbmcnKSA/IHRoaXMuX3RyYW5zbGF0ZS5pbnN0YW50KHByZWZpeFRleHQgfHwgJyAnKSA6IHByZWZpeFRleHQ7XHJcbiAgICAgICAgc3VmZml4VGV4dCA9ICh0aGlzLmVuYWJsZVRyYW5zbGF0ZUxhYmVsICYmIHN1ZmZpeFRleHQgJiYgdHlwZW9mIHN1ZmZpeFRleHQgPT09ICdzdHJpbmcnKSA/IHRoaXMuX3RyYW5zbGF0ZS5pbnN0YW50KHN1ZmZpeFRleHQgfHwgJyAnKSA6IHN1ZmZpeFRleHQ7XHJcblxyXG4gICAgICAgIC8vIGFkZCB0byBhIHRlbXAgYXJyYXkgZm9yIGpvaW5pbmcgcHVycG9zZSBhbmQgZmlsdGVyIG91dCBlbXB0eSB0ZXh0XHJcbiAgICAgICAgY29uc3QgdG1wT3B0aW9uQXJyYXkgPSBbcHJlZml4VGV4dCwgbGFiZWxUZXh0LCBzdWZmaXhUZXh0XS5maWx0ZXIoKHRleHQpID0+IHRleHQpO1xyXG4gICAgICAgIHJldHVybiB0bXBPcHRpb25BcnJheS5qb2luKHNlcGFyYXRvckJldHdlZW5MYWJlbHMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbGFiZWxUZXh0O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAnJztcclxuICB9XHJcblxyXG5cclxuICAvKiogR2V0IHRoZSBWYWxpZGF0b3IgZnVuY3Rpb24sIGNhbiBiZSBwYXNzZWQgaW4gRWRpdG9yIHByb3BlcnR5IG9yIENvbHVtbiBEZWZpbml0aW9uICovXHJcbiAgZ2V0IHZhbGlkYXRvcigpOiBFZGl0b3JWYWxpZGF0b3Ige1xyXG4gICAgcmV0dXJuIHRoaXMuY29sdW1uRWRpdG9yLnZhbGlkYXRvciB8fCB0aGlzLmNvbHVtbkRlZi52YWxpZGF0b3I7XHJcbiAgfVxyXG5cclxuICBpbml0KCkge1xyXG4gICAgaWYgKCF0aGlzLmNvbHVtbkRlZiB8fCAhdGhpcy5jb2x1bW5EZWYuaW50ZXJuYWxDb2x1bW5FZGl0b3IgfHwgKCF0aGlzLmNvbHVtbkRlZi5pbnRlcm5hbENvbHVtbkVkaXRvci5jb2xsZWN0aW9uICYmICF0aGlzLmNvbHVtbkRlZi5pbnRlcm5hbENvbHVtbkVkaXRvci5jb2xsZWN0aW9uQXN5bmMpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgW0FuZ3VsYXItU2xpY2tHcmlkXSBZb3UgbmVlZCB0byBwYXNzIGEgXCJjb2xsZWN0aW9uXCIgKG9yIFwiY29sbGVjdGlvbkFzeW5jXCIpIGluc2lkZSBDb2x1bW4gRGVmaW5pdGlvbiBFZGl0b3IgZm9yIHRoZSBNdWx0aXBsZVNlbGVjdC9TaW5nbGVTZWxlY3QgRWRpdG9yIHRvIHdvcmsgY29ycmVjdGx5LlxyXG4gICAgICBBbHNvIGVhY2ggb3B0aW9uIHNob3VsZCBpbmNsdWRlIGEgdmFsdWUvbGFiZWwgcGFpciAob3IgdmFsdWUvbGFiZWxLZXkgd2hlbiB1c2luZyBMb2NhbGUpLlxyXG4gICAgICBGb3IgZXhhbXBsZTogeyBlZGl0b3I6IHsgY29sbGVjdGlvbjogW3sgdmFsdWU6IHRydWUsIGxhYmVsOiAnVHJ1ZScgfSx7IHZhbHVlOiBmYWxzZSwgbGFiZWw6ICdGYWxzZSd9XSB9IH1gKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9jb2xsZWN0aW9uU2VydmljZSA9IG5ldyBDb2xsZWN0aW9uU2VydmljZSh0aGlzLl90cmFuc2xhdGUpO1xyXG4gICAgdGhpcy5lbmFibGVUcmFuc2xhdGVMYWJlbCA9ICh0aGlzLmNvbHVtbkRlZi5pbnRlcm5hbENvbHVtbkVkaXRvci5lbmFibGVUcmFuc2xhdGVMYWJlbCkgPyB0aGlzLmNvbHVtbkRlZi5pbnRlcm5hbENvbHVtbkVkaXRvci5lbmFibGVUcmFuc2xhdGVMYWJlbCA6IGZhbHNlO1xyXG4gICAgdGhpcy5sYWJlbE5hbWUgPSB0aGlzLmN1c3RvbVN0cnVjdHVyZSAmJiB0aGlzLmN1c3RvbVN0cnVjdHVyZS5sYWJlbCB8fCAnbGFiZWwnO1xyXG4gICAgdGhpcy5sYWJlbFByZWZpeE5hbWUgPSB0aGlzLmN1c3RvbVN0cnVjdHVyZSAmJiB0aGlzLmN1c3RvbVN0cnVjdHVyZS5sYWJlbFByZWZpeCB8fCAnbGFiZWxQcmVmaXgnO1xyXG4gICAgdGhpcy5sYWJlbFN1ZmZpeE5hbWUgPSB0aGlzLmN1c3RvbVN0cnVjdHVyZSAmJiB0aGlzLmN1c3RvbVN0cnVjdHVyZS5sYWJlbFN1ZmZpeCB8fCAnbGFiZWxTdWZmaXgnO1xyXG4gICAgdGhpcy5vcHRpb25MYWJlbCA9IHRoaXMuY3VzdG9tU3RydWN0dXJlICYmIHRoaXMuY3VzdG9tU3RydWN0dXJlLm9wdGlvbkxhYmVsIHx8ICd2YWx1ZSc7XHJcbiAgICB0aGlzLnZhbHVlTmFtZSA9IHRoaXMuY3VzdG9tU3RydWN0dXJlICYmIHRoaXMuY3VzdG9tU3RydWN0dXJlLnZhbHVlIHx8ICd2YWx1ZSc7XHJcblxyXG4gICAgaWYgKHRoaXMuZW5hYmxlVHJhbnNsYXRlTGFiZWwgJiYgKCF0aGlzLl90cmFuc2xhdGUgfHwgdHlwZW9mIHRoaXMuX3RyYW5zbGF0ZS5pbnN0YW50ICE9PSAnZnVuY3Rpb24nKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tBbmd1bGFyLVNsaWNrZ3JpZF0gcmVxdWlyZXMgXCJuZ3gtdHJhbnNsYXRlXCIgdG8gYmUgaW5zdGFsbGVkIGFuZCBjb25maWd1cmVkIHdoZW4gdGhlIGdyaWQgb3B0aW9uIFwiZW5hYmxlVHJhbnNsYXRlXCIgaXMgZW5hYmxlZC4nKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBhbHdheXMgcmVuZGVyIHRoZSBTZWxlY3QgKGRyb3Bkb3duKSBET00gZWxlbWVudCwgZXZlbiBpZiB1c2VyIHBhc3NlZCBhIFwiY29sbGVjdGlvbkFzeW5jXCIsXHJcbiAgICAvLyBpZiB0aGF0IGlzIHRoZSBjYXNlLCB0aGUgU2VsZWN0IHdpbGwgc2ltcGx5IGJlIHdpdGhvdXQgYW55IG9wdGlvbnMgYnV0IHdlIHN0aWxsIGhhdmUgdG8gcmVuZGVyIGl0IChlbHNlIFNsaWNrR3JpZCB3b3VsZCB0aHJvdyBhbiBlcnJvcilcclxuICAgIHRoaXMucmVuZGVyRG9tRWxlbWVudCh0aGlzLmNvbGxlY3Rpb24pO1xyXG4gIH1cclxuXHJcbiAgZ2V0VmFsdWUoKTogYW55IHwgYW55W10ge1xyXG4gICAgcmV0dXJuICh0aGlzLmlzTXVsdGlwbGVTZWxlY3QpID8gdGhpcy5jdXJyZW50VmFsdWVzIDogdGhpcy5jdXJyZW50VmFsdWU7XHJcbiAgfVxyXG5cclxuICBzZXRWYWx1ZSh2YWx1ZTogYW55IHwgYW55W10pIHtcclxuICAgIGlmICh0aGlzLmlzTXVsdGlwbGVTZWxlY3QgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgdGhpcy5sb2FkTXVsdGlwbGVWYWx1ZXModmFsdWUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5sb2FkU2luZ2xlVmFsdWUodmFsdWUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaGlkZSgpIHtcclxuICAgIGlmICh0aGlzLiRlZGl0b3JFbG0gJiYgdHlwZW9mIHRoaXMuJGVkaXRvckVsbS5tdWx0aXBsZVNlbGVjdCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aGlzLiRlZGl0b3JFbG0ubXVsdGlwbGVTZWxlY3QoJ2Nsb3NlJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzaG93KCkge1xyXG4gICAgaWYgKHRoaXMuJGVkaXRvckVsbSAmJiB0eXBlb2YgdGhpcy4kZWRpdG9yRWxtLm11bHRpcGxlU2VsZWN0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHRoaXMuJGVkaXRvckVsbS5tdWx0aXBsZVNlbGVjdCgnb3BlbicpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXBwbHlWYWx1ZShpdGVtOiBhbnksIHN0YXRlOiBhbnkpOiB2b2lkIHtcclxuICAgIGNvbnN0IGZpZWxkTmFtZSA9IHRoaXMuY29sdW1uRGVmICYmIHRoaXMuY29sdW1uRGVmLmZpZWxkO1xyXG4gICAgY29uc3QgZmllbGRUeXBlID0gdGhpcy5jb2x1bW5EZWYgJiYgdGhpcy5jb2x1bW5EZWYudHlwZTtcclxuICAgIGxldCBuZXdWYWx1ZSA9IHN0YXRlO1xyXG5cclxuICAgIC8vIHdoZW4gdGhlIHByb3ZpZGVkIHVzZXIgZGVmaW5lZCB0aGUgY29sdW1uIGZpZWxkIHR5cGUgYXMgYSBwb3NzaWJsZSBudW1iZXIgdGhlbiB0cnkgcGFyc2luZyB0aGUgc3RhdGUgdmFsdWUgYXMgdGhhdFxyXG4gICAgaWYgKGZpZWxkVHlwZSA9PT0gRmllbGRUeXBlLm51bWJlciB8fCBmaWVsZFR5cGUgPT09IEZpZWxkVHlwZS5pbnRlZ2VyIHx8IGZpZWxkVHlwZSA9PT0gRmllbGRUeXBlLmJvb2xlYW4pIHtcclxuICAgICAgbmV3VmFsdWUgPSBwYXJzZUZsb2F0KHN0YXRlKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB3aGVuIHNldCBhcyBhIG11bHRpcGxlIHNlbGVjdGlvbiwgd2UgY2FuIGFzc3VtZSB0aGF0IHRoZSAzcmQgcGFydHkgbGliIG11bHRpcGxlLXNlbGVjdCB3aWxsIHJldHVybiBhIENTViBzdHJpbmdcclxuICAgIC8vIHdlIG5lZWQgdG8gcmUtc3BsaXQgdGhhdCBpbnRvIGFuIGFycmF5IHRvIGJlIHRoZSBzYW1lIGFzIHRoZSBvcmlnaW5hbCBjb2x1bW5cclxuICAgIGlmICh0aGlzLmlzTXVsdGlwbGVTZWxlY3QgJiYgdHlwZW9mIHN0YXRlID09PSAnc3RyaW5nJyAmJiBzdGF0ZS5pbmRleE9mKCcsJykgPj0gMCkge1xyXG4gICAgICBuZXdWYWx1ZSA9IHN0YXRlLnNwbGl0KCcsJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaXMgdGhlIGZpZWxkIGEgY29tcGxleCBvYmplY3QsIFwidXNlci5hZGRyZXNzLnN0cmVldE51bWJlclwiXHJcbiAgICBjb25zdCBpc0NvbXBsZXhPYmplY3QgPSBmaWVsZE5hbWUgJiYgZmllbGROYW1lLmluZGV4T2YoJy4nKSA+IDA7XHJcblxyXG4gICAgLy8gdmFsaWRhdGUgdGhlIHZhbHVlIGJlZm9yZSBhcHBseWluZyBpdCAoaWYgbm90IHZhbGlkIHdlJ2xsIHNldCBhbiBlbXB0eSBzdHJpbmcpXHJcbiAgICBjb25zdCB2YWxpZGF0aW9uID0gdGhpcy52YWxpZGF0ZShuZXdWYWx1ZSk7XHJcbiAgICBuZXdWYWx1ZSA9ICh2YWxpZGF0aW9uICYmIHZhbGlkYXRpb24udmFsaWQpID8gbmV3VmFsdWUgOiAnJztcclxuXHJcbiAgICAvLyBzZXQgdGhlIG5ldyB2YWx1ZSB0byB0aGUgaXRlbSBkYXRhY29udGV4dFxyXG4gICAgaWYgKGlzQ29tcGxleE9iamVjdCkge1xyXG4gICAgICAvLyB3aGVuIGl0J3MgYSBjb21wbGV4IG9iamVjdCwgdXNlciBjb3VsZCBvdmVycmlkZSB0aGUgb2JqZWN0IHBhdGggKHdoZXJlIHRoZSBlZGl0YWJsZSBvYmplY3QgaXMgbG9jYXRlZClcclxuICAgICAgLy8gZWxzZSB3ZSB1c2UgdGhlIHBhdGggcHJvdmlkZWQgaW4gdGhlIEZpZWxkIENvbHVtbiBEZWZpbml0aW9uXHJcbiAgICAgIGNvbnN0IG9iamVjdFBhdGggPSB0aGlzLmNvbHVtbkVkaXRvciAmJiB0aGlzLmNvbHVtbkVkaXRvci5jb21wbGV4T2JqZWN0UGF0aCB8fCBmaWVsZE5hbWU7XHJcbiAgICAgIHNldERlZXBWYWx1ZShpdGVtLCBvYmplY3RQYXRoLCBuZXdWYWx1ZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpdGVtW2ZpZWxkTmFtZV0gPSBuZXdWYWx1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICB0aGlzLl9kZXN0cm95aW5nID0gdHJ1ZTtcclxuICAgIGlmICh0aGlzLiRlZGl0b3JFbG0gJiYgdHlwZW9mIHRoaXMuJGVkaXRvckVsbS5tdWx0aXBsZVNlbGVjdCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aGlzLiRlZGl0b3JFbG0ubXVsdGlwbGVTZWxlY3QoJ2Rlc3Ryb3knKTtcclxuICAgICAgdGhpcy4kZWRpdG9yRWxtLnJlbW92ZSgpO1xyXG4gICAgICBjb25zdCBlbGVtZW50Q2xhc3NOYW1lID0gdGhpcy5lbGVtZW50TmFtZS50b1N0cmluZygpLnJlcGxhY2UoJy4nLCAnXFxcXC4nKTsgLy8gbWFrZSBzdXJlIHRvIGVzY2FwZSBhbnkgZG90IFwiLlwiIGZyb20gQ1NTIGNsYXNzIHRvIGF2b2lkIGNvbnNvbGUgZXJyb3JcclxuICAgICAgJChgW25hbWU9JHtlbGVtZW50Q2xhc3NOYW1lfV0ubXMtZHJvcGApLnJlbW92ZSgpO1xyXG4gICAgICB0aGlzLiRlZGl0b3JFbG0ucmVtb3ZlKCk7XHJcbiAgICAgIHRoaXMuJGVkaXRvckVsbSA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBsb2FkVmFsdWUoaXRlbTogYW55KTogdm9pZCB7XHJcbiAgICBjb25zdCBmaWVsZE5hbWUgPSB0aGlzLmNvbHVtbkRlZiAmJiB0aGlzLmNvbHVtbkRlZi5maWVsZDtcclxuXHJcbiAgICBpZiAoaXRlbSAmJiBmaWVsZE5hbWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAvLyBpcyB0aGUgZmllbGQgYSBjb21wbGV4IG9iamVjdCwgXCJhZGRyZXNzLnN0cmVldE51bWJlclwiXHJcbiAgICAgIGNvbnN0IGlzQ29tcGxleE9iamVjdCA9IGZpZWxkTmFtZSAmJiBmaWVsZE5hbWUuaW5kZXhPZignLicpID4gMDtcclxuXHJcbiAgICAgIC8vIHdoZW4gaXQncyBhIGNvbXBsZXggb2JqZWN0LCB1c2VyIGNvdWxkIG92ZXJyaWRlIHRoZSBvYmplY3QgcGF0aCAod2hlcmUgdGhlIGVkaXRhYmxlIG9iamVjdCBpcyBsb2NhdGVkKVxyXG4gICAgICAvLyBlbHNlIHdlIHVzZSB0aGUgcGF0aCBwcm92aWRlZCBpbiB0aGUgRmllbGQgQ29sdW1uIERlZmluaXRpb25cclxuICAgICAgY29uc3Qgb2JqZWN0UGF0aCA9IHRoaXMuY29sdW1uRWRpdG9yICYmIHRoaXMuY29sdW1uRWRpdG9yLmNvbXBsZXhPYmplY3RQYXRoIHx8IGZpZWxkTmFtZTtcclxuICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gKGlzQ29tcGxleE9iamVjdCkgPyBnZXREZXNjZW5kYW50UHJvcGVydHkoaXRlbSwgb2JqZWN0UGF0aCkgOiBpdGVtW2ZpZWxkTmFtZV07XHJcbiAgICAgIGNvbnN0IHZhbHVlID0gKGlzQ29tcGxleE9iamVjdCAmJiBjdXJyZW50VmFsdWUuaGFzT3duUHJvcGVydHkodGhpcy52YWx1ZU5hbWUpKSA/IGN1cnJlbnRWYWx1ZVt0aGlzLnZhbHVlTmFtZV0gOiBjdXJyZW50VmFsdWU7XHJcblxyXG4gICAgICBpZiAodGhpcy5pc011bHRpcGxlU2VsZWN0ICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgdGhpcy5sb2FkTXVsdGlwbGVWYWx1ZXModmFsdWUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMubG9hZFNpbmdsZVZhbHVlKHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnJlZnJlc2goKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGxvYWRNdWx0aXBsZVZhbHVlcyhjdXJyZW50VmFsdWVzOiBhbnlbXSkge1xyXG4gICAgLy8gY29udmVydCB0byBzdHJpbmcgYmVjYXVzZSB0aGF0IGlzIGhvdyB0aGUgRE9NIHdpbGwgcmV0dXJuIHRoZXNlIHZhbHVlc1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudFZhbHVlcykpIHtcclxuICAgICAgLy8ga2VlcCB0aGUgZGVmYXVsdCB2YWx1ZXMgaW4gbWVtb3J5IGZvciByZWZlcmVuY2VzXHJcbiAgICAgIHRoaXMub3JpZ2luYWxWYWx1ZSA9IGN1cnJlbnRWYWx1ZXMubWFwKChpOiBhbnkpID0+IGkpO1xyXG5cclxuICAgICAgLy8gY29tcGFyZSBhbGwgdGhlIGFycmF5IHZhbHVlcyBidXQgYXMgc3RyaW5nIHR5cGUgc2luY2UgbXVsdGlwbGUtc2VsZWN0IGFsd2F5cyByZXR1cm4gc3RyaW5nXHJcbiAgICAgIGNvbnN0IGN1cnJlbnRTdHJpbmdWYWx1ZXMgPSBjdXJyZW50VmFsdWVzLm1hcCgoaTogYW55KSA9PiBpLnRvU3RyaW5nKCkpO1xyXG4gICAgICB0aGlzLiRlZGl0b3JFbG0uZmluZCgnb3B0aW9uJykuZWFjaCgoaTogbnVtYmVyLCAkZTogYW55KSA9PiB7XHJcbiAgICAgICAgJGUuc2VsZWN0ZWQgPSAoY3VycmVudFN0cmluZ1ZhbHVlcy5pbmRleE9mKCRlLnZhbHVlKSAhPT0gLTEpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGxvYWRTaW5nbGVWYWx1ZShjdXJyZW50VmFsdWU6IGFueSkge1xyXG4gICAgLy8ga2VlcCB0aGUgZGVmYXVsdCB2YWx1ZSBpbiBtZW1vcnkgZm9yIHJlZmVyZW5jZXNcclxuICAgIHRoaXMub3JpZ2luYWxWYWx1ZSA9IHR5cGVvZiBjdXJyZW50VmFsdWUgPT09ICdudW1iZXInID8gYCR7Y3VycmVudFZhbHVlfWAgOiBjdXJyZW50VmFsdWU7XHJcbiAgICB0aGlzLiRlZGl0b3JFbG0udmFsKGN1cnJlbnRWYWx1ZSk7XHJcblxyXG4gICAgLy8gbWFrZSBzdXJlIHRoZSBwcm9wIGV4aXN0cyBmaXJzdFxyXG4gICAgdGhpcy4kZWRpdG9yRWxtLmZpbmQoJ29wdGlvbicpLmVhY2goKGk6IG51bWJlciwgJGU6IGFueSkgPT4ge1xyXG4gICAgICAvLyBjaGVjayBlcXVhbGl0eSBhZnRlciBjb252ZXJ0aW5nIG9yaWdpbmFsVmFsdWUgdG8gc3RyaW5nIHNpbmNlIHRoZSBET00gdmFsdWUgd2lsbCBhbHdheXMgYmUgb2YgdHlwZSBzdHJpbmdcclxuICAgICAgJGUuc2VsZWN0ZWQgPSAoYCR7Y3VycmVudFZhbHVlfWAgPT09ICRlLnZhbHVlKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgc2F2ZSgpIHtcclxuICAgIGNvbnN0IHZhbGlkYXRpb24gPSB0aGlzLnZhbGlkYXRlKCk7XHJcbiAgICBjb25zdCBpc1ZhbGlkID0gKHZhbGlkYXRpb24gJiYgdmFsaWRhdGlvbi52YWxpZCkgfHwgZmFsc2U7XHJcblxyXG4gICAgaWYgKCF0aGlzLl9kZXN0cm95aW5nICYmIHRoaXMuaGFzQXV0b0NvbW1pdEVkaXQgJiYgaXNWYWxpZCkge1xyXG4gICAgICAvLyBkbyBub3QgdXNlIGFyZ3MuY29tbWl0Q2hhbmdlcygpIGFzIHRoaXMgc2V0cyB0aGUgZm9jdXMgdG8gdGhlIG5leHQgcm93LlxyXG4gICAgICAvLyBhbHNvIHRoZSBzZWxlY3QgbGlzdCB3aWxsIHN0YXkgc2hvd24gd2hlbiBjbGlja2luZyBvZmYgdGhlIGdyaWRcclxuICAgICAgdGhpcy5ncmlkLmdldEVkaXRvckxvY2soKS5jb21taXRDdXJyZW50RWRpdCgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5hcmdzLmNvbW1pdENoYW5nZXMoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNlcmlhbGl6ZVZhbHVlKCk6IGFueSB8IGFueVtdIHtcclxuICAgIHJldHVybiAodGhpcy5pc011bHRpcGxlU2VsZWN0KSA/IHRoaXMuY3VycmVudFZhbHVlcyA6IHRoaXMuY3VycmVudFZhbHVlO1xyXG4gIH1cclxuXHJcbiAgZm9jdXMoKSB7XHJcbiAgICBpZiAodGhpcy4kZWRpdG9yRWxtICYmIHRoaXMuJGVkaXRvckVsbS5tdWx0aXBsZVNlbGVjdCkge1xyXG4gICAgICB0aGlzLiRlZGl0b3JFbG0ubXVsdGlwbGVTZWxlY3QoJ2ZvY3VzJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpc1ZhbHVlQ2hhbmdlZCgpOiBib29sZWFuIHtcclxuICAgIGlmICh0aGlzLmlzTXVsdGlwbGVTZWxlY3QpIHtcclxuICAgICAgcmV0dXJuICFjaGFyQXJyYXlzRXF1YWwodGhpcy4kZWRpdG9yRWxtLnZhbCgpLCB0aGlzLm9yaWdpbmFsVmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuJGVkaXRvckVsbS52YWwoKSAhPT0gdGhpcy5vcmlnaW5hbFZhbHVlO1xyXG4gIH1cclxuXHJcbiAgdmFsaWRhdGUoaW5wdXRWYWx1ZT86IGFueSk6IEVkaXRvclZhbGlkYXRvck91dHB1dCB7XHJcbiAgICBjb25zdCBpc1JlcXVpcmVkID0gdGhpcy5jb2x1bW5FZGl0b3IucmVxdWlyZWQ7XHJcbiAgICBjb25zdCBlbG1WYWx1ZSA9IChpbnB1dFZhbHVlICE9PSB1bmRlZmluZWQpID8gaW5wdXRWYWx1ZSA6IHRoaXMuJGVkaXRvckVsbSAmJiB0aGlzLiRlZGl0b3JFbG0udmFsICYmIHRoaXMuJGVkaXRvckVsbS52YWwoKTtcclxuICAgIGNvbnN0IGVycm9yTXNnID0gdGhpcy5jb2x1bW5FZGl0b3IuZXJyb3JNZXNzYWdlO1xyXG5cclxuICAgIGlmICh0aGlzLnZhbGlkYXRvcikge1xyXG4gICAgICBjb25zdCB2YWx1ZSA9IChpbnB1dFZhbHVlICE9PSB1bmRlZmluZWQpID8gaW5wdXRWYWx1ZSA6ICh0aGlzLmlzTXVsdGlwbGVTZWxlY3QgPyB0aGlzLmN1cnJlbnRWYWx1ZXMgOiB0aGlzLmN1cnJlbnRWYWx1ZSk7XHJcbiAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRvcih2YWx1ZSwgdGhpcy5hcmdzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBieSBkZWZhdWx0IHRoZSBlZGl0b3IgaXMgYWxtb3N0IGFsd2F5cyB2YWxpZCAoZXhjZXB0IHdoZW4gaXQncyByZXF1aXJlZCBidXQgbm90IHByb3ZpZGVkKVxyXG4gICAgaWYgKGlzUmVxdWlyZWQgJiYgKGVsbVZhbHVlID09PSAnJyB8fCAoQXJyYXkuaXNBcnJheShlbG1WYWx1ZSkgJiYgZWxtVmFsdWUubGVuZ3RoID09PSAwKSkpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB2YWxpZDogZmFsc2UsXHJcbiAgICAgICAgbXNnOiBlcnJvck1zZyB8fCBDb25zdGFudHMuVkFMSURBVElPTl9SRVFVSVJFRF9GSUVMRFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHZhbGlkOiB0cnVlLFxyXG4gICAgICBtc2c6IG51bGxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvL1xyXG4gIC8vIHByb3RlY3RlZCBmdW5jdGlvbnNcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgLyoqXHJcbiAgICogdXNlciBtaWdodCB3YW50IHRvIGZpbHRlciBjZXJ0YWluIGl0ZW1zIG9mIHRoZSBjb2xsZWN0aW9uXHJcbiAgICogQHBhcmFtIGlucHV0Q29sbGVjdGlvblxyXG4gICAqIEByZXR1cm4gb3V0cHV0Q29sbGVjdGlvbiBmaWx0ZXJlZCBhbmQvb3Igc29ydGVkIGNvbGxlY3Rpb25cclxuICAgKi9cclxuICBwcm90ZWN0ZWQgZmlsdGVyQ29sbGVjdGlvbihpbnB1dENvbGxlY3Rpb24pIHtcclxuICAgIGxldCBvdXRwdXRDb2xsZWN0aW9uID0gaW5wdXRDb2xsZWN0aW9uO1xyXG5cclxuICAgIC8vIHVzZXIgbWlnaHQgd2FudCB0byBmaWx0ZXIgY2VydGFpbiBpdGVtcyBvZiB0aGUgY29sbGVjdGlvblxyXG4gICAgaWYgKHRoaXMuY29sdW1uRWRpdG9yICYmIHRoaXMuY29sdW1uRWRpdG9yLmNvbGxlY3Rpb25GaWx0ZXJCeSkge1xyXG4gICAgICBjb25zdCBmaWx0ZXJCeSA9IHRoaXMuY29sdW1uRWRpdG9yLmNvbGxlY3Rpb25GaWx0ZXJCeTtcclxuICAgICAgY29uc3QgZmlsdGVyQ29sbGVjdGlvbkJ5ID0gdGhpcy5jb2x1bW5FZGl0b3IuY29sbGVjdGlvbk9wdGlvbnMgJiYgdGhpcy5jb2x1bW5FZGl0b3IuY29sbGVjdGlvbk9wdGlvbnMuZmlsdGVyUmVzdWx0QWZ0ZXJFYWNoUGFzcyB8fCBudWxsO1xyXG4gICAgICBvdXRwdXRDb2xsZWN0aW9uID0gdGhpcy5fY29sbGVjdGlvblNlcnZpY2UuZmlsdGVyQ29sbGVjdGlvbihvdXRwdXRDb2xsZWN0aW9uLCBmaWx0ZXJCeSwgZmlsdGVyQ29sbGVjdGlvbkJ5KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0cHV0Q29sbGVjdGlvbjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIHVzZXIgbWlnaHQgd2FudCB0byBzb3J0IHRoZSBjb2xsZWN0aW9uIGluIGEgY2VydGFpbiB3YXlcclxuICAgKiBAcGFyYW0gaW5wdXRDb2xsZWN0aW9uXHJcbiAgICogQHJldHVybiBvdXRwdXRDb2xsZWN0aW9uIHNvcnRlZCBjb2xsZWN0aW9uXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIHNvcnRDb2xsZWN0aW9uKGlucHV0Q29sbGVjdGlvbikge1xyXG4gICAgbGV0IG91dHB1dENvbGxlY3Rpb24gPSBpbnB1dENvbGxlY3Rpb247XHJcblxyXG4gICAgLy8gdXNlciBtaWdodCB3YW50IHRvIHNvcnQgdGhlIGNvbGxlY3Rpb25cclxuICAgIGlmICh0aGlzLmNvbHVtbkRlZi5pbnRlcm5hbENvbHVtbkVkaXRvciAmJiB0aGlzLmNvbHVtbkRlZi5pbnRlcm5hbENvbHVtbkVkaXRvci5jb2xsZWN0aW9uU29ydEJ5KSB7XHJcbiAgICAgIGNvbnN0IHNvcnRCeSA9IHRoaXMuY29sdW1uRGVmLmludGVybmFsQ29sdW1uRWRpdG9yLmNvbGxlY3Rpb25Tb3J0Qnk7XHJcbiAgICAgIG91dHB1dENvbGxlY3Rpb24gPSB0aGlzLl9jb2xsZWN0aW9uU2VydmljZS5zb3J0Q29sbGVjdGlvbih0aGlzLmNvbHVtbkRlZiwgb3V0cHV0Q29sbGVjdGlvbiwgc29ydEJ5LCB0aGlzLmVuYWJsZVRyYW5zbGF0ZUxhYmVsKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0cHV0Q29sbGVjdGlvbjtcclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCByZW5kZXJEb21FbGVtZW50KGlucHV0Q29sbGVjdGlvbjogYW55W10pIHtcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dENvbGxlY3Rpb24pICYmIHRoaXMuY29sbGVjdGlvbk9wdGlvbnMgJiYgKHRoaXMuY29sbGVjdGlvbk9wdGlvbnMuY29sbGVjdGlvbkluc2lkZU9iamVjdFByb3BlcnR5IHx8IHRoaXMuY29sbGVjdGlvbk9wdGlvbnMuY29sbGVjdGlvbkluT2JqZWN0UHJvcGVydHkpKSB7XHJcbiAgICAgIGNvbnN0IGNvbGxlY3Rpb25JbnNpZGVPYmplY3RQcm9wZXJ0eSA9IHRoaXMuY29sbGVjdGlvbk9wdGlvbnMuY29sbGVjdGlvbkluc2lkZU9iamVjdFByb3BlcnR5IHx8IHRoaXMuY29sbGVjdGlvbk9wdGlvbnMuY29sbGVjdGlvbkluT2JqZWN0UHJvcGVydHk7XHJcbiAgICAgIGlucHV0Q29sbGVjdGlvbiA9IGdldERlc2NlbmRhbnRQcm9wZXJ0eShpbnB1dENvbGxlY3Rpb24sIGNvbGxlY3Rpb25JbnNpZGVPYmplY3RQcm9wZXJ0eSk7XHJcbiAgICB9XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXRDb2xsZWN0aW9uKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBcImNvbGxlY3Rpb25cIiBwYXNzZWQgdG8gdGhlIFNlbGVjdCBFZGl0b3IgaXMgbm90IGEgdmFsaWQgYXJyYXkuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gbWFrZSBhIGNvcHkgb2YgdGhlIGNvbGxlY3Rpb24gc28gdGhhdCB3ZSBkb24ndCBpbXBhY3QgU2VsZWN0RmlsdGVyLCB0aGlzIGNvdWxkIGhhcHBlbiB3aGVuIGNhbGxpbmcgXCJhZGRCbGFua0VudHJ5XCIgb3IgXCJhZGRDdXN0b21GaXJzdEVudHJ5XCJcclxuICAgIGxldCBjb2xsZWN0aW9uOiBhbnlbXSA9IFtdO1xyXG4gICAgaWYgKGlucHV0Q29sbGVjdGlvbi5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGNvbGxlY3Rpb24gPSBbLi4uaW5wdXRDb2xsZWN0aW9uXTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB1c2VyIGNhbiBvcHRpb25hbGx5IGFkZCBhIGJsYW5rIGVudHJ5IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGNvbGxlY3Rpb25cclxuICAgIC8vIG1ha2Ugc3VyZSBob3dldmVyIHRoYXQgaXQgd2Fzbid0IGFkZGVkIG1vcmUgdGhhbiBvbmNlXHJcbiAgICBpZiAodGhpcy5jb2xsZWN0aW9uT3B0aW9ucyAmJiB0aGlzLmNvbGxlY3Rpb25PcHRpb25zLmFkZEJsYW5rRW50cnkgJiYgQXJyYXkuaXNBcnJheShjb2xsZWN0aW9uKSAmJiBjb2xsZWN0aW9uLmxlbmd0aCA+IDAgJiYgY29sbGVjdGlvblswXVt0aGlzLnZhbHVlTmFtZV0gIT09ICcnKSB7XHJcbiAgICAgIGNvbGxlY3Rpb24udW5zaGlmdCh0aGlzLmNyZWF0ZUJsYW5rRW50cnkoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gdXNlciBjYW4gb3B0aW9uYWxseSBhZGQgaGlzIG93biBjdXN0b20gZW50cnkgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgY29sbGVjdGlvblxyXG4gICAgaWYgKHRoaXMuY29sbGVjdGlvbk9wdGlvbnMgJiYgdGhpcy5jb2xsZWN0aW9uT3B0aW9ucy5hZGRDdXN0b21GaXJzdEVudHJ5ICYmIEFycmF5LmlzQXJyYXkoY29sbGVjdGlvbikgJiYgY29sbGVjdGlvbi5sZW5ndGggPiAwICYmIGNvbGxlY3Rpb25bMF1bdGhpcy52YWx1ZU5hbWVdICE9PSB0aGlzLmNvbGxlY3Rpb25PcHRpb25zLmFkZEN1c3RvbUZpcnN0RW50cnlbdGhpcy52YWx1ZU5hbWVdKSB7XHJcbiAgICAgIGNvbGxlY3Rpb24udW5zaGlmdCh0aGlzLmNvbGxlY3Rpb25PcHRpb25zICYmIHRoaXMuY29sbGVjdGlvbk9wdGlvbnMuYWRkQ3VzdG9tRmlyc3RFbnRyeSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gdXNlciBjYW4gb3B0aW9uYWxseSBhZGQgaGlzIG93biBjdXN0b20gZW50cnkgYXQgdGhlIGVuZCBvZiB0aGUgY29sbGVjdGlvblxyXG4gICAgaWYgKHRoaXMuY29sbGVjdGlvbk9wdGlvbnMgJiYgdGhpcy5jb2xsZWN0aW9uT3B0aW9ucy5hZGRDdXN0b21MYXN0RW50cnkgJiYgQXJyYXkuaXNBcnJheShjb2xsZWN0aW9uKSAmJiBjb2xsZWN0aW9uLmxlbmd0aCA+IDApIHtcclxuICAgICAgY29uc3QgbGFzdENvbGxlY3Rpb25JbmRleCA9IGNvbGxlY3Rpb24ubGVuZ3RoIC0gMTtcclxuICAgICAgaWYgKGNvbGxlY3Rpb25bbGFzdENvbGxlY3Rpb25JbmRleF1bdGhpcy52YWx1ZU5hbWVdICE9PSB0aGlzLmNvbGxlY3Rpb25PcHRpb25zLmFkZEN1c3RvbUxhc3RFbnRyeVt0aGlzLnZhbHVlTmFtZV0pIHtcclxuICAgICAgICBjb2xsZWN0aW9uLnB1c2godGhpcy5jb2xsZWN0aW9uT3B0aW9ucyAmJiB0aGlzLmNvbGxlY3Rpb25PcHRpb25zLmFkZEN1c3RvbUxhc3RFbnRyeSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBsZXQgbmV3Q29sbGVjdGlvbiA9IGNvbGxlY3Rpb24gfHwgW107XHJcblxyXG4gICAgLy8gdXNlciBtaWdodCB3YW50IHRvIGZpbHRlciBhbmQvb3Igc29ydCBjZXJ0YWluIGl0ZW1zIG9mIHRoZSBjb2xsZWN0aW9uXHJcbiAgICBuZXdDb2xsZWN0aW9uID0gdGhpcy5maWx0ZXJDb2xsZWN0aW9uKG5ld0NvbGxlY3Rpb24pO1xyXG4gICAgbmV3Q29sbGVjdGlvbiA9IHRoaXMuc29ydENvbGxlY3Rpb24obmV3Q29sbGVjdGlvbik7XHJcblxyXG4gICAgLy8gc3RlcCAxLCBjcmVhdGUgSFRNTCBzdHJpbmcgdGVtcGxhdGVcclxuICAgIGNvbnN0IGVkaXRvclRlbXBsYXRlID0gdGhpcy5idWlsZFRlbXBsYXRlSHRtbFN0cmluZyhuZXdDb2xsZWN0aW9uKTtcclxuXHJcbiAgICAvLyBzdGVwIDIsIGNyZWF0ZSB0aGUgRE9NIEVsZW1lbnQgb2YgdGhlIGVkaXRvclxyXG4gICAgLy8gYWxzbyBzdWJzY3JpYmUgdG8gdGhlIG9uQ2xvc2UgZXZlbnRcclxuICAgIHRoaXMuY3JlYXRlRG9tRWxlbWVudChlZGl0b3JUZW1wbGF0ZSk7XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgYnVpbGRUZW1wbGF0ZUh0bWxTdHJpbmcoY29sbGVjdGlvbjogYW55W10pIHtcclxuICAgIGxldCBvcHRpb25zID0gJyc7XHJcbiAgICBjb25zdCBmaWVsZElkID0gdGhpcy5jb2x1bW5EZWYgJiYgdGhpcy5jb2x1bW5EZWYuaWQ7XHJcbiAgICBjb25zdCBzZXBhcmF0b3JCZXR3ZWVuTGFiZWxzID0gdGhpcy5jb2xsZWN0aW9uT3B0aW9ucyAmJiB0aGlzLmNvbGxlY3Rpb25PcHRpb25zLnNlcGFyYXRvckJldHdlZW5UZXh0TGFiZWxzIHx8ICcnO1xyXG4gICAgY29uc3QgaXNSZW5kZXJIdG1sRW5hYmxlZCA9IHRoaXMuY29sdW1uRGVmLmludGVybmFsQ29sdW1uRWRpdG9yLmVuYWJsZVJlbmRlckh0bWwgfHwgZmFsc2U7XHJcbiAgICBjb25zdCBzYW5pdGl6ZWRPcHRpb25zID0gdGhpcy5ncmlkT3B0aW9ucyAmJiB0aGlzLmdyaWRPcHRpb25zLnNhbml0aXplSHRtbE9wdGlvbnMgfHwge307XHJcblxyXG4gICAgLy8gY29sbGVjdGlvbiBjb3VsZCBiZSBhbiBBcnJheSBvZiBTdHJpbmdzIE9SIE9iamVjdHNcclxuICAgIGlmIChjb2xsZWN0aW9uLmV2ZXJ5KHggPT4gdHlwZW9mIHggPT09ICdzdHJpbmcnKSkge1xyXG4gICAgICBjb2xsZWN0aW9uLmZvckVhY2goKG9wdGlvbjogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgb3B0aW9ucyArPSBgPG9wdGlvbiB2YWx1ZT1cIiR7b3B0aW9ufVwiIGxhYmVsPVwiJHtvcHRpb259XCI+JHtvcHRpb259PC9vcHRpb24+YDtcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBhcnJheSBvZiBvYmplY3RzIHdpbGwgcmVxdWlyZSBhIGxhYmVsL3ZhbHVlIHBhaXIgdW5sZXNzIGEgY3VzdG9tU3RydWN0dXJlIGlzIHBhc3NlZFxyXG4gICAgICBjb2xsZWN0aW9uLmZvckVhY2goKG9wdGlvbjogU2VsZWN0T3B0aW9uKSA9PiB7XHJcbiAgICAgICAgaWYgKCFvcHRpb24gfHwgKG9wdGlvblt0aGlzLmxhYmVsTmFtZV0gPT09IHVuZGVmaW5lZCAmJiBvcHRpb24ubGFiZWxLZXkgPT09IHVuZGVmaW5lZCkpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgW3NlbGVjdC1lZGl0b3JdIEEgY29sbGVjdGlvbiB3aXRoIHZhbHVlL2xhYmVsIChvciB2YWx1ZS9sYWJlbEtleSB3aGVuIHVzaW5nIExvY2FsZSkgaXMgcmVxdWlyZWQgdG8gcG9wdWxhdGUgdGhlIFNlbGVjdCBsaXN0LCBmb3IgZXhhbXBsZTogeyBjb2xsZWN0aW9uOiBbIHsgdmFsdWU6ICcxJywgbGFiZWw6ICdPbmUnIH0gXSlgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbGFiZWxLZXkgPSAob3B0aW9uLmxhYmVsS2V5IHx8IG9wdGlvblt0aGlzLmxhYmVsTmFtZV0pIGFzIHN0cmluZztcclxuICAgICAgICBjb25zdCBsYWJlbFRleHQgPSAoKG9wdGlvbi5sYWJlbEtleSB8fCB0aGlzLmVuYWJsZVRyYW5zbGF0ZUxhYmVsKSAmJiBsYWJlbEtleSkgPyB0aGlzLl90cmFuc2xhdGUuaW5zdGFudChsYWJlbEtleSB8fCAnICcpIDogbGFiZWxLZXk7XHJcbiAgICAgICAgbGV0IHByZWZpeFRleHQgPSBvcHRpb25bdGhpcy5sYWJlbFByZWZpeE5hbWVdIHx8ICcnO1xyXG4gICAgICAgIGxldCBzdWZmaXhUZXh0ID0gb3B0aW9uW3RoaXMubGFiZWxTdWZmaXhOYW1lXSB8fCAnJztcclxuICAgICAgICBsZXQgb3B0aW9uTGFiZWwgPSBvcHRpb25bdGhpcy5vcHRpb25MYWJlbF0gfHwgJyc7XHJcbiAgICAgICAgaWYgKG9wdGlvbkxhYmVsICYmIG9wdGlvbkxhYmVsLnRvU3RyaW5nKSB7XHJcbiAgICAgICAgICBvcHRpb25MYWJlbCA9IG9wdGlvbkxhYmVsLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxcIi9nLCAnXFwnJyk7IC8vIHJlcGxhY2UgZG91YmxlIHF1b3RlcyBieSBzaW5nbGUgcXVvdGVzIHRvIGF2b2lkIGludGVyZmVyaW5nIHdpdGggcmVndWxhciBodG1sXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBhbHNvIHRyYW5zbGF0ZSBwcmVmaXgvc3VmZml4IGlmIGVuYWJsZVRyYW5zbGF0ZUxhYmVsIGlzIHRydWUgYW5kIHRleHQgaXMgYSBzdHJpbmdcclxuICAgICAgICBwcmVmaXhUZXh0ID0gKHRoaXMuZW5hYmxlVHJhbnNsYXRlTGFiZWwgJiYgcHJlZml4VGV4dCAmJiB0eXBlb2YgcHJlZml4VGV4dCA9PT0gJ3N0cmluZycpID8gdGhpcy5fdHJhbnNsYXRlLmluc3RhbnQocHJlZml4VGV4dCB8fCAnICcpIDogcHJlZml4VGV4dDtcclxuICAgICAgICBzdWZmaXhUZXh0ID0gKHRoaXMuZW5hYmxlVHJhbnNsYXRlTGFiZWwgJiYgc3VmZml4VGV4dCAmJiB0eXBlb2Ygc3VmZml4VGV4dCA9PT0gJ3N0cmluZycpID8gdGhpcy5fdHJhbnNsYXRlLmluc3RhbnQoc3VmZml4VGV4dCB8fCAnICcpIDogc3VmZml4VGV4dDtcclxuICAgICAgICBvcHRpb25MYWJlbCA9ICh0aGlzLmVuYWJsZVRyYW5zbGF0ZUxhYmVsICYmIG9wdGlvbkxhYmVsICYmIHR5cGVvZiBvcHRpb25MYWJlbCA9PT0gJ3N0cmluZycpID8gdGhpcy5fdHJhbnNsYXRlLmluc3RhbnQob3B0aW9uTGFiZWwgfHwgJyAnKSA6IG9wdGlvbkxhYmVsO1xyXG5cclxuICAgICAgICAvLyBhZGQgdG8gYSB0ZW1wIGFycmF5IGZvciBqb2luaW5nIHB1cnBvc2UgYW5kIGZpbHRlciBvdXQgZW1wdHkgdGV4dFxyXG4gICAgICAgIGNvbnN0IHRtcE9wdGlvbkFycmF5ID0gW3ByZWZpeFRleHQsIGxhYmVsVGV4dCwgc3VmZml4VGV4dF0uZmlsdGVyKHRleHQgPT4gKHRleHQgIT09IHVuZGVmaW5lZCAmJiB0ZXh0ICE9PSAnJykpO1xyXG4gICAgICAgIGxldCBvcHRpb25UZXh0ID0gdG1wT3B0aW9uQXJyYXkuam9pbihzZXBhcmF0b3JCZXR3ZWVuTGFiZWxzKTtcclxuXHJcbiAgICAgICAgLy8gaWYgdXNlciBzcGVjaWZpY2FsbHkgd2FudHMgdG8gcmVuZGVyIGh0bWwgdGV4dCwgaGUgbmVlZHMgdG8gb3B0LWluIGVsc2UgaXQgd2lsbCBzdHJpcHBlZCBvdXQgYnkgZGVmYXVsdFxyXG4gICAgICAgIC8vIGFsc28sIHRoZSAzcmQgcGFydHkgbGliIHdpbGwgc2FuaW5pdHplIGFueSBodG1sIGNvZGUgdW5sZXNzIGl0J3MgZW5jb2RlZCwgc28gd2UnbGwgZG8gdGhhdFxyXG4gICAgICAgIGlmIChpc1JlbmRlckh0bWxFbmFibGVkKSB7XHJcbiAgICAgICAgICAvLyBzYW5pdGl6ZSBhbnkgdW5hdXRob3JpemVkIGh0bWwgdGFncyBsaWtlIHNjcmlwdCBhbmQgb3RoZXJzXHJcbiAgICAgICAgICAvLyBmb3IgdGhlIHJlbWFpbmluZyBhbGxvd2VkIHRhZ3Mgd2UnbGwgcGVybWl0IGFsbCBhdHRyaWJ1dGVzXHJcbiAgICAgICAgICBjb25zdCBzYW5pdGl6ZWRUZXh0ID0gKERPTVB1cmlmeS5zYW5pdGl6ZShvcHRpb25UZXh0LCBzYW5pdGl6ZWRPcHRpb25zKSB8fCAnJykudG9TdHJpbmcoKTtcclxuICAgICAgICAgIG9wdGlvblRleHQgPSBodG1sRW5jb2RlKHNhbml0aXplZFRleHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaHRtbCB0ZXh0IG9mIGVhY2ggc2VsZWN0IG9wdGlvblxyXG4gICAgICAgIGxldCBvcHRpb25WYWx1ZSA9IG9wdGlvblt0aGlzLnZhbHVlTmFtZV07XHJcbiAgICAgICAgaWYgKG9wdGlvblZhbHVlID09PSB1bmRlZmluZWQgfHwgb3B0aW9uVmFsdWUgPT09IG51bGwpIHtcclxuICAgICAgICAgIG9wdGlvblZhbHVlID0gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9wdGlvbnMgKz0gYDxvcHRpb24gdmFsdWU9XCIke29wdGlvblZhbHVlfVwiIGxhYmVsPVwiJHtvcHRpb25MYWJlbH1cIj4ke29wdGlvblRleHR9PC9vcHRpb24+YDtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGA8c2VsZWN0IGlkPVwiJHt0aGlzLmVsZW1lbnROYW1lfVwiIGNsYXNzPVwibXMtZmlsdGVyIHNlYXJjaC1maWx0ZXIgZWRpdG9yLSR7ZmllbGRJZH1cIiAke3RoaXMuaXNNdWx0aXBsZVNlbGVjdCA/ICdtdWx0aXBsZT1cIm11bHRpcGxlXCInIDogJyd9PiR7b3B0aW9uc308L3NlbGVjdD5gO1xyXG4gIH1cclxuXHJcbiAgLyoqIENyZWF0ZSBhIGJsYW5rIGVudHJ5IHRoYXQgY2FuIGJlIGFkZGVkIHRvIHRoZSBjb2xsZWN0aW9uLiBJdCB3aWxsIGFsc28gcmV1c2UgdGhlIHNhbWUgY3VzdG9tU3RydWN0dXJlIGlmIG5lZWQgYmUgKi9cclxuICBwcm90ZWN0ZWQgY3JlYXRlQmxhbmtFbnRyeSgpIHtcclxuICAgIGNvbnN0IGJsYW5rRW50cnkgPSB7XHJcbiAgICAgIFt0aGlzLmxhYmVsTmFtZV06ICcnLFxyXG4gICAgICBbdGhpcy52YWx1ZU5hbWVdOiAnJ1xyXG4gICAgfTtcclxuICAgIGlmICh0aGlzLmxhYmVsUHJlZml4TmFtZSkge1xyXG4gICAgICBibGFua0VudHJ5W3RoaXMubGFiZWxQcmVmaXhOYW1lXSA9ICcnO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMubGFiZWxTdWZmaXhOYW1lKSB7XHJcbiAgICAgIGJsYW5rRW50cnlbdGhpcy5sYWJlbFN1ZmZpeE5hbWVdID0gJyc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYmxhbmtFbnRyeTtcclxuICB9XHJcblxyXG4gIC8qKiBCdWlsZCB0aGUgdGVtcGxhdGUgSFRNTCBzdHJpbmcgKi9cclxuICBwcm90ZWN0ZWQgY3JlYXRlRG9tRWxlbWVudChlZGl0b3JUZW1wbGF0ZTogc3RyaW5nKSB7XHJcbiAgICB0aGlzLiRlZGl0b3JFbG0gPSAkKGVkaXRvclRlbXBsYXRlKTtcclxuXHJcbiAgICBpZiAodGhpcy4kZWRpdG9yRWxtICYmIHR5cGVvZiB0aGlzLiRlZGl0b3JFbG0uYXBwZW5kVG8gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhpcy4kZWRpdG9yRWxtLmFwcGVuZFRvKHRoaXMuYXJncy5jb250YWluZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGFkZCBwbGFjZWhvbGRlciB3aGVuIGZvdW5kXHJcbiAgICBjb25zdCBwbGFjZWhvbGRlciA9IHRoaXMuY29sdW1uRWRpdG9yICYmIHRoaXMuY29sdW1uRWRpdG9yLnBsYWNlaG9sZGVyIHx8ICcnO1xyXG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucy5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyIHx8ICcnO1xyXG5cclxuICAgIGlmICh0eXBlb2YgdGhpcy4kZWRpdG9yRWxtLm11bHRpcGxlU2VsZWN0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIGNvbnN0IGVsZW1lbnRPcHRpb25zID0gKHRoaXMuY29sdW1uRGVmLmludGVybmFsQ29sdW1uRWRpdG9yKSA/IHRoaXMuY29sdW1uRGVmLmludGVybmFsQ29sdW1uRWRpdG9yLmVsZW1lbnRPcHRpb25zIDoge307XHJcbiAgICAgIGNvbnN0IGVkaXRvck9wdGlvbnMgPSAodGhpcy5jb2x1bW5EZWYgJiYgdGhpcy5jb2x1bW5EZWYuaW50ZXJuYWxDb2x1bW5FZGl0b3IpID8gdGhpcy5jb2x1bW5EZWYuaW50ZXJuYWxDb2x1bW5FZGl0b3IuZWRpdG9yT3B0aW9ucyA6IHt9O1xyXG4gICAgICB0aGlzLmVkaXRvckVsbU9wdGlvbnMgPSB7IC4uLnRoaXMuZGVmYXVsdE9wdGlvbnMsIC4uLmVsZW1lbnRPcHRpb25zLCAuLi5lZGl0b3JPcHRpb25zIH07XHJcbiAgICAgIHRoaXMuJGVkaXRvckVsbSA9IHRoaXMuJGVkaXRvckVsbS5tdWx0aXBsZVNlbGVjdCh0aGlzLmVkaXRvckVsbU9wdGlvbnMpO1xyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2hvdygpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIHJlZnJlc2ggdGhlIGpxdWVyeSBvYmplY3QgYmVjYXVzZSB0aGUgc2VsZWN0ZWQgY2hlY2tib3hlcyB3ZXJlIGFscmVhZHkgc2V0XHJcbiAgLy8gcHJpb3IgdG8gdGhpcyBtZXRob2QgYmVpbmcgY2FsbGVkXHJcbiAgcHJvdGVjdGVkIHJlZnJlc2goKSB7XHJcbiAgICBpZiAodHlwZW9mIHRoaXMuJGVkaXRvckVsbS5tdWx0aXBsZVNlbGVjdCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aGlzLiRlZGl0b3JFbG0ubXVsdGlwbGVTZWxlY3QoJ3JlZnJlc2gnKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuIl19