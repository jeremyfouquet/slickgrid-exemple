import * as DOMPurify_ from 'dompurify';
const DOMPurify = DOMPurify_; // patch to fix rollup to work
import { FieldType, KeyCode, } from './../models/index';
import { findOrDefault, getDescendantProperty, setDeepValue, toKebabCase } from '../services/utilities';
import { textValidator } from '../editorValidators/textValidator';
// minimum length of chars to type before starting to start querying
const MIN_LENGTH = 3;
/*
 * An example of a 'detached' editor.
 * KeyDown events are also handled to provide handling for Tab, Shift-Tab, Esc and Ctrl-Enter.
 */
export class AutoCompleteEditor {
    constructor(args) {
        this.args = args;
        if (!args) {
            throw new Error('[Angular-SlickGrid] Something is wrong with this grid, an Editor must always have valid arguments.');
        }
        this.grid = args.grid;
        this.init();
    }
    /** Getter for the Autocomplete Option */
    get autoCompleteOptions() {
        return this._autoCompleteOptions || {};
    }
    /** Get the Collection */
    get editorCollection() {
        return this.columnDef && this.columnDef.internalColumnEditor && this.columnDef.internalColumnEditor.collection || [];
    }
    /** Get the Final Collection used in the AutoCompleted Source (this may vary from the "collection" especially when providing a customStructure) */
    get elementCollection() {
        return this._elementCollection;
    }
    /** Get Column Definition object */
    get columnDef() {
        return this.args && this.args.column;
    }
    /** Get Column Editor object */
    get columnEditor() {
        return this.columnDef && this.columnDef.internalColumnEditor || {};
    }
    /** Getter for the Custom Structure if exist */
    get customStructure() {
        let customStructure = this.columnEditor && this.columnEditor.customStructure;
        const columnType = this.columnEditor && this.columnEditor.type || this.columnDef && this.columnDef.type;
        if (!customStructure && (columnType === FieldType.object && this.columnDef && this.columnDef.dataKey && this.columnDef.labelKey)) {
            customStructure = {
                label: this.columnDef.labelKey,
                value: this.columnDef.dataKey,
            };
        }
        return customStructure;
    }
    get hasAutoCommitEdit() {
        return this.gridOptions.autoCommitEdit;
    }
    /** Get the Validator function, can be passed in Editor property or Column Definition */
    get validator() {
        return this.columnEditor.validator || this.columnDef.validator;
    }
    get editorOptions() {
        return this.columnEditor && this.columnEditor.editorOptions || {};
    }
    /** jQuery UI AutoComplete instance */
    get instance() {
        return this._$editorElm.autocomplete('instance');
    }
    /** Getter for the Grid Options pulled through the Grid Object */
    get gridOptions() {
        return (this.grid && this.grid.getOptions) ? this.grid.getOptions() : {};
    }
    /** Get the Editor DOM Element */
    get editorDomElement() {
        return this._$editorElm;
    }
    init() {
        this.labelName = this.customStructure && this.customStructure.label || 'label';
        this.valueName = this.customStructure && this.customStructure.value || 'value';
        this.labelPrefixName = this.customStructure && this.customStructure.labelPrefix || 'labelPrefix';
        this.labelSuffixName = this.customStructure && this.customStructure.labelSuffix || 'labelSuffix';
        // always render the DOM element, even if user passed a "collectionAsync",
        const newCollection = this.columnEditor.collection || [];
        this.renderDomElement(newCollection);
    }
    destroy() {
        if (this._$editorElm) {
            this._$editorElm.autocomplete('destroy');
            this._$editorElm.off('keydown.nav').remove();
        }
        this._$editorElm = null;
        this._elementCollection = null;
    }
    focus() {
        if (this._$editorElm) {
            this._$editorElm.focus().select();
        }
    }
    getValue() {
        return this._$editorElm.val();
    }
    setValue(value) {
        this._$editorElm.val(value);
    }
    applyValue(item, state) {
        let newValue = state;
        const fieldName = this.columnDef && this.columnDef.field;
        // if we have a collection defined, we will try to find the string within the collection and return it
        if (Array.isArray(this.editorCollection) && this.editorCollection.length > 0) {
            newValue = findOrDefault(this.editorCollection, (collectionItem) => {
                if (collectionItem && typeof state === 'object' && collectionItem.hasOwnProperty(this.labelName)) {
                    return (collectionItem.hasOwnProperty(this.labelName) && collectionItem[this.labelName].toString()) === (state.hasOwnProperty(this.labelName) && state[this.labelName].toString());
                }
                else if (collectionItem && typeof state === 'string' && collectionItem.hasOwnProperty(this.labelName)) {
                    return (collectionItem.hasOwnProperty(this.labelName) && collectionItem[this.labelName].toString()) === state;
                }
                return collectionItem && collectionItem.toString() === state;
            });
        }
        // is the field a complex object, "address.streetNumber"
        const isComplexObject = fieldName && fieldName.indexOf('.') > 0;
        // validate the value before applying it (if not valid we'll set an empty string)
        const validation = this.validate(newValue);
        newValue = (validation && validation.valid) ? newValue : '';
        // set the new value to the item datacontext
        if (isComplexObject) {
            setDeepValue(item, fieldName, newValue);
        }
        else {
            item[fieldName] = newValue;
        }
    }
    isValueChanged() {
        const elmValue = this._$editorElm.val();
        const lastKeyEvent = this._lastInputEvent && this._lastInputEvent.keyCode;
        if (this.columnEditor && this.columnEditor.alwaysSaveOnEnterKey && lastKeyEvent === KeyCode.ENTER) {
            return true;
        }
        return (!(elmValue === '' && (this._defaultTextValue === null || this._defaultTextValue === undefined))) && (elmValue !== this._defaultTextValue);
    }
    loadValue(item) {
        const fieldName = this.columnDef && this.columnDef.field;
        if (item && fieldName !== undefined) {
            // is the field a complex object, "address.streetNumber"
            const isComplexObject = fieldName && fieldName.indexOf('.') > 0;
            const data = (isComplexObject) ? getDescendantProperty(item, fieldName) : item[fieldName];
            this._currentValue = data;
            this._defaultTextValue = typeof data === 'string' ? data : (data && data.hasOwnProperty(this.labelName) && data[this.labelName] || '');
            this._$editorElm.val(this._defaultTextValue);
            this._$editorElm.select();
        }
    }
    save() {
        const validation = this.validate();
        const isValid = (validation && validation.valid) || false;
        if (this.hasAutoCommitEdit && isValid) {
            // do not use args.commitChanges() as this sets the focus to the next row.
            // also the select list will stay shown when clicking off the grid
            this.grid.getEditorLock().commitCurrentEdit();
        }
        else {
            this.args.commitChanges();
        }
    }
    serializeValue() {
        // if you want to add the autocomplete functionality but want the user to be able to input a new option
        if (this.editorOptions.forceUserInput) {
            const minLength = this.editorOptions && this.editorOptions.hasOwnProperty('minLength') ? this.editorOptions.minLength : MIN_LENGTH;
            this._currentValue = this._$editorElm.val().length > minLength ? this._$editorElm.val() : this._currentValue;
        }
        // if user provided a custom structure, we will serialize the value returned from the object with custom structure
        if (this.customStructure && this._currentValue && this._currentValue.hasOwnProperty(this.valueName) && (this.columnDef && this.columnDef.type !== FieldType.object && this.columnEditor && this.columnEditor.type !== FieldType.object)) {
            return this._currentValue[this.valueName];
        }
        else if (this._currentValue && this._currentValue.value !== undefined) {
            // when object has a "value" property and its column is set as an Object type, we'll return an object with optional custom structure
            if (this.columnDef && this.columnDef.type === FieldType.object || ((this.columnEditor && this.columnEditor.type) === FieldType.object)) {
                return {
                    [this.labelName]: this._currentValue.label,
                    [this.valueName]: this._currentValue.value
                };
            }
            return this._currentValue.value;
        }
        // if it falls here it might be that the user provided its own custom item with something else than the regular label/value pair
        // at this point it's only available when user provide a custom template for the autocomplete renderItem callback
        return this._currentValue;
    }
    validate(inputValue) {
        const val = (inputValue !== undefined) ? inputValue : this._$editorElm && this._$editorElm.val && this._$editorElm.val();
        return textValidator(val, {
            editorArgs: this.args,
            errorMessage: this.columnEditor.errorMessage,
            minLength: this.columnEditor.minLength,
            maxLength: this.columnEditor.maxLength,
            operatorConditionalType: this.columnEditor.operatorConditionalType,
            required: this.columnEditor.required,
            validator: this.validator,
        });
    }
    //
    // private functions
    // ------------------
    // this function should be PRIVATE but for unit tests purposes we'll make it public until a better solution is found
    // a better solution would be to get the autocomplete DOM element to work with selection but I couldn't find how to do that in Jest
    onSelect(_event, ui) {
        if (ui && ui.item) {
            const item = ui && ui.item;
            this._currentValue = item;
            // when the user defines a "renderItem" (or "_renderItem") template, then we assume the user defines his own custom structure of label/value pair
            // otherwise we know that jQueryUI always require a label/value pair, we can pull them directly
            const hasCustomRenderItemCallback = this.columnEditor && this.columnEditor.callbacks && this.columnEditor.callbacks.hasOwnProperty('_renderItem') || (this.columnEditor && this.columnEditor.editorOptions && this.columnEditor.editorOptions.renderItem) || false;
            const itemLabel = typeof item === 'string' ? item : (hasCustomRenderItemCallback ? item[this.labelName] : item.label);
            this.setValue(itemLabel);
            this.save();
        }
        return false;
    }
    renderCustomItem(ul, item) {
        const templateString = this._autoCompleteOptions && this._autoCompleteOptions.renderItem && this._autoCompleteOptions.renderItem.templateCallback(item) || '';
        // sanitize any unauthorized html tags like script and others
        // for the remaining allowed tags we'll permit all attributes
        const sanitizedTemplateText = (DOMPurify.sanitize(templateString, {}) || '').toString();
        return $('<li></li>')
            .data('item.autocomplete', item)
            .append(sanitizedTemplateText)
            .appendTo(ul);
    }
    renderCollectionItem(ul, item) {
        const isRenderHtmlEnabled = this.columnEditor && this.columnEditor.enableRenderHtml || false;
        const prefixText = item.labelPrefix || '';
        const labelText = item.label || '';
        const suffixText = item.labelSuffix || '';
        const finalText = prefixText + labelText + suffixText;
        // sanitize any unauthorized html tags like script and others
        // for the remaining allowed tags we'll permit all attributes
        const sanitizedText = (DOMPurify.sanitize(finalText, {}) || '').toString();
        const $liDiv = $('<div></div>')[isRenderHtmlEnabled ? 'html' : 'text'](sanitizedText);
        return $('<li></li>')
            .data('item.autocomplete', item)
            .append($liDiv)
            .appendTo(ul);
    }
    renderDomElement(collection) {
        if (!Array.isArray(collection)) {
            throw new Error('The "collection" passed to the Autocomplete Editor is not a valid array.');
        }
        const columnId = this.columnDef && this.columnDef.id || '';
        const placeholder = this.columnEditor && this.columnEditor.placeholder || '';
        const title = this.columnEditor && this.columnEditor.title || '';
        this._$editorElm = $(`<input type="text" role="presentation" autocomplete="off" class="autocomplete editor-text editor-${columnId}" placeholder="${placeholder}" title="${title}" />`)
            .appendTo(this.args.container)
            .on('keydown.nav', (event) => {
            this._lastInputEvent = event;
            if (event.keyCode === KeyCode.LEFT || event.keyCode === KeyCode.RIGHT) {
                event.stopImmediatePropagation();
            }
        });
        // add a <span> in order to add spinner styling
        $(`<span></span>`).appendTo(this.args.container);
        // user might pass his own autocomplete options
        const autoCompleteOptions = this.columnEditor.editorOptions;
        // assign the collection to a temp variable before filtering/sorting the collection
        let finalCollection = collection;
        // user might provide his own custom structure
        // jQuery UI autocomplete requires a label/value pair, so we must remap them when user provide different ones
        if (Array.isArray(finalCollection)) {
            finalCollection = finalCollection.map((item) => {
                return { label: item[this.labelName], value: item[this.valueName], labelPrefix: item[this.labelPrefixName] || '', labelSuffix: item[this.labelSuffixName] || '' };
            });
        }
        // keep the final source collection used in the AutoComplete as reference
        this._elementCollection = finalCollection;
        // when user passes it's own autocomplete options
        // we still need to provide our own "select" callback implementation
        if (autoCompleteOptions && autoCompleteOptions.source) {
            autoCompleteOptions.select = (event, ui) => this.onSelect(event, ui);
            this._autoCompleteOptions = Object.assign({}, autoCompleteOptions);
            // when "renderItem" is defined, we need to add our custom style CSS class
            if (this._autoCompleteOptions.renderItem) {
                this._autoCompleteOptions.classes = {
                    'ui-autocomplete': `autocomplete-custom-${toKebabCase(this._autoCompleteOptions.renderItem.layout)}`
                };
            }
            // create the jQueryUI AutoComplete
            this._$editorElm.autocomplete(this._autoCompleteOptions);
            // when "renderItem" is defined, we need to call the user's custom renderItem template callback
            if (this._autoCompleteOptions.renderItem) {
                this._$editorElm.autocomplete('instance')._renderItem = this.renderCustomItem.bind(this);
            }
        }
        else {
            const definedOptions = {
                source: finalCollection,
                minLength: 0,
                select: (event, ui) => this.onSelect(event, ui),
            };
            this._autoCompleteOptions = Object.assign({}, definedOptions, this.columnEditor.editorOptions);
            this._$editorElm.autocomplete(this._autoCompleteOptions);
            // we'll use our own renderer so that it works with label prefix/suffix and also with html rendering when enabled
            this._$editorElm.autocomplete('instance')._renderItem = this.renderCollectionItem.bind(this);
        }
        // in case the user wants to save even an empty value,
        // we need to subscribe to the onKeyDown event for that use case and clear the current value
        if (this.columnEditor.alwaysSaveOnEnterKey) {
            this._$editorElm.keydown((event) => {
                if (event.keyCode === KeyCode.ENTER) {
                    this._currentValue = null;
                }
            });
        }
        // we could optionally trigger a search when clicking on the AutoComplete
        if (this.editorOptions.openSearchListOnFocus) {
            this._$editorElm.click(() => this._$editorElm.autocomplete('search', this._$editorElm.val()));
        }
        // user might override any of the jQueryUI callback methods
        if (this.columnEditor.callbacks) {
            for (const callback of Object.keys(this.columnEditor.callbacks)) {
                if (typeof this.columnEditor.callbacks[callback] === 'function') {
                    this.instance[callback] = this.columnEditor.callbacks[callback];
                }
            }
        }
        this._$editorElm.on('focus', () => {
            this._$editorElm.select();
            // we could optionally trigger a search to open the AutoComplete search list
            if (this.editorOptions.openSearchListOnFocus) {
                this._$editorElm.autocomplete('search', this._$editorElm.val());
            }
        });
        setTimeout(() => this.focus(), 50);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0b0NvbXBsZXRlRWRpdG9yLmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci1zbGlja2dyaWQvIiwic291cmNlcyI6WyJhcHAvbW9kdWxlcy9hbmd1bGFyLXNsaWNrZ3JpZC9lZGl0b3JzL2F1dG9Db21wbGV0ZUVkaXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEtBQUssVUFBVSxNQUFNLFdBQVcsQ0FBQztBQUN4QyxNQUFNLFNBQVMsR0FBRyxVQUFVLENBQUMsQ0FBQyw4QkFBOEI7QUFFNUQsT0FBTyxFQVNMLFNBQVMsRUFFVCxPQUFPLEdBQ1IsTUFBTSxtQkFBbUIsQ0FBQztBQUMzQixPQUFPLEVBQUUsYUFBYSxFQUFFLHFCQUFxQixFQUFFLFlBQVksRUFBRSxXQUFXLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUN4RyxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sbUNBQW1DLENBQUM7QUFLbEUsb0VBQW9FO0FBQ3BFLE1BQU0sVUFBVSxHQUFHLENBQUMsQ0FBQztBQUVyQjs7O0dBR0c7QUFDSCxNQUFNLE9BQU8sa0JBQWtCO0lBMkI3QixZQUFvQixJQUFxQjtRQUFyQixTQUFJLEdBQUosSUFBSSxDQUFpQjtRQUN2QyxJQUFJLENBQUMsSUFBSSxFQUFFO1lBQ1QsTUFBTSxJQUFJLEtBQUssQ0FBQyxvR0FBb0csQ0FBQyxDQUFDO1NBQ3ZIO1FBQ0QsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO1FBQ3RCLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUNkLENBQUM7SUFFRCx5Q0FBeUM7SUFDekMsSUFBSSxtQkFBbUI7UUFDckIsT0FBTyxJQUFJLENBQUMsb0JBQW9CLElBQUksRUFBRSxDQUFDO0lBQ3pDLENBQUM7SUFFRCx5QkFBeUI7SUFDekIsSUFBSSxnQkFBZ0I7UUFDbEIsT0FBTyxJQUFJLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsb0JBQW9CLElBQUksSUFBSSxDQUFD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RSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsWUFBWSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQztTQUMvRjtRQUVELDJEQUEyRDtRQUMzRCxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsU0FBUyxFQUFFO1lBQy9CLEtBQUssTUFBTSxRQUFRLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxFQUFFO2dCQUMvRCxJQUFJLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLEtBQUssVUFBVSxFQUFFO29CQUMvRCxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDO2lCQUNqRTthQUNGO1NBQ0Y7UUFFRCxJQUFJLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsR0FBRyxFQUFFO1lBQ2hDLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxFQUFFLENBQUM7WUFFMUIsNEVBQTRFO1lBQzVFLElBQUksSUFBSSxDQUFDLGFBQWEsQ0FBQyxxQkFBcUIsRUFBRTtnQkFDNUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxZQUFZLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQzthQUNqRTtRQUNILENBQUMsQ0FBQyxDQUFDO1FBRUgsVUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUNyQyxDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBET01QdXJpZnlfIGZyb20gJ2RvbXB1cmlmeSc7XHJcbmNvbnN0IERPTVB1cmlmeSA9IERPTVB1cmlmeV87IC8vIHBhdGNoIHRvIGZpeCByb2xsdXAgdG8gd29ya1xyXG5cclxuaW1wb3J0IHtcclxuICBBdXRvY29tcGxldGVPcHRpb24sXHJcbiAgQ29sbGVjdGlvbkN1c3RvbVN0cnVjdHVyZSxcclxuICBDb2x1bW4sXHJcbiAgQ29sdW1uRWRpdG9yLFxyXG4gIEVkaXRvcixcclxuICBFZGl0b3JBcmd1bWVudHMsXHJcbiAgRWRpdG9yVmFsaWRhdG9yLFxyXG4gIEVkaXRvclZhbGlkYXRvck91dHB1dCxcclxuICBGaWVsZFR5cGUsXHJcbiAgR3JpZE9wdGlvbixcclxuICBLZXlDb2RlLFxyXG59IGZyb20gJy4vLi4vbW9kZWxzL2luZGV4JztcclxuaW1wb3J0IHsgZmluZE9yRGVmYXVsdCwgZ2V0RGVzY2VuZGFudFByb3BlcnR5LCBzZXREZWVwVmFsdWUsIHRvS2ViYWJDYXNlIH0gZnJvbSAnLi4vc2VydmljZXMvdXRpbGl0aWVzJztcclxuaW1wb3J0IHsgdGV4dFZhbGlkYXRvciB9IGZyb20gJy4uL2VkaXRvclZhbGlkYXRvcnMvdGV4dFZhbGlkYXRvcic7XHJcblxyXG4vLyB1c2luZyBleHRlcm5hbCBub24tdHlwZWQganMgbGlicmFyaWVzXHJcbmRlY2xhcmUgY29uc3QgJDogYW55O1xyXG5cclxuLy8gbWluaW11bSBsZW5ndGggb2YgY2hhcnMgdG8gdHlwZSBiZWZvcmUgc3RhcnRpbmcgdG8gc3RhcnQgcXVlcnlpbmdcclxuY29uc3QgTUlOX0xFTkdUSCA9IDM7XHJcblxyXG4vKlxyXG4gKiBBbiBleGFtcGxlIG9mIGEgJ2RldGFjaGVkJyBlZGl0b3IuXHJcbiAqIEtleURvd24gZXZlbnRzIGFyZSBhbHNvIGhhbmRsZWQgdG8gcHJvdmlkZSBoYW5kbGluZyBmb3IgVGFiLCBTaGlmdC1UYWIsIEVzYyBhbmQgQ3RybC1FbnRlci5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBBdXRvQ29tcGxldGVFZGl0b3IgaW1wbGVtZW50cyBFZGl0b3Ige1xyXG4gIHByaXZhdGUgX2F1dG9Db21wbGV0ZU9wdGlvbnM6IEF1dG9jb21wbGV0ZU9wdGlvbjtcclxuICBwcml2YXRlIF9jdXJyZW50VmFsdWU6IGFueTtcclxuICBwcml2YXRlIF9kZWZhdWx0VGV4dFZhbHVlOiBzdHJpbmc7XHJcbiAgcHJpdmF0ZSBfZWxlbWVudENvbGxlY3Rpb246IGFueVtdIHwgbnVsbDtcclxuICBwcml2YXRlIF9sYXN0SW5wdXRFdmVudDogSlF1ZXJ5LkV2ZW50O1xyXG5cclxuICAvKiogVGhlIEpRdWVyeSBET00gZWxlbWVudCAqL1xyXG4gIHByaXZhdGUgXyRlZGl0b3JFbG06IGFueTtcclxuXHJcbiAgLyoqIFNsaWNrR3JpZCBHcmlkIG9iamVjdCAqL1xyXG4gIGdyaWQ6IGFueTtcclxuXHJcbiAgLyoqIFRoZSBwcm9wZXJ0eSBuYW1lIGZvciBsYWJlbHMgaW4gdGhlIGNvbGxlY3Rpb24gKi9cclxuICBsYWJlbE5hbWU6IHN0cmluZztcclxuXHJcbiAgLyoqIFRoZSBwcm9wZXJ0eSBuYW1lIGZvciBhIHByZWZpeCB0aGF0IGNhbiBiZSBhZGRlZCB0byB0aGUgbGFiZWxzIGluIHRoZSBjb2xsZWN0aW9uICovXHJcbiAgbGFiZWxQcmVmaXhOYW1lOiBzdHJpbmc7XHJcblxyXG4gIC8qKiBUaGUgcHJvcGVydHkgbmFtZSBmb3IgYSBzdWZmaXggdGhhdCBjYW4gYmUgYWRkZWQgdG8gdGhlIGxhYmVscyBpbiB0aGUgY29sbGVjdGlvbiAqL1xyXG4gIGxhYmVsU3VmZml4TmFtZTogc3RyaW5nO1xyXG5cclxuICAvKiogVGhlIHByb3BlcnR5IG5hbWUgZm9yIHZhbHVlcyBpbiB0aGUgY29sbGVjdGlvbiAqL1xyXG4gIHZhbHVlTmFtZTogc3RyaW5nO1xyXG5cclxuICBmb3JjZVVzZXJJbnB1dDogYm9vbGVhbjtcclxuXHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBhcmdzOiBFZGl0b3JBcmd1bWVudHMpIHtcclxuICAgIGlmICghYXJncykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tBbmd1bGFyLVNsaWNrR3JpZF0gU29tZXRoaW5nIGlzIHdyb25nIHdpdGggdGhpcyBncmlkLCBhbiBFZGl0b3IgbXVzdCBhbHdheXMgaGF2ZSB2YWxpZCBhcmd1bWVudHMuJyk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmdyaWQgPSBhcmdzLmdyaWQ7XHJcbiAgICB0aGlzLmluaXQoKTtcclxuICB9XHJcblxyXG4gIC8qKiBHZXR0ZXIgZm9yIHRoZSBBdXRvY29tcGxldGUgT3B0aW9uICovXHJcbiAgZ2V0IGF1dG9Db21wbGV0ZU9wdGlvbnMoKTogUGFydGlhbDxBdXRvY29tcGxldGVPcHRpb24+IHtcclxuICAgIHJldHVybiB0aGlzLl9hdXRvQ29tcGxldGVPcHRpb25zIHx8IHt9O1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldCB0aGUgQ29sbGVjdGlvbiAqL1xyXG4gIGdldCBlZGl0b3JDb2xsZWN0aW9uKCk6IGFueVtdIHtcclxuICAgIHJldHVybiB0aGlzLmNvbHVtbkRlZiAmJiB0aGlzLmNvbHVtbkRlZi5pbnRlcm5hbENvbHVtbkVkaXRvciAmJiB0aGlzLmNvbHVtbkRlZi5pbnRlcm5hbENvbHVtbkVkaXRvci5jb2xsZWN0aW9uIHx8IFtdO1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldCB0aGUgRmluYWwgQ29sbGVjdGlvbiB1c2VkIGluIHRoZSBBdXRvQ29tcGxldGVkIFNvdXJjZSAodGhpcyBtYXkgdmFyeSBmcm9tIHRoZSBcImNvbGxlY3Rpb25cIiBlc3BlY2lhbGx5IHdoZW4gcHJvdmlkaW5nIGEgY3VzdG9tU3RydWN0dXJlKSAqL1xyXG4gIGdldCBlbGVtZW50Q29sbGVjdGlvbigpOiBhbnlbXSB8IG51bGwge1xyXG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRDb2xsZWN0aW9uO1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldCBDb2x1bW4gRGVmaW5pdGlvbiBvYmplY3QgKi9cclxuICBnZXQgY29sdW1uRGVmKCk6IENvbHVtbiB8IHVuZGVmaW5lZCB7XHJcbiAgICByZXR1cm4gdGhpcy5hcmdzICYmIHRoaXMuYXJncy5jb2x1bW47XHJcbiAgfVxyXG5cclxuICAvKiogR2V0IENvbHVtbiBFZGl0b3Igb2JqZWN0ICovXHJcbiAgZ2V0IGNvbHVtbkVkaXRvcigpOiBDb2x1bW5FZGl0b3Ige1xyXG4gICAgcmV0dXJuIHRoaXMuY29sdW1uRGVmICYmIHRoaXMuY29sdW1uRGVmLmludGVybmFsQ29sdW1uRWRpdG9yIHx8IHt9O1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldHRlciBmb3IgdGhlIEN1c3RvbSBTdHJ1Y3R1cmUgaWYgZXhpc3QgKi9cclxuICBnZXQgY3VzdG9tU3RydWN0dXJlKCk6IENvbGxlY3Rpb25DdXN0b21TdHJ1Y3R1cmUge1xyXG4gICAgbGV0IGN1c3RvbVN0cnVjdHVyZSA9IHRoaXMuY29sdW1uRWRpdG9yICYmIHRoaXMuY29sdW1uRWRpdG9yLmN1c3RvbVN0cnVjdHVyZTtcclxuICAgIGNvbnN0IGNvbHVtblR5cGUgPSB0aGlzLmNvbHVtbkVkaXRvciAmJiB0aGlzLmNvbHVtbkVkaXRvci50eXBlIHx8IHRoaXMuY29sdW1uRGVmICYmIHRoaXMuY29sdW1uRGVmLnR5cGU7XHJcbiAgICBpZiAoIWN1c3RvbVN0cnVjdHVyZSAmJiAoY29sdW1uVHlwZSA9PT0gRmllbGRUeXBlLm9iamVjdCAmJiB0aGlzLmNvbHVtbkRlZiAmJiB0aGlzLmNvbHVtbkRlZi5kYXRhS2V5ICYmIHRoaXMuY29sdW1uRGVmLmxhYmVsS2V5KSkge1xyXG4gICAgICBjdXN0b21TdHJ1Y3R1cmUgPSB7XHJcbiAgICAgICAgbGFiZWw6IHRoaXMuY29sdW1uRGVmLmxhYmVsS2V5LFxyXG4gICAgICAgIHZhbHVlOiB0aGlzLmNvbHVtbkRlZi5kYXRhS2V5LFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGN1c3RvbVN0cnVjdHVyZTtcclxuICB9XHJcblxyXG4gIGdldCBoYXNBdXRvQ29tbWl0RWRpdCgpIHtcclxuICAgIHJldHVybiB0aGlzLmdyaWRPcHRpb25zLmF1dG9Db21taXRFZGl0O1xyXG4gIH1cclxuXHJcbiAgLyoqIEdldCB0aGUgVmFsaWRhdG9yIGZ1bmN0aW9uLCBjYW4gYmUgcGFzc2VkIGluIEVkaXRvciBwcm9wZXJ0eSBvciBDb2x1bW4gRGVmaW5pdGlvbiAqL1xyXG4gIGdldCB2YWxpZGF0b3IoKTogRWRpdG9yVmFsaWRhdG9yIHtcclxuICAgIHJldHVybiB0aGlzLmNvbHVtbkVkaXRvci52YWxpZGF0b3IgfHwgdGhpcy5jb2x1bW5EZWYudmFsaWRhdG9yO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGVkaXRvck9wdGlvbnMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb2x1bW5FZGl0b3IgJiYgdGhpcy5jb2x1bW5FZGl0b3IuZWRpdG9yT3B0aW9ucyB8fCB7fTtcclxuICB9XHJcblxyXG4gIC8qKiBqUXVlcnkgVUkgQXV0b0NvbXBsZXRlIGluc3RhbmNlICovXHJcbiAgZ2V0IGluc3RhbmNlKCk6IGFueSB7XHJcbiAgICByZXR1cm4gdGhpcy5fJGVkaXRvckVsbS5hdXRvY29tcGxldGUoJ2luc3RhbmNlJyk7XHJcbiAgfVxyXG5cclxuICAvKiogR2V0dGVyIGZvciB0aGUgR3JpZCBPcHRpb25zIHB1bGxlZCB0aHJvdWdoIHRoZSBHcmlkIE9iamVjdCAqL1xyXG4gIGdldCBncmlkT3B0aW9ucygpOiBHcmlkT3B0aW9uIHtcclxuICAgIHJldHVybiAodGhpcy5ncmlkICYmIHRoaXMuZ3JpZC5nZXRPcHRpb25zKSA/IHRoaXMuZ3JpZC5nZXRPcHRpb25zKCkgOiB7fTtcclxuICB9XHJcblxyXG4gIC8qKiBHZXQgdGhlIEVkaXRvciBET00gRWxlbWVudCAqL1xyXG4gIGdldCBlZGl0b3JEb21FbGVtZW50KCk6IGFueSB7XHJcbiAgICByZXR1cm4gdGhpcy5fJGVkaXRvckVsbTtcclxuICB9XHJcblxyXG4gIGluaXQoKSB7XHJcbiAgICB0aGlzLmxhYmVsTmFtZSA9IHRoaXMuY3VzdG9tU3RydWN0dXJlICYmIHRoaXMuY3VzdG9tU3RydWN0dXJlLmxhYmVsIHx8ICdsYWJlbCc7XHJcbiAgICB0aGlzLnZhbHVlTmFtZSA9IHRoaXMuY3VzdG9tU3RydWN0dXJlICYmIHRoaXMuY3VzdG9tU3RydWN0dXJlLnZhbHVlIHx8ICd2YWx1ZSc7XHJcbiAgICB0aGlzLmxhYmVsUHJlZml4TmFtZSA9IHRoaXMuY3VzdG9tU3RydWN0dXJlICYmIHRoaXMuY3VzdG9tU3RydWN0dXJlLmxhYmVsUHJlZml4IHx8ICdsYWJlbFByZWZpeCc7XHJcbiAgICB0aGlzLmxhYmVsU3VmZml4TmFtZSA9IHRoaXMuY3VzdG9tU3RydWN0dXJlICYmIHRoaXMuY3VzdG9tU3RydWN0dXJlLmxhYmVsU3VmZml4IHx8ICdsYWJlbFN1ZmZpeCc7XHJcblxyXG4gICAgLy8gYWx3YXlzIHJlbmRlciB0aGUgRE9NIGVsZW1lbnQsIGV2ZW4gaWYgdXNlciBwYXNzZWQgYSBcImNvbGxlY3Rpb25Bc3luY1wiLFxyXG4gICAgY29uc3QgbmV3Q29sbGVjdGlvbiA9IHRoaXMuY29sdW1uRWRpdG9yLmNvbGxlY3Rpb24gfHwgW107XHJcbiAgICB0aGlzLnJlbmRlckRvbUVsZW1lbnQobmV3Q29sbGVjdGlvbik7XHJcbiAgfVxyXG5cclxuICBkZXN0cm95KCkge1xyXG4gICAgaWYgKHRoaXMuXyRlZGl0b3JFbG0pIHtcclxuICAgICAgdGhpcy5fJGVkaXRvckVsbS5hdXRvY29tcGxldGUoJ2Rlc3Ryb3knKTtcclxuICAgICAgdGhpcy5fJGVkaXRvckVsbS5vZmYoJ2tleWRvd24ubmF2JykucmVtb3ZlKCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl8kZWRpdG9yRWxtID0gbnVsbDtcclxuICAgIHRoaXMuX2VsZW1lbnRDb2xsZWN0aW9uID0gbnVsbDtcclxuICB9XHJcblxyXG4gIGZvY3VzKCkge1xyXG4gICAgaWYgKHRoaXMuXyRlZGl0b3JFbG0pIHtcclxuICAgICAgdGhpcy5fJGVkaXRvckVsbS5mb2N1cygpLnNlbGVjdCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZ2V0VmFsdWUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fJGVkaXRvckVsbS52YWwoKTtcclxuICB9XHJcblxyXG4gIHNldFZhbHVlKHZhbHVlOiBzdHJpbmcpIHtcclxuICAgIHRoaXMuXyRlZGl0b3JFbG0udmFsKHZhbHVlKTtcclxuICB9XHJcblxyXG4gIGFwcGx5VmFsdWUoaXRlbTogYW55LCBzdGF0ZTogYW55KSB7XHJcbiAgICBsZXQgbmV3VmFsdWUgPSBzdGF0ZTtcclxuICAgIGNvbnN0IGZpZWxkTmFtZSA9IHRoaXMuY29sdW1uRGVmICYmIHRoaXMuY29sdW1uRGVmLmZpZWxkO1xyXG5cclxuICAgIC8vIGlmIHdlIGhhdmUgYSBjb2xsZWN0aW9uIGRlZmluZWQsIHdlIHdpbGwgdHJ5IHRvIGZpbmQgdGhlIHN0cmluZyB3aXRoaW4gdGhlIGNvbGxlY3Rpb24gYW5kIHJldHVybiBpdFxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5lZGl0b3JDb2xsZWN0aW9uKSAmJiB0aGlzLmVkaXRvckNvbGxlY3Rpb24ubGVuZ3RoID4gMCkge1xyXG4gICAgICBuZXdWYWx1ZSA9IGZpbmRPckRlZmF1bHQodGhpcy5lZGl0b3JDb2xsZWN0aW9uLCAoY29sbGVjdGlvbkl0ZW06IGFueSkgPT4ge1xyXG4gICAgICAgIGlmIChjb2xsZWN0aW9uSXRlbSAmJiB0eXBlb2Ygc3RhdGUgPT09ICdvYmplY3QnICYmIGNvbGxlY3Rpb25JdGVtLmhhc093blByb3BlcnR5KHRoaXMubGFiZWxOYW1lKSkge1xyXG4gICAgICAgICAgcmV0dXJuIChjb2xsZWN0aW9uSXRlbS5oYXNPd25Qcm9wZXJ0eSh0aGlzLmxhYmVsTmFtZSkgJiYgY29sbGVjdGlvbkl0ZW1bdGhpcy5sYWJlbE5hbWVdLnRvU3RyaW5nKCkpID09PSAoc3RhdGUuaGFzT3duUHJvcGVydHkodGhpcy5sYWJlbE5hbWUpICYmIHN0YXRlW3RoaXMubGFiZWxOYW1lXS50b1N0cmluZygpKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGNvbGxlY3Rpb25JdGVtICYmIHR5cGVvZiBzdGF0ZSA9PT0gJ3N0cmluZycgJiYgY29sbGVjdGlvbkl0ZW0uaGFzT3duUHJvcGVydHkodGhpcy5sYWJlbE5hbWUpKSB7XHJcbiAgICAgICAgICByZXR1cm4gKGNvbGxlY3Rpb25JdGVtLmhhc093blByb3BlcnR5KHRoaXMubGFiZWxOYW1lKSAmJiBjb2xsZWN0aW9uSXRlbVt0aGlzLmxhYmVsTmFtZV0udG9TdHJpbmcoKSkgPT09IHN0YXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbkl0ZW0gJiYgY29sbGVjdGlvbkl0ZW0udG9TdHJpbmcoKSA9PT0gc3RhdGU7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGlzIHRoZSBmaWVsZCBhIGNvbXBsZXggb2JqZWN0LCBcImFkZHJlc3Muc3RyZWV0TnVtYmVyXCJcclxuICAgIGNvbnN0IGlzQ29tcGxleE9iamVjdCA9IGZpZWxkTmFtZSAmJiBmaWVsZE5hbWUuaW5kZXhPZignLicpID4gMDtcclxuXHJcbiAgICAvLyB2YWxpZGF0ZSB0aGUgdmFsdWUgYmVmb3JlIGFwcGx5aW5nIGl0IChpZiBub3QgdmFsaWQgd2UnbGwgc2V0IGFuIGVtcHR5IHN0cmluZylcclxuICAgIGNvbnN0IHZhbGlkYXRpb24gPSB0aGlzLnZhbGlkYXRlKG5ld1ZhbHVlKTtcclxuICAgIG5ld1ZhbHVlID0gKHZhbGlkYXRpb24gJiYgdmFsaWRhdGlvbi52YWxpZCkgPyBuZXdWYWx1ZSA6ICcnO1xyXG5cclxuICAgIC8vIHNldCB0aGUgbmV3IHZhbHVlIHRvIHRoZSBpdGVtIGRhdGFjb250ZXh0XHJcbiAgICBpZiAoaXNDb21wbGV4T2JqZWN0KSB7XHJcbiAgICAgIHNldERlZXBWYWx1ZShpdGVtLCBmaWVsZE5hbWUsIG5ld1ZhbHVlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGl0ZW1bZmllbGROYW1lXSA9IG5ld1ZhbHVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaXNWYWx1ZUNoYW5nZWQoKTogYm9vbGVhbiB7XHJcbiAgICBjb25zdCBlbG1WYWx1ZSA9IHRoaXMuXyRlZGl0b3JFbG0udmFsKCk7XHJcbiAgICBjb25zdCBsYXN0S2V5RXZlbnQgPSB0aGlzLl9sYXN0SW5wdXRFdmVudCAmJiB0aGlzLl9sYXN0SW5wdXRFdmVudC5rZXlDb2RlO1xyXG4gICAgaWYgKHRoaXMuY29sdW1uRWRpdG9yICYmIHRoaXMuY29sdW1uRWRpdG9yLmFsd2F5c1NhdmVPbkVudGVyS2V5ICYmIGxhc3RLZXlFdmVudCA9PT0gS2V5Q29kZS5FTlRFUikge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiAoIShlbG1WYWx1ZSA9PT0gJycgJiYgKHRoaXMuX2RlZmF1bHRUZXh0VmFsdWUgPT09IG51bGwgfHwgdGhpcy5fZGVmYXVsdFRleHRWYWx1ZSA9PT0gdW5kZWZpbmVkKSkpICYmIChlbG1WYWx1ZSAhPT0gdGhpcy5fZGVmYXVsdFRleHRWYWx1ZSk7XHJcbiAgfVxyXG5cclxuICBsb2FkVmFsdWUoaXRlbTogYW55KSB7XHJcbiAgICBjb25zdCBmaWVsZE5hbWUgPSB0aGlzLmNvbHVtbkRlZiAmJiB0aGlzLmNvbHVtbkRlZi5maWVsZDtcclxuXHJcbiAgICBpZiAoaXRlbSAmJiBmaWVsZE5hbWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAvLyBpcyB0aGUgZmllbGQgYSBjb21wbGV4IG9iamVjdCwgXCJhZGRyZXNzLnN0cmVldE51bWJlclwiXHJcbiAgICAgIGNvbnN0IGlzQ29tcGxleE9iamVjdCA9IGZpZWxkTmFtZSAmJiBmaWVsZE5hbWUuaW5kZXhPZignLicpID4gMDtcclxuICAgICAgY29uc3QgZGF0YSA9IChpc0NvbXBsZXhPYmplY3QpID8gZ2V0RGVzY2VuZGFudFByb3BlcnR5KGl0ZW0sIGZpZWxkTmFtZSkgOiBpdGVtW2ZpZWxkTmFtZV07XHJcblxyXG4gICAgICB0aGlzLl9jdXJyZW50VmFsdWUgPSBkYXRhO1xyXG4gICAgICB0aGlzLl9kZWZhdWx0VGV4dFZhbHVlID0gdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnID8gZGF0YSA6IChkYXRhICYmIGRhdGEuaGFzT3duUHJvcGVydHkodGhpcy5sYWJlbE5hbWUpICYmIGRhdGFbdGhpcy5sYWJlbE5hbWVdIHx8ICcnKTtcclxuICAgICAgdGhpcy5fJGVkaXRvckVsbS52YWwodGhpcy5fZGVmYXVsdFRleHRWYWx1ZSk7XHJcbiAgICAgIHRoaXMuXyRlZGl0b3JFbG0uc2VsZWN0KCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzYXZlKCkge1xyXG4gICAgY29uc3QgdmFsaWRhdGlvbiA9IHRoaXMudmFsaWRhdGUoKTtcclxuICAgIGNvbnN0IGlzVmFsaWQgPSAodmFsaWRhdGlvbiAmJiB2YWxpZGF0aW9uLnZhbGlkKSB8fCBmYWxzZTtcclxuXHJcbiAgICBpZiAodGhpcy5oYXNBdXRvQ29tbWl0RWRpdCAmJiBpc1ZhbGlkKSB7XHJcbiAgICAgIC8vIGRvIG5vdCB1c2UgYXJncy5jb21taXRDaGFuZ2VzKCkgYXMgdGhpcyBzZXRzIHRoZSBmb2N1cyB0byB0aGUgbmV4dCByb3cuXHJcbiAgICAgIC8vIGFsc28gdGhlIHNlbGVjdCBsaXN0IHdpbGwgc3RheSBzaG93biB3aGVuIGNsaWNraW5nIG9mZiB0aGUgZ3JpZFxyXG4gICAgICB0aGlzLmdyaWQuZ2V0RWRpdG9yTG9jaygpLmNvbW1pdEN1cnJlbnRFZGl0KCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmFyZ3MuY29tbWl0Q2hhbmdlcygpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc2VyaWFsaXplVmFsdWUoKTogYW55IHtcclxuICAgIC8vIGlmIHlvdSB3YW50IHRvIGFkZCB0aGUgYXV0b2NvbXBsZXRlIGZ1bmN0aW9uYWxpdHkgYnV0IHdhbnQgdGhlIHVzZXIgdG8gYmUgYWJsZSB0byBpbnB1dCBhIG5ldyBvcHRpb25cclxuICAgIGlmICh0aGlzLmVkaXRvck9wdGlvbnMuZm9yY2VVc2VySW5wdXQpIHtcclxuICAgICAgY29uc3QgbWluTGVuZ3RoID0gdGhpcy5lZGl0b3JPcHRpb25zICYmIHRoaXMuZWRpdG9yT3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnbWluTGVuZ3RoJykgPyB0aGlzLmVkaXRvck9wdGlvbnMubWluTGVuZ3RoIDogTUlOX0xFTkdUSDtcclxuICAgICAgdGhpcy5fY3VycmVudFZhbHVlID0gdGhpcy5fJGVkaXRvckVsbS52YWwoKS5sZW5ndGggPiBtaW5MZW5ndGggPyB0aGlzLl8kZWRpdG9yRWxtLnZhbCgpIDogdGhpcy5fY3VycmVudFZhbHVlO1xyXG4gICAgfVxyXG4gICAgLy8gaWYgdXNlciBwcm92aWRlZCBhIGN1c3RvbSBzdHJ1Y3R1cmUsIHdlIHdpbGwgc2VyaWFsaXplIHRoZSB2YWx1ZSByZXR1cm5lZCBmcm9tIHRoZSBvYmplY3Qgd2l0aCBjdXN0b20gc3RydWN0dXJlXHJcbiAgICBpZiAodGhpcy5jdXN0b21TdHJ1Y3R1cmUgJiYgdGhpcy5fY3VycmVudFZhbHVlICYmIHRoaXMuX2N1cnJlbnRWYWx1ZS5oYXNPd25Qcm9wZXJ0eSh0aGlzLnZhbHVlTmFtZSkgJiYgKHRoaXMuY29sdW1uRGVmICYmIHRoaXMuY29sdW1uRGVmLnR5cGUgIT09IEZpZWxkVHlwZS5vYmplY3QgJiYgdGhpcy5jb2x1bW5FZGl0b3IgJiYgdGhpcy5jb2x1bW5FZGl0b3IudHlwZSAhPT0gRmllbGRUeXBlLm9iamVjdCkpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRWYWx1ZVt0aGlzLnZhbHVlTmFtZV07XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2N1cnJlbnRWYWx1ZSAmJiB0aGlzLl9jdXJyZW50VmFsdWUudmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAvLyB3aGVuIG9iamVjdCBoYXMgYSBcInZhbHVlXCIgcHJvcGVydHkgYW5kIGl0cyBjb2x1bW4gaXMgc2V0IGFzIGFuIE9iamVjdCB0eXBlLCB3ZSdsbCByZXR1cm4gYW4gb2JqZWN0IHdpdGggb3B0aW9uYWwgY3VzdG9tIHN0cnVjdHVyZVxyXG4gICAgICBpZiAodGhpcy5jb2x1bW5EZWYgJiYgdGhpcy5jb2x1bW5EZWYudHlwZSA9PT0gRmllbGRUeXBlLm9iamVjdCB8fCAoKHRoaXMuY29sdW1uRWRpdG9yICYmIHRoaXMuY29sdW1uRWRpdG9yLnR5cGUpID09PSBGaWVsZFR5cGUub2JqZWN0KSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBbdGhpcy5sYWJlbE5hbWVdOiB0aGlzLl9jdXJyZW50VmFsdWUubGFiZWwsXHJcbiAgICAgICAgICBbdGhpcy52YWx1ZU5hbWVdOiB0aGlzLl9jdXJyZW50VmFsdWUudmFsdWVcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50VmFsdWUudmFsdWU7XHJcbiAgICB9XHJcbiAgICAvLyBpZiBpdCBmYWxscyBoZXJlIGl0IG1pZ2h0IGJlIHRoYXQgdGhlIHVzZXIgcHJvdmlkZWQgaXRzIG93biBjdXN0b20gaXRlbSB3aXRoIHNvbWV0aGluZyBlbHNlIHRoYW4gdGhlIHJlZ3VsYXIgbGFiZWwvdmFsdWUgcGFpclxyXG4gICAgLy8gYXQgdGhpcyBwb2ludCBpdCdzIG9ubHkgYXZhaWxhYmxlIHdoZW4gdXNlciBwcm92aWRlIGEgY3VzdG9tIHRlbXBsYXRlIGZvciB0aGUgYXV0b2NvbXBsZXRlIHJlbmRlckl0ZW0gY2FsbGJhY2tcclxuICAgIHJldHVybiB0aGlzLl9jdXJyZW50VmFsdWU7XHJcbiAgfVxyXG5cclxuICB2YWxpZGF0ZShpbnB1dFZhbHVlPzogYW55KTogRWRpdG9yVmFsaWRhdG9yT3V0cHV0IHtcclxuICAgIGNvbnN0IHZhbCA9IChpbnB1dFZhbHVlICE9PSB1bmRlZmluZWQpID8gaW5wdXRWYWx1ZSA6IHRoaXMuXyRlZGl0b3JFbG0gJiYgdGhpcy5fJGVkaXRvckVsbS52YWwgJiYgdGhpcy5fJGVkaXRvckVsbS52YWwoKTtcclxuICAgIHJldHVybiB0ZXh0VmFsaWRhdG9yKHZhbCwge1xyXG4gICAgICBlZGl0b3JBcmdzOiB0aGlzLmFyZ3MsXHJcbiAgICAgIGVycm9yTWVzc2FnZTogdGhpcy5jb2x1bW5FZGl0b3IuZXJyb3JNZXNzYWdlLFxyXG4gICAgICBtaW5MZW5ndGg6IHRoaXMuY29sdW1uRWRpdG9yLm1pbkxlbmd0aCxcclxuICAgICAgbWF4TGVuZ3RoOiB0aGlzLmNvbHVtbkVkaXRvci5tYXhMZW5ndGgsXHJcbiAgICAgIG9wZXJhdG9yQ29uZGl0aW9uYWxUeXBlOiB0aGlzLmNvbHVtbkVkaXRvci5vcGVyYXRvckNvbmRpdGlvbmFsVHlwZSxcclxuICAgICAgcmVxdWlyZWQ6IHRoaXMuY29sdW1uRWRpdG9yLnJlcXVpcmVkLFxyXG4gICAgICB2YWxpZGF0b3I6IHRoaXMudmFsaWRhdG9yLFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvL1xyXG4gIC8vIHByaXZhdGUgZnVuY3Rpb25zXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8vIHRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIFBSSVZBVEUgYnV0IGZvciB1bml0IHRlc3RzIHB1cnBvc2VzIHdlJ2xsIG1ha2UgaXQgcHVibGljIHVudGlsIGEgYmV0dGVyIHNvbHV0aW9uIGlzIGZvdW5kXHJcbiAgLy8gYSBiZXR0ZXIgc29sdXRpb24gd291bGQgYmUgdG8gZ2V0IHRoZSBhdXRvY29tcGxldGUgRE9NIGVsZW1lbnQgdG8gd29yayB3aXRoIHNlbGVjdGlvbiBidXQgSSBjb3VsZG4ndCBmaW5kIGhvdyB0byBkbyB0aGF0IGluIEplc3RcclxuICBvblNlbGVjdChfZXZlbnQ6IEV2ZW50LCB1aTogeyBpdGVtOiBhbnk7IH0pIHtcclxuICAgIGlmICh1aSAmJiB1aS5pdGVtKSB7XHJcbiAgICAgIGNvbnN0IGl0ZW0gPSB1aSAmJiB1aS5pdGVtO1xyXG4gICAgICB0aGlzLl9jdXJyZW50VmFsdWUgPSBpdGVtO1xyXG4gICAgICAvLyB3aGVuIHRoZSB1c2VyIGRlZmluZXMgYSBcInJlbmRlckl0ZW1cIiAob3IgXCJfcmVuZGVySXRlbVwiKSB0ZW1wbGF0ZSwgdGhlbiB3ZSBhc3N1bWUgdGhlIHVzZXIgZGVmaW5lcyBoaXMgb3duIGN1c3RvbSBzdHJ1Y3R1cmUgb2YgbGFiZWwvdmFsdWUgcGFpclxyXG4gICAgICAvLyBvdGhlcndpc2Ugd2Uga25vdyB0aGF0IGpRdWVyeVVJIGFsd2F5cyByZXF1aXJlIGEgbGFiZWwvdmFsdWUgcGFpciwgd2UgY2FuIHB1bGwgdGhlbSBkaXJlY3RseVxyXG4gICAgICBjb25zdCBoYXNDdXN0b21SZW5kZXJJdGVtQ2FsbGJhY2sgPSB0aGlzLmNvbHVtbkVkaXRvciAmJiB0aGlzLmNvbHVtbkVkaXRvci5jYWxsYmFja3MgJiYgdGhpcy5jb2x1bW5FZGl0b3IuY2FsbGJhY2tzLmhhc093blByb3BlcnR5KCdfcmVuZGVySXRlbScpIHx8ICh0aGlzLmNvbHVtbkVkaXRvciAmJiB0aGlzLmNvbHVtbkVkaXRvci5lZGl0b3JPcHRpb25zICYmIHRoaXMuY29sdW1uRWRpdG9yLmVkaXRvck9wdGlvbnMucmVuZGVySXRlbSkgfHwgZmFsc2U7XHJcblxyXG4gICAgICBjb25zdCBpdGVtTGFiZWwgPSB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycgPyBpdGVtIDogKGhhc0N1c3RvbVJlbmRlckl0ZW1DYWxsYmFjayA/IGl0ZW1bdGhpcy5sYWJlbE5hbWVdIDogaXRlbS5sYWJlbCk7XHJcbiAgICAgIHRoaXMuc2V0VmFsdWUoaXRlbUxhYmVsKTtcclxuICAgICAgdGhpcy5zYXZlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHJlbmRlckN1c3RvbUl0ZW0odWw6IEhUTUxFbGVtZW50LCBpdGVtOiBhbnkpIHtcclxuICAgIGNvbnN0IHRlbXBsYXRlU3RyaW5nID0gdGhpcy5fYXV0b0NvbXBsZXRlT3B0aW9ucyAmJiB0aGlzLl9hdXRvQ29tcGxldGVPcHRpb25zLnJlbmRlckl0ZW0gJiYgdGhpcy5fYXV0b0NvbXBsZXRlT3B0aW9ucy5yZW5kZXJJdGVtLnRlbXBsYXRlQ2FsbGJhY2soaXRlbSkgfHwgJyc7XHJcblxyXG4gICAgLy8gc2FuaXRpemUgYW55IHVuYXV0aG9yaXplZCBodG1sIHRhZ3MgbGlrZSBzY3JpcHQgYW5kIG90aGVyc1xyXG4gICAgLy8gZm9yIHRoZSByZW1haW5pbmcgYWxsb3dlZCB0YWdzIHdlJ2xsIHBlcm1pdCBhbGwgYXR0cmlidXRlc1xyXG4gICAgY29uc3Qgc2FuaXRpemVkVGVtcGxhdGVUZXh0ID0gKERPTVB1cmlmeS5zYW5pdGl6ZSh0ZW1wbGF0ZVN0cmluZywge30pIHx8ICcnKS50b1N0cmluZygpO1xyXG5cclxuICAgIHJldHVybiAkKCc8bGk+PC9saT4nKVxyXG4gICAgICAuZGF0YSgnaXRlbS5hdXRvY29tcGxldGUnLCBpdGVtKVxyXG4gICAgICAuYXBwZW5kKHNhbml0aXplZFRlbXBsYXRlVGV4dClcclxuICAgICAgLmFwcGVuZFRvKHVsKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgcmVuZGVyQ29sbGVjdGlvbkl0ZW0odWw6IEhUTUxFbGVtZW50LCBpdGVtOiBhbnkpIHtcclxuICAgIGNvbnN0IGlzUmVuZGVySHRtbEVuYWJsZWQgPSB0aGlzLmNvbHVtbkVkaXRvciAmJiB0aGlzLmNvbHVtbkVkaXRvci5lbmFibGVSZW5kZXJIdG1sIHx8IGZhbHNlO1xyXG4gICAgY29uc3QgcHJlZml4VGV4dCA9IGl0ZW0ubGFiZWxQcmVmaXggfHwgJyc7XHJcbiAgICBjb25zdCBsYWJlbFRleHQgPSBpdGVtLmxhYmVsIHx8ICcnO1xyXG4gICAgY29uc3Qgc3VmZml4VGV4dCA9IGl0ZW0ubGFiZWxTdWZmaXggfHwgJyc7XHJcbiAgICBjb25zdCBmaW5hbFRleHQgPSBwcmVmaXhUZXh0ICsgbGFiZWxUZXh0ICsgc3VmZml4VGV4dDtcclxuXHJcbiAgICAvLyBzYW5pdGl6ZSBhbnkgdW5hdXRob3JpemVkIGh0bWwgdGFncyBsaWtlIHNjcmlwdCBhbmQgb3RoZXJzXHJcbiAgICAvLyBmb3IgdGhlIHJlbWFpbmluZyBhbGxvd2VkIHRhZ3Mgd2UnbGwgcGVybWl0IGFsbCBhdHRyaWJ1dGVzXHJcbiAgICBjb25zdCBzYW5pdGl6ZWRUZXh0ID0gKERPTVB1cmlmeS5zYW5pdGl6ZShmaW5hbFRleHQsIHt9KSB8fCAnJykudG9TdHJpbmcoKTtcclxuXHJcbiAgICBjb25zdCAkbGlEaXYgPSAkKCc8ZGl2PjwvZGl2PicpW2lzUmVuZGVySHRtbEVuYWJsZWQgPyAnaHRtbCcgOiAndGV4dCddKHNhbml0aXplZFRleHQpO1xyXG4gICAgcmV0dXJuICQoJzxsaT48L2xpPicpXHJcbiAgICAgIC5kYXRhKCdpdGVtLmF1dG9jb21wbGV0ZScsIGl0ZW0pXHJcbiAgICAgIC5hcHBlbmQoJGxpRGl2KVxyXG4gICAgICAuYXBwZW5kVG8odWwpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSByZW5kZXJEb21FbGVtZW50KGNvbGxlY3Rpb246IGFueVtdKSB7XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29sbGVjdGlvbikpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgXCJjb2xsZWN0aW9uXCIgcGFzc2VkIHRvIHRoZSBBdXRvY29tcGxldGUgRWRpdG9yIGlzIG5vdCBhIHZhbGlkIGFycmF5LicpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgY29sdW1uSWQgPSB0aGlzLmNvbHVtbkRlZiAmJiB0aGlzLmNvbHVtbkRlZi5pZCB8fCAnJztcclxuICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gdGhpcy5jb2x1bW5FZGl0b3IgJiYgdGhpcy5jb2x1bW5FZGl0b3IucGxhY2Vob2xkZXIgfHwgJyc7XHJcbiAgICBjb25zdCB0aXRsZSA9IHRoaXMuY29sdW1uRWRpdG9yICYmIHRoaXMuY29sdW1uRWRpdG9yLnRpdGxlIHx8ICcnO1xyXG5cclxuICAgIHRoaXMuXyRlZGl0b3JFbG0gPSAkKGA8aW5wdXQgdHlwZT1cInRleHRcIiByb2xlPVwicHJlc2VudGF0aW9uXCIgYXV0b2NvbXBsZXRlPVwib2ZmXCIgY2xhc3M9XCJhdXRvY29tcGxldGUgZWRpdG9yLXRleHQgZWRpdG9yLSR7Y29sdW1uSWR9XCIgcGxhY2Vob2xkZXI9XCIke3BsYWNlaG9sZGVyfVwiIHRpdGxlPVwiJHt0aXRsZX1cIiAvPmApXHJcbiAgICAgIC5hcHBlbmRUbyh0aGlzLmFyZ3MuY29udGFpbmVyKVxyXG4gICAgICAub24oJ2tleWRvd24ubmF2JywgKGV2ZW50OiBKUXVlcnkuRXZlbnQpID0+IHtcclxuICAgICAgICB0aGlzLl9sYXN0SW5wdXRFdmVudCA9IGV2ZW50O1xyXG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBLZXlDb2RlLkxFRlQgfHwgZXZlbnQua2V5Q29kZSA9PT0gS2V5Q29kZS5SSUdIVCkge1xyXG4gICAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAvLyBhZGQgYSA8c3Bhbj4gaW4gb3JkZXIgdG8gYWRkIHNwaW5uZXIgc3R5bGluZ1xyXG4gICAgJChgPHNwYW4+PC9zcGFuPmApLmFwcGVuZFRvKHRoaXMuYXJncy5jb250YWluZXIpO1xyXG5cclxuICAgIC8vIHVzZXIgbWlnaHQgcGFzcyBoaXMgb3duIGF1dG9jb21wbGV0ZSBvcHRpb25zXHJcbiAgICBjb25zdCBhdXRvQ29tcGxldGVPcHRpb25zOiBBdXRvY29tcGxldGVPcHRpb24gPSB0aGlzLmNvbHVtbkVkaXRvci5lZGl0b3JPcHRpb25zO1xyXG5cclxuICAgIC8vIGFzc2lnbiB0aGUgY29sbGVjdGlvbiB0byBhIHRlbXAgdmFyaWFibGUgYmVmb3JlIGZpbHRlcmluZy9zb3J0aW5nIHRoZSBjb2xsZWN0aW9uXHJcbiAgICBsZXQgZmluYWxDb2xsZWN0aW9uID0gY29sbGVjdGlvbjtcclxuXHJcbiAgICAvLyB1c2VyIG1pZ2h0IHByb3ZpZGUgaGlzIG93biBjdXN0b20gc3RydWN0dXJlXHJcbiAgICAvLyBqUXVlcnkgVUkgYXV0b2NvbXBsZXRlIHJlcXVpcmVzIGEgbGFiZWwvdmFsdWUgcGFpciwgc28gd2UgbXVzdCByZW1hcCB0aGVtIHdoZW4gdXNlciBwcm92aWRlIGRpZmZlcmVudCBvbmVzXHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmaW5hbENvbGxlY3Rpb24pKSB7XHJcbiAgICAgIGZpbmFsQ29sbGVjdGlvbiA9IGZpbmFsQ29sbGVjdGlvbi5tYXAoKGl0ZW0pID0+IHtcclxuICAgICAgICByZXR1cm4geyBsYWJlbDogaXRlbVt0aGlzLmxhYmVsTmFtZV0sIHZhbHVlOiBpdGVtW3RoaXMudmFsdWVOYW1lXSwgbGFiZWxQcmVmaXg6IGl0ZW1bdGhpcy5sYWJlbFByZWZpeE5hbWVdIHx8ICcnLCBsYWJlbFN1ZmZpeDogaXRlbVt0aGlzLmxhYmVsU3VmZml4TmFtZV0gfHwgJycgfTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8ga2VlcCB0aGUgZmluYWwgc291cmNlIGNvbGxlY3Rpb24gdXNlZCBpbiB0aGUgQXV0b0NvbXBsZXRlIGFzIHJlZmVyZW5jZVxyXG4gICAgdGhpcy5fZWxlbWVudENvbGxlY3Rpb24gPSBmaW5hbENvbGxlY3Rpb247XHJcblxyXG4gICAgLy8gd2hlbiB1c2VyIHBhc3NlcyBpdCdzIG93biBhdXRvY29tcGxldGUgb3B0aW9uc1xyXG4gICAgLy8gd2Ugc3RpbGwgbmVlZCB0byBwcm92aWRlIG91ciBvd24gXCJzZWxlY3RcIiBjYWxsYmFjayBpbXBsZW1lbnRhdGlvblxyXG4gICAgaWYgKGF1dG9Db21wbGV0ZU9wdGlvbnMgJiYgYXV0b0NvbXBsZXRlT3B0aW9ucy5zb3VyY2UpIHtcclxuICAgICAgYXV0b0NvbXBsZXRlT3B0aW9ucy5zZWxlY3QgPSAoZXZlbnQ6IEV2ZW50LCB1aTogeyBpdGVtOiBhbnk7IH0pID0+IHRoaXMub25TZWxlY3QoZXZlbnQsIHVpKTtcclxuICAgICAgdGhpcy5fYXV0b0NvbXBsZXRlT3B0aW9ucyA9IHsgLi4uYXV0b0NvbXBsZXRlT3B0aW9ucyB9O1xyXG5cclxuICAgICAgLy8gd2hlbiBcInJlbmRlckl0ZW1cIiBpcyBkZWZpbmVkLCB3ZSBuZWVkIHRvIGFkZCBvdXIgY3VzdG9tIHN0eWxlIENTUyBjbGFzc1xyXG4gICAgICBpZiAodGhpcy5fYXV0b0NvbXBsZXRlT3B0aW9ucy5yZW5kZXJJdGVtKSB7XHJcbiAgICAgICAgdGhpcy5fYXV0b0NvbXBsZXRlT3B0aW9ucy5jbGFzc2VzID0ge1xyXG4gICAgICAgICAgJ3VpLWF1dG9jb21wbGV0ZSc6IGBhdXRvY29tcGxldGUtY3VzdG9tLSR7dG9LZWJhYkNhc2UodGhpcy5fYXV0b0NvbXBsZXRlT3B0aW9ucy5yZW5kZXJJdGVtLmxheW91dCl9YFxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgLy8gY3JlYXRlIHRoZSBqUXVlcnlVSSBBdXRvQ29tcGxldGVcclxuICAgICAgdGhpcy5fJGVkaXRvckVsbS5hdXRvY29tcGxldGUodGhpcy5fYXV0b0NvbXBsZXRlT3B0aW9ucyk7XHJcblxyXG4gICAgICAvLyB3aGVuIFwicmVuZGVySXRlbVwiIGlzIGRlZmluZWQsIHdlIG5lZWQgdG8gY2FsbCB0aGUgdXNlcidzIGN1c3RvbSByZW5kZXJJdGVtIHRlbXBsYXRlIGNhbGxiYWNrXHJcbiAgICAgIGlmICh0aGlzLl9hdXRvQ29tcGxldGVPcHRpb25zLnJlbmRlckl0ZW0pIHtcclxuICAgICAgICB0aGlzLl8kZWRpdG9yRWxtLmF1dG9jb21wbGV0ZSgnaW5zdGFuY2UnKS5fcmVuZGVySXRlbSA9IHRoaXMucmVuZGVyQ3VzdG9tSXRlbS5iaW5kKHRoaXMpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBkZWZpbmVkT3B0aW9uczogQXV0b2NvbXBsZXRlT3B0aW9uID0ge1xyXG4gICAgICAgIHNvdXJjZTogZmluYWxDb2xsZWN0aW9uLFxyXG4gICAgICAgIG1pbkxlbmd0aDogMCxcclxuICAgICAgICBzZWxlY3Q6IChldmVudDogRXZlbnQsIHVpOiB7IGl0ZW06IGFueTsgfSkgPT4gdGhpcy5vblNlbGVjdChldmVudCwgdWkpLFxyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLl9hdXRvQ29tcGxldGVPcHRpb25zID0geyAuLi5kZWZpbmVkT3B0aW9ucywgLi4uKHRoaXMuY29sdW1uRWRpdG9yLmVkaXRvck9wdGlvbnMgYXMgQXV0b2NvbXBsZXRlT3B0aW9uKSB9O1xyXG4gICAgICB0aGlzLl8kZWRpdG9yRWxtLmF1dG9jb21wbGV0ZSh0aGlzLl9hdXRvQ29tcGxldGVPcHRpb25zKTtcclxuXHJcbiAgICAgIC8vIHdlJ2xsIHVzZSBvdXIgb3duIHJlbmRlcmVyIHNvIHRoYXQgaXQgd29ya3Mgd2l0aCBsYWJlbCBwcmVmaXgvc3VmZml4IGFuZCBhbHNvIHdpdGggaHRtbCByZW5kZXJpbmcgd2hlbiBlbmFibGVkXHJcbiAgICAgIHRoaXMuXyRlZGl0b3JFbG0uYXV0b2NvbXBsZXRlKCdpbnN0YW5jZScpLl9yZW5kZXJJdGVtID0gdGhpcy5yZW5kZXJDb2xsZWN0aW9uSXRlbS5iaW5kKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGluIGNhc2UgdGhlIHVzZXIgd2FudHMgdG8gc2F2ZSBldmVuIGFuIGVtcHR5IHZhbHVlLFxyXG4gICAgLy8gd2UgbmVlZCB0byBzdWJzY3JpYmUgdG8gdGhlIG9uS2V5RG93biBldmVudCBmb3IgdGhhdCB1c2UgY2FzZSBhbmQgY2xlYXIgdGhlIGN1cnJlbnQgdmFsdWVcclxuICAgIGlmICh0aGlzLmNvbHVtbkVkaXRvci5hbHdheXNTYXZlT25FbnRlcktleSkge1xyXG4gICAgICB0aGlzLl8kZWRpdG9yRWxtLmtleWRvd24oKGV2ZW50OiBKUXVlcnkuRXZlbnQpID0+IHtcclxuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gS2V5Q29kZS5FTlRFUikge1xyXG4gICAgICAgICAgdGhpcy5fY3VycmVudFZhbHVlID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHdlIGNvdWxkIG9wdGlvbmFsbHkgdHJpZ2dlciBhIHNlYXJjaCB3aGVuIGNsaWNraW5nIG9uIHRoZSBBdXRvQ29tcGxldGVcclxuICAgIGlmICh0aGlzLmVkaXRvck9wdGlvbnMub3BlblNlYXJjaExpc3RPbkZvY3VzKSB7XHJcbiAgICAgIHRoaXMuXyRlZGl0b3JFbG0uY2xpY2soKCkgPT4gdGhpcy5fJGVkaXRvckVsbS5hdXRvY29tcGxldGUoJ3NlYXJjaCcsIHRoaXMuXyRlZGl0b3JFbG0udmFsKCkpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB1c2VyIG1pZ2h0IG92ZXJyaWRlIGFueSBvZiB0aGUgalF1ZXJ5VUkgY2FsbGJhY2sgbWV0aG9kc1xyXG4gICAgaWYgKHRoaXMuY29sdW1uRWRpdG9yLmNhbGxiYWNrcykge1xyXG4gICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIE9iamVjdC5rZXlzKHRoaXMuY29sdW1uRWRpdG9yLmNhbGxiYWNrcykpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuY29sdW1uRWRpdG9yLmNhbGxiYWNrc1tjYWxsYmFja10gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgIHRoaXMuaW5zdGFuY2VbY2FsbGJhY2tdID0gdGhpcy5jb2x1bW5FZGl0b3IuY2FsbGJhY2tzW2NhbGxiYWNrXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl8kZWRpdG9yRWxtLm9uKCdmb2N1cycsICgpID0+IHtcclxuICAgICAgdGhpcy5fJGVkaXRvckVsbS5zZWxlY3QoKTtcclxuXHJcbiAgICAgIC8vIHdlIGNvdWxkIG9wdGlvbmFsbHkgdHJpZ2dlciBhIHNlYXJjaCB0byBvcGVuIHRoZSBBdXRvQ29tcGxldGUgc2VhcmNoIGxpc3RcclxuICAgICAgaWYgKHRoaXMuZWRpdG9yT3B0aW9ucy5vcGVuU2VhcmNoTGlzdE9uRm9jdXMpIHtcclxuICAgICAgICB0aGlzLl8kZWRpdG9yRWxtLmF1dG9jb21wbGV0ZSgnc2VhcmNoJywgdGhpcy5fJGVkaXRvckVsbS52YWwoKSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5mb2N1cygpLCA1MCk7XHJcbiAgfVxyXG59XHJcbiJdfQ==