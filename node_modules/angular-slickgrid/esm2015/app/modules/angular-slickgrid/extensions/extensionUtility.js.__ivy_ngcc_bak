import * as tslib_1 from "tslib";
import { Injectable, Optional } from '@angular/core';
import { TranslateService } from '@ngx-translate/core';
import { Constants } from '../constants';
import { ExtensionName } from '../models/index';
import { SharedService } from '../services/shared.service';
import { getTranslationPrefix } from '../services/utilities';
let ExtensionUtility = class ExtensionUtility {
    constructor(sharedService, translate) {
        this.sharedService = sharedService;
        this.translate = translate;
    }
    /**
     * Load SlickGrid Extension (Control/Plugin) dynamically (on demand)
     * This will basically only load the extension when user enables the feature
     * @param extensionName
     */
    loadExtensionDynamically(extensionName) {
        try {
            switch (extensionName) {
                case ExtensionName.autoTooltip:
                    require('slickgrid/plugins/slick.autotooltips');
                    break;
                case ExtensionName.cellExternalCopyManager:
                    require('slickgrid/plugins/slick.cellexternalcopymanager');
                    break;
                case ExtensionName.checkboxSelector:
                    require('slickgrid/plugins/slick.checkboxselectcolumn');
                    break;
                case ExtensionName.cellMenu:
                    require('slickgrid/plugins/slick.cellmenu');
                    break;
                case ExtensionName.columnPicker:
                    require('slickgrid/controls/slick.columnpicker');
                    break;
                case ExtensionName.contextMenu:
                    require('slickgrid/plugins/slick.contextmenu');
                    break;
                case ExtensionName.draggableGrouping:
                    require('slickgrid/plugins/slick.draggablegrouping');
                    break;
                case ExtensionName.gridMenu:
                    require('slickgrid/controls/slick.gridmenu');
                    break;
                case ExtensionName.groupItemMetaProvider:
                    require('slickgrid/slick.groupitemmetadataprovider');
                    break;
                case ExtensionName.headerButton:
                    require('slickgrid/plugins/slick.headerbuttons');
                    break;
                case ExtensionName.headerMenu:
                    require('slickgrid/plugins/slick.headermenu');
                    break;
                case ExtensionName.rowSelection:
                    require('slickgrid/plugins/slick.rowselectionmodel');
                    break;
                case ExtensionName.rowDetailView:
                    require('slickgrid/plugins/slick.rowdetailview');
                    break;
                case ExtensionName.rowMoveManager:
                    require('slickgrid/plugins/slick.rowmovemanager');
                    break;
            }
        }
        catch (e) {
            // do nothing, we fall here when using Angular and RequireJS
        }
    }
    /**
     * From a Grid Menu object property name, we will return the correct title output string following this order
     * 1- if user provided a title, use it as the output title
     * 2- else if user provided a title key, use it to translate the output title
     * 3- else if nothing is provided use text defined as constants
     */
    getPickerTitleOutputString(propName, pickerName) {
        if (this.sharedService.gridOptions && this.sharedService.gridOptions.enableTranslate && (!this.translate || !this.translate.instant)) {
            throw new Error('[Angular-Slickgrid] requires "ngx-translate" to be installed and configured when the grid option "enableTranslate" is enabled.');
        }
        let output = '';
        const picker = this.sharedService.gridOptions && this.sharedService.gridOptions[pickerName] || {};
        const enableTranslate = this.sharedService.gridOptions && this.sharedService.gridOptions.enableTranslate || false;
        // get locales provided by user in forRoot or else use default English locales via the Constants
        const locales = this.sharedService && this.sharedService.gridOptions && this.sharedService.gridOptions.locales || Constants.locales;
        const title = picker && picker[propName];
        const titleKey = picker && picker[`${propName}Key`];
        const gridOptions = this.sharedService.gridOptions;
        const translationPrefix = getTranslationPrefix(gridOptions);
        if (titleKey && this.translate && this.translate.currentLang && this.translate.instant) {
            output = this.translate.instant(titleKey || ' ');
        }
        else {
            switch (propName) {
                case 'customTitle':
                    output = title || enableTranslate && this.translate && this.translate.currentLang && this.translate.instant && this.translate.instant(`${translationPrefix}COMMANDS` || ' ') || locales && locales.TEXT_COMMANDS;
                    break;
                case 'columnTitle':
                    output = title || enableTranslate && this.translate && this.translate.currentLang && this.translate.instant && this.translate.instant(`${translationPrefix}COLUMNS` || ' ') || locales && locales.TEXT_COLUMNS;
                    break;
                case 'forceFitTitle':
                    output = title || enableTranslate && this.translate && this.translate.currentLang && this.translate.instant && this.translate.instant(`${translationPrefix}FORCE_FIT_COLUMNS` || ' ') || locales && locales.TEXT_FORCE_FIT_COLUMNS;
                    break;
                case 'syncResizeTitle':
                    output = title || enableTranslate && this.translate && this.translate.currentLang && this.translate.instant && this.translate.instant(`${translationPrefix}SYNCHRONOUS_RESIZE` || ' ') || locales && locales.TEXT_SYNCHRONOUS_RESIZE;
                    break;
                default:
                    output = title;
                    break;
            }
        }
        return output;
    }
    /**
     * Loop through object provided and set to null any property found starting with "onX"
     * @param {Object}: obj
     */
    nullifyFunctionNameStartingWithOn(obj) {
        if (obj) {
            for (const prop of Object.keys(obj)) {
                if (prop.startsWith('on')) {
                    obj[prop] = null;
                }
            }
        }
    }
    /**
     * When using ColumnPicker/GridMenu to show/hide a column, we potentially need to readjust the grid option "frozenColumn" index.
     * That is because SlickGrid freezes by column index and it has no knowledge of the columns themselves and won't change the index, we need to do that ourselves whenever necessary.
     * Note: we call this method right after the visibleColumns array got updated, it won't work properly if we call it before the setting the visibleColumns.
     * @param {String} pickerColumnId - what is the column id triggered by the picker
     * @param {Number} frozenColumnIndex - current frozenColumn index
     * @param {Boolean} showingColumn - is the column being shown or hidden?
     * @param {Array<Object>} allColumns - all columns (including hidden ones)
     * @param {Array<Object>} visibleColumns - only visible columns (excluding hidden ones)
     */
    readjustFrozenColumnIndexWhenNeeded(pickerColumnId, frozenColumnIndex, showingColumn, allColumns, visibleColumns) {
        if (frozenColumnIndex >= 0 && pickerColumnId) {
            // calculate a possible frozenColumn index variance
            let frozenColIndexVariance = 0;
            if (showingColumn) {
                const definedFrozenColumnIndex = visibleColumns.findIndex(col => col.id === this.sharedService.frozenVisibleColumnId);
                const columnIndex = visibleColumns.findIndex(col => col.id === pickerColumnId);
                frozenColIndexVariance = (columnIndex >= 0 && (frozenColumnIndex >= columnIndex || definedFrozenColumnIndex === columnIndex)) ? 1 : 0;
            }
            else {
                const columnIndex = allColumns.findIndex(col => col.id === pickerColumnId);
                frozenColIndexVariance = (columnIndex >= 0 && frozenColumnIndex >= columnIndex) ? -1 : 0;
            }
            // if we have a variance different than 0 then apply it
            const newFrozenColIndex = frozenColumnIndex + frozenColIndexVariance;
            if (frozenColIndexVariance !== 0) {
                this.sharedService.grid.setOptions({ frozenColumn: newFrozenColIndex });
            }
            // to freeze columns, we need to take only the visible columns and we also need to use setColumns() when some of them are hidden
            // to make sure that we only use the visible columns, not doing this would show back some of the hidden columns
            if (Array.isArray(visibleColumns) && Array.isArray(allColumns) && visibleColumns.length !== allColumns.length) {
                this.sharedService.grid.setColumns(visibleColumns);
            }
        }
    }
    /**
     * Sort items (by pointers) in an array by a property name
     * @params items array
     * @param property name to sort with
     */
    sortItems(items, propertyName) {
        // sort the custom items by their position in the list
        if (Array.isArray(items)) {
            items.sort((itemA, itemB) => {
                if (itemA && itemB && itemA.hasOwnProperty(propertyName) && itemB.hasOwnProperty(propertyName)) {
                    return itemA[propertyName] - itemB[propertyName];
                }
                return 0;
            });
        }
    }
    /** Translate the an array of items from an input key and assign to the output key */
    translateItems(items, inputKey, outputKey) {
        if (Array.isArray(items)) {
            for (const item of items) {
                if (item[inputKey]) {
                    item[outputKey] = this.translate && this.translate && this.translate.currentLang && this.translate.instant && this.translate.instant(item[inputKey]);
                }
            }
        }
    }
    /**
     * When "enabledTranslate" is set to True, we will try to translate if the Translate Service exist or use the Locales when not
     * @param translationKey
     * @param localeKey
     */
    translateWhenEnabledAndServiceExist(translationKey, localeKey) {
        let text = '';
        const gridOptions = this.sharedService && this.sharedService.gridOptions;
        // get locales provided by user in main file or else use default English locales via the Constants
        const locales = gridOptions && gridOptions.locales || Constants.locales;
        if (gridOptions.enableTranslate && this.translate && this.translate.currentLang && this.translate.instant) {
            text = this.translate.instant(translationKey || ' ');
        }
        else if (locales && locales.hasOwnProperty(localeKey)) {
            text = locales[localeKey];
        }
        else {
            text = localeKey;
        }
        return text;
    }
};
ExtensionUtility.ctorParameters = () => [
    { type: SharedService },
    { type: TranslateService, decorators: [{ type: Optional }] }
];
ExtensionUtility = tslib_1.__decorate([
    Injectable(),
    tslib_1.__param(1, Optional())
], ExtensionUtility);
export { ExtensionUtility };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXh0ZW5zaW9uVXRpbGl0eS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2FuZ3VsYXItc2xpY2tncmlkLyIsInNvdXJjZXMiOlsiYXBwL21vZHVsZXMvYW5ndWxhci1zbGlja2dyaWQvZXh0ZW5zaW9ucy9leHRlbnNpb25VdGlsaXR5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNyRCxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUV2RCxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sY0FBYyxDQUFDO0FBQ3pDLE9BQU8sRUFBVSxhQUFhLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUN4RCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFDM0QsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFLN0QsSUFBYSxnQkFBZ0IsR0FBN0IsTUFBYSxnQkFBZ0I7SUFDM0IsWUFBb0IsYUFBNEIsRUFBc0IsU0FBMkI7UUFBN0Usa0JBQWEsR0FBYixhQUFhLENBQWU7UUFBc0IsY0FBUyxHQUFULFNBQVMsQ0FBa0I7SUFBSSxDQUFDO0lBRXRHOzs7O09BSUc7SUFDSCx3QkFBd0IsQ0FBQyxhQUE0QjtRQUNuRCxJQUFJO1lBQ0YsUUFBUSxhQUFhLEVBQUU7Z0JBQ3JCLEtBQUssYUFBYSxDQUFDLFdBQVc7b0JBQzVCLE9BQU8sQ0FBQyxzQ0FBc0MsQ0FBQyxDQUFDO29CQUNoRCxNQUFNO2dCQUNSLEtBQUssYUFBYSxDQUFDLHVCQUF1QjtvQkFDeEMsT0FBTyxDQUFDLGlEQUFpRCxDQUFDLENBQUM7b0JBQzNELE1BQU07Z0JBQ1IsS0FBSyxhQUFhLENBQUMsZ0JBQWdCO29CQUNqQyxPQUFPLENBQUMsOENBQThDLENBQUMsQ0FBQztvQkFDeEQsTUFBTTtnQkFDUixLQUFLLGFBQWEsQ0FBQyxRQUFRO29CQUN6QixP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QUFlLElBQUksSUFBSSxDQUFDLFNBQVMsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sRUFBRTtZQUN6RyxJQUFJLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsY0FBYyxJQUFJLEdBQUcsQ0FBQyxDQUFDO1NBQ3REO2FBQU0sSUFBSSxPQUFPLElBQUksT0FBTyxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsRUFBRTtZQUN2RCxJQUFJLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1NBQzNCO2FBQU07WUFDTCxJQUFJLEdBQUcsU0FBUyxDQUFDO1NBQ2xCO1FBQ0QsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0NBQ0YsQ0FBQTs7WUE1TW9DLGFBQWE7WUFBaUMsZ0JBQWdCLHVCQUE5QyxRQUFROztBQURoRCxnQkFBZ0I7SUFENUIsVUFBVSxFQUFFO0lBRXdDLG1CQUFBLFFBQVEsRUFBRSxDQUFBO0dBRGxELGdCQUFnQixDQTZNNUI7U0E3TVksZ0JBQWdCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgVHJhbnNsYXRlU2VydmljZSB9IGZyb20gJ0BuZ3gtdHJhbnNsYXRlL2NvcmUnO1xyXG5cclxuaW1wb3J0IHsgQ29uc3RhbnRzIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcclxuaW1wb3J0IHsgQ29sdW1uLCBFeHRlbnNpb25OYW1lIH0gZnJvbSAnLi4vbW9kZWxzL2luZGV4JztcclxuaW1wb3J0IHsgU2hhcmVkU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL3NoYXJlZC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgZ2V0VHJhbnNsYXRpb25QcmVmaXggfSBmcm9tICcuLi9zZXJ2aWNlcy91dGlsaXRpZXMnO1xyXG5cclxuZGVjbGFyZSBmdW5jdGlvbiByZXF1aXJlKG5hbWU6IHN0cmluZyk7XHJcblxyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBFeHRlbnNpb25VdGlsaXR5IHtcclxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHNoYXJlZFNlcnZpY2U6IFNoYXJlZFNlcnZpY2UsIEBPcHRpb25hbCgpIHByaXZhdGUgdHJhbnNsYXRlOiBUcmFuc2xhdGVTZXJ2aWNlKSB7IH1cclxuXHJcbiAgLyoqXHJcbiAgICogTG9hZCBTbGlja0dyaWQgRXh0ZW5zaW9uIChDb250cm9sL1BsdWdpbikgZHluYW1pY2FsbHkgKG9uIGRlbWFuZClcclxuICAgKiBUaGlzIHdpbGwgYmFzaWNhbGx5IG9ubHkgbG9hZCB0aGUgZXh0ZW5zaW9uIHdoZW4gdXNlciBlbmFibGVzIHRoZSBmZWF0dXJlXHJcbiAgICogQHBhcmFtIGV4dGVuc2lvbk5hbWVcclxuICAgKi9cclxuICBsb2FkRXh0ZW5zaW9uRHluYW1pY2FsbHkoZXh0ZW5zaW9uTmFtZTogRXh0ZW5zaW9uTmFtZSk6IGFueSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBzd2l0Y2ggKGV4dGVuc2lvbk5hbWUpIHtcclxuICAgICAgICBjYXNlIEV4dGVuc2lvbk5hbWUuYXV0b1Rvb2x0aXA6XHJcbiAgICAgICAgICByZXF1aXJlKCdzbGlja2dyaWQvcGx1Z2lucy9zbGljay5hdXRvdG9vbHRpcHMnKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgRXh0ZW5zaW9uTmFtZS5jZWxsRXh0ZXJuYWxDb3B5TWFuYWdlcjpcclxuICAgICAgICAgIHJlcXVpcmUoJ3NsaWNrZ3JpZC9wbHVnaW5zL3NsaWNrLmNlbGxleHRlcm5hbGNvcHltYW5hZ2VyJyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEV4dGVuc2lvbk5hbWUuY2hlY2tib3hTZWxlY3RvcjpcclxuICAgICAgICAgIHJlcXVpcmUoJ3NsaWNrZ3JpZC9wbHVnaW5zL3NsaWNrLmNoZWNrYm94c2VsZWN0Y29sdW1uJyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEV4dGVuc2lvbk5hbWUuY2VsbE1lbnU6XHJcbiAgICAgICAgICByZXF1aXJlKCdzbGlja2dyaWQvcGx1Z2lucy9zbGljay5jZWxsbWVudScpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBFeHRlbnNpb25OYW1lLmNvbHVtblBpY2tlcjpcclxuICAgICAgICAgIHJlcXVpcmUoJ3NsaWNrZ3JpZC9jb250cm9scy9zbGljay5jb2x1bW5waWNrZXInKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgRXh0ZW5zaW9uTmFtZS5jb250ZXh0TWVudTpcclxuICAgICAgICAgIHJlcXVpcmUoJ3NsaWNrZ3JpZC9wbHVnaW5zL3NsaWNrLmNvbnRleHRtZW51Jyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEV4dGVuc2lvbk5hbWUuZHJhZ2dhYmxlR3JvdXBpbmc6XHJcbiAgICAgICAgICByZXF1aXJlKCdzbGlja2dyaWQvcGx1Z2lucy9zbGljay5kcmFnZ2FibGVncm91cGluZycpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBFeHRlbnNpb25OYW1lLmdyaWRNZW51OlxyXG4gICAgICAgICAgcmVxdWlyZSgnc2xpY2tncmlkL2NvbnRyb2xzL3NsaWNrLmdyaWRtZW51Jyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEV4dGVuc2lvbk5hbWUuZ3JvdXBJdGVtTWV0YVByb3ZpZGVyOlxyXG4gICAgICAgICAgcmVxdWlyZSgnc2xpY2tncmlkL3NsaWNrLmdyb3VwaXRlbW1ldGFkYXRhcHJvdmlkZXInKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgRXh0ZW5zaW9uTmFtZS5oZWFkZXJCdXR0b246XHJcbiAgICAgICAgICByZXF1aXJlKCdzbGlja2dyaWQvcGx1Z2lucy9zbGljay5oZWFkZXJidXR0b25zJyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEV4dGVuc2lvbk5hbWUuaGVhZGVyTWVudTpcclxuICAgICAgICAgIHJlcXVpcmUoJ3NsaWNrZ3JpZC9wbHVnaW5zL3NsaWNrLmhlYWRlcm1lbnUnKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgRXh0ZW5zaW9uTmFtZS5yb3dTZWxlY3Rpb246XHJcbiAgICAgICAgICByZXF1aXJlKCdzbGlja2dyaWQvcGx1Z2lucy9zbGljay5yb3dzZWxlY3Rpb25tb2RlbCcpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBFeHRlbnNpb25OYW1lLnJvd0RldGFpbFZpZXc6XHJcbiAgICAgICAgICByZXF1aXJlKCdzbGlja2dyaWQvcGx1Z2lucy9zbGljay5yb3dkZXRhaWx2aWV3Jyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEV4dGVuc2lvbk5hbWUucm93TW92ZU1hbmFnZXI6XHJcbiAgICAgICAgICByZXF1aXJlKCdzbGlja2dyaWQvcGx1Z2lucy9zbGljay5yb3dtb3ZlbWFuYWdlcicpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgLy8gZG8gbm90aGluZywgd2UgZmFsbCBoZXJlIHdoZW4gdXNpbmcgQW5ndWxhciBhbmQgUmVxdWlyZUpTXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGcm9tIGEgR3JpZCBNZW51IG9iamVjdCBwcm9wZXJ0eSBuYW1lLCB3ZSB3aWxsIHJldHVybiB0aGUgY29ycmVjdCB0aXRsZSBvdXRwdXQgc3RyaW5nIGZvbGxvd2luZyB0aGlzIG9yZGVyXHJcbiAgICogMS0gaWYgdXNlciBwcm92aWRlZCBhIHRpdGxlLCB1c2UgaXQgYXMgdGhlIG91dHB1dCB0aXRsZVxyXG4gICAqIDItIGVsc2UgaWYgdXNlciBwcm92aWRlZCBhIHRpdGxlIGtleSwgdXNlIGl0IHRvIHRyYW5zbGF0ZSB0aGUgb3V0cHV0IHRpdGxlXHJcbiAgICogMy0gZWxzZSBpZiBub3RoaW5nIGlzIHByb3ZpZGVkIHVzZSB0ZXh0IGRlZmluZWQgYXMgY29uc3RhbnRzXHJcbiAgICovXHJcbiAgZ2V0UGlja2VyVGl0bGVPdXRwdXRTdHJpbmcocHJvcE5hbWU6IHN0cmluZywgcGlja2VyTmFtZTogJ2dyaWRNZW51JyB8ICdjb2x1bW5QaWNrZXInKSB7XHJcbiAgICBpZiAodGhpcy5zaGFyZWRTZXJ2aWNlLmdyaWRPcHRpb25zICYmIHRoaXMuc2hhcmVkU2VydmljZS5ncmlkT3B0aW9ucy5lbmFibGVUcmFuc2xhdGUgJiYgKCF0aGlzLnRyYW5zbGF0ZSB8fCAhdGhpcy50cmFuc2xhdGUuaW5zdGFudCkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdbQW5ndWxhci1TbGlja2dyaWRdIHJlcXVpcmVzIFwibmd4LXRyYW5zbGF0ZVwiIHRvIGJlIGluc3RhbGxlZCBhbmQgY29uZmlndXJlZCB3aGVuIHRoZSBncmlkIG9wdGlvbiBcImVuYWJsZVRyYW5zbGF0ZVwiIGlzIGVuYWJsZWQuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IG91dHB1dCA9ICcnO1xyXG4gICAgY29uc3QgcGlja2VyID0gdGhpcy5zaGFyZWRTZXJ2aWNlLmdyaWRPcHRpb25zICYmIHRoaXMuc2hhcmVkU2VydmljZS5ncmlkT3B0aW9uc1twaWNrZXJOYW1lXSB8fCB7fTtcclxuICAgIGNvbnN0IGVuYWJsZVRyYW5zbGF0ZSA9IHRoaXMuc2hhcmVkU2VydmljZS5ncmlkT3B0aW9ucyAmJiB0aGlzLnNoYXJlZFNlcnZpY2UuZ3JpZE9wdGlvbnMuZW5hYmxlVHJhbnNsYXRlIHx8IGZhbHNlO1xyXG5cclxuICAgIC8vIGdldCBsb2NhbGVzIHByb3ZpZGVkIGJ5IHVzZXIgaW4gZm9yUm9vdCBvciBlbHNlIHVzZSBkZWZhdWx0IEVuZ2xpc2ggbG9jYWxlcyB2aWEgdGhlIENvbnN0YW50c1xyXG4gICAgY29uc3QgbG9jYWxlcyA9IHRoaXMuc2hhcmVkU2VydmljZSAmJiB0aGlzLnNoYXJlZFNlcnZpY2UuZ3JpZE9wdGlvbnMgJiYgdGhpcy5zaGFyZWRTZXJ2aWNlLmdyaWRPcHRpb25zLmxvY2FsZXMgfHwgQ29uc3RhbnRzLmxvY2FsZXM7XHJcblxyXG4gICAgY29uc3QgdGl0bGUgPSBwaWNrZXIgJiYgcGlja2VyW3Byb3BOYW1lXTtcclxuICAgIGNvbnN0IHRpdGxlS2V5ID0gcGlja2VyICYmIHBpY2tlcltgJHtwcm9wTmFtZX1LZXlgXTtcclxuICAgIGNvbnN0IGdyaWRPcHRpb25zID0gdGhpcy5zaGFyZWRTZXJ2aWNlLmdyaWRPcHRpb25zO1xyXG4gICAgY29uc3QgdHJhbnNsYXRpb25QcmVmaXggPSBnZXRUcmFuc2xhdGlvblByZWZpeChncmlkT3B0aW9ucyk7XHJcblxyXG4gICAgaWYgKHRpdGxlS2V5ICYmIHRoaXMudHJhbnNsYXRlICYmIHRoaXMudHJhbnNsYXRlLmN1cnJlbnRMYW5nICYmIHRoaXMudHJhbnNsYXRlLmluc3RhbnQpIHtcclxuICAgICAgb3V0cHV0ID0gdGhpcy50cmFuc2xhdGUuaW5zdGFudCh0aXRsZUtleSB8fCAnICcpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc3dpdGNoIChwcm9wTmFtZSkge1xyXG4gICAgICAgIGNhc2UgJ2N1c3RvbVRpdGxlJzpcclxuICAgICAgICAgIG91dHB1dCA9IHRpdGxlIHx8IGVuYWJsZVRyYW5zbGF0ZSAmJiB0aGlzLnRyYW5zbGF0ZSAmJiB0aGlzLnRyYW5zbGF0ZS5jdXJyZW50TGFuZyAmJiB0aGlzLnRyYW5zbGF0ZS5pbnN0YW50ICYmIHRoaXMudHJhbnNsYXRlLmluc3RhbnQoYCR7dHJhbnNsYXRpb25QcmVmaXh9Q09NTUFORFNgIHx8ICcgJykgfHwgbG9jYWxlcyAmJiBsb2NhbGVzLlRFWFRfQ09NTUFORFM7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdjb2x1bW5UaXRsZSc6XHJcbiAgICAgICAgICBvdXRwdXQgPSB0aXRsZSB8fCBlbmFibGVUcmFuc2xhdGUgJiYgdGhpcy50cmFuc2xhdGUgJiYgdGhpcy50cmFuc2xhdGUuY3VycmVudExhbmcgJiYgdGhpcy50cmFuc2xhdGUuaW5zdGFudCAmJiB0aGlzLnRyYW5zbGF0ZS5pbnN0YW50KGAke3RyYW5zbGF0aW9uUHJlZml4fUNPTFVNTlNgIHx8ICcgJykgfHwgbG9jYWxlcyAmJiBsb2NhbGVzLlRFWFRfQ09MVU1OUztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2ZvcmNlRml0VGl0bGUnOlxyXG4gICAgICAgICAgb3V0cHV0ID0gdGl0bGUgfHwgZW5hYmxlVHJhbnNsYXRlICYmIHRoaXMudHJhbnNsYXRlICYmIHRoaXMudHJhbnNsYXRlLmN1cnJlbnRMYW5nICYmIHRoaXMudHJhbnNsYXRlLmluc3RhbnQgJiYgdGhpcy50cmFuc2xhdGUuaW5zdGFudChgJHt0cmFuc2xhdGlvblByZWZpeH1GT1JDRV9GSVRfQ09MVU1OU2AgfHwgJyAnKSB8fCBsb2NhbGVzICYmIGxvY2FsZXMuVEVYVF9GT1JDRV9GSVRfQ09MVU1OUztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ3N5bmNSZXNpemVUaXRsZSc6XHJcbiAgICAgICAgICBvdXRwdXQgPSB0aXRsZSB8fCBlbmFibGVUcmFuc2xhdGUgJiYgdGhpcy50cmFuc2xhdGUgJiYgdGhpcy50cmFuc2xhdGUuY3VycmVudExhbmcgJiYgdGhpcy50cmFuc2xhdGUuaW5zdGFudCAmJiB0aGlzLnRyYW5zbGF0ZS5pbnN0YW50KGAke3RyYW5zbGF0aW9uUHJlZml4fVNZTkNIUk9OT1VTX1JFU0laRWAgfHwgJyAnKSB8fCBsb2NhbGVzICYmIGxvY2FsZXMuVEVYVF9TWU5DSFJPTk9VU19SRVNJWkU7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgb3V0cHV0ID0gdGl0bGU7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG91dHB1dDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIExvb3AgdGhyb3VnaCBvYmplY3QgcHJvdmlkZWQgYW5kIHNldCB0byBudWxsIGFueSBwcm9wZXJ0eSBmb3VuZCBzdGFydGluZyB3aXRoIFwib25YXCJcclxuICAgKiBAcGFyYW0ge09iamVjdH06IG9ialxyXG4gICAqL1xyXG4gIG51bGxpZnlGdW5jdGlvbk5hbWVTdGFydGluZ1dpdGhPbihvYmo/OiBhbnkpIHtcclxuICAgIGlmIChvYmopIHtcclxuICAgICAgZm9yIChjb25zdCBwcm9wIG9mIE9iamVjdC5rZXlzKG9iaikpIHtcclxuICAgICAgICBpZiAocHJvcC5zdGFydHNXaXRoKCdvbicpKSB7XHJcbiAgICAgICAgICBvYmpbcHJvcF0gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogV2hlbiB1c2luZyBDb2x1bW5QaWNrZXIvR3JpZE1lbnUgdG8gc2hvdy9oaWRlIGEgY29sdW1uLCB3ZSBwb3RlbnRpYWxseSBuZWVkIHRvIHJlYWRqdXN0IHRoZSBncmlkIG9wdGlvbiBcImZyb3plbkNvbHVtblwiIGluZGV4LlxyXG4gICAqIFRoYXQgaXMgYmVjYXVzZSBTbGlja0dyaWQgZnJlZXplcyBieSBjb2x1bW4gaW5kZXggYW5kIGl0IGhhcyBubyBrbm93bGVkZ2Ugb2YgdGhlIGNvbHVtbnMgdGhlbXNlbHZlcyBhbmQgd29uJ3QgY2hhbmdlIHRoZSBpbmRleCwgd2UgbmVlZCB0byBkbyB0aGF0IG91cnNlbHZlcyB3aGVuZXZlciBuZWNlc3NhcnkuXHJcbiAgICogTm90ZTogd2UgY2FsbCB0aGlzIG1ldGhvZCByaWdodCBhZnRlciB0aGUgdmlzaWJsZUNvbHVtbnMgYXJyYXkgZ290IHVwZGF0ZWQsIGl0IHdvbid0IHdvcmsgcHJvcGVybHkgaWYgd2UgY2FsbCBpdCBiZWZvcmUgdGhlIHNldHRpbmcgdGhlIHZpc2libGVDb2x1bW5zLlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwaWNrZXJDb2x1bW5JZCAtIHdoYXQgaXMgdGhlIGNvbHVtbiBpZCB0cmlnZ2VyZWQgYnkgdGhlIHBpY2tlclxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmcm96ZW5Db2x1bW5JbmRleCAtIGN1cnJlbnQgZnJvemVuQ29sdW1uIGluZGV4XHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBzaG93aW5nQ29sdW1uIC0gaXMgdGhlIGNvbHVtbiBiZWluZyBzaG93biBvciBoaWRkZW4/XHJcbiAgICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBhbGxDb2x1bW5zIC0gYWxsIGNvbHVtbnMgKGluY2x1ZGluZyBoaWRkZW4gb25lcylcclxuICAgKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IHZpc2libGVDb2x1bW5zIC0gb25seSB2aXNpYmxlIGNvbHVtbnMgKGV4Y2x1ZGluZyBoaWRkZW4gb25lcylcclxuICAgKi9cclxuICByZWFkanVzdEZyb3plbkNvbHVtbkluZGV4V2hlbk5lZWRlZChwaWNrZXJDb2x1bW5JZDogc3RyaW5nIHwgbnVtYmVyLCBmcm96ZW5Db2x1bW5JbmRleDogbnVtYmVyLCBzaG93aW5nQ29sdW1uOiBib29sZWFuLCBhbGxDb2x1bW5zOiBDb2x1bW5bXSwgdmlzaWJsZUNvbHVtbnM6IENvbHVtbltdKSB7XHJcbiAgICBpZiAoZnJvemVuQ29sdW1uSW5kZXggPj0gMCAmJiBwaWNrZXJDb2x1bW5JZCkge1xyXG4gICAgICAvLyBjYWxjdWxhdGUgYSBwb3NzaWJsZSBmcm96ZW5Db2x1bW4gaW5kZXggdmFyaWFuY2VcclxuICAgICAgbGV0IGZyb3plbkNvbEluZGV4VmFyaWFuY2UgPSAwO1xyXG4gICAgICBpZiAoc2hvd2luZ0NvbHVtbikge1xyXG4gICAgICAgIGNvbnN0IGRlZmluZWRGcm96ZW5Db2x1bW5JbmRleCA9IHZpc2libGVDb2x1bW5zLmZpbmRJbmRleChjb2wgPT4gY29sLmlkID09PSB0aGlzLnNoYXJlZFNlcnZpY2UuZnJvemVuVmlzaWJsZUNvbHVtbklkKTtcclxuICAgICAgICBjb25zdCBjb2x1bW5JbmRleCA9IHZpc2libGVDb2x1bW5zLmZpbmRJbmRleChjb2wgPT4gY29sLmlkID09PSBwaWNrZXJDb2x1bW5JZCk7XHJcbiAgICAgICAgZnJvemVuQ29sSW5kZXhWYXJpYW5jZSA9IChjb2x1bW5JbmRleCA+PSAwICYmIChmcm96ZW5Db2x1bW5JbmRleCA+PSBjb2x1bW5JbmRleCB8fCBkZWZpbmVkRnJvemVuQ29sdW1uSW5kZXggPT09IGNvbHVtbkluZGV4KSkgPyAxIDogMDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCBjb2x1bW5JbmRleCA9IGFsbENvbHVtbnMuZmluZEluZGV4KGNvbCA9PiBjb2wuaWQgPT09IHBpY2tlckNvbHVtbklkKTtcclxuICAgICAgICBmcm96ZW5Db2xJbmRleFZhcmlhbmNlID0gKGNvbHVtbkluZGV4ID49IDAgJiYgZnJvemVuQ29sdW1uSW5kZXggPj0gY29sdW1uSW5kZXgpID8gLTEgOiAwO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIGlmIHdlIGhhdmUgYSB2YXJpYW5jZSBkaWZmZXJlbnQgdGhhbiAwIHRoZW4gYXBwbHkgaXRcclxuICAgICAgY29uc3QgbmV3RnJvemVuQ29sSW5kZXggPSBmcm96ZW5Db2x1bW5JbmRleCArIGZyb3plbkNvbEluZGV4VmFyaWFuY2U7XHJcbiAgICAgIGlmIChmcm96ZW5Db2xJbmRleFZhcmlhbmNlICE9PSAwKSB7XHJcbiAgICAgICAgdGhpcy5zaGFyZWRTZXJ2aWNlLmdyaWQuc2V0T3B0aW9ucyh7IGZyb3plbkNvbHVtbjogbmV3RnJvemVuQ29sSW5kZXggfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHRvIGZyZWV6ZSBjb2x1bW5zLCB3ZSBuZWVkIHRvIHRha2Ugb25seSB0aGUgdmlzaWJsZSBjb2x1bW5zIGFuZCB3ZSBhbHNvIG5lZWQgdG8gdXNlIHNldENvbHVtbnMoKSB3aGVuIHNvbWUgb2YgdGhlbSBhcmUgaGlkZGVuXHJcbiAgICAgIC8vIHRvIG1ha2Ugc3VyZSB0aGF0IHdlIG9ubHkgdXNlIHRoZSB2aXNpYmxlIGNvbHVtbnMsIG5vdCBkb2luZyB0aGlzIHdvdWxkIHNob3cgYmFjayBzb21lIG9mIHRoZSBoaWRkZW4gY29sdW1uc1xyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2aXNpYmxlQ29sdW1ucykgJiYgQXJyYXkuaXNBcnJheShhbGxDb2x1bW5zKSAmJiB2aXNpYmxlQ29sdW1ucy5sZW5ndGggIT09IGFsbENvbHVtbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcy5zaGFyZWRTZXJ2aWNlLmdyaWQuc2V0Q29sdW1ucyh2aXNpYmxlQ29sdW1ucyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNvcnQgaXRlbXMgKGJ5IHBvaW50ZXJzKSBpbiBhbiBhcnJheSBieSBhIHByb3BlcnR5IG5hbWVcclxuICAgKiBAcGFyYW1zIGl0ZW1zIGFycmF5XHJcbiAgICogQHBhcmFtIHByb3BlcnR5IG5hbWUgdG8gc29ydCB3aXRoXHJcbiAgICovXHJcbiAgc29ydEl0ZW1zPFQgPSBhbnk+KGl0ZW1zOiBUW10sIHByb3BlcnR5TmFtZTogc3RyaW5nKSB7XHJcbiAgICAvLyBzb3J0IHRoZSBjdXN0b20gaXRlbXMgYnkgdGhlaXIgcG9zaXRpb24gaW4gdGhlIGxpc3RcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xyXG4gICAgICBpdGVtcy5zb3J0KChpdGVtQTogVCwgaXRlbUI6IFQpID0+IHtcclxuICAgICAgICBpZiAoaXRlbUEgJiYgaXRlbUIgJiYgaXRlbUEuaGFzT3duUHJvcGVydHkocHJvcGVydHlOYW1lKSAmJiBpdGVtQi5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpKSB7XHJcbiAgICAgICAgICByZXR1cm4gaXRlbUFbcHJvcGVydHlOYW1lXSAtIGl0ZW1CW3Byb3BlcnR5TmFtZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKiBUcmFuc2xhdGUgdGhlIGFuIGFycmF5IG9mIGl0ZW1zIGZyb20gYW4gaW5wdXQga2V5IGFuZCBhc3NpZ24gdG8gdGhlIG91dHB1dCBrZXkgKi9cclxuICB0cmFuc2xhdGVJdGVtczxUID0gYW55PihpdGVtczogVFtdLCBpbnB1dEtleTogc3RyaW5nLCBvdXRwdXRLZXk6IHN0cmluZykge1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XHJcbiAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xyXG4gICAgICAgIGlmIChpdGVtW2lucHV0S2V5XSkge1xyXG4gICAgICAgICAgaXRlbVtvdXRwdXRLZXldID0gdGhpcy50cmFuc2xhdGUgJiYgdGhpcy50cmFuc2xhdGUgJiYgdGhpcy50cmFuc2xhdGUuY3VycmVudExhbmcgJiYgdGhpcy50cmFuc2xhdGUuaW5zdGFudCAmJiB0aGlzLnRyYW5zbGF0ZS5pbnN0YW50KGl0ZW1baW5wdXRLZXldKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFdoZW4gXCJlbmFibGVkVHJhbnNsYXRlXCIgaXMgc2V0IHRvIFRydWUsIHdlIHdpbGwgdHJ5IHRvIHRyYW5zbGF0ZSBpZiB0aGUgVHJhbnNsYXRlIFNlcnZpY2UgZXhpc3Qgb3IgdXNlIHRoZSBMb2NhbGVzIHdoZW4gbm90XHJcbiAgICogQHBhcmFtIHRyYW5zbGF0aW9uS2V5XHJcbiAgICogQHBhcmFtIGxvY2FsZUtleVxyXG4gICAqL1xyXG4gIHRyYW5zbGF0ZVdoZW5FbmFibGVkQW5kU2VydmljZUV4aXN0KHRyYW5zbGF0aW9uS2V5OiBzdHJpbmcsIGxvY2FsZUtleTogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgIGxldCB0ZXh0ID0gJyc7XHJcbiAgICBjb25zdCBncmlkT3B0aW9ucyA9IHRoaXMuc2hhcmVkU2VydmljZSAmJiB0aGlzLnNoYXJlZFNlcnZpY2UuZ3JpZE9wdGlvbnM7XHJcblxyXG4gICAgLy8gZ2V0IGxvY2FsZXMgcHJvdmlkZWQgYnkgdXNlciBpbiBtYWluIGZpbGUgb3IgZWxzZSB1c2UgZGVmYXVsdCBFbmdsaXNoIGxvY2FsZXMgdmlhIHRoZSBDb25zdGFudHNcclxuICAgIGNvbnN0IGxvY2FsZXMgPSBncmlkT3B0aW9ucyAmJiBncmlkT3B0aW9ucy5sb2NhbGVzIHx8IENvbnN0YW50cy5sb2NhbGVzO1xyXG5cclxuICAgIGlmIChncmlkT3B0aW9ucy5lbmFibGVUcmFuc2xhdGUgJiYgdGhpcy50cmFuc2xhdGUgJiYgdGhpcy50cmFuc2xhdGUuY3VycmVudExhbmcgJiYgdGhpcy50cmFuc2xhdGUuaW5zdGFudCkge1xyXG4gICAgICB0ZXh0ID0gdGhpcy50cmFuc2xhdGUuaW5zdGFudCh0cmFuc2xhdGlvbktleSB8fCAnICcpO1xyXG4gICAgfSBlbHNlIGlmIChsb2NhbGVzICYmIGxvY2FsZXMuaGFzT3duUHJvcGVydHkobG9jYWxlS2V5KSkge1xyXG4gICAgICB0ZXh0ID0gbG9jYWxlc1tsb2NhbGVLZXldO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGV4dCA9IGxvY2FsZUtleTtcclxuICAgIH1cclxuICAgIHJldHVybiB0ZXh0O1xyXG4gIH1cclxufVxyXG4iXX0=