(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs'), require('rxjs/operators'), require('@ngx-translate/core'), require('moment-mini'), require('excel-builder-webpacker'), require('text-encoding-utf-8'), require('slickgrid/plugins/slick.cellrangedecorator'), require('slickgrid/plugins/slick.cellrangeselector'), require('slickgrid/plugins/slick.cellselectionmodel'), require('lodash.isequal'), require('dompurify'), require('flatpickr'), require('jquery-ui-dist/jquery-ui'), require('slickgrid/lib/jquery.event.drag-2.3.0'), require('slickgrid/lib/jquery.mousewheel'), require('slickgrid/slick.core'), require('slickgrid/slick.grid'), require('slickgrid/slick.dataview'), require('@angular/common')) :
    typeof define === 'function' && define.amd ? define('angular-slickgrid', ['exports', '@angular/core', 'rxjs', 'rxjs/operators', '@ngx-translate/core', 'moment-mini', 'excel-builder-webpacker', 'text-encoding-utf-8', 'slickgrid/plugins/slick.cellrangedecorator', 'slickgrid/plugins/slick.cellrangeselector', 'slickgrid/plugins/slick.cellselectionmodel', 'lodash.isequal', 'dompurify', 'flatpickr', 'jquery-ui-dist/jquery-ui', 'slickgrid/lib/jquery.event.drag-2.3.0', 'slickgrid/lib/jquery.mousewheel', 'slickgrid/slick.core', 'slickgrid/slick.grid', 'slickgrid/slick.dataview', '@angular/common'], factory) :
    (global = global || self, factory(global['angular-slickgrid'] = {}, global.ng.core, global.rxjs, global.rxjs.operators, global['ngx-translate-core'], global.moment, global.excelBuilderWebpacker, global.textEncodingUtf8, null, null, null, global.lodash.isequal, global.dompurify, global.flatpickr, null, null, null, null, null, null, global.ng.common));
}(this, (function (exports, core, rxjs, operators, core$1, moment_, excelBuilderWebpacker, textEncodingUtf8, slick_cellrangedecorator, slick_cellrangeselector, slick_cellselectionmodel, isequal_, DOMPurify_, Flatpickr__default, jqueryUi, jquery_event_drag2_3_0, jquery_mousewheel, slick_core, slick_grid, slick_dataview, common) { 'use strict';

    var Flatpickr__default__default = 'default' in Flatpickr__default ? Flatpickr__default['default'] : Flatpickr__default;

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    var __createBinding = Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    });

    function __exportStar(m, o) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
    }

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    var __setModuleDefault = Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
        o["default"] = v;
    };

    function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }

    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }

    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    (function (CaseType) {
        /** For example: camelCase */
        CaseType[CaseType["camelCase"] = 0] = "camelCase";
        /** For example: PascalCase */
        CaseType[CaseType["pascalCase"] = 1] = "pascalCase";
        /** For example: snake_case */
        CaseType[CaseType["snakeCase"] = 2] = "snakeCase";
        /** For example: kebab-case */
        CaseType[CaseType["kebabCase"] = 3] = "kebabCase";
    })(exports.CaseType || (exports.CaseType = {}));


    (function (DelimiterType) {
        DelimiterType["colon"] = ":";
        DelimiterType["comma"] = ",";
        DelimiterType["equalSign"] = "=";
        DelimiterType["pipe"] = "|";
        DelimiterType["semicolon"] = ";";
        DelimiterType["space"] = " ";
        DelimiterType["tab"] = "\t";
        DelimiterType["doubleColon"] = "::";
        DelimiterType["doublePipe"] = "||";
        DelimiterType["doubleSemicolon"] = ";;";
    })(exports.DelimiterType || (exports.DelimiterType = {}));


    (function (EmitterType) {
        EmitterType["local"] = "local";
        EmitterType["remote"] = "remote";
    })(exports.EmitterType || (exports.EmitterType = {}));

    /** List of available SlickGrid Extensions (Controls & Plugins) */

    (function (ExtensionName) {
        ExtensionName["autoTooltip"] = "autoTooltip";
        ExtensionName["cellExternalCopyManager"] = "cellExternalCopyManager";
        ExtensionName["cellMenu"] = "cellMenu";
        ExtensionName["checkboxSelector"] = "checkboxSelector";
        ExtensionName["columnPicker"] = "columnPicker";
        ExtensionName["contextMenu"] = "contextMenu";
        ExtensionName["draggableGrouping"] = "draggableGrouping";
        ExtensionName["groupItemMetaProvider"] = "groupItemMetaProvider";
        ExtensionName["gridMenu"] = "gridMenu";
        ExtensionName["headerButton"] = "headerButton";
        ExtensionName["headerMenu"] = "headerMenu";
        ExtensionName["noname"] = "noname";
        ExtensionName["rowDetailView"] = "rowDetailView";
        ExtensionName["rowMoveManager"] = "rowMoveManager";
        ExtensionName["rowSelection"] = "rowSelection";
    })(exports.ExtensionName || (exports.ExtensionName = {}));


    (function (FieldType) {
        /** unknown type */
        FieldType["unknown"] = "unknown";
        /** string type */
        FieldType["string"] = "string";
        /** boolean type (true/false) */
        FieldType["boolean"] = "boolean";
        /** integer number type (1,2,99) */
        FieldType["integer"] = "integer";
        /** float number (with decimal) type */
        FieldType["float"] = "float";
        /** number includes Integer and Float */
        FieldType["number"] = "number";
        /** new Date(), javascript Date object */
        FieldType["date"] = "date";
        /** Format: 'YYYY-MM-DD' => 2001-02-28 */
        FieldType["dateIso"] = "dateIso";
        /** Format: 'YYYY-MM-DDTHH:mm:ss.SSSZ' => 2001-02-28T14:00:00.123Z */
        FieldType["dateUtc"] = "dateUtc";
        /** new Date(), javacript Date Object with Time */
        FieldType["dateTime"] = "dateTime";
        /** Format: 'YYYY-MM-DD HH:mm:ss' => 2001-02-28 14:01:01 */
        FieldType["dateTimeIso"] = "dateTimeIso";
        /** Format: 'YYYY-MM-DD h:mm:ss a' => 2001-02-28 11:01:01 pm */
        FieldType["dateTimeIsoAmPm"] = "dateTimeIsoAmPm";
        /** Format: 'YYYY-MM-DD h:mm:ss A' => 2001-02-28 11:01:01 PM */
        FieldType["dateTimeIsoAM_PM"] = "dateTimeIsoAM_PM";
        /** Format: 'YYYY-MM-DD HH:mm' => 2001-02-28 14:01 */
        FieldType["dateTimeShortIso"] = "dateTimeShortIso";
        /** Format (Euro): 'DD/MM/YYYY' => 28/02/2001 */
        FieldType["dateEuro"] = "dateEuro";
        /** Format (Euro): 'D/M/YY' => 28/2/12 */
        FieldType["dateEuroShort"] = "dateEuroShort";
        /** Format (Euro): 'DD/MM/YYYY HH:mm' => 28/02/2001 13:01 */
        FieldType["dateTimeShortEuro"] = "dateTimeShortEuro";
        /** Format (Euro): 'DD/MM/YYYY HH:mm:ss' => 02/28/2001 13:01:01 */
        FieldType["dateTimeEuro"] = "dateTimeEuro";
        /** Format (Euro): 'DD/MM/YYYY hh:mm:ss a' => 28/02/2001 11:01:01 pm */
        FieldType["dateTimeEuroAmPm"] = "dateTimeEuroAmPm";
        /** Format (Euro): 'DD/MM/YYYY hh:mm:ss A' => 28/02/2001 11:01:01 PM */
        FieldType["dateTimeEuroAM_PM"] = "dateTimeEuroAM_PM";
        /** Format (Euro): 'D/M/YY H:m:s' => 28/2/14 14:1:2 */
        FieldType["dateTimeEuroShort"] = "dateTimeEuroShort";
        /** Format (Euro): 'D/M/YY h:m:s a' => 28/2/14 1:2:10 pm */
        FieldType["dateTimeEuroShortAmPm"] = "dateTimeEuroShortAmPm";
        /** Format (Euro): 'D/M/YY h:m:s A' => 28/2/14 14:1:1 PM */
        FieldType["dateTimeEuroShortAM_PM"] = "dateTimeEuroShortAM_PM";
        /** Format: 'MM/DD/YYYY' => 02/28/2001 */
        FieldType["dateUs"] = "dateUs";
        /** Format: 'M/D/YY' => 2/28/12 */
        FieldType["dateUsShort"] = "dateUsShort";
        /** Format: 'MM/DD/YYYY HH:mm' => 02/28/2001 13:01 */
        FieldType["dateTimeShortUs"] = "dateTimeShortUs";
        /** Format: 'MM/DD/YYYY HH:mm:ss' => 02/28/2001 13:01:01 */
        FieldType["dateTimeUs"] = "dateTimeUs";
        /** Format: 'MM/DD/YYYY hh:mm:ss a' => 02/28/2001 11:01:01 pm */
        FieldType["dateTimeUsAmPm"] = "dateTimeUsAmPm";
        /** Format: 'MM/DD/YYYY hh:mm:ss A' => 02/28/2001 11:01:01 PM */
        FieldType["dateTimeUsAM_PM"] = "dateTimeUsAM_PM";
        /** Format: 'M/D/YY H:m:s' => 2/28/14 14:1:2 */
        FieldType["dateTimeUsShort"] = "dateTimeUsShort";
        /** Format: 'M/D/YY h:m:s a' => 2/28/14 1:2:10 pm */
        FieldType["dateTimeUsShortAmPm"] = "dateTimeUsShortAmPm";
        /** Format: 'M/D/YY h:m:s A' => 2/28/14 14:1:1 PM */
        FieldType["dateTimeUsShortAM_PM"] = "dateTimeUsShortAM_PM";
        /** complex object with various properties */
        FieldType["object"] = "object";
        /** password text string */
        FieldType["password"] = "password";
        /** alias to string */
        FieldType["text"] = "text";
        /** readonly text string */
        FieldType["readonly"] = "readonly";
    })(exports.FieldType || (exports.FieldType = {}));


    (function (FileType) {
        FileType["csv"] = "csv";
        FileType["txt"] = "txt";
        FileType["xls"] = "xls";
        FileType["xlsx"] = "xlsx";
    })(exports.FileType || (exports.FileType = {}));


    (function (FilterMultiplePassType) {
        FilterMultiplePassType["merge"] = "merge";
        FilterMultiplePassType["chain"] = "chain";
    })(exports.FilterMultiplePassType || (exports.FilterMultiplePassType = {}));


    (function (GridStateType) {
        GridStateType["columns"] = "columns";
        GridStateType["filter"] = "filter";
        GridStateType["pagination"] = "pagination";
        GridStateType["sorter"] = "sorter";
        GridStateType["rowSelection"] = "rowSelection";
    })(exports.GridStateType || (exports.GridStateType = {}));


    (function (KeyCode) {
        KeyCode[KeyCode["BACKSPACE"] = 8] = "BACKSPACE";
        KeyCode[KeyCode["DELETE"] = 46] = "DELETE";
        KeyCode[KeyCode["DOWN"] = 40] = "DOWN";
        KeyCode[KeyCode["END"] = 35] = "END";
        KeyCode[KeyCode["ENTER"] = 13] = "ENTER";
        KeyCode[KeyCode["ESCAPE"] = 27] = "ESCAPE";
        KeyCode[KeyCode["HOME"] = 36] = "HOME";
        KeyCode[KeyCode["INSERT"] = 45] = "INSERT";
        KeyCode[KeyCode["LEFT"] = 37] = "LEFT";
        KeyCode[KeyCode["PAGE_DOWN"] = 34] = "PAGE_DOWN";
        KeyCode[KeyCode["PAGE_UP"] = 33] = "PAGE_UP";
        KeyCode[KeyCode["RIGHT"] = 39] = "RIGHT";
        KeyCode[KeyCode["TAB"] = 9] = "TAB";
        KeyCode[KeyCode["UP"] = 38] = "UP";
        KeyCode[KeyCode["SPACE"] = 32] = "SPACE";
    })(exports.KeyCode || (exports.KeyCode = {}));


    (function (OperatorType) {
        /** value is empty */
        OperatorType["empty"] = "";
        /** value contains x */
        OperatorType["contains"] = "Contains";
        /** value not contains x (inversed of contains) */
        OperatorType["notContains"] = "Not_Contains";
        /** value less than x */
        OperatorType["lessThan"] = "LT";
        /** value less than or equal to x */
        OperatorType["lessThanOrEqual"] = "LE";
        /** value greater than x */
        OperatorType["greaterThan"] = "GT";
        /** value great than or equal to x */
        OperatorType["greaterThanOrEqual"] = "GE";
        /** value not equal to x */
        OperatorType["notEqual"] = "NE";
        /** value equal to x */
        OperatorType["equal"] = "EQ";
        /** String ends with value */
        OperatorType["endsWith"] = "EndsWith";
        /**
         * Search in an inclusive range of values that is greater or equal to search value 1 and is smaller or equal to value 2
         * For example the search term of "5..10" will return any values that are greater or equal to 5 and smaller or equal to 10
         */
        OperatorType["rangeInclusive"] = "RangeInclusive";
        /**
         * Search in an inclusive range of values that is greater then search value 1 and is smaller then value 2
         * For example the search term of "5..10" will return any values that is greater then 5 and smaller then 10
         */
        OperatorType["rangeExclusive"] = "RangeExclusive";
        /** String starts with value */
        OperatorType["startsWith"] = "StartsWith";
        /** Find an equal match inside a collection */
        OperatorType["in"] = "IN";
        /** Inverse (Not In) of an equal match inside a collection */
        OperatorType["notIn"] = "NOT_IN";
        /**
         * Find a substring contained inside a collection
         * For example, this condition would return True with "IN_CONTAINS":: value='Task2,Task3', collection=['Task2','Task3']
         * This would have returned False with "IN" because 'Task2' does not equal 'Task2,Task3'. However 'Task2' is contained in 'Task2,Task3'
         */
        OperatorType["inContains"] = "IN_CONTAINS";
        /** Inversed (Not In) of substring contained inside a collection */
        OperatorType["notInContains"] = "NOT_IN_CONTAINS";
    })(exports.OperatorType || (exports.OperatorType = {}));


    (function (SortDirection) {
        SortDirection["asc"] = "asc";
        SortDirection["ASC"] = "ASC";
        SortDirection["desc"] = "desc";
        SortDirection["DESC"] = "DESC";
    })(exports.SortDirection || (exports.SortDirection = {}));


    (function (SortDirectionNumber) {
        SortDirectionNumber[SortDirectionNumber["asc"] = 1] = "asc";
        SortDirectionNumber[SortDirectionNumber["desc"] = -1] = "desc";
        SortDirectionNumber[SortDirectionNumber["neutral"] = 0] = "neutral";
    })(exports.SortDirectionNumber || (exports.SortDirectionNumber = {}));

    var AngularUtilService = /** @class */ (function () {
        function AngularUtilService(compFactoryResolver, appRef, injector) {
            this.compFactoryResolver = compFactoryResolver;
            this.appRef = appRef;
            this.injector = injector;
        }
        // ref https://hackernoon.com/angular-pro-tip-how-to-dynamically-create-components-in-body-ba200cc289e6
        AngularUtilService.prototype.createAngularComponent = function (component) {
            // Create a component reference from the component
            var componentRef = this.compFactoryResolver
                .resolveComponentFactory(component)
                .create(this.injector);
            // Attach component to the appRef so that it's inside the ng component tree
            this.appRef.attachView(componentRef.hostView);
            // Get DOM element from component
            var domElem;
            var viewRef = componentRef.hostView;
            if (viewRef && Array.isArray(viewRef.rootNodes) && viewRef.rootNodes[0]) {
                domElem = viewRef.rootNodes[0];
            }
            return { componentRef: componentRef, domElement: domElem };
        };
        // ref https://hackernoon.com/angular-pro-tip-how-to-dynamically-create-components-in-body-ba200cc289e6
        AngularUtilService.prototype.createAngularComponentAppendToDom = function (component, targetElement, clearTargetContent) {
            if (clearTargetContent === void 0) { clearTargetContent = false; }
            var componentOutput = this.createAngularComponent(component);
            // Append DOM element to the HTML element specified
            if (targetElement && targetElement.appendChild) {
                if (clearTargetContent && targetElement.innerHTML) {
                    targetElement.innerHTML = '';
                }
                targetElement.appendChild(componentOutput.domElement);
            }
            else {
                document.body.appendChild(componentOutput.domElement); // when no target provided, we'll simply add it to the HTML Body
            }
            return componentOutput;
        };
        AngularUtilService.ctorParameters = function () { return [
            { type: core.ComponentFactoryResolver },
            { type: core.ApplicationRef },
            { type: core.Injector }
        ]; };
        AngularUtilService = __decorate([
            core.Injectable()
        ], AngularUtilService);
        return AngularUtilService;
    }());

    var main = {};
    /** Execute the Backend Processes Callback, that could come from an Observable or a Promise callback */
    main.executeBackendProcessesCallback = function exeBackendProcessesCallback(startTime, processResult, backendApi, totalItems) {
        var endTime = new Date();
        // define what our internal Post Process callback, only available for GraphQL Service for now
        // it will basically refresh the Dataset & Pagination removing the need for the user to always create his own PostProcess every time
        if (processResult && backendApi && backendApi.internalPostProcess) {
            backendApi.internalPostProcess(processResult);
        }
        // send the response process to the postProcess callback
        if (backendApi.postProcess) {
            if (processResult instanceof Object) {
                processResult.metrics = {
                    startTime: startTime,
                    endTime: endTime,
                    executionTime: endTime.valueOf() - startTime.valueOf(),
                    itemCount: totalItems,
                    totalItemCount: totalItems
                };
                // @deprecated
                processResult.statistics = processResult.metrics;
            }
            backendApi.postProcess(processResult);
        }
    };
    /** On a backend service api error, we will run the "onError" if there is 1 provided or just throw back the error when nothing is provided */
    main.onBackendError = function backendError(e, backendApi) {
        if (backendApi && backendApi.onError) {
            backendApi.onError(e);
        }
        else {
            throw e;
        }
    };
    /**
     * Execute the backend callback, which are mainly the "process" & "postProcess" methods.
     * Also note that "preProcess" was executed prior to this callback
     */
    main.executeBackendCallback = function exeBackendCallback(backendServiceApi, query, args, startTime, totalItems, emitActionChangedCallback, httpCancelRequests$) {
        if (backendServiceApi) {
            // emit an onFilterChanged event when it's not called by a clear filter
            if (args && !args.clearFilterTriggered && !args.clearSortTriggered) {
                emitActionChangedCallback(exports.EmitterType.remote);
            }
            // the processes can be Observables (like HttpClient) or Promises
            var process_1 = backendServiceApi.process(query);
            if (process_1 instanceof Promise && process_1.then) {
                process_1.then(function (processResult) { return main.executeBackendProcessesCallback(startTime, processResult, backendServiceApi, totalItems); })
                    .catch(function (error) { return main.onBackendError(error, backendServiceApi); });
            }
            else if (rxjs.isObservable(process_1)) {
                // this will abort any previous HTTP requests, that were previously hooked in the takeUntil, before sending a new request
                if (rxjs.isObservable(httpCancelRequests$)) {
                    httpCancelRequests$.next();
                }
                process_1
                    // the following takeUntil, will potentially be used later to cancel any pending http request (takeUntil another rx, that would be httpCancelRequests$, completes)
                    // but make sure the observable is actually defined with the iif condition check before piping it to the takeUntil
                    .pipe(operators.takeUntil(rxjs.iif(function () { return rxjs.isObservable(httpCancelRequests$); }, httpCancelRequests$, rxjs.EMPTY)))
                    .subscribe(function (processResult) { return main.executeBackendProcessesCallback(startTime, processResult, backendServiceApi, totalItems); }, function (error) { return main.onBackendError(error, backendServiceApi); });
            }
        }
    };
    /** Refresh the dataset through the Backend Service */
    main.refreshBackendDataset = function refreshBackend(gridOptions) {
        var query = '';
        var backendApi = gridOptions && gridOptions.backendServiceApi;
        if (!backendApi || !backendApi.service || !backendApi.process) {
            throw new Error("BackendServiceApi requires at least a \"process\" function and a \"service\" defined");
        }
        if (backendApi.service) {
            query = backendApi.service.buildQuery();
        }
        if (query && query !== '') {
            // keep start time & end timestamps & return it after process execution
            var startTime = new Date();
            if (backendApi.preProcess) {
                backendApi.preProcess();
            }
            var totalItems = gridOptions && gridOptions.pagination && gridOptions.pagination.totalItems;
            main.executeBackendCallback(backendApi, query, null, startTime, totalItems);
        }
    };
    // export all methods & the main so that it works in all modules but also in Jest unit test
    // export every method as independent constant so that it still works whenever this is used in other modules
    var executeBackendProcessesCallback = main.executeBackendProcessesCallback;
    var onBackendError = main.onBackendError;
    var executeBackendCallback = main.executeBackendCallback;
    var refreshBackendDataset = main.refreshBackendDataset;

    var BindingEventService = /** @class */ (function () {
        function BindingEventService() {
            this._boundedEvents = [];
        }
        /** Bind an event listener to any element */
        BindingEventService.prototype.bind = function (element, eventName, listener, options) {
            element.addEventListener(eventName, listener, options);
            this._boundedEvents.push({ element: element, eventName: eventName, listener: listener });
        };
        /** Unbind all will remove every every event handlers that were bounded earlier */
        BindingEventService.prototype.unbindAll = function () {
            while (this._boundedEvents.length > 0) {
                var boundedEvent = this._boundedEvents.pop();
                var element = boundedEvent.element, eventName = boundedEvent.eventName, listener = boundedEvent.listener;
                if (element && element.removeEventListener) {
                    element.removeEventListener(eventName, listener);
                }
            }
        };
        return BindingEventService;
    }());

    // Boostrap dropdown service
    var BsDropDownService = /** @class */ (function () {
        function BsDropDownService(angularUtilService) {
            this.angularUtilService = angularUtilService;
        }
        Object.defineProperty(BsDropDownService.prototype, "domElement", {
            get: function () {
                return this._domElement;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BsDropDownService.prototype, "domContainerElement", {
            get: function () {
                return this._domContainerElement;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BsDropDownService.prototype, "gridViewport", {
            get: function () {
                return $('.slick-viewport');
            },
            enumerable: true,
            configurable: true
        });
        BsDropDownService.prototype.dispose = function () {
            if (this._domElement && this._domElement.remove) {
                this._domElement.remove();
            }
        };
        BsDropDownService.prototype.dropContainerShow = function () {
            if (this._domContainerElement && this._domContainerElement.show) {
                this._domContainerElement.show();
            }
        };
        BsDropDownService.prototype.render = function (dropdownParams) {
            var _this = this;
            return new Promise(function (resolve) {
                var component = dropdownParams.component, args = dropdownParams.args, parent = dropdownParams.parent, offsetTop = dropdownParams.offsetTop, offsetLeft = dropdownParams.offsetLeft, offsetDropupBottom = dropdownParams.offsetDropupBottom;
                var cell = args.cell;
                var row = args.row;
                _this._domContainerElement = $("#myDrop-r" + row + "-c" + cell);
                if (_this._domContainerElement) {
                    // hide the dropdown we created as a formatter Component, we'll redisplay it later
                    var cellPos_1 = _this._domContainerElement.offset();
                    var componentOutput_1 = _this.angularUtilService.createAngularComponent(component);
                    var componentInstance = componentOutput_1 && componentOutput_1.componentRef && componentOutput_1.componentRef.instance;
                    if (componentInstance) {
                        var myDropId_1 = componentInstance.dropdownId || 'myDrop';
                        var dropDownToggleId_1 = componentInstance.dropDownToggleId || 'dropdownMenu1';
                        _this._domElement = $("#" + myDropId_1);
                        if (_this._domElement) {
                            // make sure to remove any previous Action dropdown elements, to avoid having multiple element of the same on top of each other
                            _this.dispose();
                            // assign the row data to the dropdown component instance
                            Object.assign(componentInstance, { parent: parent, row: args.row, dataContext: args.grid.getDataItem(args.row) });
                            // use a delay to make sure Angular ran at least a full cycle and make sure it finished rendering the Component before using it
                            setTimeout(function () {
                                // create a new dropdown element
                                _this._domElement = $(componentOutput_1.domElement);
                                var topPos = (cellPos_1 && cellPos_1.top || 0) + 30 + (offsetTop || 0);
                                var leftPos = (cellPos_1 && cellPos_1.left || 0) + (offsetLeft || 0);
                                _this._domElement.appendTo('body');
                                _this._domElement.css('position', 'absolute');
                                _this._domElement.css('top', topPos);
                                _this._domElement.css('left', leftPos);
                                $("#" + myDropId_1).addClass('open');
                                $("#" + dropDownToggleId_1).hide();
                                // check if it should drop Up or Down
                                var offset = 35;
                                var iElement = $('.dropdown-menu');
                                var iElementWrapper = iElement.parent();
                                var iElementWrapperOffset = iElementWrapper.offset() || {};
                                var iElementWrapperOffsetTop = iElementWrapperOffset.top || iElementWrapper && iElementWrapper.length > 0 && iElementWrapper[0].offsetTop;
                                var iElementHeight = iElement.height();
                                var windowHeight = window.innerHeight;
                                var shouldDropUp = (windowHeight - iElementHeight - offset) < iElementWrapperOffsetTop;
                                var menuMarginTop = '0px';
                                if (shouldDropUp) {
                                    var offsetBottom = offsetDropupBottom || 0;
                                    menuMarginTop = '-'.concat("" + (iElementHeight + offset + offsetBottom + 5), 'px');
                                }
                                _this._domElement.css({ 'margin-top': menuMarginTop });
                                // set dropdown margin left according to the document width
                                var parentOffset = iElementWrapperOffset.left;
                                var leftMargin = parentOffset - $(document).width();
                                _this._domElement.css({ 'margin-left': (_this._domElement.width() + leftMargin + 60) + 'px' });
                                try {
                                    _this._domElement.dropdown('show'); // required for Bootstrap 4 only
                                }
                                catch (e) {
                                    // Bootstrap 3 wil throw an error since that method doesn't exist, we can safely disregard it
                                }
                                _this._domElement.on('hidden.bs.dropdown', function () { return _this.dropContainerShow(); });
                                // hide dropdown menu on grid scroll
                                _this.gridViewport.on('scroll', function () { return _this.dispose(); });
                                // hide on dropdown click
                                _this._domElement.on('click', function () { return _this.dispose(); });
                                resolve(true);
                            });
                        }
                    }
                }
            });
        };
        BsDropDownService.ctorParameters = function () { return [
            { type: AngularUtilService }
        ]; };
        BsDropDownService = __decorate([
            core.Injectable()
        ], BsDropDownService);
        return BsDropDownService;
    }());

    var numericSorter = function (value1, value2, sortDirection, sortColumn) {
        var checkForUndefinedValues = sortColumn && sortColumn.valueCouldBeUndefined || false;
        var x = (isNaN(value1) || value1 === '' || value1 === null || (checkForUndefinedValues && value1 === undefined)) ? -99e+10 : parseFloat(value1);
        var y = (isNaN(value2) || value2 === '' || value2 === null || (checkForUndefinedValues && value2 === undefined)) ? -99e+10 : parseFloat(value2);
        return sortDirection * (x === y ? 0 : (x > y ? 1 : -1));
    };

    var objectStringSorter = function (value1, value2, sortDirection, sortColumn) {
        if (!sortColumn || !sortColumn.dataKey) {
            throw new Error('Sorting a "FieldType.object" requires you to provide the "dataKey" (object property name) of the object so that we can use it to sort correctly');
        }
        var stringValue1 = (value1 && value1.hasOwnProperty(sortColumn.dataKey)) ? value1[sortColumn.dataKey] : value1;
        var stringValue2 = (value2 && value2.hasOwnProperty(sortColumn.dataKey)) ? value2[sortColumn.dataKey] : value2;
        if (sortDirection === undefined || sortDirection === null) {
            sortDirection = exports.SortDirectionNumber.neutral;
        }
        var position = 0;
        if (typeof value1 !== 'object') {
            position = -99e+10;
        }
        else if (typeof value2 !== 'object') {
            position = 99e+10;
        }
        else if (!stringValue1) {
            position = -1;
        }
        else if (!stringValue2) {
            position = 1;
        }
        else if (stringValue1 === stringValue2) {
            position = 0;
        }
        else if (sortDirection) {
            position = stringValue1 < stringValue2 ? -1 : 1;
        }
        else {
            position = stringValue1 < stringValue2 ? 1 : -1;
        }
        return sortDirection * position;
    };

    var stringSorter = function (value1, value2, sortDirection, sortColumn) {
        if (sortDirection === undefined || sortDirection === null) {
            sortDirection = exports.SortDirectionNumber.neutral;
        }
        var position = 0;
        var checkForUndefinedValues = sortColumn && sortColumn.valueCouldBeUndefined || false;
        if (value1 === value2) {
            position = 0;
        }
        else if (value1 === null || (checkForUndefinedValues && value1 === undefined)) {
            position = -1;
        }
        else if (value2 === null || (checkForUndefinedValues && value2 === undefined)) {
            position = 1;
        }
        else if (sortDirection) {
            position = value1 < value2 ? -1 : 1;
        }
        else {
            position = value1 < value2 ? 1 : -1;
        }
        return sortDirection * position;
    };

    var moment = moment_; // patch to fix rollup "moment has no default export" issue, document here https://github.com/rollup/rollup/issues/670
    /**
     * Add an item to an array only when the item does not exists, when the item is an object we will be using their "id" to compare
     * @param inputArray
     * @param inputItem
     * @param itemIdPropName
     */
    function addToArrayWhenNotExists(inputArray, inputItem, itemIdPropName) {
        if (itemIdPropName === void 0) { itemIdPropName = 'id'; }
        var arrayRowIndex = -1;
        if (typeof inputItem === 'object' && inputItem.hasOwnProperty(itemIdPropName)) {
            arrayRowIndex = inputArray.findIndex(function (item) { return item[itemIdPropName] === inputItem[itemIdPropName]; });
        }
        else {
            arrayRowIndex = inputArray.findIndex(function (item) { return item === inputItem; });
        }
        if (arrayRowIndex < 0) {
            inputArray.push(inputItem);
        }
    }
    /**
     * Simple function to which will loop and create as demanded the number of white spaces,
     * this is used in the CSV export
     * @param int nbSpaces: number of white spaces to create
     */
    function addWhiteSpaces(nbSpaces) {
        var result = '';
        for (var i = 0; i < nbSpaces; i++) {
            result += ' ';
        }
        return result;
    }
    /**
     * Remove a column from the grid by it's index in the grid
     * @param array input
     * @param index
     */
    function arrayRemoveItemByIndex(array, index) {
        return array.filter(function (_el, i) { return index !== i; });
    }
    /**
     * Convert a flat array (with "parentId" references) into a hierarchical dataset structure (where children are array(s) inside their parent objects)
     * @param flatArray input array (flat dataset)
     * @param options you can provide the following options:: "parentPropName" (defaults to "parent"), "childrenPropName" (defaults to "children") and "identifierPropName" (defaults to "id")
     * @return roots - hierarchical data view array
     */
    function convertParentChildArrayToHierarchicalView(flatArray, options) {
        var childrenPropName = options && options.childrenPropName || 'children';
        var parentPropName = options && options.parentPropName || '__parentId';
        var identifierPropName = options && options.identifierPropName || 'id';
        var hasChildrenFlagPropName = '__hasChildren';
        var treeLevelPropName = '__treeLevel';
        var inputArray = $.extend(true, [], flatArray);
        var roots = []; // things without parent
        // make them accessible by guid on this map
        var all = {};
        inputArray.forEach(function (item) { return all[item[identifierPropName]] = item; });
        // connect childrens to its parent, and split roots apart
        Object.keys(all).forEach(function (id) {
            var item = all[id];
            if (item[parentPropName] === null || !item.hasOwnProperty(parentPropName)) {
                delete item[parentPropName];
                roots.push(item);
            }
            else if (item[parentPropName] in all) {
                var p = all[item[parentPropName]];
                if (!(childrenPropName in p)) {
                    p[childrenPropName] = [];
                }
                delete item[parentPropName];
                p[childrenPropName].push(item);
            }
            // delete any unnecessary properties that were possibly created in the flat array but shouldn't be part of the tree data
            delete item[treeLevelPropName];
            delete item[hasChildrenFlagPropName];
        });
        return roots;
    }
    /**
     * Convert a hierarchical array (with children) into a flat array structure array (where the children are pushed as next indexed item in the array)
     * @param hierarchicalArray - input hierarchical array
     * @param options - you can provide "childrenPropName" (defaults to "children")
     * @return output - Parent/Child array
     */
    function convertHierarchicalViewToParentChildArray(hierarchicalArray, options) {
        var outputArray = [];
        convertHierarchicalViewToParentChildArrayByReference($.extend(true, [], hierarchicalArray), outputArray, options, 0);
        // the output array is the one passed as reference
        return outputArray;
    }
    /**
     * Convert a hierarchical array (with children) into a flat array structure array but using the array as the output (the array is the pointer reference)
     * @param hierarchicalArray - input hierarchical array
     * @param outputArrayRef - output array passed (and modified) by reference
     * @param options - you can provide "childrenPropName" (defaults to "children")
     * @param treeLevel - tree level number
     * @param parentId - parent ID
     */
    function convertHierarchicalViewToParentChildArrayByReference(hierarchicalArray, outputArrayRef, options, treeLevel, parentId) {
        var e_1, _a;
        if (treeLevel === void 0) { treeLevel = 0; }
        var childrenPropName = options && options.childrenPropName || 'children';
        var identifierPropName = options && options.identifierPropName || 'id';
        var hasChildrenFlagPropName = options && options.hasChildrenFlagPropName || '__hasChildren';
        var treeLevelPropName = options && options.treeLevelPropName || '__treeLevel';
        var parentPropName = options && options.parentPropName || '__parentId';
        if (Array.isArray(hierarchicalArray)) {
            var _loop_1 = function (item) {
                if (item) {
                    var itemExist = outputArrayRef.find(function (itm) { return itm[identifierPropName] === item[identifierPropName]; });
                    if (!itemExist) {
                        item[treeLevelPropName] = treeLevel; // save tree level ref
                        item[parentPropName] = parentId || null;
                        outputArrayRef.push(item);
                    }
                    if (Array.isArray(item[childrenPropName])) {
                        treeLevel++;
                        convertHierarchicalViewToParentChildArrayByReference(item[childrenPropName], outputArrayRef, options, treeLevel, item[identifierPropName]);
                        treeLevel--;
                        item[hasChildrenFlagPropName] = true;
                        delete item[childrenPropName]; // remove the children property
                    }
                }
            };
            try {
                for (var hierarchicalArray_1 = __values(hierarchicalArray), hierarchicalArray_1_1 = hierarchicalArray_1.next(); !hierarchicalArray_1_1.done; hierarchicalArray_1_1 = hierarchicalArray_1.next()) {
                    var item = hierarchicalArray_1_1.value;
                    _loop_1(item);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (hierarchicalArray_1_1 && !hierarchicalArray_1_1.done && (_a = hierarchicalArray_1.return)) _a.call(hierarchicalArray_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
    }
    /**
     * Create an immutable clone of an array or object
     * (c) 2019 Chris Ferdinandi, MIT License, https://gomakethings.com
     * @param  {Array|Object} obj The array or object to copy
     * @return {Array|Object}     The clone of the array or object
     */
    function deepCopy(obj) {
        /**
         * Create an immutable copy of an object
         * @return {Object}
         */
        var cloneObj = function () {
            // Create new object
            var clone = {};
            // Loop through each item in the original
            // Recursively copy it's value and add to the clone
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    clone[key] = deepCopy(obj[key]);
                }
            }
            return clone;
        };
        /**
         * Create an immutable copy of an array
         * @return {Array}
         */
        var cloneArr = function () {
            return obj.map(function (item) { return deepCopy(item); });
        };
        // -- init --//
        // Get object type
        var type = Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();
        // If an object
        if (type === 'object') {
            return cloneObj();
        }
        // If an array
        if (type === 'array') {
            return cloneArr();
        }
        // Otherwise, return it as-is
        return obj;
    }
    /**
     * Find an item from a hierarchical view structure (a parent that can have children array which themseleves can children and so on)
     * @param hierarchicalArray
     * @param predicate
     * @param childrenPropertyName
     */
    function findItemInHierarchicalStructure(hierarchicalArray, predicate, childrenPropertyName) {
        if (!childrenPropertyName) {
            throw new Error('findRecursive requires parameter "childrenPropertyName"');
        }
        var initialFind = hierarchicalArray.find(predicate);
        var elementsWithChildren = hierarchicalArray.filter(function (x) { return x.hasOwnProperty(childrenPropertyName) && x[childrenPropertyName]; });
        if (initialFind) {
            return initialFind;
        }
        else if (elementsWithChildren.length) {
            var childElements_1 = [];
            elementsWithChildren.forEach(function (item) {
                if (item.hasOwnProperty(childrenPropertyName)) {
                    childElements_1.push.apply(childElements_1, __spread(item[childrenPropertyName]));
                }
            });
            return findItemInHierarchicalStructure(childElements_1, predicate, childrenPropertyName);
        }
        return undefined;
    }
    /**
     * HTML decode using jQuery with a <div>
     * Create a in-memory div, set it's inner text(which jQuery automatically encodes)
     * then grab the encoded contents back out.  The div never exists on the page.
    */
    function htmlDecode(encodedStr) {
        var parser = DOMParser && new DOMParser;
        if (parser && parser.parseFromString) {
            var dom = parser.parseFromString('<!doctype html><body>' + encodedStr, 'text/html');
            return dom && dom.body && dom.body.textContent;
        }
        else {
            // for some browsers that might not support DOMParser, use jQuery instead
            return $('<div/>').html(encodedStr).text();
        }
    }
    /**
     * HTML encode using jQuery with a <div>
     * Create a in-memory div, set it's inner text(which jQuery automatically encodes)
     * then grab the encoded contents back out.  The div never exists on the page.
    */
    function htmlEncode(inputValue) {
        var entityMap = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            '\'': '&#39;'
        };
        // all symbols::  /[&<>"'`=\/]/g
        return (inputValue || '').toString().replace(/[&<>"']/g, function (s) { return entityMap[s]; });
    }
    /**
     * Decode text into html entity
     * @param string text: input text
     * @param string text: output text
     */
    function htmlEntityDecode(input) {
        return input.replace(/&#(\d+);/g, function (_match, dec) {
            return String.fromCharCode(dec);
        });
    }
    /**
     * Decode text into html entity
     * @param string text: input text
     * @param string text: output text
     */
    function htmlEntityEncode(input) {
        var buf = [];
        for (var i = input.length - 1; i >= 0; i--) {
            buf.unshift(['&#', input[i].charCodeAt(), ';'].join(''));
        }
        return buf.join('');
    }
    /**
     * Compares two arrays of characters to determine if all the items are equal
     * @param a first array
     * @param b second array to compare with a
     * @param [orderMatters=false] flag if the order matters, if not arrays will be sorted before comparison
     * @return boolean true if equal, else false
     */
    function charArraysEqual(a, b, orderMatters) {
        if (orderMatters === void 0) { orderMatters = false; }
        if (!a || !b || !Array.isArray(a) || !Array.isArray(a)) {
            return false;
        }
        if (a.length !== b.length) {
            return false;
        }
        if (!orderMatters && a.sort && b.sort) {
            a.sort();
            b.sort();
        }
        for (var i = 0; i < a.length; ++i) {
            if (a[i] !== b[i]) {
                return false;
            }
        }
        return true;
    }
    /**
     * Try casting an input of type Promise | Observable into a Promise type.
     * @param object which could be of type Promise or Observable
     * @param fromServiceName string representing the caller service name and will be used if we throw a casting problem error
     */
    function castToPromise(input, fromServiceName) {
        if (fromServiceName === void 0) { fromServiceName = ''; }
        var promise = input;
        if (input instanceof Promise) {
            // if it's already a Promise then return it
            return input;
        }
        else if (input instanceof rxjs.Observable) {
            promise = input.pipe(operators.first()).toPromise();
        }
        if (!(promise instanceof Promise)) {
            throw new Error("Something went wrong, Angular-Slickgrid " + fromServiceName + " is not able to convert the Observable into a Promise.\n      If you are using Angular HttpClient, you could try converting your http call to a Promise with \".toPromise()\"\n      for example::  this.http.post('graphql', { query: graphqlQuery }).toPromise()\n      ");
        }
        return promise;
    }
    /**
     * Uses the logic function to find an item in an array or returns the default
     * value provided (empty object by default)
     * @param any[] array the array to filter
     * @param function logic the logic to find the item
     * @param any [defaultVal={}] the default value to return
     * @return object the found object or default value
     */
    function findOrDefault(array, logic, defaultVal) {
        if (defaultVal === void 0) { defaultVal = {}; }
        return array.find(logic) || defaultVal;
    }
    /**
     * Encode string to html special char and add html space padding defined
     * @param {string} inputStr - input string
     * @param {number} paddingLength - padding to add
     */
    function htmlEncodedStringWithPadding(inputStr, paddingLength) {
        var inputStrLn = inputStr.length;
        var outputStr = htmlEncode(inputStr);
        if (inputStrLn < paddingLength) {
            for (var i = inputStrLn; i < paddingLength; i++) {
                outputStr += "&nbsp;";
            }
        }
        return outputStr;
    }
    /**
      * Take a number (or a string) and display it as a formatted decimal string with defined minimum and maximum decimals
      * @param input
      * @param minDecimal
      * @param maxDecimal
      */
    function decimalFormatted(input, minDecimal, maxDecimal, decimalSeparator, thousandSeparator) {
        if (decimalSeparator === void 0) { decimalSeparator = '.'; }
        if (thousandSeparator === void 0) { thousandSeparator = ''; }
        if (isNaN(+input)) {
            return input;
        }
        var minDec = (minDecimal === undefined) ? 2 : minDecimal;
        var maxDec = (maxDecimal === undefined) ? 2 : maxDecimal;
        var amount = String(Math.round(+input * Math.pow(10, maxDec)) / Math.pow(10, maxDec));
        if ((amount.indexOf('.') < 0) && (minDec > 0)) {
            amount += '.';
        }
        while ((amount.length - amount.indexOf('.')) <= minDec) {
            amount += '0';
        }
        var decimalSplit = amount.split('.');
        var integerNumber;
        var decimalNumber;
        // do we want to display our number with a custom separator in each thousand position
        if (thousandSeparator) {
            integerNumber = decimalSplit.length >= 1 ? thousandSeparatorFormatted(decimalSplit[0], thousandSeparator) : undefined;
        }
        else {
            integerNumber = decimalSplit.length >= 1 ? decimalSplit[0] : amount;
        }
        // when using a separator that is not a dot, replace it with the new separator
        if (decimalSplit.length > 1) {
            decimalNumber = decimalSplit[1];
        }
        var output = '';
        if (integerNumber !== undefined && decimalNumber !== undefined) {
            output = "" + integerNumber + decimalSeparator + decimalNumber;
        }
        else if (integerNumber !== undefined && integerNumber !== null) {
            output = integerNumber;
        }
        return output;
    }
    /**
     * Loop through all properties of an object and nullify any properties that are instanceof HTMLElement,
     * if we detect an array then use recursion to go inside it and apply same logic
     * @param obj - object containing 1 or more properties with DOM Elements
     */
    function destroyObjectDomElementProps(obj) {
        var e_2, _a;
        if (obj) {
            try {
                for (var _b = __values(Object.keys(obj)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var key = _c.value;
                    if (Array.isArray(obj[key])) {
                        destroyObjectDomElementProps(obj[key]);
                    }
                    if (obj[key] instanceof HTMLElement) {
                        obj[key] = null;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    }
    /**
     * Format a number following options passed as arguments (decimals, separator, ...)
     * @param input
     * @param minDecimal
     * @param maxDecimal
     * @param displayNegativeNumberWithParentheses
     * @param symbolPrefix
     * @param symbolSuffix
     * @param decimalSeparator
     * @param thousandSeparator
     */
    function formatNumber(input, minDecimal, maxDecimal, displayNegativeNumberWithParentheses, symbolPrefix, symbolSuffix, decimalSeparator, thousandSeparator) {
        if (symbolPrefix === void 0) { symbolPrefix = ''; }
        if (symbolSuffix === void 0) { symbolSuffix = ''; }
        if (decimalSeparator === void 0) { decimalSeparator = '.'; }
        if (thousandSeparator === void 0) { thousandSeparator = ''; }
        if (isNaN(+input)) {
            return input;
        }
        var calculatedValue = ((Math.round(parseFloat(input) * 1000000) / 1000000));
        if (calculatedValue < 0) {
            var absValue = Math.abs(calculatedValue);
            if (displayNegativeNumberWithParentheses) {
                if (!isNaN(minDecimal) || !isNaN(maxDecimal)) {
                    return "(" + symbolPrefix + decimalFormatted(absValue, minDecimal, maxDecimal, decimalSeparator, thousandSeparator) + symbolSuffix + ")";
                }
                var formattedValue = thousandSeparatorFormatted("" + absValue, thousandSeparator);
                return "(" + symbolPrefix + formattedValue + symbolSuffix + ")";
            }
            else {
                if (!isNaN(minDecimal) || !isNaN(maxDecimal)) {
                    return "-" + symbolPrefix + decimalFormatted(absValue, minDecimal, maxDecimal, decimalSeparator, thousandSeparator) + symbolSuffix;
                }
                var formattedValue = thousandSeparatorFormatted("" + absValue, thousandSeparator);
                return "-" + symbolPrefix + formattedValue + symbolSuffix;
            }
        }
        else {
            if (!isNaN(minDecimal) || !isNaN(maxDecimal)) {
                return "" + symbolPrefix + decimalFormatted(input, minDecimal, maxDecimal, decimalSeparator, thousandSeparator) + symbolSuffix;
            }
            var formattedValue = thousandSeparatorFormatted("" + input, thousandSeparator);
            return "" + symbolPrefix + formattedValue + symbolSuffix;
        }
    }
    /** From a dot (.) notation path, find and return a property within an object given a path */
    function getDescendantProperty(obj, path) {
        return path.split('.').reduce(function (acc, part) { return acc && acc[part]; }, obj);
    }
    /** Get HTML Element position offset (without jQuery) */
    function getHtmlElementOffset(element) {
        var rect = element.getBoundingClientRect();
        var top = 0;
        var left = 0;
        if (rect && rect.top !== undefined && rect.left !== undefined) {
            top = rect.top + window.pageYOffset;
            left = rect.left + window.pageXOffset;
        }
        return { top: top, left: left };
    }
    /** Get Translation Prefix, defaults to an empty string */
    function getTranslationPrefix(gridOptions) {
        if (gridOptions && gridOptions.translationNamespace) {
            return gridOptions.translationNamespace + (gridOptions.translationNamespaceSeparator || '');
        }
        return '';
    }
    /**
     * From a Date FieldType, return it's equivalent moment.js format
     * refer to moment.js for the format standard used: https://momentjs.com/docs/#/parsing/string-format/
     * @param fieldType
     */
    function mapMomentDateFormatWithFieldType(fieldType) {
        var map;
        switch (fieldType) {
            case exports.FieldType.dateTime:
            case exports.FieldType.dateTimeIso:
                map = 'YYYY-MM-DD HH:mm:ss';
                break;
            case exports.FieldType.dateTimeShortIso:
                map = 'YYYY-MM-DD HH:mm';
                break;
            case exports.FieldType.dateTimeIsoAmPm:
                map = 'YYYY-MM-DD hh:mm:ss a';
                break;
            case exports.FieldType.dateTimeIsoAM_PM:
                map = 'YYYY-MM-DD hh:mm:ss A';
                break;
            // all Euro Formats (date/month/year)
            case exports.FieldType.dateEuro:
                map = 'DD/MM/YYYY';
                break;
            case exports.FieldType.dateEuroShort:
                map = 'D/M/YY';
                break;
            case exports.FieldType.dateTimeEuro:
                map = 'DD/MM/YYYY HH:mm:ss';
                break;
            case exports.FieldType.dateTimeShortEuro:
                map = 'DD/MM/YYYY HH:mm';
                break;
            case exports.FieldType.dateTimeEuroAmPm:
                map = 'DD/MM/YYYY hh:mm:ss a';
                break;
            case exports.FieldType.dateTimeEuroAM_PM:
                map = 'DD/MM/YYYY hh:mm:ss A';
                break;
            case exports.FieldType.dateTimeEuroShort:
                map = 'D/M/YY H:m:s';
                break;
            case exports.FieldType.dateTimeEuroShortAmPm:
                map = 'D/M/YY h:m:s a';
                break;
            // all US Formats (month/date/year)
            case exports.FieldType.dateUs:
                map = 'MM/DD/YYYY';
                break;
            case exports.FieldType.dateUsShort:
                map = 'M/D/YY';
                break;
            case exports.FieldType.dateTimeUs:
                map = 'MM/DD/YYYY HH:mm:ss';
                break;
            case exports.FieldType.dateTimeShortUs:
                map = 'MM/DD/YYYY HH:mm';
                break;
            case exports.FieldType.dateTimeUsAmPm:
                map = 'MM/DD/YYYY hh:mm:ss a';
                break;
            case exports.FieldType.dateTimeUsAM_PM:
                map = 'MM/DD/YYYY hh:mm:ss A';
                break;
            case exports.FieldType.dateTimeUsShort:
                map = 'M/D/YY H:m:s';
                break;
            case exports.FieldType.dateTimeUsShortAmPm:
                map = 'M/D/YY h:m:s a';
                break;
            case exports.FieldType.dateUtc:
                map = 'YYYY-MM-DDTHH:mm:ss.SSSZ';
                break;
            case exports.FieldType.date:
            case exports.FieldType.dateIso:
            default:
                map = 'YYYY-MM-DD';
                break;
        }
        return map;
    }
    /**
     * From a Date FieldType, return it's equivalent Flatpickr format
     * refer to Flatpickr for the format standard used: https://chmln.github.io/flatpickr/formatting/#date-formatting-tokens
     * also note that they seem very similar to PHP format (except for am/pm): http://php.net/manual/en/function.date.php
     * @param fieldType
     */
    function mapFlatpickrDateFormatWithFieldType(fieldType) {
        /*
          d: Day of the month, 2 digits with leading zeros	01 to 31
          D: A textual representation of a day	Mon through Sun
          l: (lowercase 'L')	A full textual representation of the day of the week	Sunday through Saturday
          j: Day of the month without leading zeros	1 to 31
          J: Day of the month without leading zeros and ordinal suffix	1st, 2nd, to 31st
          w: Numeric representation of the day of the week	0 (for Sunday) through 6 (for Saturday)
          F: A full textual representation of a month	January through December
          m: Numeric representation of a month, with leading zero	01 through 12
          n: Numeric representation of a month, without leading zeros	1 through 12
          M: A short textual representation of a month	Jan through Dec
          U: The number of seconds since the Unix Epoch	1413704993
          y: A two digit representation of a year	99 or 03
          Y: A full numeric representation of a year, 4 digits	1999 or 2003
          H: Hours (24 hours)	00 to 23
          h: Hours	1 to 12
          i: Minutes	00 to 59
          S: Seconds, 2 digits	00 to 59
          s: Seconds	0, 1 to 59
          K: AM/PM	AM or PM
        */
        var map;
        switch (fieldType) {
            case exports.FieldType.dateTime:
            case exports.FieldType.dateTimeIso:
                map = 'Y-m-d H:i:S';
                break;
            case exports.FieldType.dateTimeShortIso:
                map = 'Y-m-d H:i';
                break;
            case exports.FieldType.dateTimeIsoAmPm:
            case exports.FieldType.dateTimeIsoAM_PM:
                map = 'Y-m-d h:i:S K'; // there is no lowercase in Flatpickr :(
                break;
            // all Euro Formats (date/month/year)
            case exports.FieldType.dateEuro:
                map = 'd/m/Y';
                break;
            case exports.FieldType.dateEuroShort:
                map = 'd/m/y';
                break;
            case exports.FieldType.dateTimeEuro:
                map = 'd/m/Y H:i:S';
                break;
            case exports.FieldType.dateTimeShortEuro:
                map = 'd/m/y H:i';
                break;
            case exports.FieldType.dateTimeEuroAmPm:
                map = 'd/m/Y h:i:S K'; // there is no lowercase in Flatpickr :(
                break;
            case exports.FieldType.dateTimeEuroAM_PM:
                map = 'd/m/Y h:i:s K';
                break;
            case exports.FieldType.dateTimeEuroShort:
                map = 'd/m/y H:i:s';
                break;
            case exports.FieldType.dateTimeEuroShortAmPm:
                map = 'd/m/y h:i:s K'; // there is no lowercase in Flatpickr :(
                break;
            // all US Formats (month/date/year)
            case exports.FieldType.dateUs:
                map = 'm/d/Y';
                break;
            case exports.FieldType.dateUsShort:
                map = 'm/d/y';
                break;
            case exports.FieldType.dateTimeUs:
                map = 'm/d/Y H:i:S';
                break;
            case exports.FieldType.dateTimeShortUs:
                map = 'm/d/y H:i';
                break;
            case exports.FieldType.dateTimeUsAmPm:
                map = 'm/d/Y h:i:S K'; // there is no lowercase in Flatpickr :(
                break;
            case exports.FieldType.dateTimeUsAM_PM:
                map = 'm/d/Y h:i:s K';
                break;
            case exports.FieldType.dateTimeUsShort:
                map = 'm/d/y H:i:s';
                break;
            case exports.FieldType.dateTimeUsShortAmPm:
                map = 'm/d/y h:i:s K'; // there is no lowercase in Flatpickr :(
                break;
            case exports.FieldType.dateUtc:
                map = 'Z';
                break;
            case exports.FieldType.date:
            case exports.FieldType.dateIso:
            default:
                map = 'Y-m-d';
                break;
        }
        return map;
    }
    /**
     * Mapper for query operators (ex.: <= is "le", > is "gt")
     * @param string operator
     * @returns string map
     */
    function mapOperatorType(operator) {
        var map;
        switch (operator) {
            case '<':
            case 'LT':
                map = exports.OperatorType.lessThan;
                break;
            case '<=':
            case 'LE':
                map = exports.OperatorType.lessThanOrEqual;
                break;
            case '>':
            case 'GT':
                map = exports.OperatorType.greaterThan;
                break;
            case '>=':
            case 'GE':
                map = exports.OperatorType.greaterThanOrEqual;
                break;
            case '<>':
            case '!=':
            case 'NE':
                map = exports.OperatorType.notEqual;
                break;
            case '*':
            case 'a*':
            case 'StartsWith':
                map = exports.OperatorType.startsWith;
                break;
            case '*z':
            case 'EndsWith':
                map = exports.OperatorType.endsWith;
                break;
            case '=':
            case '==':
            case 'EQ':
                map = exports.OperatorType.equal;
                break;
            case 'IN':
                map = exports.OperatorType.in;
                break;
            case 'NIN':
            case 'NOT_IN':
                map = exports.OperatorType.notIn;
                break;
            case 'Not_Contains':
            case 'NOT_CONTAINS':
                map = exports.OperatorType.notContains;
                break;
            case 'Contains':
            case 'CONTAINS':
            default:
                map = exports.OperatorType.contains;
                break;
        }
        return map;
    }
    /**
     * Find equivalent short designation of an Operator Type or Operator String.
     * When using a Compound Filter, we use the short designation and so we need the mapped value.
     * For example OperatorType.startsWith short designation is "a*", while OperatorType.greaterThanOrEqual is ">="
     */
    function mapOperatorToShorthandDesignation(operator) {
        var shortOperator = '';
        switch (operator) {
            case exports.OperatorType.greaterThan:
            case '>':
                shortOperator = '>';
                break;
            case exports.OperatorType.greaterThanOrEqual:
            case '>=':
                shortOperator = '>=';
                break;
            case exports.OperatorType.lessThan:
            case '<':
                shortOperator = '<';
                break;
            case exports.OperatorType.lessThanOrEqual:
            case '<=':
                shortOperator = '<=';
                break;
            case exports.OperatorType.notEqual:
            case '<>':
                shortOperator = '<>';
                break;
            case exports.OperatorType.equal:
            case '=':
            case '==':
            case 'EQ':
                shortOperator = '=';
                break;
            case exports.OperatorType.startsWith:
            case 'a*':
            case '*':
                shortOperator = 'a*';
                break;
            case exports.OperatorType.endsWith:
            case '*z':
                shortOperator = '*z';
                break;
            default:
                // any other operator will be considered as already a short expression, so we can return same input operator
                shortOperator = operator;
                break;
        }
        return shortOperator;
    }
    /**
     * Mapper for query operator by a Filter Type
     * For example a multiple-select typically uses 'IN' operator
     * @param operator
     * @returns string map
     */
    function mapOperatorByFieldType(fieldType) {
        var map;
        switch (fieldType) {
            case exports.FieldType.unknown:
            case exports.FieldType.string:
            case exports.FieldType.text:
            case exports.FieldType.password:
            case exports.FieldType.readonly:
                map = exports.OperatorType.contains;
                break;
            case exports.FieldType.float:
            case exports.FieldType.number:
            case exports.FieldType.date:
            case exports.FieldType.dateIso:
            case exports.FieldType.dateUtc:
            case exports.FieldType.dateTime:
            case exports.FieldType.dateTimeIso:
            case exports.FieldType.dateTimeIsoAmPm:
            case exports.FieldType.dateTimeIsoAM_PM:
            case exports.FieldType.dateEuro:
            case exports.FieldType.dateEuroShort:
            case exports.FieldType.dateTimeEuro:
            case exports.FieldType.dateTimeEuroAmPm:
            case exports.FieldType.dateTimeEuroAM_PM:
            case exports.FieldType.dateTimeEuroShort:
            case exports.FieldType.dateTimeEuroShortAmPm:
            case exports.FieldType.dateTimeEuroShortAM_PM:
            case exports.FieldType.dateUs:
            case exports.FieldType.dateUsShort:
            case exports.FieldType.dateTimeUs:
            case exports.FieldType.dateTimeUsAmPm:
            case exports.FieldType.dateTimeUsAM_PM:
            case exports.FieldType.dateTimeUsShort:
            case exports.FieldType.dateTimeUsShortAmPm:
            case exports.FieldType.dateTimeUsShortAM_PM:
            default:
                map = exports.OperatorType.equal;
                break;
        }
        return map;
    }
    /** Parse any input (bool, number, string) and return a boolean or False when not possible */
    function parseBoolean(input) {
        return /(true|1)/i.test(input + '');
    }
    /**
     * Parse a date passed as a string (Date only, without time) and return a Date object (if valid)
     * @param inputDateString
     * @returns string date formatted
     */
    function parseUtcDate(inputDateString, useUtc) {
        var date = null;
        if (/^[0-9\-\/]*$/.test(inputDateString)) {
            // get the UTC datetime with moment.js but we need to decode the value so that it's valid text
            var dateString = decodeURIComponent(inputDateString);
            var dateMoment = moment(new Date(dateString));
            if (dateMoment.isValid() && dateMoment.year().toString().length === 4) {
                date = (useUtc) ? dateMoment.utc().format() : dateMoment.format();
            }
        }
        return date;
    }
    /**
     * Sanitize, return only the text without HTML tags
     * @input htmlString
     * @return text
     */
    function sanitizeHtmlToText(htmlString) {
        var temp = document.createElement('div');
        temp.innerHTML = htmlString;
        return temp.textContent || temp.innerText || '';
    }
    /** Set the object value of deeper node from a given dot (.) notation path (e.g.: "user.firstName") */
    function setDeepValue(obj, path, value) {
        if (typeof path === 'string') {
            path = path.split('.');
        }
        if (path.length > 1) {
            var e = path.shift();
            if (obj && e !== undefined) {
                setDeepValue(obj[e] = Object.prototype.toString.call(obj[e]) === '[object Object]' ? obj[e] : {}, path, value);
            }
        }
        else if (obj && path[0]) {
            obj[path[0]] = value;
        }
    }
    /**
     * Format a number or a string into a string that is separated every thousand,
     * the default separator is a comma but user can optionally pass a different one
     * @param inputValue
     * @param separator default to comma ","
     * @returns string
     */
    function thousandSeparatorFormatted(inputValue, separator) {
        if (separator === void 0) { separator = ','; }
        if (inputValue !== null && inputValue !== undefined) {
            var stringValue = "" + inputValue;
            var decimalSplit = stringValue.split('.');
            if (decimalSplit.length === 2) {
                return decimalSplit[0].replace(/\B(?=(\d{3})+(?!\d))/g, separator) + "." + decimalSplit[1];
            }
            return stringValue.replace(/\B(?=(\d{3})+(?!\d))/g, separator);
        }
        return inputValue;
    }
    /**
     * Title case (or capitalize) first char of a string, for example "hello world" will become "Hello world"
     * Change the string to be title case on the complete sentence (upper case first char of each word while changing everything else to lower case)
     * @param inputStr
     * @returns string
     */
    function titleCase(inputStr, caseEveryWords) {
        if (caseEveryWords === void 0) { caseEveryWords = false; }
        if (typeof inputStr === 'string') {
            if (caseEveryWords) {
                return inputStr.replace(/\w\S*/g, function (outputStr) {
                    return outputStr.charAt(0).toUpperCase() + outputStr.substr(1).toLowerCase();
                });
            }
            return inputStr.charAt(0).toUpperCase() + inputStr.slice(1);
        }
        return inputStr;
    }
    /**
     * Converts a string to camel case (camelCase), for example "hello-world" (or "hellow world") will become "helloWorld"
     * @param inputStr the string to convert
     * @return the string in camel case
     */
    function toCamelCase(inputStr) {
        if (typeof inputStr === 'string') {
            return inputStr.replace(/(?:^\w|[A-Z]|\b\w|[\s+\-_\/])/g, function (match, offset) {
                // remove white space or hypens or underscores
                if (/[\s+\-_\/]/.test(match)) {
                    return '';
                }
                return offset === 0 ? match.toLowerCase() : match.toUpperCase();
            });
        }
        return inputStr;
    }
    /**
     * Converts a string to kebab (hypen) case, for example "helloWorld" will become "hello-world"
     * @param str the string to convert
     * @return the string in kebab case
     */
    function toKebabCase(inputStr) {
        if (typeof inputStr === 'string') {
            return toCamelCase(inputStr).replace(/([A-Z])/g, '-$1').toLowerCase();
        }
        return inputStr;
    }
    /**
     * Converts a string from camelCase to snake_case (underscore) case, for example "helloWorld" will become "hello_world"
     * @param str the string to convert
     * @return the string in kebab case
     */
    function toSnakeCase(inputStr) {
        if (typeof inputStr === 'string') {
            return toCamelCase(inputStr).replace(/([A-Z])/g, '_$1').toLowerCase();
        }
        return inputStr;
    }
    /**
     * Takes an input array and makes sure the array has unique values by removing duplicates
     * @param array input with possible duplicates
     * @param objectProperty optionally provide an object property to compare (example: 'id')
     * @return array output without duplicates
     */
    function uniqueArray(arr) {
        if (Array.isArray(arr) && arr.length > 0) {
            return arr.filter(function (item, index) {
                return arr.indexOf(item) >= index;
            });
        }
        return arr;
    }
    /**
     * Takes an input array of objects and makes sure the array has unique object values by removing duplicates
     * it will loop through the array using a property name (or "id" when is not provided) to compare uniqueness
     * @param array input with possible duplicates
     * @param propertyName defaults to "id"
     * @return array output without duplicates
     */
    function uniqueObjectArray(arr, propertyName) {
        var e_3, _a;
        if (propertyName === void 0) { propertyName = 'id'; }
        if (Array.isArray(arr) && arr.length > 0) {
            var result = [];
            var map = new Map();
            try {
                for (var arr_1 = __values(arr), arr_1_1 = arr_1.next(); !arr_1_1.done; arr_1_1 = arr_1.next()) {
                    var item = arr_1_1.value;
                    if (!map.has(item[propertyName])) {
                        map.set(item[propertyName], true); // set any value to Map
                        result.push({
                            id: item[propertyName],
                            name: item.name
                        });
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (arr_1_1 && !arr_1_1.done && (_a = arr_1.return)) _a.call(arr_1);
                }
                finally { if (e_3) throw e_3.error; }
            }
            return result;
        }
        return arr;
    }
    /**
     * Unsubscribe all Observables Subscriptions
     * It will return an empty array if it all went well
     * @param subscriptions
     */
    function unsubscribeAllObservables(subscriptions) {
        if (Array.isArray(subscriptions)) {
            subscriptions.forEach(function (subscription) {
                if (subscription && subscription.unsubscribe) {
                    subscription.unsubscribe();
                }
            });
            subscriptions = [];
        }
        return subscriptions;
    }

    var moment$1 = moment_; // patch to fix rollup "moment has no default export" issue, document here https://github.com/rollup/rollup/issues/670
    function compareDates(value1, value2, sortDirection, sortColumn, format, strict) {
        var diff = 0;
        var checkForUndefinedValues = sortColumn && sortColumn.valueCouldBeUndefined || false;
        if (value1 === null || value1 === '' || (checkForUndefinedValues && value1 === undefined) || !moment$1(value1, format, strict).isValid()) {
            diff = -1;
        }
        else if (value2 === null || value2 === '' || (checkForUndefinedValues && value2 === undefined) || !moment$1(value2, format, strict).isValid()) {
            diff = 1;
        }
        else {
            var date1 = moment$1(value1, format, strict);
            var date2 = moment$1(value2, format, strict);
            diff = parseInt(date1.format('X'), 10) - parseInt(date2.format('X'), 10);
        }
        return sortDirection * (diff === 0 ? 0 : (diff > 0 ? 1 : -1));
    }
    /** From a FieldType, return the associated date Sorter */
    function getAssociatedDateSorter(fieldType) {
        var FORMAT = (fieldType === exports.FieldType.date) ? moment$1.ISO_8601 : mapMomentDateFormatWithFieldType(fieldType);
        return function (value1, value2, sortDirection, sortColumn) {
            if (FORMAT === moment$1.ISO_8601) {
                return compareDates(value1, value2, sortDirection, sortColumn, FORMAT, false);
            }
            return compareDates(value1, value2, sortDirection, sortColumn, FORMAT, true);
        };
    }

    var Sorters = {
        /** Sorter method to sort values by Date object type (uses Moment.js ISO_8601 standard format, optionally include time) */
        date: getAssociatedDateSorter(exports.FieldType.date),
        /**
         * Sorter method to sort values by Date formatted as ISO date (excluding time),
         * If you wish to optionally include time simply use the "Sorters.date" which work with/without time
         */
        dateIso: getAssociatedDateSorter(exports.FieldType.dateIso),
        /** Sorter method to sort values by Date formatted as (YYYY-MM-DDTHH:mm:ss.SSSZ) */
        dateUtc: getAssociatedDateSorter(exports.FieldType.dateUtc),
        /** Sorter method to sort values by Date and Time (native Date object) */
        dateTime: getAssociatedDateSorter(exports.FieldType.dateTime),
        /** Sorter method to sort values by Date formatted as (YYYY-MM-DD HH:mm:ss) */
        dateTimeIso: getAssociatedDateSorter(exports.FieldType.dateTimeIso),
        /** Sorter method to sort values by Date formatted as (YYYY-MM-DD h:mm:ss a) */
        dateTimeIsoAmPm: getAssociatedDateSorter(exports.FieldType.dateTimeIsoAmPm),
        /** Sorter method to sort values by Date formatted as (YYYY-MM-DD h:mm:ss A) */
        dateTimeIsoAM_PM: getAssociatedDateSorter(exports.FieldType.dateTimeIsoAM_PM),
        /** Sorter method to sort values by Date formatted as (YYYY-MM-DD HH:mm) */
        dateTimeShortIso: getAssociatedDateSorter(exports.FieldType.dateTimeShortIso),
        /** Sorter method to sort values by Date formatted as Euro date (DD/MM/YYYY) */
        dateEuro: getAssociatedDateSorter(exports.FieldType.dateEuro),
        /** Sorter method to sort values by Date formatted as Euro short date (D/M/YY) */
        dateEuroShort: getAssociatedDateSorter(exports.FieldType.dateEuroShort),
        /** Sorter method to sort values by Date formatted as (DD/MM/YYYY HH:mm) */
        dateTimeShortEuro: getAssociatedDateSorter(exports.FieldType.dateTimeShortEuro),
        /** Sorter method to sort values by Date formatted as (DD/MM/YYYY HH:mm:ss) */
        dateTimeEuro: getAssociatedDateSorter(exports.FieldType.dateTimeEuro),
        /** Sorter method to sort values by Date formatted as (DD/MM/YYYY hh:mm:ss a) */
        dateTimeEuroAmPm: getAssociatedDateSorter(exports.FieldType.dateTimeEuroAmPm),
        /** Sorter method to sort values by Date formatted as (DD/MM/YYYY hh:mm:ss A) */
        dateTimeEuroAM_PM: getAssociatedDateSorter(exports.FieldType.dateTimeEuroAM_PM),
        /** Sorter method to sort values by Date formatted as (D/M/YY H:m:s) */
        dateTimeEuroShort: getAssociatedDateSorter(exports.FieldType.dateTimeEuroShort),
        /** Sorter method to sort values by Date formatted as (D/M/YY h:m:s a) */
        dateTimeEuroShortAmPm: getAssociatedDateSorter(exports.FieldType.dateTimeEuroShortAmPm),
        /** Sorter method to sort values by Date formatted as (D/M/YY h:m:s A) */
        dateTimeEuroShortAM_PM: getAssociatedDateSorter(exports.FieldType.dateTimeEuroShortAM_PM),
        /** Sorter method to sort values by Date formatted as US date (MM/DD/YYYY) */
        dateUs: getAssociatedDateSorter(exports.FieldType.dateUs),
        /** Sorter method to sort values by Date formatted as US short date (M/D/YY) */
        dateUsShort: getAssociatedDateSorter(exports.FieldType.dateUsShort),
        /** Sorter method to sort values by Date formatted as (MM/DD/YYYY HH:mm) */
        dateTimeShortUs: getAssociatedDateSorter(exports.FieldType.dateTimeShortUs),
        /** Sorter method to sort values by Date formatted as (MM/DD/YYYY HH:mm:s) */
        dateTimeUs: getAssociatedDateSorter(exports.FieldType.dateTimeUs),
        /** Sorter method to sort values by Date formatted as (MM/DD/YYYY hh:mm:ss a) */
        dateTimeUsAmPm: getAssociatedDateSorter(exports.FieldType.dateTimeUsAmPm),
        /** Sorter method to sort values by Date formatted as (MM/DD/YYYY hh:mm:ss A) */
        dateTimeUsAM_PM: getAssociatedDateSorter(exports.FieldType.dateTimeUsAM_PM),
        /** Sorter method to sort values by Date formatted as (M/D/YY H:m:s) */
        dateTimeUsShort: getAssociatedDateSorter(exports.FieldType.dateTimeUsShort),
        /** Sorter method to sort values by Date formatted as (M/D/YY h:m:s a) */
        dateTimeUsShortAmPm: getAssociatedDateSorter(exports.FieldType.dateTimeUsShortAmPm),
        /** Sorter method to sort values by Date formatted as (M/D/YY h:m:s A) */
        dateTimeUsShortAM_PM: getAssociatedDateSorter(exports.FieldType.dateTimeUsShortAM_PM),
        /** Sorter method to sort values as numeric fields */
        numeric: numericSorter,
        /**
         * Sorter method to sort object values with a "dataKey" provided in your column definition, it's data content must be of type string
         * Example:
         * columnDef = { id='user', field: 'user', ..., dataKey: 'firstName', sorter: Sorters.objectString }
         * collection = [{ firstName: 'John', lastName: 'Doe' }, { firstName: 'Bob', lastName: 'Cash' }]
         */
        objectString: objectStringSorter,
        /** Sorter method to sort values as regular strings */
        string: stringSorter
    };

    function sortByFieldType(fieldType, value1, value2, sortDirection, sortColumn) {
        var sortResult = 0;
        switch (fieldType) {
            case exports.FieldType.float:
            case exports.FieldType.integer:
            case exports.FieldType.number:
                sortResult = Sorters.numeric(value1, value2, sortDirection, sortColumn);
                break;
            case exports.FieldType.date:
            case exports.FieldType.dateIso:
            case exports.FieldType.dateUtc:
            case exports.FieldType.dateTime:
            case exports.FieldType.dateTimeIso:
            case exports.FieldType.dateTimeIsoAmPm:
            case exports.FieldType.dateTimeIsoAM_PM:
            case exports.FieldType.dateTimeShortIso:
            case exports.FieldType.dateEuro:
            case exports.FieldType.dateEuroShort:
            case exports.FieldType.dateTimeShortEuro:
            case exports.FieldType.dateTimeEuro:
            case exports.FieldType.dateTimeEuroAmPm:
            case exports.FieldType.dateTimeEuroAM_PM:
            case exports.FieldType.dateTimeEuroShort:
            case exports.FieldType.dateTimeEuroShortAmPm:
            case exports.FieldType.dateTimeEuroShortAM_PM:
            case exports.FieldType.dateUs:
            case exports.FieldType.dateUsShort:
            case exports.FieldType.dateTimeShortUs:
            case exports.FieldType.dateTimeUs:
            case exports.FieldType.dateTimeUsAmPm:
            case exports.FieldType.dateTimeUsAM_PM:
            case exports.FieldType.dateTimeUsShort:
            case exports.FieldType.dateTimeUsShortAmPm:
            case exports.FieldType.dateTimeUsShortAM_PM:
                sortResult = getAssociatedDateSorter(fieldType).call(this, value1, value2, sortDirection, sortColumn);
                break;
            case exports.FieldType.object:
                sortResult = Sorters.objectString(value1, value2, sortDirection, sortColumn);
                break;
            case exports.FieldType.string:
            case exports.FieldType.text:
            case exports.FieldType.password:
            case exports.FieldType.readonly:
            default:
                sortResult = Sorters.string(value1, value2, sortDirection, sortColumn);
                break;
        }
        return sortResult;
    }

    var CollectionService = /** @class */ (function () {
        function CollectionService(translate) {
            this.translate = translate;
        }
        /**
         * Filter 1 or more items from a collection
         * @param collection
         * @param filterByOptions
         */
        CollectionService.prototype.filterCollection = function (collection, filterByOptions, filterResultBy) {
            var e_1, _a;
            if (filterResultBy === void 0) { filterResultBy = exports.FilterMultiplePassType.chain; }
            var filteredCollection = [];
            // when it's array, we will use the new filtered collection after every pass
            // basically if input collection has 10 items on 1st pass and 1 item is filtered out, then on 2nd pass the input collection will be 9 items
            if (Array.isArray(filterByOptions)) {
                filteredCollection = (filterResultBy === exports.FilterMultiplePassType.merge) ? [] : collection;
                try {
                    for (var filterByOptions_1 = __values(filterByOptions), filterByOptions_1_1 = filterByOptions_1.next(); !filterByOptions_1_1.done; filterByOptions_1_1 = filterByOptions_1.next()) {
                        var filter = filterByOptions_1_1.value;
                        if (filterResultBy === exports.FilterMultiplePassType.merge) {
                            var filteredPass = this.singleFilterCollection(collection, filter);
                            filteredCollection = uniqueArray(__spread(filteredCollection, filteredPass));
                        }
                        else {
                            filteredCollection = this.singleFilterCollection(filteredCollection, filter);
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (filterByOptions_1_1 && !filterByOptions_1_1.done && (_a = filterByOptions_1.return)) _a.call(filterByOptions_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            else {
                filteredCollection = this.singleFilterCollection(collection, filterByOptions);
            }
            return filteredCollection;
        };
        /**
         * Filter an item from a collection
         * @param collection
         * @param filterBy
         */
        CollectionService.prototype.singleFilterCollection = function (collection, filterBy) {
            var filteredCollection = [];
            if (filterBy) {
                var objectProperty_1 = filterBy.property;
                var operator = filterBy.operator || exports.OperatorType.equal;
                // just check for undefined since the filter value could be null, 0, '', false etc
                var value_1 = typeof filterBy.value === 'undefined' ? '' : filterBy.value;
                switch (operator) {
                    case exports.OperatorType.equal:
                        if (objectProperty_1) {
                            filteredCollection = collection.filter(function (item) { return item[objectProperty_1] === value_1; });
                        }
                        else {
                            filteredCollection = collection.filter(function (item) { return item === value_1; });
                        }
                        break;
                    case exports.OperatorType.contains:
                        if (objectProperty_1) {
                            filteredCollection = collection.filter(function (item) { return item[objectProperty_1].toString().indexOf(value_1.toString()) !== -1; });
                        }
                        else {
                            filteredCollection = collection.filter(function (item) { return (item !== null && item !== undefined) && item.toString().indexOf(value_1.toString()) !== -1; });
                        }
                        break;
                    case exports.OperatorType.notContains:
                        if (objectProperty_1) {
                            filteredCollection = collection.filter(function (item) { return item[objectProperty_1].toString().indexOf(value_1.toString()) === -1; });
                        }
                        else {
                            filteredCollection = collection.filter(function (item) { return (item !== null && item !== undefined) && item.toString().indexOf(value_1.toString()) === -1; });
                        }
                        break;
                    case exports.OperatorType.notEqual:
                    default:
                        if (objectProperty_1) {
                            filteredCollection = collection.filter(function (item) { return item[objectProperty_1] !== value_1; });
                        }
                        else {
                            filteredCollection = collection.filter(function (item) { return item !== value_1; });
                        }
                }
            }
            return filteredCollection;
        };
        /**
         * Sort 1 or more items in a collection
         * @param column definition
         * @param collection
         * @param sortByOptions
         * @param enableTranslateLabel
         */
        CollectionService.prototype.sortCollection = function (columnDef, collection, sortByOptions, enableTranslateLabel) {
            var _this = this;
            if (enableTranslateLabel && (!this.translate || !this.translate.instant)) {
                throw new Error('[Angular-Slickgrid] requires "ngx-translate" to be installed and configured when the grid option "enableTranslate" is enabled.');
            }
            var sortedCollection = [];
            if (sortByOptions) {
                if (Array.isArray(sortByOptions)) {
                    // multi-sort
                    sortedCollection = collection.sort(function (dataRow1, dataRow2) {
                        for (var i = 0, l = sortByOptions.length; i < l; i++) {
                            var sortBy = sortByOptions[i];
                            if (sortBy && sortBy.property) {
                                // collection of objects with a property name provided
                                var sortDirection = sortBy.sortDesc ? exports.SortDirectionNumber.desc : exports.SortDirectionNumber.asc;
                                var objectProperty = sortBy.property;
                                var fieldType = sortBy.fieldType || exports.FieldType.string;
                                var value1 = (enableTranslateLabel) ? _this.translate && _this.translate.currentLang && _this.translate.instant(dataRow1[objectProperty] || ' ') : dataRow1[objectProperty];
                                var value2 = (enableTranslateLabel) ? _this.translate && _this.translate.currentLang && _this.translate.instant(dataRow2[objectProperty] || ' ') : dataRow2[objectProperty];
                                var sortResult = sortByFieldType(fieldType, value1, value2, sortDirection, columnDef);
                                if (sortResult !== exports.SortDirectionNumber.neutral) {
                                    return sortResult;
                                }
                            }
                        }
                        return exports.SortDirectionNumber.neutral;
                    });
                }
                else if (sortByOptions && sortByOptions.property) {
                    // single sort
                    // collection of objects with a property name provided
                    var objectProperty_2 = sortByOptions.property;
                    var sortDirection_1 = sortByOptions.sortDesc ? exports.SortDirectionNumber.desc : exports.SortDirectionNumber.asc;
                    var fieldType_1 = sortByOptions.fieldType || exports.FieldType.string;
                    if (objectProperty_2) {
                        sortedCollection = collection.sort(function (dataRow1, dataRow2) {
                            var value1 = (enableTranslateLabel) ? _this.translate && _this.translate.currentLang && _this.translate.instant(dataRow1[objectProperty_2] || ' ') : dataRow1[objectProperty_2];
                            var value2 = (enableTranslateLabel) ? _this.translate && _this.translate.currentLang && _this.translate.instant(dataRow2[objectProperty_2] || ' ') : dataRow2[objectProperty_2];
                            var sortResult = sortByFieldType(fieldType_1, value1, value2, sortDirection_1, columnDef);
                            if (sortResult !== exports.SortDirectionNumber.neutral) {
                                return sortResult;
                            }
                            return exports.SortDirectionNumber.neutral;
                        });
                    }
                }
                else if (sortByOptions && !sortByOptions.property) {
                    var sortDirection_2 = sortByOptions.sortDesc ? exports.SortDirectionNumber.desc : exports.SortDirectionNumber.asc;
                    var fieldType_2 = sortByOptions.fieldType || exports.FieldType.string;
                    sortedCollection = collection.sort(function (dataRow1, dataRow2) {
                        var value1 = (enableTranslateLabel) ? _this.translate && _this.translate.currentLang && _this.translate.instant(dataRow1 || ' ') : dataRow1;
                        var value2 = (enableTranslateLabel) ? _this.translate && _this.translate.currentLang && _this.translate.instant(dataRow2 || ' ') : dataRow2;
                        var sortResult = sortByFieldType(fieldType_2, value1, value2, sortDirection_2, columnDef);
                        if (sortResult !== exports.SortDirectionNumber.neutral) {
                            return sortResult;
                        }
                        return exports.SortDirectionNumber.neutral;
                    });
                }
            }
            return sortedCollection;
        };
        CollectionService.ctorParameters = function () { return [
            { type: core$1.TranslateService, decorators: [{ type: core.Optional }] }
        ]; };
        CollectionService = __decorate([
            core.Injectable(),
            __param(0, core.Optional())
        ], CollectionService);
        return CollectionService;
    }());

    var Constants = /** @class */ (function () {
        function Constants() {
        }
        // English Locale texts when using only 1 Locale instead of I18N
        Constants.locales = {
            TEXT_ALL_SELECTED: 'All Selected',
            TEXT_CANCEL: 'Cancel',
            TEXT_CLEAR_ALL_FILTERS: 'Clear all Filters',
            TEXT_CLEAR_ALL_GROUPING: 'Clear all Grouping',
            TEXT_CLEAR_ALL_SORTING: 'Clear all Sorting',
            TEXT_CLEAR_FROZEN_COLUMNS: 'Clear Frozen Columns',
            TEXT_COLLAPSE_ALL_GROUPS: 'Collapse all Groups',
            TEXT_CONTAINS: 'Contains',
            TEXT_COLUMNS: 'Columns',
            TEXT_COMMANDS: 'Commands',
            TEXT_COPY: 'Copy',
            TEXT_EQUALS: 'Equals',
            TEXT_EQUAL_TO: 'Equal to',
            TEXT_ENDS_WITH: 'Ends With',
            TEXT_EXPAND_ALL_GROUPS: 'Expand all Groups',
            TEXT_EXPORT_TO_CSV: 'Export in CSV format',
            TEXT_EXPORT_TO_TEXT_FORMAT: 'Export in Text format (Tab delimited)',
            TEXT_EXPORT_TO_EXCEL: 'Export to Excel',
            TEXT_FORCE_FIT_COLUMNS: 'Force fit columns',
            TEXT_FREEZE_COLUMNS: 'Freeze Columns',
            TEXT_GREATER_THAN: 'Greater than',
            TEXT_GREATER_THAN_OR_EQUAL_TO: 'Greater than or equal to',
            TEXT_GROUP_BY: 'Group By',
            TEXT_HIDE_COLUMN: 'Hide Column',
            TEXT_ITEMS: 'items',
            TEXT_ITEMS_PER_PAGE: 'items per page',
            TEXT_OF: 'of',
            TEXT_OK: 'OK',
            TEXT_LAST_UPDATE: 'Last Update',
            TEXT_LESS_THAN: 'Less than',
            TEXT_LESS_THAN_OR_EQUAL_TO: 'Less than or equal to',
            TEXT_NOT_EQUAL_TO: 'Not equal to',
            TEXT_PAGE: 'Page',
            TEXT_REFRESH_DATASET: 'Refresh Dataset',
            TEXT_REMOVE_FILTER: 'Remove Filter',
            TEXT_REMOVE_SORT: 'Remove Sort',
            TEXT_SAVE: 'Save',
            TEXT_SELECT_ALL: 'Select All',
            TEXT_SYNCHRONOUS_RESIZE: 'Synchronous resize',
            TEXT_SORT_ASCENDING: 'Sort Ascending',
            TEXT_SORT_DESCENDING: 'Sort Descending',
            TEXT_STARTS_WITH: 'Starts With',
            TEXT_TOGGLE_FILTER_ROW: 'Toggle Filter Row',
            TEXT_TOGGLE_PRE_HEADER_ROW: 'Toggle Pre-Header Row',
            TEXT_X_OF_Y_SELECTED: '# of % selected',
        };
        // some Validation default texts
        Constants.VALIDATION_REQUIRED_FIELD = 'Field is required';
        Constants.VALIDATION_EDITOR_VALID_NUMBER = 'Please enter a valid number';
        Constants.VALIDATION_EDITOR_VALID_INTEGER = 'Please enter a valid integer number';
        Constants.VALIDATION_EDITOR_INTEGER_BETWEEN = 'Please enter a valid integer number between {{minValue}} and {{maxValue}}';
        Constants.VALIDATION_EDITOR_INTEGER_MAX = 'Please enter a valid integer number that is lower than {{maxValue}}';
        Constants.VALIDATION_EDITOR_INTEGER_MAX_INCLUSIVE = 'Please enter a valid integer number that is lower than or equal to {{maxValue}}';
        Constants.VALIDATION_EDITOR_INTEGER_MIN = 'Please enter a valid integer number that is greater than {{minValue}}';
        Constants.VALIDATION_EDITOR_INTEGER_MIN_INCLUSIVE = 'Please enter a valid integer number that is greater than or equal to {{minValue}}';
        Constants.VALIDATION_EDITOR_NUMBER_BETWEEN = 'Please enter a valid number between {{minValue}} and {{maxValue}}';
        Constants.VALIDATION_EDITOR_NUMBER_MAX = 'Please enter a valid number that is lower than {{maxValue}}';
        Constants.VALIDATION_EDITOR_NUMBER_MAX_INCLUSIVE = 'Please enter a valid number that is lower than or equal to {{maxValue}}';
        Constants.VALIDATION_EDITOR_NUMBER_MIN = 'Please enter a valid number that is greater than {{minValue}}';
        Constants.VALIDATION_EDITOR_NUMBER_MIN_INCLUSIVE = 'Please enter a valid number that is greater than or equal to {{minValue}}';
        Constants.VALIDATION_EDITOR_DECIMAL_BETWEEN = 'Please enter a valid number with a maximum of {{maxDecimal}} decimals';
        Constants.VALIDATION_EDITOR_TEXT_LENGTH_BETWEEN = 'Please make sure your text length is between {{minLength}} and {{maxLength}} characters';
        Constants.VALIDATION_EDITOR_TEXT_MAX_LENGTH = 'Please make sure your text is less than {{maxLength}} characters';
        Constants.VALIDATION_EDITOR_TEXT_MAX_LENGTH_INCLUSIVE = 'Please make sure your text is less than or equal to {{maxLength}} characters';
        Constants.VALIDATION_EDITOR_TEXT_MIN_LENGTH = 'Please make sure your text is more than {{minLength}} character(s)';
        Constants.VALIDATION_EDITOR_TEXT_MIN_LENGTH_INCLUSIVE = 'Please make sure your text is at least {{minLength}} character(s)';
        return Constants;
    }());

    function exportWithFormatterWhenDefined(row, col, dataContext, columnDef, grid, exportOptions) {
        var output = '';
        var isEvaluatingFormatter = false;
        // first check if there are any export options provided (as Grid Options)
        if (exportOptions && exportOptions.hasOwnProperty('exportWithFormatter')) {
            isEvaluatingFormatter = !!exportOptions.exportWithFormatter;
        }
        // second check if "exportWithFormatter" is provided in the column definition, if so it will have precendence over the Grid Options exportOptions
        if (columnDef && columnDef.hasOwnProperty('exportWithFormatter')) {
            isEvaluatingFormatter = !!columnDef.exportWithFormatter;
        }
        // did the user provide a Custom Formatter for the export
        var exportCustomFormatter = (columnDef.exportCustomFormatter !== undefined) ? columnDef.exportCustomFormatter : undefined;
        // does the field have the dot (.) notation and is a complex object? if so pull the first property name
        var fieldId = columnDef.field || columnDef.id || '';
        var fieldProperty = fieldId;
        if (typeof columnDef.field === 'string' && columnDef.field.indexOf('.') > 0) {
            var props = columnDef.field.split('.');
            fieldProperty = (props.length > 0) ? props[0] : columnDef.field;
        }
        var cellValue = dataContext.hasOwnProperty(fieldProperty) ? dataContext[fieldProperty] : null;
        if (dataContext && exportCustomFormatter !== undefined) {
            var formattedData = exportCustomFormatter(row, col, cellValue, columnDef, dataContext, grid);
            output = formattedData;
            if (formattedData && typeof formattedData === 'object' && formattedData.hasOwnProperty('text')) {
                output = formattedData.text;
            }
            if (output === null || output === undefined) {
                output = '';
            }
        }
        else if (isEvaluatingFormatter && columnDef.formatter) {
            var formattedData = columnDef.formatter(row, col, cellValue, columnDef, dataContext, grid);
            output = formattedData;
            if (formattedData && typeof formattedData === 'object' && formattedData.hasOwnProperty('text')) {
                output = formattedData.text;
            }
            if (output === null || output === undefined) {
                output = '';
            }
        }
        else {
            output = (!dataContext.hasOwnProperty(fieldProperty)) ? '' : cellValue;
            if (output === null || output === undefined) {
                output = '';
            }
        }
        return output;
    }

    var moment$2 = moment_; // patch to fix rollup "moment has no default export" issue, document here https://github.com/rollup/rollup/issues/670
    var ExcelExportService = /** @class */ (function () {
        function ExcelExportService(translate) {
            this.translate = translate;
            this._fileFormat = exports.FileType.xlsx;
            this._hasGroupedItems = false;
            this.onGridBeforeExportToExcel = new rxjs.Subject();
            this.onGridAfterExportToExcel = new rxjs.Subject();
        }
        Object.defineProperty(ExcelExportService.prototype, "datasetIdName", {
            get: function () {
                return this._gridOptions && this._gridOptions.datasetIdPropertyName || 'id';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExcelExportService.prototype, "_gridOptions", {
            /** Getter for the Grid Options pulled through the Grid Object */
            get: function () {
                return (this._grid && this._grid.getOptions) ? this._grid.getOptions() : {};
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Initialize the Export Service
         * @param grid
         * @param dataView
         */
        ExcelExportService.prototype.init = function (grid, dataView) {
            this._grid = grid;
            this._dataView = dataView;
            // get locales provided by user in forRoot or else use default English locales via the Constants
            this._locales = this._gridOptions && this._gridOptions.locales || Constants.locales;
            if (this._gridOptions.enableTranslate && (!this.translate || !this.translate.instant)) {
                throw new Error('[Angular-Slickgrid] requires "ngx-translate" to be installed and configured when the grid option "enableTranslate" is enabled.');
            }
        };
        /**
         * Function to export the Grid result to an Excel CSV format using javascript for it to produce the CSV file.
         * This is a WYSIWYG export to file output (What You See is What You Get)
         *
         * NOTES: The column position needs to match perfectly the JSON Object position because of the way we are pulling the data,
         * which means that if any column(s) got moved in the UI, it has to be reflected in the JSON array output as well
         *
         * Example: exportToExcel({ format: FileType.csv, delimiter: DelimiterType.comma })
         */
        ExcelExportService.prototype.exportToExcel = function (options) {
            var _this = this;
            if (!this._grid || !this._dataView) {
                throw new Error('[Angular-Slickgrid] it seems that the SlickGrid & DataView objects are not initialized did you forget to enable the grid option flag "enableExcelExport"?');
            }
            return new Promise(function (resolve, reject) {
                _this.onGridBeforeExportToExcel.next(true);
                _this._excelExportOptions = $.extend(true, {}, _this._gridOptions.excelExportOptions, options);
                _this._fileFormat = _this._excelExportOptions.format || exports.FileType.xlsx;
                // prepare the Excel Workbook & Sheet
                _this._workbook = new excelBuilderWebpacker.Workbook();
                _this._sheet = new excelBuilderWebpacker.Worksheet({ name: _this._excelExportOptions.sheetName || 'Sheet1' });
                // add any Excel Format/Stylesheet to current Workbook
                _this._stylesheet = _this._workbook.getStyleSheet();
                var boldFormatter = _this._stylesheet.createFormat({ font: { bold: true } });
                var stringFormatter = _this._stylesheet.createFormat({ format: '@' });
                var numberFormatter = _this._stylesheet.createFormat({ format: '0' });
                var usdFormatter = _this._stylesheet.createFormat({ format: '$#,##0.00' });
                _this._stylesheetFormats = {
                    boldFormatter: boldFormatter,
                    dollarFormatter: usdFormatter,
                    numberFormatter: numberFormatter,
                    stringFormatter: stringFormatter,
                };
                // get the CSV output from the grid data
                var dataOutput = _this.getDataOutput();
                // trigger a download file
                // wrap it into a setTimeout so that the EventAggregator has enough time to start a pre-process like showing a spinner
                setTimeout(function () { return __awaiter(_this, void 0, void 0, function () {
                    var columns, currentSheetData, finalOutput, mimeType, excelBlob, downloadOptions, error_1;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                _a.trys.push([0, 2, , 3]);
                                if (this._gridOptions && this._gridOptions.excelExportOptions && this._gridOptions.excelExportOptions.customExcelHeader) {
                                    this._gridOptions.excelExportOptions.customExcelHeader(this._workbook, this._sheet);
                                }
                                columns = this._grid && this._grid.getColumns && this._grid.getColumns() || [];
                                this._sheet.setColumns(this.getColumnStyles(columns));
                                currentSheetData = this._sheet.data;
                                finalOutput = currentSheetData;
                                if (Array.isArray(currentSheetData) && Array.isArray(dataOutput)) {
                                    finalOutput = this._sheet.data.concat(dataOutput);
                                }
                                this._sheet.setData(finalOutput);
                                this._workbook.addWorksheet(this._sheet);
                                mimeType = this._fileFormat === exports.FileType.xls ? 'application/vnd.ms-excel' : 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet ';
                                return [4 /*yield*/, excelBuilderWebpacker.Builder.createFile(this._workbook, { type: 'blob', mimeType: mimeType })];
                            case 1:
                                excelBlob = _a.sent();
                                downloadOptions = {
                                    filename: this._excelExportOptions.filename + "." + this._fileFormat,
                                    format: this._fileFormat
                                };
                                // start downloading but add the Blob property only on the start download not on the event itself
                                this.startDownloadFile(__assign({}, downloadOptions, { blob: excelBlob, data: this._sheet.data }));
                                this.onGridAfterExportToExcel.next(downloadOptions);
                                resolve(true);
                                return [3 /*break*/, 3];
                            case 2:
                                error_1 = _a.sent();
                                reject(error_1);
                                return [3 /*break*/, 3];
                            case 3: return [2 /*return*/];
                        }
                    });
                }); });
            });
        };
        /**
         * Triggers download file with file format.
         * IE(6-10) are not supported
         * All other browsers will use plain javascript on client side to produce a file download.
         * @param options
         */
        ExcelExportService.prototype.startDownloadFile = function (options) {
            // IE(6-10) don't support javascript download and our service doesn't support either so throw an error, we have to make a round trip to the Web Server for exporting
            if (navigator.appName === 'Microsoft Internet Explorer') {
                throw new Error('Microsoft Internet Explorer 6 to 10 do not support javascript export to Excel. Please upgrade your browser.');
            }
            // when using IE/Edge, then use different download call
            if (typeof navigator.msSaveOrOpenBlob === 'function') {
                navigator.msSaveOrOpenBlob(options.blob, options.filename);
            }
            else {
                // this trick will generate a temp <a /> tag
                // the code will then trigger a hidden click for it to start downloading
                var link = document && document.createElement('a');
                var url = URL.createObjectURL(options.blob);
                if (link && document) {
                    link.textContent = 'download';
                    link.href = url;
                    link.setAttribute('download', options.filename);
                    // set the visibility to hidden so there is no effect on your web-layout
                    link.style.visibility = 'hidden';
                    // this part will append the anchor tag, trigger a click (for download to start) and finally remove the tag once completed
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                }
            }
        };
        /** use different Excel Stylesheet Format as per the Field Type */
        ExcelExportService.prototype.useCellFormatByFieldType = function (data, fieldType) {
            var outputData = data;
            switch (fieldType) {
                case exports.FieldType.dateTime:
                case exports.FieldType.dateTimeIso:
                case exports.FieldType.dateTimeShortIso:
                case exports.FieldType.dateTimeIsoAmPm:
                case exports.FieldType.dateTimeIsoAM_PM:
                case exports.FieldType.dateEuro:
                case exports.FieldType.dateEuroShort:
                case exports.FieldType.dateTimeEuro:
                case exports.FieldType.dateTimeShortEuro:
                case exports.FieldType.dateTimeEuroAmPm:
                case exports.FieldType.dateTimeEuroAM_PM:
                case exports.FieldType.dateTimeEuroShort:
                case exports.FieldType.dateTimeEuroShortAmPm:
                case exports.FieldType.dateUs:
                case exports.FieldType.dateUsShort:
                case exports.FieldType.dateTimeUs:
                case exports.FieldType.dateTimeShortUs:
                case exports.FieldType.dateTimeUsAmPm:
                case exports.FieldType.dateTimeUsAM_PM:
                case exports.FieldType.dateTimeUsShort:
                case exports.FieldType.dateTimeUsShortAmPm:
                case exports.FieldType.dateUtc:
                case exports.FieldType.date:
                case exports.FieldType.dateIso:
                    outputData = data;
                    if (data) {
                        var defaultDateFormat = mapMomentDateFormatWithFieldType(fieldType);
                        var isDateValid = moment$2(data, defaultDateFormat, false).isValid();
                        var outputDate = (data && isDateValid) ? moment$2(data).format(defaultDateFormat) : data;
                        var dateFormatter = this._stylesheet.createFormat({ format: defaultDateFormat });
                        outputData = { value: outputDate, metadata: { style: dateFormatter.id } };
                    }
                    break;
                case exports.FieldType.number:
                    var val = isNaN(+data) ? null : data;
                    outputData = { value: val, metadata: { style: this._stylesheetFormats.numberFormatter.id } };
                    break;
                default:
                    outputData = data;
            }
            return outputData;
        };
        // -----------------------
        // Private functions
        // -----------------------
        ExcelExportService.prototype.getDataOutput = function () {
            var columns = this._grid && this._grid.getColumns && this._grid.getColumns() || [];
            // data variable which will hold all the fields data of a row
            var outputData = [];
            var columnHeaderStyle = this._gridOptions && this._gridOptions.excelExportOptions && this._gridOptions.excelExportOptions.columnHeaderStyle;
            var columnHeaderStyleId = this._stylesheetFormats.boldFormatter.id;
            if (columnHeaderStyle) {
                columnHeaderStyleId = this._stylesheet.createFormat(columnHeaderStyle).id;
            }
            // get all Grouped Column Header Titles when defined (from pre-header row)
            if (this._gridOptions.createPreHeaderPanel && this._gridOptions.showPreHeaderPanel && !this._gridOptions.enableDraggableGrouping) {
                // when having Grouped Header Titles (in the pre-header), then make the cell Bold & Aligned Center
                var boldCenterAlign = this._stylesheet.createFormat({ alignment: { horizontal: 'center' }, font: { bold: true } });
                outputData.push(this.getColumnGroupedHeaderTitlesData(columns, { style: boldCenterAlign && boldCenterAlign.id }));
            }
            // get all Column Header Titles (it might include a "Group by" title at A1 cell)
            // also style the headers, defaults to Bold but user could pass his own style
            outputData.push(this.getColumnHeaderData(columns, { style: columnHeaderStyleId }));
            // Populate the rest of the Grid Data
            this.pushAllGridRowDataToArray(outputData, columns);
            return outputData;
        };
        /** Get each column style including a style for the width of each column */
        ExcelExportService.prototype.getColumnStyles = function (columns) {
            var _this = this;
            var grouping = this._dataView && this._dataView.getGrouping && this._dataView.getGrouping();
            var columnStyles = [];
            if (grouping) {
                columnStyles.push({
                    bestFit: true,
                    columnStyles: (this._gridOptions && this._gridOptions.excelExportOptions && this._gridOptions.excelExportOptions.customColumnWidth) || 10
                });
            }
            columns.forEach(function (columnDef) {
                var skippedField = columnDef.excludeFromExport || false;
                // if column width is 0, then we consider that field as a hidden field and should not be part of the export
                if ((columnDef.width === undefined || columnDef.width > 0) && !skippedField) {
                    columnStyles.push({
                        bestFit: true,
                        width: columnDef.exportColumnWidth || (_this._gridOptions && _this._gridOptions.excelExportOptions && _this._gridOptions.excelExportOptions.customColumnWidth) || 10
                    });
                }
            });
            return columnStyles;
        };
        /**
         * Get all Grouped Header Titles and their keys, translate the title when required, and format them in Bold
         * @param {Array<object>} columns of the grid
         */
        ExcelExportService.prototype.getColumnGroupedHeaderTitlesData = function (columns, metadata) {
            var outputGroupedHeaderTitles = [];
            // get all Column Header Titles
            this._groupedColumnHeaders = this.getColumnGroupedHeaderTitles(columns) || [];
            if (this._groupedColumnHeaders && Array.isArray(this._groupedColumnHeaders) && this._groupedColumnHeaders.length > 0) {
                // add the header row + add a new line at the end of the row
                outputGroupedHeaderTitles = this._groupedColumnHeaders.map(function (header) { return ({ value: header.title, metadata: metadata }); });
            }
            // merge necessary cells (any grouped header titles)
            // dealing with the Excel column position is a bit tricky since the first 26 columns are single char (A,B,...) but after that it becomes double char (AA,AB,...)
            // so we must first see if we are in the first section of 26 chars, if that is the case we just concatenate 1 (1st row) so it becomes (A1, B1, ...)
            // but if we are over enumarating passed 26, we need an extra prefix (AA1, AB1, ...)
            var charA = 'A'.charCodeAt(0);
            var cellPositionStart = 'A';
            var cellPositionEnd = '';
            var lastIndex = 0;
            var headersLn = this._groupedColumnHeaders.length;
            for (var cellIndex = 0; cellIndex < headersLn; cellIndex++) {
                // if we reached the last indenx, we are considered at the end
                // else we check if next title is equal to current title, if so then we know it's a grouped header
                // and we include it and continue looping until we reach the end
                if ((cellIndex + 1) === headersLn || ((cellIndex + 1) < headersLn && this._groupedColumnHeaders[cellIndex].title !== this._groupedColumnHeaders[cellIndex + 1].title)) {
                    // calculate left prefix, divide by 26 and use modulo to find out what number add to A
                    // for example if we have cell index 54, we will do ((54/26) %26) => 2.0769, Math.floor is 2, then we do A which is 65 + 2 gives us B so final cell will be AB1
                    var leftCellCharCodePrefix = Math.floor((lastIndex / 26) % 26);
                    var leftCellCharacterPrefix = String.fromCharCode(charA + leftCellCharCodePrefix - 1);
                    var rightCellCharCodePrefix = Math.floor((cellIndex / 26) % 26);
                    var rightCellCharacterPrefix = String.fromCharCode(charA + rightCellCharCodePrefix - 1);
                    cellPositionEnd = String.fromCharCode(charA + (cellIndex % 26));
                    var leftCell = "" + (lastIndex > 26 ? leftCellCharacterPrefix : '') + cellPositionStart + "1";
                    var rightCell = "" + (cellIndex > 26 ? rightCellCharacterPrefix : '') + cellPositionEnd + "1";
                    this._sheet.mergeCells(leftCell, rightCell);
                    cellPositionStart = String.fromCharCode(cellPositionEnd.charCodeAt(0) + 1);
                    lastIndex = cellIndex;
                }
            }
            return outputGroupedHeaderTitles;
        };
        /** Get all column headers and format them in Bold */
        ExcelExportService.prototype.getColumnHeaderData = function (columns, metadata) {
            var outputHeaderTitles = [];
            // get all Column Header Titles
            this._columnHeaders = this.getColumnHeaders(columns) || [];
            if (this._columnHeaders && Array.isArray(this._columnHeaders) && this._columnHeaders.length > 0) {
                // add the header row + add a new line at the end of the row
                outputHeaderTitles = this._columnHeaders.map(function (header) { return ({ value: header.title, metadata: metadata }); });
            }
            // do we have a Group by title?
            var groupTitle = this.getGroupColumnTitle();
            if (groupTitle) {
                outputHeaderTitles.unshift({ value: groupTitle, metadata: metadata });
            }
            return outputHeaderTitles;
        };
        ExcelExportService.prototype.getGroupColumnTitle = function () {
            // Group By text, it could be set in the export options or from translation or if nothing is found then use the English constant text
            var groupByColumnHeader = this._excelExportOptions.groupingColumnHeaderTitle;
            if (!groupByColumnHeader && this._gridOptions.enableTranslate && this.translate && this.translate.currentLang && this.translate.instant) {
                groupByColumnHeader = this.translate.instant(getTranslationPrefix(this._gridOptions) + "GROUP_BY");
            }
            else if (!groupByColumnHeader) {
                groupByColumnHeader = this._locales && this._locales.TEXT_GROUP_BY;
            }
            // get grouped column titles and if found, we will add a "Group by" column at the first column index
            // if it's a CSV format, we'll escape the text in double quotes
            var grouping = this._dataView && this._dataView.getGrouping && this._dataView.getGrouping();
            if (grouping && Array.isArray(grouping) && grouping.length > 0) {
                this._hasGroupedItems = true;
                return groupByColumnHeader;
            }
            else {
                this._hasGroupedItems = false;
            }
            return null;
        };
        /**
         * Get all Grouped Header Titles and their keys, translate the title when required.
         * @param {Array<object>} columns of the grid
         */
        ExcelExportService.prototype.getColumnGroupedHeaderTitles = function (columns) {
            var _this = this;
            var groupedColumnHeaders = [];
            if (columns && Array.isArray(columns)) {
                // Populate the Grouped Column Header, pull the columnGroup(Key) defined
                columns.forEach(function (columnDef) {
                    var groupedHeaderTitle = '';
                    if (columnDef.columnGroupKey && _this._gridOptions.enableTranslate && _this.translate && _this.translate.currentLang && _this.translate.instant) {
                        groupedHeaderTitle = _this.translate.instant(columnDef.columnGroupKey);
                    }
                    else {
                        groupedHeaderTitle = columnDef.columnGroup;
                    }
                    var skippedField = columnDef.excludeFromExport || false;
                    // if column width is 0px, then we consider that field as a hidden field and should not be part of the export
                    if ((columnDef.width === undefined || columnDef.width > 0) && !skippedField) {
                        groupedColumnHeaders.push({
                            key: (columnDef.field || columnDef.id),
                            title: groupedHeaderTitle || '',
                        });
                    }
                });
            }
            return groupedColumnHeaders;
        };
        /**
         * Get all header titles and their keys, translate the title when required.
         * @param columns of the grid
         */
        ExcelExportService.prototype.getColumnHeaders = function (columns) {
            var _this = this;
            var columnHeaders = [];
            if (columns && Array.isArray(columns)) {
                // Populate the Column Header, pull the name defined
                columns.forEach(function (columnDef) {
                    var headerTitle = '';
                    if ((columnDef.headerKey || columnDef.nameKey) && _this._gridOptions.enableTranslate && _this.translate && _this.translate.currentLang && _this.translate.instant) {
                        headerTitle = _this.translate.instant((columnDef.headerKey || columnDef.nameKey));
                    }
                    else {
                        headerTitle = columnDef.name || titleCase(columnDef.field);
                    }
                    var skippedField = columnDef.excludeFromExport || false;
                    // if column width is 0, then we consider that field as a hidden field and should not be part of the export
                    if ((columnDef.width === undefined || columnDef.width > 0) && !skippedField) {
                        columnHeaders.push({
                            key: columnDef.field || columnDef.id,
                            title: headerTitle
                        });
                    }
                });
            }
            return columnHeaders;
        };
        /**
         * Get all the grid row data and return that as an output string
         */
        ExcelExportService.prototype.pushAllGridRowDataToArray = function (originalDaraArray, columns) {
            var lineCount = this._dataView && this._dataView.getLength && this._dataView.getLength();
            // loop through all the grid rows of data
            for (var rowNumber = 0; rowNumber < lineCount; rowNumber++) {
                var itemObj = this._dataView.getItem(rowNumber);
                if (itemObj) {
                    // Normal row (not grouped by anything) would have an ID which was predefined in the Grid Columns definition
                    if (itemObj[this.datasetIdName] !== null && itemObj[this.datasetIdName] !== undefined) {
                        // get regular row item data
                        originalDaraArray.push(this.readRegularRowData(columns, rowNumber, itemObj));
                    }
                    else if (this._hasGroupedItems && itemObj.__groupTotals === undefined) {
                        // get the group row
                        originalDaraArray.push([this.readGroupedTitleRow(itemObj)]);
                    }
                    else if (itemObj.__groupTotals) {
                        // else if the row is a Group By and we have agreggators, then a property of '__groupTotals' would exist under that object
                        originalDaraArray.push(this.readGroupedTotalRow(columns, itemObj));
                    }
                }
            }
            return originalDaraArray;
        };
        /**
         * Get the data of a regular row (a row without grouping)
         * @param row
         * @param itemObj
         */
        ExcelExportService.prototype.readRegularRowData = function (columns, row, itemObj) {
            var idx = 0;
            var rowOutputStrings = [];
            for (var col = 0, ln = columns.length; col < ln; col++) {
                var columnDef = columns[col];
                var fieldType = columnDef.outputType || columnDef.type || exports.FieldType.string;
                // skip excluded column
                if (columnDef.excludeFromExport) {
                    continue;
                }
                // if we are grouping and are on 1st column index, we need to skip this column since it will be used later by the grouping text:: Group by [columnX]
                if (this._hasGroupedItems && idx === 0) {
                    rowOutputStrings.push('');
                }
                // get the output by analyzing if we'll pull the value from the cell or from a formatter
                var itemData = exportWithFormatterWhenDefined(row, col, itemObj, columnDef, this._grid, this._excelExportOptions);
                // does the user want to sanitize the output data (remove HTML tags)?
                if (columnDef.sanitizeDataExport || this._excelExportOptions.sanitizeDataExport) {
                    itemData = sanitizeHtmlToText(itemData);
                }
                // use different Excel Stylesheet Format as per the Field Type
                if (!columnDef.exportWithFormatter) {
                    itemData = this.useCellFormatByFieldType(itemData, fieldType);
                }
                rowOutputStrings.push(itemData);
                idx++;
            }
            return rowOutputStrings;
        };
        /**
         * Get the grouped title(s) and its group title formatter, for example if we grouped by salesRep, the returned result would be:: 'Sales Rep: John Dow (2 items)'
         * @param itemObj
         */
        ExcelExportService.prototype.readGroupedTitleRow = function (itemObj) {
            var groupName = sanitizeHtmlToText(itemObj.title);
            if (this._excelExportOptions && this._excelExportOptions.addGroupIndentation) {
                var collapsedSymbol = this._excelExportOptions && this._excelExportOptions.groupCollapsedSymbol || '\u25B9';
                var expandedSymbol = this._excelExportOptions && this._excelExportOptions.groupExpandedSymbol || '\u25BF';
                var chevron = itemObj.collapsed ? collapsedSymbol : expandedSymbol;
                return chevron + ' ' + addWhiteSpaces(5 * itemObj.level) + groupName;
            }
            return groupName;
        };
        /**
         * Get the grouped totals (below the regular rows), these are set by Slick Aggregators.
         * For example if we grouped by "salesRep" and we have a Sum Aggregator on "sales", then the returned output would be:: ["Sum 123$"]
         * @param itemObj
         */
        ExcelExportService.prototype.readGroupedTotalRow = function (columns, itemObj) {
            var _this = this;
            var groupingAggregatorRowText = this._excelExportOptions.groupingAggregatorRowText || '';
            var outputStrings = [groupingAggregatorRowText];
            columns.forEach(function (columnDef) {
                var itemData = '';
                var skippedField = columnDef.excludeFromExport || false;
                // if there's a exportCustomGroupTotalsFormatter or groupTotalsFormatter, we will re-run it to get the exact same output as what is shown in UI
                if (columnDef.exportCustomGroupTotalsFormatter) {
                    itemData = columnDef.exportCustomGroupTotalsFormatter(itemObj, columnDef);
                }
                else {
                    if (columnDef.groupTotalsFormatter) {
                        itemData = columnDef.groupTotalsFormatter(itemObj, columnDef);
                    }
                }
                // does the user want to sanitize the output data (remove HTML tags)?
                if (columnDef.sanitizeDataExport || _this._excelExportOptions.sanitizeDataExport) {
                    itemData = sanitizeHtmlToText(itemData);
                }
                // add the column (unless user wants to skip it)
                if ((columnDef.width === undefined || columnDef.width > 0) && !skippedField) {
                    outputStrings.push(itemData);
                }
            });
            return outputStrings;
        };
        ExcelExportService.ctorParameters = function () { return [
            { type: core$1.TranslateService, decorators: [{ type: core.Optional }] }
        ]; };
        ExcelExportService = __decorate([
            core.Injectable(),
            __param(0, core.Optional())
        ], ExcelExportService);
        return ExcelExportService;
    }());

    var ExportService = /** @class */ (function () {
        function ExportService(translate) {
            this.translate = translate;
            this._delimiter = ',';
            this._fileFormat = exports.FileType.csv;
            this._lineCarriageReturn = '\n';
            this._exportQuoteWrapper = '';
            this._hasGroupedItems = false;
            this.onGridBeforeExportToFile = new rxjs.Subject();
            this.onGridAfterExportToFile = new rxjs.Subject();
        }
        Object.defineProperty(ExportService.prototype, "datasetIdName", {
            get: function () {
                return this._gridOptions && this._gridOptions.datasetIdPropertyName || 'id';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExportService.prototype, "_gridOptions", {
            /** Getter for the Grid Options pulled through the Grid Object */
            get: function () {
                return (this._grid && this._grid.getOptions) ? this._grid.getOptions() : {};
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Initialize the Export Service
         * @param grid
         * @param gridOptions
         * @param dataView
         */
        ExportService.prototype.init = function (grid, dataView) {
            this._grid = grid;
            this._dataView = dataView;
            // get locales provided by user in forRoot or else use default English locales via the Constants
            this._locales = this._gridOptions && this._gridOptions.locales || Constants.locales;
            if (this._gridOptions.enableTranslate && (!this.translate || !this.translate.instant)) {
                throw new Error('[Angular-Slickgrid] requires "ngx-translate" to be installed and configured when the grid option "enableTranslate" is enabled.');
            }
        };
        /**
         * Function to export the Grid result to an Excel CSV format using javascript for it to produce the CSV file.
         * This is a WYSIWYG export to file output (What You See is What You Get)
         *
         * NOTES: The column position needs to match perfectly the JSON Object position because of the way we are pulling the data,
         * which means that if any column(s) got moved in the UI, it has to be reflected in the JSON array output as well
         *
         * Example: exportToFile({ format: FileType.csv, delimiter: DelimiterType.comma })
         */
        ExportService.prototype.exportToFile = function (options) {
            var _this = this;
            if (!this._grid || !this._dataView) {
                throw new Error('[Angular-Slickgrid] it seems that the SlickGrid & DataView objects are not initialized did you forget to enable the grid option flag "enableExcelExport"?');
            }
            return new Promise(function (resolve, reject) {
                _this.onGridBeforeExportToFile.next(true);
                _this._exportOptions = $.extend(true, {}, _this._gridOptions.exportOptions, options);
                _this._delimiter = _this._exportOptions.delimiterOverride || _this._exportOptions.delimiter || '';
                _this._fileFormat = _this._exportOptions.format || exports.FileType.csv;
                // get the CSV output from the grid data
                var dataOutput = _this.getDataOutput();
                // trigger a download file
                // wrap it into a setTimeout so that the EventAggregator has enough time to start a pre-process like showing a spinner
                setTimeout(function () {
                    try {
                        var downloadOptions = {
                            filename: _this._exportOptions.filename + "." + _this._fileFormat,
                            format: _this._fileFormat,
                            useUtf8WithBom: _this._exportOptions.hasOwnProperty('useUtf8WithBom') ? _this._exportOptions.useUtf8WithBom : true
                        };
                        // start downloading but add the content property only on the start download not on the event itself
                        _this.startDownloadFile(__assign({}, downloadOptions, { content: dataOutput })); // add content property
                        _this.onGridAfterExportToFile.next(downloadOptions);
                        resolve(true);
                    }
                    catch (error) {
                        reject(error);
                    }
                }, 0);
            });
        };
        /**
         * Triggers download file with file format.
         * IE(6-10) are not supported
         * All other browsers will use plain javascript on client side to produce a file download.
         * @param options
         */
        ExportService.prototype.startDownloadFile = function (options) {
            // IE(6-10) don't support javascript download and our service doesn't support either so throw an error, we have to make a round trip to the Web Server for exporting
            if (navigator.appName === 'Microsoft Internet Explorer') {
                throw new Error('Microsoft Internet Explorer 6 to 10 do not support javascript export to CSV. Please upgrade your browser.');
            }
            // set the correct MIME type
            var mimeType = (options.format === exports.FileType.csv) ? 'text/csv' : 'text/plain';
            // make sure no html entities exist in the data
            var dataContent = htmlEntityDecode(options.content);
            // dealing with Excel CSV export and UTF-8 is a little tricky.. We will use Option #2 to cover older Excel versions
            // Option #1: we need to make Excel knowing that it's dealing with an UTF-8, A correctly formatted UTF8 file can have a Byte Order Mark as its first three octets
            // reference: http://stackoverflow.com/questions/155097/microsoft-excel-mangles-diacritics-in-csv-files
            // Option#2: use a 3rd party extension to javascript encode into UTF-16
            var outputData;
            if (options.format === exports.FileType.csv) {
                outputData = new textEncodingUtf8.TextEncoder('utf-8').encode(dataContent);
            }
            else {
                outputData = dataContent;
            }
            // create a Blob object for the download
            var blob = new Blob([options.useUtf8WithBom ? '\uFEFF' : '', outputData], {
                type: mimeType + ";charset=utf-8;"
            });
            // when using IE/Edge, then use different download call
            if (typeof navigator.msSaveOrOpenBlob === 'function') {
                navigator.msSaveOrOpenBlob(blob, options.filename);
            }
            else {
                // this trick will generate a temp <a /> tag
                // the code will then trigger a hidden click for it to start downloading
                var link = document.createElement('a');
                var csvUrl = URL.createObjectURL(blob);
                link.textContent = 'download';
                link.href = csvUrl;
                link.setAttribute('download', options.filename);
                // set the visibility to hidden so there is no effect on your web-layout
                link.style.visibility = 'hidden';
                // this part will append the anchor tag, trigger a click (for download to start) and finally remove the tag once completed
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        };
        // -----------------------
        // Private functions
        // -----------------------
        ExportService.prototype.getDataOutput = function () {
            var _this = this;
            var columns = this._grid.getColumns() || [];
            // Group By text, it could be set in the export options or from translation or if nothing is found then use the English constant text
            var groupByColumnHeader = this._exportOptions.groupingColumnHeaderTitle;
            if (!groupByColumnHeader && this._gridOptions.enableTranslate && this.translate && this.translate.currentLang && this.translate.instant) {
                groupByColumnHeader = this.translate.instant(getTranslationPrefix(this._gridOptions) + "GROUP_BY");
            }
            else if (!groupByColumnHeader) {
                groupByColumnHeader = this._locales && this._locales.TEXT_GROUP_BY;
            }
            // a CSV needs double quotes wrapper, the other types do not need any wrapper
            this._exportQuoteWrapper = (this._fileFormat === exports.FileType.csv) ? '"' : '';
            // data variable which will hold all the fields data of a row
            var outputDataString = '';
            // get grouped column titles and if found, we will add a "Group by" column at the first column index
            // if it's a CSV format, we'll escape the text in double quotes
            var grouping = this._dataView.getGrouping();
            if (grouping && Array.isArray(grouping) && grouping.length > 0) {
                this._hasGroupedItems = true;
                outputDataString += (this._fileFormat === exports.FileType.csv) ? "\"" + groupByColumnHeader + "\"" + this._delimiter : "" + groupByColumnHeader + this._delimiter;
            }
            else {
                this._hasGroupedItems = false;
            }
            // get all Grouped Column Header Titles when defined (from pre-header row)
            if (this._gridOptions.createPreHeaderPanel && this._gridOptions.showPreHeaderPanel && !this._gridOptions.enableDraggableGrouping) {
                this._groupedColumnHeaders = this.getColumnGroupedHeaderTitles(columns) || [];
                if (this._groupedColumnHeaders && Array.isArray(this._groupedColumnHeaders) && this._groupedColumnHeaders.length > 0) {
                    // add the header row + add a new line at the end of the row
                    var outputGroupedHeaderTitles = this._groupedColumnHeaders.map(function (header) { return "" + _this._exportQuoteWrapper + header.title + _this._exportQuoteWrapper; });
                    outputDataString += (outputGroupedHeaderTitles.join(this._delimiter) + this._lineCarriageReturn);
                }
            }
            // get all Column Header Titles
            this._columnHeaders = this.getColumnHeaders(columns) || [];
            if (this._columnHeaders && Array.isArray(this._columnHeaders) && this._columnHeaders.length > 0) {
                // add the header row + add a new line at the end of the row
                var outputHeaderTitles = this._columnHeaders.map(function (header) { return "" + _this._exportQuoteWrapper + header.title + _this._exportQuoteWrapper; });
                outputDataString += (outputHeaderTitles.join(this._delimiter) + this._lineCarriageReturn);
            }
            // Populate the rest of the Grid Data
            outputDataString += this.getAllGridRowData(columns, this._lineCarriageReturn);
            return outputDataString;
        };
        /**
         * Get all the grid row data and return that as an output string
         */
        ExportService.prototype.getAllGridRowData = function (columns, lineCarriageReturn) {
            var outputDataStrings = [];
            var lineCount = this._dataView.getLength();
            // loop through all the grid rows of data
            for (var rowNumber = 0; rowNumber < lineCount; rowNumber++) {
                var itemObj = this._dataView.getItem(rowNumber);
                if (itemObj) {
                    // Normal row (not grouped by anything) would have an ID which was predefined in the Grid Columns definition
                    if (itemObj[this.datasetIdName] !== null && itemObj[this.datasetIdName] !== undefined) {
                        // get regular row item data
                        outputDataStrings.push(this.readRegularRowData(columns, rowNumber, itemObj));
                    }
                    else if (this._hasGroupedItems && itemObj.__groupTotals === undefined) {
                        // get the group row
                        outputDataStrings.push(this.readGroupedTitleRow(itemObj));
                    }
                    else if (itemObj.__groupTotals) {
                        // else if the row is a Group By and we have agreggators, then a property of '__groupTotals' would exist under that object
                        outputDataStrings.push(this.readGroupedTotalRow(columns, itemObj));
                    }
                }
            }
            return outputDataStrings.join(lineCarriageReturn);
        };
        /**
       * Get all Grouped Header Titles and their keys, translate the title when required.
       * @param {Array<object>} columns of the grid
       */
        ExportService.prototype.getColumnGroupedHeaderTitles = function (columns) {
            var _this = this;
            var groupedColumnHeaders = [];
            if (columns && Array.isArray(columns)) {
                // Populate the Grouped Column Header, pull the columnGroup(Key) defined
                columns.forEach(function (columnDef) {
                    var groupedHeaderTitle = '';
                    if ((columnDef.columnGroupKey || columnDef.columnGroupKey) && _this._gridOptions.enableTranslate && _this.translate && _this.translate.currentLang && _this.translate.instant) {
                        groupedHeaderTitle = _this.translate.instant((columnDef.columnGroupKey || columnDef.columnGroupKey));
                    }
                    else {
                        groupedHeaderTitle = columnDef.columnGroup || '';
                    }
                    var skippedField = columnDef.excludeFromExport || false;
                    // if column width is 0px, then we consider that field as a hidden field and should not be part of the export
                    if ((columnDef.width === undefined || columnDef.width > 0) && !skippedField) {
                        groupedColumnHeaders.push({
                            key: (columnDef.field || columnDef.id),
                            title: groupedHeaderTitle || ''
                        });
                    }
                });
            }
            return groupedColumnHeaders;
        };
        /**
         * Get all header titles and their keys, translate the title when required.
         * @param {Array<object>} columns of the grid
         */
        ExportService.prototype.getColumnHeaders = function (columns) {
            var _this = this;
            var columnHeaders = [];
            if (columns && Array.isArray(columns)) {
                // Populate the Column Header, pull the name defined
                columns.forEach(function (columnDef) {
                    var headerTitle = '';
                    if ((columnDef.headerKey || columnDef.nameKey) && _this._gridOptions.enableTranslate && _this.translate && _this.translate.currentLang && _this.translate.instant) {
                        headerTitle = _this.translate.instant((columnDef.headerKey || columnDef.nameKey));
                    }
                    else {
                        headerTitle = columnDef.name || titleCase(columnDef.field);
                    }
                    var skippedField = columnDef.excludeFromExport || false;
                    // if column width is 0, then we consider that field as a hidden field and should not be part of the export
                    if ((columnDef.width === undefined || columnDef.width > 0) && !skippedField) {
                        columnHeaders.push({
                            key: columnDef.field || columnDef.id,
                            title: headerTitle
                        });
                    }
                });
            }
            return columnHeaders;
        };
        /**
         * Get the data of a regular row (a row without grouping)
         * @param row
         * @param itemObj
         */
        ExportService.prototype.readRegularRowData = function (columns, row, itemObj) {
            var idx = 0;
            var rowOutputStrings = [];
            var exportQuoteWrapper = this._exportQuoteWrapper;
            for (var col = 0, ln = columns.length; col < ln; col++) {
                var columnDef = columns[col];
                // skip excluded column
                if (columnDef.excludeFromExport) {
                    continue;
                }
                // if we are grouping and are on 1st column index, we need to skip this column since it will be used later by the grouping text:: Group by [columnX]
                if (this._hasGroupedItems && idx === 0) {
                    var emptyValue = this._fileFormat === exports.FileType.csv ? "\"\"" : '';
                    rowOutputStrings.push(emptyValue);
                }
                // get the output by analyzing if we'll pull the value from the cell or from a formatter
                var itemData = exportWithFormatterWhenDefined(row, col, itemObj, columnDef, this._grid, this._exportOptions);
                // does the user want to sanitize the output data (remove HTML tags)?
                if (columnDef.sanitizeDataExport || this._exportOptions.sanitizeDataExport) {
                    itemData = sanitizeHtmlToText(itemData);
                }
                // when CSV we also need to escape double quotes twice, so " becomes ""
                if (this._fileFormat === exports.FileType.csv && itemData) {
                    itemData = itemData.toString().replace(/"/gi, "\"\"");
                }
                // do we have a wrapper to keep as a string? in certain cases like "1E06", we don't want excel to transform it into exponential (1.0E06)
                // to cancel that effect we can had = in front, ex: ="1E06"
                var keepAsStringWrapper = (columnDef && columnDef.exportCsvForceToKeepAsString) ? '=' : '';
                rowOutputStrings.push(keepAsStringWrapper + exportQuoteWrapper + itemData + exportQuoteWrapper);
                idx++;
            }
            return rowOutputStrings.join(this._delimiter);
        };
        /**
         * Get the grouped title(s) and its group title formatter, for example if we grouped by salesRep, the returned result would be:: 'Sales Rep: John Dow (2 items)'
         * @param itemObj
         */
        ExportService.prototype.readGroupedTitleRow = function (itemObj) {
            var groupName = sanitizeHtmlToText(itemObj.title);
            var exportQuoteWrapper = this._exportQuoteWrapper;
            groupName = addWhiteSpaces(5 * itemObj.level) + groupName;
            if (this._fileFormat === exports.FileType.csv) {
                // when CSV we also need to escape double quotes twice, so " becomes ""
                groupName = groupName.toString().replace(/"/gi, "\"\"");
            }
            return exportQuoteWrapper + groupName + exportQuoteWrapper;
        };
        /**
         * Get the grouped totals (below the regular rows), these are set by Slick Aggregators.
         * For example if we grouped by "salesRep" and we have a Sum Aggregator on "sales", then the returned output would be:: ["Sum 123$"]
         * @param itemObj
         */
        ExportService.prototype.readGroupedTotalRow = function (columns, itemObj) {
            var _this = this;
            var delimiter = this._exportOptions.delimiter;
            var format = this._exportOptions.format;
            var groupingAggregatorRowText = this._exportOptions.groupingAggregatorRowText || '';
            var exportQuoteWrapper = this._exportQuoteWrapper;
            var outputStrings = ["" + exportQuoteWrapper + groupingAggregatorRowText + exportQuoteWrapper];
            columns.forEach(function (columnDef) {
                var itemData = '';
                var skippedField = columnDef.excludeFromExport || false;
                // if there's a groupTotalsFormatter, we will re-run it to get the exact same output as what is shown in UI
                if (columnDef.groupTotalsFormatter) {
                    itemData = columnDef.groupTotalsFormatter(itemObj, columnDef);
                }
                // does the user want to sanitize the output data (remove HTML tags)?
                if (columnDef.sanitizeDataExport || _this._exportOptions.sanitizeDataExport) {
                    itemData = sanitizeHtmlToText(itemData);
                }
                if (format === exports.FileType.csv) {
                    // when CSV we also need to escape double quotes twice, so a double quote " becomes 2x double quotes ""
                    itemData = itemData.toString().replace(/"/gi, "\"\"");
                }
                // add the column (unless user wants to skip it)
                if ((columnDef.width === undefined || columnDef.width > 0) && !skippedField) {
                    outputStrings.push(exportQuoteWrapper + itemData + exportQuoteWrapper);
                }
            });
            return outputStrings.join(delimiter);
        };
        ExportService.ctorParameters = function () { return [
            { type: core$1.TranslateService, decorators: [{ type: core.Optional }] }
        ]; };
        ExportService = __decorate([
            core.Injectable(),
            __param(0, core.Optional())
        ], ExportService);
        return ExportService;
    }());

    var SharedService = /** @class */ (function () {
        function SharedService() {
            this._hideHeaderRowAfterPageLoad = false;
            this.onHeaderMenuHideColumns = new rxjs.Subject();
        }
        Object.defineProperty(SharedService.prototype, "allColumns", {
            // --
            // public
            /** Getter for All Columns  in the grid (hidden/visible) */
            get: function () {
                return this._allColumns;
            },
            /** Setter for All Columns  in the grid (hidden/visible) */
            set: function (allColumns) {
                this._allColumns = allColumns;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SharedService.prototype, "columnDefinitions", {
            /** Getter for the Column Definitions pulled through the Grid Object */
            get: function () {
                return (this._grid && this._grid.getColumns) ? this._grid.getColumns() : [];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SharedService.prototype, "currentPagination", {
            /** Getter for the Current Pagination (when Pagination is enabled) */
            get: function () {
                return this._currentPagination;
            },
            /** Setter for the Current Pagination (when Pagination is enabled) */
            set: function (currentPagination) {
                this._currentPagination = currentPagination;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SharedService.prototype, "dataView", {
            /** Getter for SlickGrid DataView object */
            get: function () {
                return this._dataView;
            },
            /** Setter for SlickGrid DataView object */
            set: function (dataView) {
                this._dataView = dataView;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SharedService.prototype, "frozenVisibleColumnId", {
            /** Setter to keep the frozen column id for reference if we ever show/hide column from ColumnPicker/GridMenu afterward */
            get: function () {
                return this._frozenVisibleColumnId;
            },
            /** Getter to keep the frozen column id for reference if we ever show/hide column from ColumnPicker/GridMenu afterward */
            set: function (columnId) {
                this._frozenVisibleColumnId = columnId;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SharedService.prototype, "grid", {
            /** Getter for SlickGrid Grid object */
            get: function () {
                return this._grid;
            },
            /** Setter for SlickGrid Grid object */
            set: function (grid) {
                this._grid = grid;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SharedService.prototype, "gridOptions", {
            /** Getter for the Grid Options pulled through the Grid Object */
            get: function () {
                return this._gridOptions || this._grid && this._grid.getOptions && this._grid.getOptions() || {};
            },
            /** Setter for the Grid Options pulled through the Grid Object */
            set: function (gridOptions) {
                this._gridOptions = gridOptions;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SharedService.prototype, "groupItemMetadataProvider", {
            /** Getter for the Grid Options */
            get: function () {
                return this._groupItemMetadataProvider;
            },
            /** Setter for the Grid Options */
            set: function (groupItemMetadataProvider) {
                this._groupItemMetadataProvider = groupItemMetadataProvider;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SharedService.prototype, "hideHeaderRowAfterPageLoad", {
            /** Getter to know if user want to hide header row after 1st page load */
            get: function () {
                return this._hideHeaderRowAfterPageLoad;
            },
            /** Setter for knowing if user want to hide header row after 1st page load */
            set: function (hideHeaderRowAfterPageLoad) {
                this._hideHeaderRowAfterPageLoad = hideHeaderRowAfterPageLoad;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SharedService.prototype, "visibleColumns", {
            /** Getter for the Visible Columns in the grid */
            get: function () {
                return this._visibleColumns;
            },
            /** Setter for the Visible Columns in the grid */
            set: function (visibleColumns) {
                this._visibleColumns = visibleColumns;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SharedService.prototype, "hierarchicalDataset", {
            /** Getter for the Hierarchical Tree Data dataset when the feature is enabled */
            get: function () {
                return this._hierarchicalDataset;
            },
            /** Getter for the Hierarchical Tree Data dataset when the feature is enabled */
            set: function (hierarchicalDataset) {
                this._hierarchicalDataset = hierarchicalDataset;
            },
            enumerable: true,
            configurable: true
        });
        return SharedService;
    }());

    var ExtensionUtility = /** @class */ (function () {
        function ExtensionUtility(sharedService, translate) {
            this.sharedService = sharedService;
            this.translate = translate;
        }
        /**
         * Load SlickGrid Extension (Control/Plugin) dynamically (on demand)
         * This will basically only load the extension when user enables the feature
         * @param extensionName
         */
        ExtensionUtility.prototype.loadExtensionDynamically = function (extensionName) {
            try {
                switch (extensionName) {
                    case exports.ExtensionName.autoTooltip:
                        require('slickgrid/plugins/slick.autotooltips');
                        break;
                    case exports.ExtensionName.cellExternalCopyManager:
                        require('slickgrid/plugins/slick.cellexternalcopymanager');
                        break;
                    case exports.ExtensionName.checkboxSelector:
                        require('slickgrid/plugins/slick.checkboxselectcolumn');
                        break;
                    case exports.ExtensionName.cellMenu:
                        require('slickgrid/plugins/slick.cellmenu');
                        break;
                    case exports.ExtensionName.columnPicker:
                        require('slickgrid/controls/slick.columnpicker');
                        break;
                    case exports.ExtensionName.contextMenu:
                        require('slickgrid/plugins/slick.contextmenu');
                        break;
                    case exports.ExtensionName.draggableGrouping:
                        require('slickgrid/plugins/slick.draggablegrouping');
                        break;
                    case exports.ExtensionName.gridMenu:
                        require('slickgrid/controls/slick.gridmenu');
                        break;
                    case exports.ExtensionName.groupItemMetaProvider:
                        require('slickgrid/slick.groupitemmetadataprovider');
                        break;
                    case exports.ExtensionName.headerButton:
                        require('slickgrid/plugins/slick.headerbuttons');
                        break;
                    case exports.ExtensionName.headerMenu:
                        require('slickgrid/plugins/slick.headermenu');
                        break;
                    case exports.ExtensionName.rowSelection:
                        require('slickgrid/plugins/slick.rowselectionmodel');
                        break;
                    case exports.ExtensionName.rowDetailView:
                        require('slickgrid/plugins/slick.rowdetailview');
                        break;
                    case exports.ExtensionName.rowMoveManager:
                        require('slickgrid/plugins/slick.rowmovemanager');
                        break;
                }
            }
            catch (e) {
                // do nothing, we fall here when using Angular and RequireJS
            }
        };
        /**
         * From a Grid Menu object property name, we will return the correct title output string following this order
         * 1- if user provided a title, use it as the output title
         * 2- else if user provided a title key, use it to translate the output title
         * 3- else if nothing is provided use text defined as constants
         */
        ExtensionUtility.prototype.getPickerTitleOutputString = function (propName, pickerName) {
            if (this.sharedService.gridOptions && this.sharedService.gridOptions.enableTranslate && (!this.translate || !this.translate.instant)) {
                throw new Error('[Angular-Slickgrid] requires "ngx-translate" to be installed and configured when the grid option "enableTranslate" is enabled.');
            }
            var output = '';
            var picker = this.sharedService.gridOptions && this.sharedService.gridOptions[pickerName] || {};
            var enableTranslate = this.sharedService.gridOptions && this.sharedService.gridOptions.enableTranslate || false;
            // get locales provided by user in forRoot or else use default English locales via the Constants
            var locales = this.sharedService && this.sharedService.gridOptions && this.sharedService.gridOptions.locales || Constants.locales;
            var title = picker && picker[propName];
            var titleKey = picker && picker[propName + "Key"];
            var gridOptions = this.sharedService.gridOptions;
            var translationPrefix = getTranslationPrefix(gridOptions);
            if (titleKey && this.translate && this.translate.currentLang && this.translate.instant) {
                output = this.translate.instant(titleKey || ' ');
            }
            else {
                switch (propName) {
                    case 'customTitle':
                        output = title || enableTranslate && this.translate && this.translate.currentLang && this.translate.instant && this.translate.instant(translationPrefix + "COMMANDS" || ' ') || locales && locales.TEXT_COMMANDS;
                        break;
                    case 'columnTitle':
                        output = title || enableTranslate && this.translate && this.translate.currentLang && this.translate.instant && this.translate.instant(translationPrefix + "COLUMNS" || ' ') || locales && locales.TEXT_COLUMNS;
                        break;
                    case 'forceFitTitle':
                        output = title || enableTranslate && this.translate && this.translate.currentLang && this.translate.instant && this.translate.instant(translationPrefix + "FORCE_FIT_COLUMNS" || ' ') || locales && locales.TEXT_FORCE_FIT_COLUMNS;
                        break;
                    case 'syncResizeTitle':
                        output = title || enableTranslate && this.translate && this.translate.currentLang && this.translate.instant && this.translate.instant(translationPrefix + "SYNCHRONOUS_RESIZE" || ' ') || locales && locales.TEXT_SYNCHRONOUS_RESIZE;
                        break;
                    default:
                        output = title;
                        break;
                }
            }
            return output;
        };
        /**
         * Loop through object provided and set to null any property found starting with "onX"
         * @param {Object}: obj
         */
        ExtensionUtility.prototype.nullifyFunctionNameStartingWithOn = function (obj) {
            var e_1, _a;
            if (obj) {
                try {
                    for (var _b = __values(Object.keys(obj)), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var prop = _c.value;
                        if (prop.startsWith('on')) {
                            obj[prop] = null;
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
        };
        /**
         * When using ColumnPicker/GridMenu to show/hide a column, we potentially need to readjust the grid option "frozenColumn" index.
         * That is because SlickGrid freezes by column index and it has no knowledge of the columns themselves and won't change the index, we need to do that ourselves whenever necessary.
         * Note: we call this method right after the visibleColumns array got updated, it won't work properly if we call it before the setting the visibleColumns.
         * @param {String} pickerColumnId - what is the column id triggered by the picker
         * @param {Number} frozenColumnIndex - current frozenColumn index
         * @param {Boolean} showingColumn - is the column being shown or hidden?
         * @param {Array<Object>} allColumns - all columns (including hidden ones)
         * @param {Array<Object>} visibleColumns - only visible columns (excluding hidden ones)
         */
        ExtensionUtility.prototype.readjustFrozenColumnIndexWhenNeeded = function (pickerColumnId, frozenColumnIndex, showingColumn, allColumns, visibleColumns) {
            var _this = this;
            if (frozenColumnIndex >= 0 && pickerColumnId) {
                // calculate a possible frozenColumn index variance
                var frozenColIndexVariance = 0;
                if (showingColumn) {
                    var definedFrozenColumnIndex = visibleColumns.findIndex(function (col) { return col.id === _this.sharedService.frozenVisibleColumnId; });
                    var columnIndex = visibleColumns.findIndex(function (col) { return col.id === pickerColumnId; });
                    frozenColIndexVariance = (columnIndex >= 0 && (frozenColumnIndex >= columnIndex || definedFrozenColumnIndex === columnIndex)) ? 1 : 0;
                }
                else {
                    var columnIndex = allColumns.findIndex(function (col) { return col.id === pickerColumnId; });
                    frozenColIndexVariance = (columnIndex >= 0 && frozenColumnIndex >= columnIndex) ? -1 : 0;
                }
                // if we have a variance different than 0 then apply it
                var newFrozenColIndex = frozenColumnIndex + frozenColIndexVariance;
                if (frozenColIndexVariance !== 0) {
                    this.sharedService.grid.setOptions({ frozenColumn: newFrozenColIndex });
                }
                // to freeze columns, we need to take only the visible columns and we also need to use setColumns() when some of them are hidden
                // to make sure that we only use the visible columns, not doing this would show back some of the hidden columns
                if (Array.isArray(visibleColumns) && Array.isArray(allColumns) && visibleColumns.length !== allColumns.length) {
                    this.sharedService.grid.setColumns(visibleColumns);
                }
            }
        };
        /**
         * Sort items (by pointers) in an array by a property name
         * @params items array
         * @param property name to sort with
         */
        ExtensionUtility.prototype.sortItems = function (items, propertyName) {
            // sort the custom items by their position in the list
            if (Array.isArray(items)) {
                items.sort(function (itemA, itemB) {
                    if (itemA && itemB && itemA.hasOwnProperty(propertyName) && itemB.hasOwnProperty(propertyName)) {
                        return itemA[propertyName] - itemB[propertyName];
                    }
                    return 0;
                });
            }
        };
        /** Translate the an array of items from an input key and assign to the output key */
        ExtensionUtility.prototype.translateItems = function (items, inputKey, outputKey) {
            var e_2, _a;
            if (Array.isArray(items)) {
                try {
                    for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
                        var item = items_1_1.value;
                        if (item[inputKey]) {
                            item[outputKey] = this.translate && this.translate && this.translate.currentLang && this.translate.instant && this.translate.instant(item[inputKey]);
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        };
        /**
         * When "enabledTranslate" is set to True, we will try to translate if the Translate Service exist or use the Locales when not
         * @param translationKey
         * @param localeKey
         */
        ExtensionUtility.prototype.translateWhenEnabledAndServiceExist = function (translationKey, localeKey) {
            var text = '';
            var gridOptions = this.sharedService && this.sharedService.gridOptions;
            // get locales provided by user in main file or else use default English locales via the Constants
            var locales = gridOptions && gridOptions.locales || Constants.locales;
            if (gridOptions.enableTranslate && this.translate && this.translate.currentLang && this.translate.instant) {
                text = this.translate.instant(translationKey || ' ');
            }
            else if (locales && locales.hasOwnProperty(localeKey)) {
                text = locales[localeKey];
            }
            else {
                text = localeKey;
            }
            return text;
        };
        ExtensionUtility.ctorParameters = function () { return [
            { type: SharedService },
            { type: core$1.TranslateService, decorators: [{ type: core.Optional }] }
        ]; };
        ExtensionUtility = __decorate([
            core.Injectable(),
            __param(1, core.Optional())
        ], ExtensionUtility);
        return ExtensionUtility;
    }());

    var AutoTooltipExtension = /** @class */ (function () {
        function AutoTooltipExtension(extensionUtility, sharedService) {
            this.extensionUtility = extensionUtility;
            this.sharedService = sharedService;
        }
        AutoTooltipExtension.prototype.dispose = function () {
            if (this._addon && this._addon.destroy) {
                this._addon.destroy();
                this._addon = null;
            }
        };
        /** Get the instance of the SlickGrid addon (control or plugin). */
        AutoTooltipExtension.prototype.getAddonInstance = function () {
            return this._addon;
        };
        AutoTooltipExtension.prototype.register = function () {
            if (this.sharedService && this.sharedService.grid && this.sharedService.gridOptions) {
                // dynamically import the SlickGrid plugin (addon) with RequireJS
                this.extensionUtility.loadExtensionDynamically(exports.ExtensionName.autoTooltip);
                this._addon = new Slick.AutoTooltips(this.sharedService.gridOptions.autoTooltipOptions || {});
                this.sharedService.grid.registerPlugin(this._addon);
                return this._addon;
            }
            return null;
        };
        AutoTooltipExtension.ctorParameters = function () { return [
            { type: ExtensionUtility },
            { type: SharedService }
        ]; };
        AutoTooltipExtension = __decorate([
            core.Injectable()
        ], AutoTooltipExtension);
        return AutoTooltipExtension;
    }());

    var CellExternalCopyManagerExtension = /** @class */ (function () {
        function CellExternalCopyManagerExtension(extensionUtility, sharedService) {
            this.extensionUtility = extensionUtility;
            this.sharedService = sharedService;
            this._eventHandler = new Slick.EventHandler();
            this._bindingEventService = new BindingEventService();
        }
        Object.defineProperty(CellExternalCopyManagerExtension.prototype, "addonOptions", {
            get: function () {
                return this._addonOptions;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CellExternalCopyManagerExtension.prototype, "eventHandler", {
            get: function () {
                return this._eventHandler;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CellExternalCopyManagerExtension.prototype, "commandQueue", {
            get: function () {
                return this._commandQueue;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CellExternalCopyManagerExtension.prototype, "undoRedoBuffer", {
            get: function () {
                return this._undoRedoBuffer;
            },
            enumerable: true,
            configurable: true
        });
        CellExternalCopyManagerExtension.prototype.dispose = function () {
            // unsubscribe all SlickGrid events
            this._eventHandler.unsubscribeAll();
            this._bindingEventService.unbindAll();
            if (this._addon && this._addon.destroy) {
                this._addon.destroy();
            }
            if (this._cellSelectionModel && this._cellSelectionModel.destroy) {
                this._cellSelectionModel.destroy();
            }
            this.extensionUtility.nullifyFunctionNameStartingWithOn(this._addonOptions);
            this._addon = null;
            this._addonOptions = null;
        };
        /** Get the instance of the SlickGrid addon (control or plugin). */
        CellExternalCopyManagerExtension.prototype.getAddonInstance = function () {
            return this._addon;
        };
        CellExternalCopyManagerExtension.prototype.register = function () {
            var _this = this;
            if (this.sharedService && this.sharedService.grid && this.sharedService.gridOptions) {
                // dynamically import the SlickGrid plugin (addon) with RequireJS
                this.extensionUtility.loadExtensionDynamically(exports.ExtensionName.cellExternalCopyManager);
                this.createUndoRedoBuffer();
                this._bindingEventService.bind(document.body, 'keydown', this.handleKeyDown.bind(this));
                this._addonOptions = __assign({}, this.getDefaultOptions(), this.sharedService.gridOptions.excelCopyBufferOptions);
                this._cellSelectionModel = new Slick.CellSelectionModel();
                this.sharedService.grid.setSelectionModel(this._cellSelectionModel);
                this._addon = new Slick.CellExternalCopyManager(this._addonOptions);
                if (this._addon) {
                    this.sharedService.grid.registerPlugin(this._addon);
                }
                // hook to all possible events
                if (this.sharedService.grid && this._addonOptions) {
                    if (this._addonOptions.onExtensionRegistered) {
                        this._addonOptions.onExtensionRegistered(this._addon);
                    }
                    this._eventHandler.subscribe(this._addon.onCopyCells, function (e, args) {
                        if (_this._addonOptions && typeof _this._addonOptions.onCopyCells === 'function') {
                            _this._addonOptions.onCopyCells(e, args);
                        }
                    });
                    this._eventHandler.subscribe(this._addon.onCopyCancelled, function (e, args) {
                        if (_this._addonOptions && typeof _this._addonOptions.onCopyCancelled === 'function') {
                            _this._addonOptions.onCopyCancelled(e, args);
                        }
                    });
                    this._eventHandler.subscribe(this._addon.onPasteCells, function (e, args) {
                        if (_this._addonOptions && typeof _this._addonOptions.onPasteCells === 'function') {
                            _this._addonOptions.onPasteCells(e, args);
                        }
                    });
                }
                return this._addon;
            }
            return null;
        };
        /** Create an undo redo buffer used by the Excel like copy */
        CellExternalCopyManagerExtension.prototype.createUndoRedoBuffer = function () {
            var _this = this;
            var commandCtr = 0;
            this._commandQueue = [];
            this._undoRedoBuffer = {
                queueAndExecuteCommand: function (editCommand) {
                    _this._commandQueue[commandCtr] = editCommand;
                    commandCtr++;
                    editCommand.execute();
                },
                undo: function () {
                    if (commandCtr === 0) {
                        return;
                    }
                    commandCtr--;
                    var command = _this._commandQueue[commandCtr];
                    if (command && Slick.GlobalEditorLock.cancelCurrentEdit()) {
                        command.undo();
                    }
                },
                redo: function () {
                    if (commandCtr >= _this._commandQueue.length) {
                        return;
                    }
                    var command = _this._commandQueue[commandCtr];
                    commandCtr++;
                    if (command && Slick.GlobalEditorLock.cancelCurrentEdit()) {
                        command.execute();
                    }
                }
            };
        };
        /** @return default plugin (addon) options */
        CellExternalCopyManagerExtension.prototype.getDefaultOptions = function () {
            var _this = this;
            var newRowIds = 0;
            return {
                clipboardCommandHandler: function (editCommand) {
                    _this._undoRedoBuffer.queueAndExecuteCommand.call(_this._undoRedoBuffer, editCommand);
                },
                dataItemColumnValueExtractor: function (item, columnDef) {
                    // when grid or cell is not editable, we will possibly evaluate the Formatter if it was passed
                    // to decide if we evaluate the Formatter, we will use the same flag from Export which is "exportWithFormatter"
                    if (!_this.sharedService.gridOptions.editable || !columnDef.editor) {
                        var isEvaluatingFormatter = (columnDef.exportWithFormatter !== undefined) ? columnDef.exportWithFormatter : (_this.sharedService.gridOptions.exportOptions && _this.sharedService.gridOptions.exportOptions.exportWithFormatter);
                        if (columnDef.formatter && isEvaluatingFormatter) {
                            var formattedOutput = columnDef.formatter(0, 0, item[columnDef.field], columnDef, item, _this.sharedService.grid);
                            if (columnDef.sanitizeDataExport || (_this.sharedService.gridOptions.exportOptions && _this.sharedService.gridOptions.exportOptions.sanitizeDataExport)) {
                                var outputString = formattedOutput;
                                if (formattedOutput && typeof formattedOutput === 'object' && formattedOutput.hasOwnProperty('text')) {
                                    outputString = formattedOutput.text;
                                }
                                if (outputString === null) {
                                    outputString = '';
                                }
                                return sanitizeHtmlToText(outputString);
                            }
                            return formattedOutput;
                        }
                    }
                    // else use the default "dataItemColumnValueExtractor" from the plugin itself
                    // we can do that by setting back the getter with null
                    return null;
                },
                readOnlyMode: false,
                includeHeaderWhenCopying: false,
                newRowCreator: function (count) {
                    for (var i = 0; i < count; i++) {
                        var item = {
                            id: 'newRow_' + newRowIds++
                        };
                        _this.sharedService.grid.getData().addItem(item);
                    }
                }
            };
        };
        /** Hook an undo shortcut key hook that will redo/undo the copy buffer using Ctrl+(Shift)+Z keyboard events */
        CellExternalCopyManagerExtension.prototype.handleKeyDown = function (e) {
            var keyCode = e.keyCode || e.code;
            if (keyCode === 90 && (e.ctrlKey || e.metaKey)) {
                if (e.shiftKey) {
                    this._undoRedoBuffer.redo(); // Ctrl + Shift + Z
                }
                else {
                    this._undoRedoBuffer.undo(); // Ctrl + Z
                }
            }
        };
        CellExternalCopyManagerExtension.ctorParameters = function () { return [
            { type: ExtensionUtility },
            { type: SharedService }
        ]; };
        CellExternalCopyManagerExtension = __decorate([
            core.Injectable()
        ], CellExternalCopyManagerExtension);
        return CellExternalCopyManagerExtension;
    }());

    var CellMenuExtension = /** @class */ (function () {
        function CellMenuExtension(extensionUtility, sharedService, translate) {
            this.extensionUtility = extensionUtility;
            this.sharedService = sharedService;
            this.translate = translate;
            this._eventHandler = new Slick.EventHandler();
        }
        Object.defineProperty(CellMenuExtension.prototype, "eventHandler", {
            get: function () {
                return this._eventHandler;
            },
            enumerable: true,
            configurable: true
        });
        CellMenuExtension.prototype.dispose = function () {
            // unsubscribe all SlickGrid events
            this._eventHandler.unsubscribeAll();
            if (this._addon && this._addon.destroy) {
                this._addon.destroy();
            }
            this.extensionUtility.nullifyFunctionNameStartingWithOn(this._cellMenuOptions);
            this._addon = null;
            this._cellMenuOptions = null;
        };
        /** Get the instance of the SlickGrid addon (control or plugin). */
        CellMenuExtension.prototype.getAddonInstance = function () {
            return this._addon;
        };
        /**
         * Create the Action Cell Menu and expose all the available hooks that user can subscribe (onCommand, onBeforeMenuShow, ...)
         * @param grid
         * @param dataView
         * @param columnDefinitions
         */
        CellMenuExtension.prototype.register = function () {
            var _this = this;
            if (this.sharedService.gridOptions && this.sharedService.gridOptions.enableTranslate && (!this.translate || !this.translate.instant)) {
                throw new Error('[Angular-Slickgrid] requires "ngx-translate" to be installed and configured when the grid option "enableTranslate" is enabled.');
            }
            if (this.sharedService && this.sharedService.grid && this.sharedService.gridOptions) {
                // get locales provided by user in main file or else use default English locales via the Constants
                this._locales = this.sharedService.gridOptions && this.sharedService.gridOptions.locales || Constants.locales;
                // dynamically import the SlickGrid plugin (addon) with RequireJS
                this.extensionUtility.loadExtensionDynamically(exports.ExtensionName.cellMenu);
                this._cellMenuOptions = __assign({}, this.getDefaultCellMenuOptions(), this.sharedService.gridOptions.cellMenu);
                this.sharedService.gridOptions.cellMenu = this._cellMenuOptions;
                // translate the item keys when necessary
                if (this.sharedService.gridOptions.enableTranslate) {
                    this.translateCellMenu();
                }
                // sort all menu items by their position order when defined
                this.sortMenuItems(this.sharedService.allColumns);
                this._addon = new Slick.Plugins.CellMenu(this._cellMenuOptions);
                this.sharedService.grid.registerPlugin(this._addon);
                // hook all events
                if (this._cellMenuOptions) {
                    if (this._cellMenuOptions.onExtensionRegistered) {
                        this._cellMenuOptions.onExtensionRegistered(this._addon);
                    }
                    if (this._cellMenuOptions && typeof this._cellMenuOptions.onCommand === 'function') {
                        this._eventHandler.subscribe(this._addon.onCommand, function (event, args) {
                            _this._cellMenuOptions.onCommand(event, args);
                        });
                    }
                    if (this._cellMenuOptions && typeof this._cellMenuOptions.onOptionSelected === 'function') {
                        this._eventHandler.subscribe(this._addon.onOptionSelected, function (event, args) {
                            _this._cellMenuOptions.onOptionSelected(event, args);
                        });
                    }
                    if (this._cellMenuOptions && typeof this._cellMenuOptions.onAfterMenuShow === 'function') {
                        this._eventHandler.subscribe(this._addon.onAfterMenuShow, function (event, args) {
                            _this._cellMenuOptions.onAfterMenuShow(event, args);
                        });
                    }
                    if (this._cellMenuOptions && typeof this._cellMenuOptions.onBeforeMenuShow === 'function') {
                        this._eventHandler.subscribe(this._addon.onBeforeMenuShow, function (event, args) {
                            _this._cellMenuOptions.onBeforeMenuShow(event, args);
                        });
                    }
                    if (this._cellMenuOptions && typeof this._cellMenuOptions.onBeforeMenuClose === 'function') {
                        this._eventHandler.subscribe(this._addon.onBeforeMenuClose, function (event, args) {
                            _this._cellMenuOptions.onBeforeMenuClose(event, args);
                        });
                    }
                }
                return this._addon;
            }
            return null;
        };
        /** Translate the Cell Menu titles, we need to loop through all column definition to re-translate them */
        CellMenuExtension.prototype.translateCellMenu = function () {
            if (this.sharedService.gridOptions && this.sharedService.gridOptions.cellMenu) {
                this.resetMenuTranslations(this.sharedService.allColumns);
            }
        };
        /**
         * @return default Action Cell Menu options
         */
        CellMenuExtension.prototype.getDefaultCellMenuOptions = function () {
            return {
                width: 180,
            };
        };
        /**
         * Reset all the internal Menu options which have text to translate
         * @param grid menu object
         */
        CellMenuExtension.prototype.resetMenuTranslations = function (columnDefinitions) {
            var _this = this;
            var gridOptions = this.sharedService && this.sharedService.gridOptions;
            if (gridOptions && gridOptions.enableTranslate) {
                columnDefinitions.forEach(function (columnDef) {
                    if (columnDef && columnDef.cellMenu && (Array.isArray(columnDef.cellMenu.commandItems) || Array.isArray(columnDef.cellMenu.optionItems))) {
                        // get both items list
                        var columnCellMenuCommandItems = columnDef.cellMenu.commandItems || [];
                        var columnCellMenuOptionItems = columnDef.cellMenu.optionItems || [];
                        // translate their titles only if they have a titleKey defined
                        if (columnDef.cellMenu.commandTitleKey) {
                            columnDef.cellMenu.commandTitle = _this.translate && _this.translate.currentLang && _this.translate.instant && _this.translate.instant(columnDef.cellMenu.commandTitleKey) || _this._locales && _this._locales.TEXT_COMMANDS || columnDef.cellMenu.commandTitle;
                        }
                        if (columnDef.cellMenu.optionTitleKey) {
                            columnDef.cellMenu.optionTitle = _this.translate && _this.translate.currentLang && _this.translate.instant && _this.translate.instant(columnDef.cellMenu.optionTitleKey) || columnDef.cellMenu.optionTitle;
                        }
                        // translate both command/option items (whichever is provided)
                        _this.extensionUtility.translateItems(columnCellMenuCommandItems, 'titleKey', 'title');
                        _this.extensionUtility.translateItems(columnCellMenuOptionItems, 'titleKey', 'title');
                    }
                });
            }
        };
        CellMenuExtension.prototype.sortMenuItems = function (columnDefinitions) {
            var _this = this;
            columnDefinitions.forEach(function (columnDef) {
                if (columnDef && columnDef.cellMenu && columnDef.cellMenu.commandItems) {
                    // get both items list
                    var columnCellMenuCommandItems = columnDef.cellMenu.commandItems || [];
                    var columnCellMenuOptionItems = columnDef.cellMenu.optionItems || [];
                    _this.extensionUtility.sortItems(columnCellMenuCommandItems, 'positionOrder');
                    _this.extensionUtility.sortItems(columnCellMenuOptionItems, 'positionOrder');
                }
            });
        };
        CellMenuExtension.ctorParameters = function () { return [
            { type: ExtensionUtility },
            { type: SharedService },
            { type: core$1.TranslateService, decorators: [{ type: core.Optional }] }
        ]; };
        CellMenuExtension = __decorate([
            core.Injectable(),
            __param(2, core.Optional())
        ], CellMenuExtension);
        return CellMenuExtension;
    }());

    var CheckboxSelectorExtension = /** @class */ (function () {
        function CheckboxSelectorExtension(extensionUtility, sharedService) {
            this.extensionUtility = extensionUtility;
            this.sharedService = sharedService;
        }
        CheckboxSelectorExtension.prototype.dispose = function () {
            if (this._addon && this._addon.destroy) {
                this._addon.destroy();
            }
            this._addon = null;
            if (this._rowSelectionPlugin && this._rowSelectionPlugin.destroy) {
                this._rowSelectionPlugin.destroy();
            }
        };
        /**
         * Create the plugin before the Grid creation, else it will behave oddly.
         * Mostly because the column definitions might change after the grid creation
         */
        CheckboxSelectorExtension.prototype.create = function (columnDefinitions, gridOptions) {
            if (Array.isArray(columnDefinitions) && gridOptions) {
                // dynamically import the SlickGrid plugin (addon) with RequireJS
                this.extensionUtility.loadExtensionDynamically(exports.ExtensionName.checkboxSelector);
                if (!this._addon) {
                    this._addon = new Slick.CheckboxSelectColumn(gridOptions.checkboxSelector || {});
                }
                var iconColumn = this._addon.getColumnDefinition();
                if (typeof iconColumn === 'object') {
                    iconColumn.excludeFromExport = true;
                    iconColumn.excludeFromColumnPicker = true;
                    iconColumn.excludeFromGridMenu = true;
                    iconColumn.excludeFromQuery = true;
                    iconColumn.excludeFromHeaderMenu = true;
                    // column index position in the grid
                    var columnPosition = gridOptions && gridOptions.checkboxSelector && gridOptions.checkboxSelector.columnIndexPosition || 0;
                    if (columnPosition > 0) {
                        columnDefinitions.splice(columnPosition, 0, iconColumn);
                    }
                    else {
                        columnDefinitions.unshift(iconColumn);
                    }
                }
                return this._addon;
            }
            return null;
        };
        /** Get the instance of the SlickGrid addon (control or plugin). */
        CheckboxSelectorExtension.prototype.getAddonInstance = function () {
            return this._addon;
        };
        CheckboxSelectorExtension.prototype.register = function (rowSelectionPlugin) {
            var _this = this;
            if (this.sharedService && this.sharedService.grid && this.sharedService.gridOptions) {
                // the plugin has to be created BEFORE the grid (else it behaves oddly), but we can only watch grid events AFTER the grid is created
                this.sharedService.grid.registerPlugin(this._addon);
                // this also requires the Row Selection Model to be registered as well
                if (!rowSelectionPlugin || !this.sharedService.grid.getSelectionModel()) {
                    this.extensionUtility.loadExtensionDynamically(exports.ExtensionName.rowSelection);
                    rowSelectionPlugin = new Slick.RowSelectionModel(this.sharedService.gridOptions.rowSelectionOptions || {});
                    this.sharedService.grid.setSelectionModel(rowSelectionPlugin);
                }
                // user might want to pre-select some rows
                // the setTimeout is because of timing issue with styling (row selection happen but rows aren't highlighted properly)
                if (this.sharedService.gridOptions.preselectedRows && rowSelectionPlugin && this.sharedService.grid.getSelectionModel()) {
                    setTimeout(function () { return _this._addon.selectRows(_this.sharedService.gridOptions.preselectedRows); });
                }
                this._rowSelectionPlugin = rowSelectionPlugin;
                return rowSelectionPlugin;
            }
            return null;
        };
        CheckboxSelectorExtension.ctorParameters = function () { return [
            { type: ExtensionUtility },
            { type: SharedService }
        ]; };
        CheckboxSelectorExtension = __decorate([
            core.Injectable()
        ], CheckboxSelectorExtension);
        return CheckboxSelectorExtension;
    }());

    var ColumnPickerExtension = /** @class */ (function () {
        function ColumnPickerExtension(extensionUtility, sharedService) {
            this.extensionUtility = extensionUtility;
            this.sharedService = sharedService;
            this._eventHandler = new Slick.EventHandler();
        }
        Object.defineProperty(ColumnPickerExtension.prototype, "eventHandler", {
            get: function () {
                return this._eventHandler;
            },
            enumerable: true,
            configurable: true
        });
        ColumnPickerExtension.prototype.dispose = function () {
            // unsubscribe all SlickGrid events
            this._eventHandler.unsubscribeAll();
            if (this._addon && this._addon.destroy) {
                this._addon.destroy();
            }
            this.extensionUtility.nullifyFunctionNameStartingWithOn(this._columnPicker);
            this._addon = null;
        };
        /** Get the instance of the SlickGrid addon (control or plugin). */
        ColumnPickerExtension.prototype.getAddonInstance = function () {
            return this._addon;
        };
        ColumnPickerExtension.prototype.register = function () {
            var _this = this;
            if (this.sharedService && this.sharedService.grid && this.sharedService.gridOptions) {
                // dynamically import the SlickGrid plugin (addon) with RequireJS
                this.extensionUtility.loadExtensionDynamically(exports.ExtensionName.columnPicker);
                // localization support for the picker
                var columnTitle = this.extensionUtility.getPickerTitleOutputString('columnTitle', 'columnPicker');
                var forceFitTitle = this.extensionUtility.getPickerTitleOutputString('forceFitTitle', 'columnPicker');
                var syncResizeTitle = this.extensionUtility.getPickerTitleOutputString('syncResizeTitle', 'columnPicker');
                this._columnPicker = this.sharedService.gridOptions.columnPicker || {};
                this.sharedService.gridOptions.columnPicker = this._columnPicker;
                this._columnPicker.columnTitle = this._columnPicker.columnTitle || columnTitle;
                this._columnPicker.forceFitTitle = this._columnPicker.forceFitTitle || forceFitTitle;
                this._columnPicker.syncResizeTitle = this._columnPicker.syncResizeTitle || syncResizeTitle;
                this._addon = new Slick.Controls.ColumnPicker(this.sharedService.allColumns, this.sharedService.grid, this.sharedService.gridOptions);
                if (this.sharedService.grid && this.sharedService.gridOptions.enableColumnPicker) {
                    if (this._columnPicker.onExtensionRegistered) {
                        this._columnPicker.onExtensionRegistered(this._addon);
                    }
                    this._eventHandler.subscribe(this._addon.onColumnsChanged, function (e, args) {
                        if (_this._columnPicker && typeof _this._columnPicker.onColumnsChanged === 'function') {
                            _this._columnPicker.onColumnsChanged(e, args);
                        }
                        if (args && Array.isArray(args.columns) && args.columns.length !== _this.sharedService.visibleColumns.length) {
                            _this.sharedService.visibleColumns = args.columns;
                        }
                        // if we're using frozen columns, we need to readjust pinning when the new hidden column becomes visible again on the left pinning container
                        // we need to readjust frozenColumn index because SlickGrid freezes by index and has no knowledge of the columns themselves
                        var frozenColumnIndex = _this.sharedService.gridOptions.frozenColumn !== undefined ? _this.sharedService.gridOptions.frozenColumn : -1;
                        if (frozenColumnIndex >= 0) {
                            var isColumnShown = args.showing, columnId = args.columnId, allColumns = args.allColumns, visibleColumns = args.columns;
                            _this.extensionUtility.readjustFrozenColumnIndexWhenNeeded(columnId, frozenColumnIndex, isColumnShown, allColumns, visibleColumns);
                        }
                    });
                }
                return this._addon;
            }
            return null;
        };
        /** Translate the Column Picker headers and also the last 2 checkboxes */
        ColumnPickerExtension.prototype.translateColumnPicker = function () {
            // update the properties by pointers, that is the only way to get Column Picker Control to see the new values
            if (this._columnPicker) {
                this.emptyColumnPickerTitles();
                this._columnPicker.columnTitle = this.extensionUtility.getPickerTitleOutputString('columnTitle', 'columnPicker');
                this._columnPicker.forceFitTitle = this.extensionUtility.getPickerTitleOutputString('forceFitTitle', 'columnPicker');
                this._columnPicker.syncResizeTitle = this.extensionUtility.getPickerTitleOutputString('syncResizeTitle', 'columnPicker');
            }
            // translate all columns (including hidden columns)
            // eventually deprecate the "headerKey" and use only the "nameKey"
            this.extensionUtility.translateItems(this.sharedService.allColumns, 'headerKey', 'name');
            this.extensionUtility.translateItems(this.sharedService.allColumns, 'nameKey', 'name');
            // update the Titles of each sections (command, customTitle, ...)
            if (this._addon && this._addon.updateAllTitles && this._columnPicker) {
                this._addon.updateAllTitles(this._columnPicker);
            }
        };
        ColumnPickerExtension.prototype.emptyColumnPickerTitles = function () {
            if (this._columnPicker) {
                this._columnPicker.columnTitle = '';
                this._columnPicker.forceFitTitle = '';
                this._columnPicker.syncResizeTitle = '';
            }
        };
        ColumnPickerExtension.ctorParameters = function () { return [
            { type: ExtensionUtility },
            { type: SharedService }
        ]; };
        ColumnPickerExtension = __decorate([
            core.Injectable()
        ], ColumnPickerExtension);
        return ColumnPickerExtension;
    }());

    var TreeDataService = /** @class */ (function () {
        function TreeDataService(sharedService) {
            this.sharedService = sharedService;
            this._eventHandler = new Slick.EventHandler();
        }
        Object.defineProperty(TreeDataService.prototype, "dataset", {
            get: function () {
                return this.dataView && this.dataView.getItems && this.dataView.getItems();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeDataService.prototype, "datasetHierarchical", {
            get: function () {
                return this.sharedService.hierarchicalDataset;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeDataService.prototype, "dataView", {
            get: function () {
                return this._grid && this._grid.getData && this._grid.getData();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeDataService.prototype, "gridOptions", {
            get: function () {
                return this._grid && this._grid.getOptions && this._grid.getOptions() || {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeDataService.prototype, "eventHandler", {
            /** Getter of the SlickGrid Event Handler */
            get: function () {
                return this._eventHandler;
            },
            enumerable: true,
            configurable: true
        });
        TreeDataService.prototype.dispose = function () {
            // unsubscribe all SlickGrid events
            if (this._eventHandler && this._eventHandler.unsubscribeAll) {
                this._eventHandler.unsubscribeAll();
            }
        };
        TreeDataService.prototype.init = function (grid) {
            this._grid = grid;
            // subscribe to the SlickGrid event and call the backend execution
            this._eventHandler.subscribe(grid.onClick, this.handleOnCellClick.bind(this));
        };
        TreeDataService.prototype.handleOnCellClick = function (event, args) {
            if (event && args) {
                var targetElm = event.target || {};
                var treeDataOptions = this.gridOptions.treeDataOptions;
                var collapsedPropName = treeDataOptions && treeDataOptions.collapsedPropName || '__collapsed';
                var idPropName = this.gridOptions.datasetIdPropertyName || 'id';
                if (targetElm && targetElm.className) {
                    var hasToggleClass = targetElm.className.indexOf('toggle') >= 0 || false;
                    if (hasToggleClass) {
                        var item = this.dataView.getItem(args.row);
                        if (item) {
                            item[collapsedPropName] = !item[collapsedPropName] ? true : false;
                            this.dataView.updateItem(item[idPropName], item);
                            this._grid.invalidate();
                        }
                        event.stopImmediatePropagation();
                    }
                }
            }
        };
        TreeDataService.prototype.toggleTreeDataCollapse = function (collapsing) {
            if (this.gridOptions) {
                var treeDataOptions = this.gridOptions.treeDataOptions;
                if (this.gridOptions.enableTreeData) {
                    var items = this.dataView.getItems() || [];
                    var collapsedPropName_1 = treeDataOptions && treeDataOptions.collapsedPropName || '__collapsed';
                    items.forEach(function (item) { return item[collapsedPropName_1] = collapsing; });
                    this.dataView.setItems(items);
                    this._grid.invalidate();
                }
            }
        };
        TreeDataService.ctorParameters = function () { return [
            { type: SharedService }
        ]; };
        TreeDataService = __decorate([
            core.Injectable()
        ], TreeDataService);
        return TreeDataService;
    }());

    var ContextMenuExtension = /** @class */ (function () {
        function ContextMenuExtension(excelExportService, exportService, extensionUtility, sharedService, treeDataService, translate) {
            this.excelExportService = excelExportService;
            this.exportService = exportService;
            this.extensionUtility = extensionUtility;
            this.sharedService = sharedService;
            this.treeDataService = treeDataService;
            this.translate = translate;
            this._eventHandler = new Slick.EventHandler();
        }
        Object.defineProperty(ContextMenuExtension.prototype, "eventHandler", {
            get: function () {
                return this._eventHandler;
            },
            enumerable: true,
            configurable: true
        });
        ContextMenuExtension.prototype.dispose = function () {
            // unsubscribe all SlickGrid events
            this._eventHandler.unsubscribeAll();
            if (this._addon && this._addon.destroy) {
                this._addon.destroy();
            }
            if (this.sharedService.gridOptions && this.sharedService.gridOptions.contextMenu && this.sharedService.gridOptions.contextMenu.commandItems) {
                this.sharedService.gridOptions.contextMenu = this._userOriginalContextMenu;
            }
            this.extensionUtility.nullifyFunctionNameStartingWithOn(this._contextMenuOptions);
            this._addon = null;
            this._contextMenuOptions = null;
        };
        /** Get the instance of the SlickGrid addon (control or plugin). */
        ContextMenuExtension.prototype.getAddonInstance = function () {
            return this._addon;
        };
        /**
         * Create the Action Cell Menu and expose all the available hooks that user can subscribe (onCommand, onBeforeMenuShow, ...)
         * @param grid
         * @param dataView
         * @param columnDefinitions
         */
        ContextMenuExtension.prototype.register = function () {
            var _this = this;
            if (this.sharedService.gridOptions && this.sharedService.gridOptions.enableTranslate && (!this.translate || !this.translate.instant)) {
                throw new Error('[Angular-Slickgrid] requires "ngx-translate" to be installed and configured when the grid option "enableTranslate" is enabled.');
            }
            if (this.sharedService && this.sharedService.grid && this.sharedService.gridOptions && this.sharedService.gridOptions.contextMenu) {
                this._contextMenuOptions = this.sharedService.gridOptions.contextMenu;
                // keep original user context menu, useful when switching locale to translate
                this._userOriginalContextMenu = __assign({}, this._contextMenuOptions);
                // dynamically import the SlickGrid plugin (addon) with RequireJS
                this.extensionUtility.loadExtensionDynamically(exports.ExtensionName.contextMenu);
                // merge the original commands with the built-in internal commands
                var originalCommandItems = this._userOriginalContextMenu && Array.isArray(this._userOriginalContextMenu.commandItems) ? this._userOriginalContextMenu.commandItems : [];
                this._contextMenuOptions.commandItems = __spread(originalCommandItems, this.addMenuCustomCommands(originalCommandItems));
                this._contextMenuOptions = __assign({}, this._contextMenuOptions);
                this.sharedService.gridOptions.contextMenu = this._contextMenuOptions;
                // sort all menu items by their position order when defined
                this.extensionUtility.sortItems(this._contextMenuOptions.commandItems || [], 'positionOrder');
                this.extensionUtility.sortItems(this._contextMenuOptions.optionItems || [], 'positionOrder');
                this._addon = new Slick.Plugins.ContextMenu(this._contextMenuOptions);
                this.sharedService.grid.registerPlugin(this._addon);
                // translate the item keys when necessary
                if (this.sharedService.gridOptions.enableTranslate) {
                    this.translateContextMenu();
                }
                // hook all events
                if (this.sharedService.grid && this._contextMenuOptions) {
                    if (this._contextMenuOptions.onExtensionRegistered) {
                        this._contextMenuOptions.onExtensionRegistered(this._addon);
                    }
                    if (this._contextMenuOptions && typeof this._contextMenuOptions.onCommand === 'function') {
                        this._eventHandler.subscribe(this._addon.onCommand, function (event, args) {
                            _this._contextMenuOptions.onCommand(event, args);
                        });
                    }
                    if (this._contextMenuOptions && typeof this._contextMenuOptions.onOptionSelected === 'function') {
                        this._eventHandler.subscribe(this._addon.onOptionSelected, function (event, args) {
                            _this._contextMenuOptions.onOptionSelected(event, args);
                        });
                    }
                    if (this._contextMenuOptions && typeof this._contextMenuOptions.onBeforeMenuShow === 'function') {
                        this._eventHandler.subscribe(this._addon.onBeforeMenuShow, function (event, args) {
                            _this._contextMenuOptions.onBeforeMenuShow(event, args);
                        });
                    }
                    if (this._contextMenuOptions && typeof this._contextMenuOptions.onBeforeMenuClose === 'function') {
                        this._eventHandler.subscribe(this._addon.onBeforeMenuClose, function (event, args) {
                            _this._contextMenuOptions.onBeforeMenuClose(event, args);
                        });
                    }
                    if (this._contextMenuOptions && typeof this._contextMenuOptions.onAfterMenuShow === 'function') {
                        this._eventHandler.subscribe(this._addon.onAfterMenuShow, function (event, args) {
                            _this._contextMenuOptions.onAfterMenuShow(event, args);
                        });
                    }
                }
                return this._addon;
            }
            return null;
        };
        /** Translate the Cell Menu titles, we need to loop through all column definition to re-translate them */
        ContextMenuExtension.prototype.translateContextMenu = function () {
            if (this.sharedService && this.sharedService.gridOptions && this.sharedService.gridOptions.contextMenu) {
                var contextMenu = this.sharedService.gridOptions.contextMenu;
                var menuOptions = {};
                if (contextMenu.commandTitleKey) {
                    contextMenu.commandTitle = this.translate && this.translate.currentLang && this.translate.instant && this.translate.instant(contextMenu.commandTitleKey) || contextMenu.commandTitle;
                    menuOptions.commandTitle = contextMenu.commandTitle;
                }
                if (contextMenu.optionTitleKey) {
                    contextMenu.optionTitle = this.translate && this.translate.currentLang && this.translate.instant && this.translate.instant(contextMenu.optionTitleKey) || contextMenu.optionTitle;
                    menuOptions.optionTitle = contextMenu.optionTitle;
                }
                var originalCommandItems = this._userOriginalContextMenu && Array.isArray(this._userOriginalContextMenu.commandItems) ? this._userOriginalContextMenu.commandItems : [];
                contextMenu.commandItems = __spread(originalCommandItems, this.addMenuCustomCommands(originalCommandItems));
                menuOptions.commandItems = contextMenu.commandItems; // copy it also to the menuOptions else they won't be translated when locale changes
                // translate all command/options and resort them afterward
                this.extensionUtility.translateItems(contextMenu.commandItems || [], 'titleKey', 'title');
                this.extensionUtility.translateItems(contextMenu.optionItems || [], 'titleKey', 'title');
                this.extensionUtility.sortItems(contextMenu.commandItems || [], 'positionOrder');
                this.extensionUtility.sortItems(contextMenu.optionItems || [], 'positionOrder');
                // update the title options so that it has latest translated values
                if (this._addon && this._addon.setOptions) {
                    this._addon.setOptions(menuOptions);
                }
            }
        };
        // --
        // private functions
        // ------------------
        /** Create Context Menu with Custom Commands (copy cell value, export) */
        ContextMenuExtension.prototype.addMenuCustomCommands = function (originalCustomItems) {
            var _this = this;
            var menuCustomItems = [];
            var gridOptions = this.sharedService && this.sharedService.gridOptions || {};
            var contextMenu = gridOptions && gridOptions.contextMenu;
            var dataView = this.sharedService && this.sharedService.dataView;
            var translationPrefix = getTranslationPrefix(gridOptions);
            // show context menu: Copy (cell value)
            if (contextMenu && !contextMenu.hideCopyCellValueCommand) {
                var commandName_1 = 'copy';
                if (!originalCustomItems.find(function (item) { return item.hasOwnProperty('command') && item.command === commandName_1; })) {
                    menuCustomItems.push({
                        iconCssClass: contextMenu.iconCopyCellValueCommand || 'fa fa-clone',
                        title: this.extensionUtility.translateWhenEnabledAndServiceExist(translationPrefix + "COPY", 'TEXT_COPY'),
                        disabled: false,
                        command: commandName_1,
                        positionOrder: 50,
                        action: function (e, args) {
                            _this.copyToClipboard(args);
                        },
                        itemUsabilityOverride: function (args) {
                            // make sure there's an item to copy before enabling this command
                            var columnDef = args && args.column;
                            var dataContext = args && args.dataContext;
                            if (typeof columnDef.queryFieldNameGetterFn === 'function') {
                                var cellValue = _this.getCellValueFromQueryFieldGetter(columnDef, dataContext);
                                if (cellValue !== '' && cellValue !== undefined) {
                                    return true;
                                }
                            }
                            else if (columnDef && dataContext.hasOwnProperty(columnDef.field)) {
                                return dataContext[columnDef.field] !== '' && dataContext[columnDef.field] !== null && dataContext[columnDef.field] !== undefined;
                            }
                            return false;
                        }
                    });
                }
            }
            // show context menu: Export to file
            if (gridOptions && gridOptions.enableExport && contextMenu && !contextMenu.hideExportCsvCommand) {
                var commandName_2 = 'export-csv';
                if (!originalCustomItems.find(function (item) { return item.hasOwnProperty('command') && item.command === commandName_2; })) {
                    menuCustomItems.push({
                        iconCssClass: contextMenu.iconExportCsvCommand || 'fa fa-download',
                        title: this.extensionUtility.translateWhenEnabledAndServiceExist(translationPrefix + "EXPORT_TO_CSV", 'TEXT_EXPORT_TO_CSV'),
                        disabled: false,
                        command: commandName_2,
                        positionOrder: 51,
                        action: function () { return _this.exportService.exportToFile({
                            delimiter: exports.DelimiterType.comma,
                            filename: 'export',
                            format: exports.FileType.csv,
                            useUtf8WithBom: true,
                        }); },
                    });
                }
            }
            // show context menu: Export to Excel
            if (gridOptions && gridOptions.enableExcelExport && contextMenu && !contextMenu.hideExportExcelCommand) {
                var commandName_3 = 'export-excel';
                if (!originalCustomItems.find(function (item) { return item.hasOwnProperty('command') && item.command === commandName_3; })) {
                    menuCustomItems.push({
                        iconCssClass: contextMenu.iconExportExcelCommand || 'fa fa-file-excel-o text-success',
                        title: this.extensionUtility.translateWhenEnabledAndServiceExist(translationPrefix + "EXPORT_TO_EXCEL", 'TEXT_EXPORT_TO_EXCEL'),
                        disabled: false,
                        command: commandName_3,
                        positionOrder: 52,
                        action: function () { return _this.excelExportService.exportToExcel({
                            filename: 'export',
                            format: exports.FileType.xlsx,
                        }); },
                    });
                }
            }
            // show context menu: export to text file as tab delimited
            if (gridOptions && gridOptions.enableExport && contextMenu && !contextMenu.hideExportTextDelimitedCommand) {
                var commandName_4 = 'export-text-delimited';
                if (!originalCustomItems.find(function (item) { return item.hasOwnProperty('command') && item.command === commandName_4; })) {
                    menuCustomItems.push({
                        iconCssClass: contextMenu.iconExportTextDelimitedCommand || 'fa fa-download',
                        title: this.extensionUtility.translateWhenEnabledAndServiceExist(translationPrefix + "EXPORT_TO_TAB_DELIMITED", 'TEXT_EXPORT_TO_TAB_DELIMITED'),
                        disabled: false,
                        command: commandName_4,
                        positionOrder: 53,
                        action: function () { return _this.exportService.exportToFile({
                            delimiter: exports.DelimiterType.tab,
                            filename: 'export',
                            format: exports.FileType.txt,
                            useUtf8WithBom: true,
                        }); },
                    });
                }
            }
            // -- Grouping Commands
            if (gridOptions && (gridOptions.enableGrouping || gridOptions.enableDraggableGrouping || gridOptions.enableTreeData)) {
                // add a divider (separator) between the top sort commands and the other clear commands
                if (contextMenu && !contextMenu.hideCopyCellValueCommand) {
                    menuCustomItems.push({ divider: true, command: '', positionOrder: 54 });
                }
                // show context menu: Clear Grouping
                if (gridOptions && !gridOptions.enableTreeData && contextMenu && !contextMenu.hideClearAllGrouping) {
                    var commandName_5 = 'clear-grouping';
                    if (!originalCustomItems.find(function (item) { return item.hasOwnProperty('command') && item.command === commandName_5; })) {
                        menuCustomItems.push({
                            iconCssClass: contextMenu.iconClearGroupingCommand || 'fa fa-times',
                            title: this.extensionUtility.translateWhenEnabledAndServiceExist(translationPrefix + "CLEAR_ALL_GROUPING", 'TEXT_CLEAR_ALL_GROUPING'),
                            disabled: false,
                            command: commandName_5,
                            positionOrder: 55,
                            action: function () { return dataView.setGrouping([]); },
                            itemUsabilityOverride: function () {
                                // only enable the command when there's an actually grouping in play
                                var groupingArray = dataView && dataView.getGrouping && dataView.getGrouping();
                                return Array.isArray(groupingArray) && groupingArray.length > 0;
                            }
                        });
                    }
                }
                // show context menu: Collapse all Groups
                if (gridOptions && contextMenu && !contextMenu.hideCollapseAllGroups) {
                    var commandName_6 = 'collapse-all-groups';
                    if (!originalCustomItems.find(function (item) { return item.hasOwnProperty('command') && item.command === commandName_6; })) {
                        menuCustomItems.push({
                            iconCssClass: contextMenu.iconCollapseAllGroupsCommand || 'fa fa-compress',
                            title: this.extensionUtility.translateWhenEnabledAndServiceExist(translationPrefix + "COLLAPSE_ALL_GROUPS", 'TEXT_COLLAPSE_ALL_GROUPS'),
                            disabled: false,
                            command: commandName_6,
                            positionOrder: 56,
                            action: function () {
                                if (gridOptions.enableTreeData) {
                                    _this.treeDataService.toggleTreeDataCollapse(true);
                                }
                                else {
                                    dataView.collapseAllGroups();
                                }
                            },
                            itemUsabilityOverride: function () {
                                if (gridOptions.enableTreeData) {
                                    return true;
                                }
                                // only enable the command when there's an actually grouping in play
                                var groupingArray = dataView && dataView.getGrouping && dataView.getGrouping();
                                return Array.isArray(groupingArray) && groupingArray.length > 0;
                            }
                        });
                    }
                }
                // show context menu: Expand all Groups
                if (gridOptions && contextMenu && !contextMenu.hideExpandAllGroups) {
                    var commandName_7 = 'expand-all-groups';
                    if (!originalCustomItems.find(function (item) { return item.hasOwnProperty('command') && item.command === commandName_7; })) {
                        menuCustomItems.push({
                            iconCssClass: contextMenu.iconExpandAllGroupsCommand || 'fa fa-expand',
                            title: this.extensionUtility.translateWhenEnabledAndServiceExist(translationPrefix + "EXPAND_ALL_GROUPS", 'TEXT_EXPAND_ALL_GROUPS'),
                            disabled: false,
                            command: commandName_7,
                            positionOrder: 57,
                            action: function () {
                                if (gridOptions.enableTreeData) {
                                    _this.treeDataService.toggleTreeDataCollapse(false);
                                }
                                else {
                                    dataView.expandAllGroups();
                                }
                            },
                            itemUsabilityOverride: function () {
                                if (gridOptions.enableTreeData) {
                                    return true;
                                }
                                // only enable the command when there's an actually grouping in play
                                var groupingArray = dataView && dataView.getGrouping && dataView.getGrouping();
                                return Array.isArray(groupingArray) && groupingArray.length > 0;
                            }
                        });
                    }
                }
            }
            return menuCustomItems;
        };
        /**
         * First get the value, if "exportWithFormatter" is set then we'll use the formatter output
         * Then we create the DOM trick to copy a text value by creating a fake <div> that is not shown to the user
         * and from there we can call the execCommand 'copy' command and expect the value to be in clipboard
         * @param args
         */
        ContextMenuExtension.prototype.copyToClipboard = function (args) {
            try {
                if (args && args.grid && args.command) {
                    // get the value, if "exportWithFormatter" is set then we'll use the formatter output
                    var gridOptions = this.sharedService && this.sharedService.gridOptions || {};
                    var cell = args && args.cell || 0;
                    var row = args && args.row || 0;
                    var columnDef = args && args.column;
                    var dataContext = args && args.dataContext;
                    var grid = this.sharedService && this.sharedService.grid;
                    var exportOptions = gridOptions && (gridOptions.excelExportOptions || gridOptions.exportOptions);
                    var textToCopy = exportWithFormatterWhenDefined(row, cell, dataContext, columnDef, grid, exportOptions);
                    if (typeof columnDef.queryFieldNameGetterFn === 'function') {
                        textToCopy = this.getCellValueFromQueryFieldGetter(columnDef, dataContext);
                    }
                    // create fake <div> to copy into clipboard & delete it from the DOM once we're done
                    var range = document.createRange();
                    var tmpElem = $('<div>').css({ position: 'absolute', left: '-1000px', top: '-1000px' }).text(textToCopy);
                    $('body').append(tmpElem);
                    range.selectNodeContents(tmpElem.get(0));
                    var selection = window.getSelection();
                    if (selection && selection.addRange && selection.removeAllRanges) {
                        selection.removeAllRanges();
                        selection.addRange(range);
                        var success = document.execCommand('copy', false, textToCopy);
                        if (success) {
                            tmpElem.remove();
                        }
                    }
                }
            }
            catch (e) { }
        };
        /**
         * When a queryFieldNameGetterFn is defined, then get the value from that getter callback function
         * @param columnDef
         * @param dataContext
         * @return cellValue
         */
        ContextMenuExtension.prototype.getCellValueFromQueryFieldGetter = function (columnDef, dataContext) {
            var cellValue = '';
            if (typeof columnDef.queryFieldNameGetterFn === 'function') {
                var queryFieldName = columnDef.queryFieldNameGetterFn(dataContext);
                // get the cell value from the item or when it's a dot notation then exploded the item and get the final value
                if (queryFieldName && queryFieldName.indexOf('.') >= 0) {
                    cellValue = getDescendantProperty(dataContext, queryFieldName);
                }
                else {
                    cellValue = dataContext[queryFieldName];
                }
            }
            return cellValue;
        };
        ContextMenuExtension.ctorParameters = function () { return [
            { type: ExcelExportService },
            { type: ExportService },
            { type: ExtensionUtility },
            { type: SharedService },
            { type: TreeDataService },
            { type: core$1.TranslateService, decorators: [{ type: core.Optional }] }
        ]; };
        ContextMenuExtension = __decorate([
            core.Injectable(),
            __param(5, core.Optional())
        ], ContextMenuExtension);
        return ContextMenuExtension;
    }());

    var DraggableGroupingExtension = /** @class */ (function () {
        function DraggableGroupingExtension(extensionUtility, sharedService) {
            this.extensionUtility = extensionUtility;
            this.sharedService = sharedService;
            this._eventHandler = new Slick.EventHandler();
        }
        Object.defineProperty(DraggableGroupingExtension.prototype, "eventHandler", {
            get: function () {
                return this._eventHandler;
            },
            enumerable: true,
            configurable: true
        });
        DraggableGroupingExtension.prototype.dispose = function () {
            // unsubscribe all SlickGrid events
            this._eventHandler.unsubscribeAll();
            if (this._addon && this._addon.destroy) {
                this._addon.destroy();
            }
            this.extensionUtility.nullifyFunctionNameStartingWithOn(this._draggableGroupingOptions);
            this._addon = null;
            this._draggableGroupingOptions = null;
        };
        /**
         * Bind/Create different plugins before the Grid creation.
         * For example the multi-select have to be added to the column definition before the grid is created to work properly
         */
        DraggableGroupingExtension.prototype.create = function (gridOptions) {
            if (gridOptions) {
                // dynamically import the SlickGrid plugin (addon) with RequireJS
                this.extensionUtility.loadExtensionDynamically(exports.ExtensionName.draggableGrouping);
                if (!this._addon) {
                    this._addon = new Slick.DraggableGrouping(gridOptions.draggableGrouping || {});
                }
                return this._addon;
            }
            return null;
        };
        /** Get the instance of the SlickGrid addon (control or plugin). */
        DraggableGroupingExtension.prototype.getAddonInstance = function () {
            return this._addon;
        };
        DraggableGroupingExtension.prototype.register = function () {
            var _this = this;
            if (this.sharedService && this.sharedService.grid && this.sharedService.gridOptions) {
                this.sharedService.grid.registerPlugin(this._addon);
                // Events
                if (this.sharedService.grid && this.sharedService.gridOptions.draggableGrouping) {
                    this._draggableGroupingOptions = this.sharedService.gridOptions.draggableGrouping;
                    if (this._draggableGroupingOptions.onExtensionRegistered) {
                        this._draggableGroupingOptions.onExtensionRegistered(this._addon);
                    }
                    this._eventHandler.subscribe(this._addon.onGroupChanged, function (e, args) {
                        if (_this._draggableGroupingOptions && typeof _this._draggableGroupingOptions.onGroupChanged === 'function') {
                            _this._draggableGroupingOptions.onGroupChanged(e, args);
                        }
                    });
                }
                return this._addon;
            }
            return null;
        };
        DraggableGroupingExtension.ctorParameters = function () { return [
            { type: ExtensionUtility },
            { type: SharedService }
        ]; };
        DraggableGroupingExtension = __decorate([
            core.Injectable()
        ], DraggableGroupingExtension);
        return DraggableGroupingExtension;
    }());

    var booleanFilterCondition = function (options) {
        var searchTerm = Array.isArray(options.searchTerms) && options.searchTerms[0] || '';
        return parseBoolean(options.cellValue) === parseBoolean(searchTerm);
    };

    /**
     * Compare 2 objects,
     * we will loop through all properties of the object to compare the entire content of both objects
     * Optionally we can compare by a property key, when that is provided we will compare the object content
     * @param o1
     * @param o2
     * @param compareKey optional
     * @return boolean are objects equals?
     */
    function compareObjects(o1, o2, compareKey) {
        // if user provided an object compare key then compare directly both objects by that key
        if (compareKey && ((o1 && o1.hasOwnProperty(compareKey)) || (o2 && o2.hasOwnProperty(compareKey)))) {
            return o1[compareKey] === o2 || o1 === o2[compareKey] || o1[compareKey] === o2[compareKey];
        }
        // loop through all object properties to compare the full content of the object
        // we'll return false as soon as a difference is detected
        for (var p in o1) {
            if (o1.hasOwnProperty(p)) {
                if (o1[p] !== o2[p]) {
                    return false;
                }
            }
        }
        return true;
    }
    var testFilterCondition = function (operator, value1, value2) {
        switch (operator) {
            case '<':
            case 'LT': return (value1 < value2);
            case '<=':
            case 'LE': return (value1 <= value2);
            case '>':
            case 'GT': return (value1 > value2);
            case '>=':
            case 'GE': return (value1 >= value2);
            case '!=':
            case '<>':
            case 'NE': return (value1 !== value2);
            case '=':
            case '==':
            case 'EQ': return (value1 === value2);
            case 'IN': return ((value2 && value2.indexOf) ? (value2.indexOf(value1) > -1) : false);
            case 'NIN':
            case 'NOT_IN':
                return ((value2 && value2.includes) ? (!value2.includes(value1)) : false);
            case 'IN_CONTAINS':
                if (value2 && Array.isArray(value2) && value2.findIndex) {
                    return ((value2.findIndex(function (val) { return value1.indexOf(val) > -1; })) > -1);
                }
                return false;
            case 'NIN_CONTAINS':
            case 'NOT_IN_CONTAINS':
                if (value2 && Array.isArray(value2) && value2.findIndex) {
                    return !((value2.findIndex(function (val) { return value1.indexOf(val) > -1; })) > -1);
                }
                return false;
        }
        return true;
    };

    var collectionSearchFilterCondition = function (options) {
        // multiple-select will always return text, so we should make our cell values text as well
        var cellValue = options.cellValue + '';
        return testFilterCondition(options.operator || 'IN', cellValue, options.searchTerms || []);
    };

    var numberFilterCondition = function (options) {
        var cellValue = parseFloat(options.cellValue);
        var searchTerms = Array.isArray(options.searchTerms) && options.searchTerms || [0];
        var isRangeSearch = false;
        var searchValue1;
        var searchValue2;
        if (searchTerms.length === 2 || (typeof searchTerms[0] === 'string' && searchTerms[0].indexOf('..') > 0)) {
            isRangeSearch = true;
            var searchValues = (searchTerms.length === 2) ? searchTerms : searchTerms[0].split('..');
            searchValue1 = parseFloat(Array.isArray(searchValues) && searchValues[0] + '');
            searchValue2 = parseFloat(Array.isArray(searchValues) && searchValues[1] + '');
        }
        else {
            searchValue1 = parseFloat(searchTerms[0] + '');
        }
        if (!searchValue1 && !options.operator) {
            return true;
        }
        if (isRangeSearch) {
            var isInclusive = options.operator && options.operator === exports.OperatorType.rangeInclusive;
            var resultCondition1 = testFilterCondition((isInclusive ? '>=' : '>'), cellValue, searchValue1);
            var resultCondition2 = testFilterCondition((isInclusive ? '<=' : '<'), cellValue, searchValue2);
            return (resultCondition1 && resultCondition2);
        }
        return testFilterCondition(options.operator || '==', cellValue, searchValue1);
    };

    var objectFilterCondition = function (options) {
        var searchTerm = (Array.isArray(options.searchTerms) && options.searchTerms[0] || '');
        if (!searchTerm && !options.operator) {
            return true;
        }
        switch (options.operator) {
            case '!=':
            case '<>':
            case 'NE':
                return !compareObjects(options.cellValue, searchTerm, options.dataKey);
            case '=':
            case '==':
            case 'EQ':
            default:
                return compareObjects(options.cellValue, searchTerm, options.dataKey);
        }
    };

    var stringFilterCondition = function (options) {
        // make sure the cell value is a string by casting it when possible
        options.cellValue = (options.cellValue === undefined || options.cellValue === null) ? '' : options.cellValue.toString();
        // make both the cell value and search value lower for case insensitive comparison
        var cellValue = options.cellValue.toLowerCase();
        var searchTerm = (Array.isArray(options.searchTerms) && options.searchTerms[0]) || '';
        if (typeof searchTerm === 'string') {
            searchTerm = searchTerm.toLowerCase();
        }
        if (options.operator === '*' || options.operator === exports.OperatorType.endsWith) {
            return cellValue.endsWith(searchTerm);
        }
        else if ((options.operator === '' && options.cellValueLastChar === '*') || options.operator === exports.OperatorType.startsWith) {
            return cellValue.startsWith(searchTerm);
        }
        else if (options.operator === '' || options.operator === exports.OperatorType.contains) {
            return (cellValue.indexOf(searchTerm) > -1);
        }
        return testFilterCondition(options.operator || '==', cellValue, searchTerm);
    };

    var moment$3 = moment_; // patch to fix rollup "moment has no default export" issue, document here https://github.com/rollup/rollup/issues/670
    var executeMappedCondition = function (options) {
        // when using a multi-select ('IN' operator) we will not use the field type but instead go directly with a collection search
        var operator = options && options.operator && options.operator.toUpperCase();
        if (operator === 'IN' || operator === 'NIN' || operator === 'IN_CONTAINS' || operator === 'NIN_CONTAINS') {
            return collectionSearchFilterCondition(options);
        }
        // execute the mapped type, or default to String condition check
        switch (options.fieldType) {
            case exports.FieldType.boolean:
                return booleanFilterCondition(options);
            case exports.FieldType.date:
            case exports.FieldType.dateIso:
            case exports.FieldType.dateUtc:
            case exports.FieldType.dateTime:
            case exports.FieldType.dateTimeIso:
            case exports.FieldType.dateTimeIsoAmPm:
            case exports.FieldType.dateTimeIsoAM_PM:
            case exports.FieldType.dateTimeShortIso:
            case exports.FieldType.dateEuro:
            case exports.FieldType.dateEuroShort:
            case exports.FieldType.dateTimeShortEuro:
            case exports.FieldType.dateTimeEuro:
            case exports.FieldType.dateTimeEuroAmPm:
            case exports.FieldType.dateTimeEuroAM_PM:
            case exports.FieldType.dateTimeEuroShort:
            case exports.FieldType.dateTimeEuroShortAmPm:
            case exports.FieldType.dateTimeEuroShortAM_PM:
            case exports.FieldType.dateUs:
            case exports.FieldType.dateUsShort:
            case exports.FieldType.dateTimeShortUs:
            case exports.FieldType.dateTimeUs:
            case exports.FieldType.dateTimeUsAmPm:
            case exports.FieldType.dateTimeUsAM_PM:
            case exports.FieldType.dateTimeUsShort:
            case exports.FieldType.dateTimeUsShortAmPm:
            case exports.FieldType.dateTimeUsShortAM_PM:
                return executeAssociatedDateCondition(options);
            case exports.FieldType.integer:
            case exports.FieldType.float:
            case exports.FieldType.number:
                return numberFilterCondition(options);
            case exports.FieldType.object:
                return objectFilterCondition(options);
            case exports.FieldType.string:
            case exports.FieldType.text:
            case exports.FieldType.password:
            case exports.FieldType.readonly:
            default:
                return stringFilterCondition(options);
        }
    };
    /**
     * Execute Date filter condition and use correct date format depending on it's field type (or filterSearchType when that is provided)
     * @param options
     */
    function executeAssociatedDateCondition(options) {
        var filterSearchType = options && (options.filterSearchType || options.fieldType) || exports.FieldType.dateIso;
        var FORMAT = mapMomentDateFormatWithFieldType(filterSearchType);
        var searchTerms = Array.isArray(options.searchTerms) && options.searchTerms || [];
        var isRangeSearch = false;
        var dateSearch1;
        var dateSearch2;
        // return when cell value is not a valid date
        if (searchTerms.length === 0 || searchTerms[0] === '' || searchTerms[0] === null || !moment$3(options.cellValue, FORMAT, true).isValid()) {
            return false;
        }
        // cell value in moment format
        var dateCell = moment$3(options.cellValue, FORMAT, true);
        if (searchTerms.length === 2 || (typeof searchTerms[0] === 'string' && searchTerms[0].indexOf('..') > 0)) {
            isRangeSearch = true;
            var searchValues = (searchTerms.length === 2) ? searchTerms : searchTerms[0].split('..');
            var searchValue1 = (Array.isArray(searchValues) && searchValues[0] || '');
            var searchValue2 = (Array.isArray(searchValues) && searchValues[1] || '');
            var searchTerm1 = moment$3(searchValue1, FORMAT, true);
            var searchTerm2 = moment$3(searchValue2, FORMAT, true);
            // return if any of the 2 values are invalid dates
            if (!moment$3(searchTerm1, FORMAT, true).isValid() || !moment$3(searchTerm2, FORMAT, true).isValid()) {
                return false;
            }
            dateSearch1 = moment$3(searchTerm1, FORMAT, true);
            dateSearch2 = moment$3(searchTerm2, FORMAT, true);
        }
        else {
            // return if the search term is an invalid date
            if (!moment$3(searchTerms[0], FORMAT, true).isValid()) {
                return false;
            }
            dateSearch1 = moment$3(searchTerms[0], FORMAT, true);
        }
        // when comparing with Dates only (without time), we need to disregard the time portion, we can do so by setting our time to start at midnight
        // ref, see https://stackoverflow.com/a/19699447/1212166
        var dateCellTimestamp = FORMAT.toLowerCase().includes('h') ? parseInt(dateCell.format('X'), 10) : parseInt(dateCell.clone().startOf('day').format('X'), 10);
        // run the filter condition with date in Unix Timestamp format
        if (isRangeSearch) {
            var isInclusive = options.operator && options.operator === exports.OperatorType.rangeInclusive;
            var resultCondition1 = testFilterCondition((isInclusive ? '>=' : '>'), dateCellTimestamp, parseInt(dateSearch1.format('X'), 10));
            var resultCondition2 = testFilterCondition((isInclusive ? '<=' : '<'), dateCellTimestamp, parseInt(dateSearch2.format('X'), 10));
            return (resultCondition1 && resultCondition2);
        }
        var dateSearchTimestamp1 = FORMAT.toLowerCase().includes('h') ? parseInt(dateSearch1.format('X'), 10) : parseInt(dateSearch1.clone().startOf('day').format('X'), 10);
        return testFilterCondition(options.operator || '==', dateCellTimestamp, dateSearchTimestamp1);
    }
    ;

    var FilterConditions = {
        executeMappedCondition: executeMappedCondition,
        booleanFilter: booleanFilterCondition,
        collectionSearchFilter: collectionSearchFilterCondition,
        numberFilter: numberFilterCondition,
        stringFilter: stringFilterCondition,
        testFilter: testFilterCondition
    };

    var DOMPurify = DOMPurify_; // patch to fix rollup to work
    var AutoCompleteFilter = /** @class */ (function () {
        /**
         * Initialize the Filter
         */
        function AutoCompleteFilter(translate, collectionService) {
            this.translate = translate;
            this.collectionService = collectionService;
            this._clearFilterTriggered = false;
            this._shouldTriggerQuery = true;
            this.isFilled = false;
            /** The property name for values in the collection */
            this.valueName = 'label';
            this.enableTranslateLabel = false;
            this.subscriptions = [];
        }
        Object.defineProperty(AutoCompleteFilter.prototype, "autoCompleteOptions", {
            /** Getter for the Autocomplete Option */
            get: function () {
                return this._autoCompleteOptions || {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AutoCompleteFilter.prototype, "collectionOptions", {
            /** Getter for the Collection Options */
            get: function () {
                return this.columnDef && this.columnDef.filter && this.columnDef.filter.collectionOptions || {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AutoCompleteFilter.prototype, "collection", {
            /** Getter for the Collection Used by the Filter */
            get: function () {
                return this._collection;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AutoCompleteFilter.prototype, "columnFilter", {
            /** Getter for the Column Filter */
            get: function () {
                return this.columnDef && this.columnDef.filter || {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AutoCompleteFilter.prototype, "filterDomElement", {
            /** Get the Editor DOM Element */
            get: function () {
                return this.$filterElm;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AutoCompleteFilter.prototype, "filterOptions", {
            get: function () {
                return this.columnFilter && this.columnFilter.filterOptions || {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AutoCompleteFilter.prototype, "customStructure", {
            /** Getter for the Custom Structure if exist */
            get: function () {
                var customStructure = this.columnFilter && this.columnFilter.customStructure;
                var columnType = this.columnFilter && this.columnFilter.type || this.columnDef && this.columnDef.type;
                if (!customStructure && (columnType === exports.FieldType.object && this.columnDef && this.columnDef.dataKey && this.columnDef.labelKey)) {
                    customStructure = {
                        label: this.columnDef.labelKey,
                        value: this.columnDef.dataKey,
                    };
                }
                return customStructure;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AutoCompleteFilter.prototype, "defaultOperator", {
            /** Getter to know what would be the default operator when none is specified */
            get: function () {
                return exports.OperatorType.equal;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AutoCompleteFilter.prototype, "gridOptions", {
            /** Getter for the Grid Options pulled through the Grid Object */
            get: function () {
                return (this.grid && this.grid.getOptions) ? this.grid.getOptions() : {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AutoCompleteFilter.prototype, "instance", {
            /** jQuery UI AutoComplete instance */
            get: function () {
                return this.$filterElm.autocomplete('instance');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AutoCompleteFilter.prototype, "operator", {
            /** Getter of the Operator to use when doing the filter comparing */
            get: function () {
                return this.columnFilter && this.columnFilter.operator || this.defaultOperator;
            },
            /** Setter for the filter operator */
            set: function (operator) {
                if (this.columnFilter) {
                    this.columnFilter.operator = operator;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Initialize the filter template
         */
        AutoCompleteFilter.prototype.init = function (args) {
            if (!args) {
                throw new Error('[Angular-SlickGrid] A filter must always have an "init()" with valid arguments.');
            }
            this.grid = args.grid;
            this.callback = args.callback;
            this.columnDef = args.columnDef;
            this.searchTerms = (args.hasOwnProperty('searchTerms') ? args.searchTerms : []) || [];
            if (!this.grid || !this.columnDef || !this.columnFilter || (!this.columnFilter.collection && !this.columnFilter.collectionAsync && !this.columnFilter.filterOptions)) {
                throw new Error("[Angular-SlickGrid] You need to pass a \"collection\" (or \"collectionAsync\") for the AutoComplete Filter to work correctly. Also each option should include a value/label pair (or value/labelKey when using Locale). For example:: { filter: model: Filters.autoComplete, collection: [{ value: true, label: 'True' }, { value: false, label: 'False'}] }");
            }
            this.enableTranslateLabel = this.columnFilter && this.columnFilter.enableTranslateLabel || false;
            this.labelName = this.customStructure && this.customStructure.label || 'label';
            this.valueName = this.customStructure && this.customStructure.value || 'value';
            this.labelPrefixName = this.customStructure && this.customStructure.labelPrefix || 'labelPrefix';
            this.labelSuffixName = this.customStructure && this.customStructure.labelSuffix || 'labelSuffix';
            // always render the DOM element, even if user passed a "collectionAsync",
            var newCollection = this.columnFilter.collection || [];
            this._collection = newCollection;
            this.renderDomElement(newCollection);
            // on every Filter which have a "collection" or a "collectionAsync"
            // we will add (or replace) a Subject to the "collectionAsync" property so that user has possibility to change the collection
            // if "collectionAsync" is already set by the user, it will resolve it first then after it will replace it with a Subject
            var collectionAsync = this.columnFilter && this.columnFilter.collectionAsync;
            if (collectionAsync) {
                return this.renderOptionsAsync(collectionAsync); // create Subject after resolve (createCollectionAsyncSubject)
            }
            else {
                return new Promise(function (resolve) { return resolve(true); });
            }
        };
        /**
         * Clear the filter value
         */
        AutoCompleteFilter.prototype.clear = function (shouldTriggerQuery) {
            if (shouldTriggerQuery === void 0) { shouldTriggerQuery = true; }
            if (this.$filterElm) {
                this._clearFilterTriggered = true;
                this._shouldTriggerQuery = shouldTriggerQuery;
                this.searchTerms = [];
                this.$filterElm.val('');
                this.$filterElm.trigger('input');
            }
        };
        /**
         * destroy the filter
         */
        AutoCompleteFilter.prototype.destroy = function () {
            // also unsubscribe all RxJS subscriptions
            this.subscriptions = unsubscribeAllObservables(this.subscriptions);
            if (this.$filterElm) {
                this.$filterElm.off('input').remove();
            }
            this.$filterElm = null;
            this._collection = null;
        };
        /** Set value(s) on the DOM element */
        AutoCompleteFilter.prototype.setValues = function (values, operator) {
            if (values) {
                this.$filterElm.val(values);
            }
            // set the operator when defined
            this.operator = operator || this.defaultOperator;
        };
        //
        // protected functions
        // ------------------
        /**
         * user might want to filter certain items of the collection
         * @param inputCollection
         * @return outputCollection filtered and/or sorted collection
         */
        AutoCompleteFilter.prototype.filterCollection = function (inputCollection) {
            var outputCollection = inputCollection;
            // user might want to filter certain items of the collection
            if (this.columnFilter && this.columnFilter.collectionFilterBy) {
                var filterBy = this.columnFilter.collectionFilterBy;
                var filterCollectionBy = this.columnFilter.collectionOptions && this.columnFilter.collectionOptions.filterResultAfterEachPass || null;
                outputCollection = this.collectionService.filterCollection(outputCollection, filterBy, filterCollectionBy);
            }
            return outputCollection;
        };
        /**
         * user might want to sort the collection in a certain way
         * @param inputCollection
         * @return outputCollection filtered and/or sorted collection
         */
        AutoCompleteFilter.prototype.sortCollection = function (inputCollection) {
            var outputCollection = inputCollection;
            // user might want to sort the collection
            if (this.columnFilter && this.columnFilter.collectionSortBy) {
                var sortBy = this.columnFilter.collectionSortBy;
                outputCollection = this.collectionService.sortCollection(this.columnDef, outputCollection, sortBy, this.enableTranslateLabel);
            }
            return outputCollection;
        };
        AutoCompleteFilter.prototype.renderOptionsAsync = function (collectionAsync) {
            return __awaiter(this, void 0, void 0, function () {
                var awaitedCollection;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!collectionAsync) return [3 /*break*/, 2];
                            return [4 /*yield*/, castToPromise(collectionAsync)];
                        case 1:
                            awaitedCollection = _a.sent();
                            this.renderDomElementFromCollectionAsync(awaitedCollection);
                            // because we accept Promises & HttpClient Observable only execute once
                            // we will re-create an RxJs Subject which will replace the "collectionAsync" which got executed once anyway
                            // doing this provide the user a way to call a "collectionAsync.next()"
                            this.createCollectionAsyncSubject();
                            _a.label = 2;
                        case 2: return [2 /*return*/, true];
                    }
                });
            });
        };
        /** Create or recreate an Observable Subject and reassign it to the "collectionAsync" object so user can call a "collectionAsync.next()" on it */
        AutoCompleteFilter.prototype.createCollectionAsyncSubject = function () {
            var _this = this;
            var newCollectionAsync = new rxjs.Subject();
            this.columnFilter.collectionAsync = newCollectionAsync;
            this.subscriptions.push(newCollectionAsync.subscribe(function (collection) { return _this.renderDomElementFromCollectionAsync(collection); }));
        };
        /**
         * When user use a CollectionAsync we will use the returned collection to render the filter DOM element
         * and reinitialize filter collection with this new collection
         */
        AutoCompleteFilter.prototype.renderDomElementFromCollectionAsync = function (collection) {
            this._collection = collection;
            if (this.collectionOptions && (this.collectionOptions.collectionInsideObjectProperty || this.collectionOptions.collectionInObjectProperty)) {
                var collectionInsideObjectProperty = this.collectionOptions.collectionInsideObjectProperty || this.collectionOptions.collectionInObjectProperty;
                collection = getDescendantProperty(collection, collectionInsideObjectProperty);
            }
            if (!Array.isArray(collection)) {
                throw new Error('Something went wrong while trying to pull the collection from the "collectionAsync" call in the AutoComplete Filter, the collection is not a valid array.');
            }
            // copy over the array received from the async call to the "collection" as the new collection to use
            // this has to be BEFORE the `collectionObserver().subscribe` to avoid going into an infinite loop
            this.columnFilter.collection = collection;
            // recreate Filter DOM element after getting async collection
            this.renderDomElement(collection);
        };
        AutoCompleteFilter.prototype.renderDomElement = function (collection) {
            var _this = this;
            if (!Array.isArray(collection) && this.collectionOptions && (this.collectionOptions.collectionInsideObjectProperty || this.collectionOptions.collectionInObjectProperty)) {
                var collectionInsideObjectProperty = this.collectionOptions.collectionInsideObjectProperty || this.collectionOptions.collectionInObjectProperty;
                collection = getDescendantProperty(collection, collectionInsideObjectProperty);
            }
            if (!Array.isArray(collection)) {
                throw new Error('The "collection" passed to the Autocomplete Filter is not a valid array.');
            }
            // assign the collection to a temp variable before filtering/sorting the collection
            var newCollection = collection;
            // user might want to filter and/or sort certain items of the collection
            newCollection = this.filterCollection(newCollection);
            newCollection = this.sortCollection(newCollection);
            // filter input can only have 1 search term, so we will use the 1st array index if it exist
            var searchTerm = (Array.isArray(this.searchTerms) && this.searchTerms.length >= 0) ? this.searchTerms[0] : '';
            // step 1, create HTML string template
            var filterTemplate = this.buildTemplateHtmlString();
            // step 2, create the DOM Element of the filter & pre-load search term
            // also subscribe to the onSelect event
            this._collection = newCollection;
            this.$filterElm = this.createDomElement(filterTemplate, newCollection, searchTerm);
            // step 3, subscribe to the input change event and run the callback when that happens
            // also add/remove "filled" class for styling purposes
            this.$filterElm.on('input', function (e) {
                var value = e && e.target && e.target.value || '';
                var enableWhiteSpaceTrim = _this.gridOptions.enableFilterTrimWhiteSpace || _this.columnFilter.enableTrimWhiteSpace;
                if (typeof value === 'string' && enableWhiteSpaceTrim) {
                    value = value.trim();
                }
                if (_this._clearFilterTriggered) {
                    _this.callback(e, { columnDef: _this.columnDef, clearFilterTriggered: _this._clearFilterTriggered, shouldTriggerQuery: _this._shouldTriggerQuery });
                    _this.$filterElm.removeClass('filled');
                }
                else {
                    value === '' ? _this.$filterElm.removeClass('filled') : _this.$filterElm.addClass('filled');
                    _this.callback(e, { columnDef: _this.columnDef, operator: _this.operator, searchTerms: [value], shouldTriggerQuery: _this._shouldTriggerQuery });
                }
                // reset both flags for next use
                _this._clearFilterTriggered = false;
                _this._shouldTriggerQuery = true;
            });
        };
        /**
         * Create the HTML template as a string
         */
        AutoCompleteFilter.prototype.buildTemplateHtmlString = function () {
            var columnId = this.columnDef && this.columnDef.id;
            var placeholder = (this.gridOptions) ? (this.gridOptions.defaultFilterPlaceholder || '') : '';
            if (this.columnFilter && this.columnFilter.placeholder) {
                placeholder = this.columnFilter.placeholder;
            }
            return "<input type=\"text\" role=\"presentation\" autocomplete=\"off\" class=\"form-control autocomplete search-filter filter-" + columnId + "\" placeholder=\"" + placeholder + "\">";
        };
        /**
         * From the html template string, create a DOM element
         * @param filterTemplate
         */
        AutoCompleteFilter.prototype.createDomElement = function (filterTemplate, collection, searchTerm) {
            var e_1, _a;
            var _this = this;
            var columnId = this.columnDef && this.columnDef.id;
            var $headerElm = this.grid.getHeaderRowColumn(columnId);
            $($headerElm).empty();
            // create the DOM element & add an ID and filter class
            this.$filterElm = $(filterTemplate);
            var searchTermInput = searchTerm;
            // user might provide his own custom structure
            // jQuery UI autocomplete requires a label/value pair, so we must remap them when user provide different ones
            if (Array.isArray(collection)) {
                collection = collection.map(function (item) {
                    return { label: item[_this.labelName], value: item[_this.valueName], labelPrefix: item[_this.labelPrefixName] || '', labelSuffix: item[_this.labelSuffixName] || '' };
                });
            }
            // user might pass his own autocomplete options
            var autoCompleteOptions = this.filterOptions;
            // when user passes it's own autocomplete options
            // we still need to provide our own "select" callback implementation
            if (autoCompleteOptions && autoCompleteOptions.source) {
                autoCompleteOptions.select = function (event, ui) { return _this.onSelect(event, ui); };
                this._autoCompleteOptions = __assign({}, autoCompleteOptions);
                // when renderItem is defined, we need to add our custom style CSS class
                if (this._autoCompleteOptions.renderItem) {
                    this._autoCompleteOptions.classes = {
                        'ui-autocomplete': "autocomplete-custom-" + toKebabCase(this._autoCompleteOptions.renderItem.layout)
                    };
                }
                // create the jQueryUI AutoComplete
                this.$filterElm.autocomplete(this._autoCompleteOptions);
                // when "renderItem" is defined, we need to call the user's custom renderItem template callback
                if (this._autoCompleteOptions.renderItem) {
                    this.$filterElm.autocomplete('instance')._renderItem = this.renderCustomItem.bind(this);
                }
            }
            else {
                var definedOptions = {
                    minLength: 0,
                    source: collection,
                    select: function (event, ui) { return _this.onSelect(event, ui); },
                };
                this._autoCompleteOptions = __assign({}, definedOptions, this.filterOptions);
                this.$filterElm.autocomplete(this._autoCompleteOptions);
                // we'll use our own renderer so that it works with label prefix/suffix and also with html rendering when enabled
                this.$filterElm.autocomplete('instance')._renderItem = this.renderCollectionItem.bind(this);
            }
            this.$filterElm.val(searchTermInput);
            this.$filterElm.data('columnId', columnId);
            // if there's a search term, we will add the "filled" class for styling purposes
            if (searchTerm) {
                this.$filterElm.addClass('filled');
            }
            // append the new DOM element to the header row
            if (this.$filterElm && typeof this.$filterElm.appendTo === 'function') {
                var $container = $("<div class=\"autocomplete-container\"></div>");
                $container.appendTo($headerElm);
                this.$filterElm.appendTo($container);
                // add a <span> in order to add spinner styling
                $("<span></span>").appendTo($container);
            }
            // we could optionally trigger a search when clicking on the AutoComplete
            if (this.filterOptions.openSearchListOnFocus) {
                this.$filterElm.click(function () { return _this.$filterElm.autocomplete('search', _this.$filterElm.val()); });
            }
            // user might override any of the jQueryUI callback methods
            if (this.columnFilter.callbacks) {
                try {
                    for (var _b = __values(Object.keys(this.columnFilter.callbacks)), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var callback = _c.value;
                        if (typeof this.columnFilter.callbacks[callback] === 'function') {
                            this.$filterElm.autocomplete('instance')[callback] = this.columnFilter.callbacks[callback];
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            return this.$filterElm;
        };
        //
        // private functions
        // ------------------
        // this function should be PRIVATE but for unit tests purposes we'll make it public until a better solution is found
        // a better solution would be to get the autocomplete DOM element to work with selection but I couldn't find how to do that in Jest
        AutoCompleteFilter.prototype.onSelect = function (event, ui) {
            if (ui && ui.item) {
                var item = ui.item;
                // when the user defines a "renderItem" (or "_renderItem") template, then we assume the user defines his own custom structure of label/value pair
                // otherwise we know that jQueryUI always require a label/value pair, we can pull them directly
                var hasCustomRenderItemCallback = this.columnFilter && this.columnFilter.callbacks && this.columnFilter.callbacks.hasOwnProperty('_renderItem') || (this.columnFilter && this.columnFilter.filterOptions && this.columnFilter.filterOptions.renderItem) || false;
                var itemLabel = typeof item === 'string' ? item : (hasCustomRenderItemCallback ? item[this.labelName] : item.label);
                var itemValue = typeof item === 'string' ? item : (hasCustomRenderItemCallback ? item[this.valueName] : item.value);
                this.setValues(itemLabel);
                itemValue === '' ? this.$filterElm.removeClass('filled') : this.$filterElm.addClass('filled');
                this.callback(event, { columnDef: this.columnDef, operator: this.operator, searchTerms: [itemValue], shouldTriggerQuery: this._shouldTriggerQuery });
                // reset both flags for next use
                this._clearFilterTriggered = false;
                this._shouldTriggerQuery = true;
            }
            return false;
        };
        AutoCompleteFilter.prototype.renderCustomItem = function (ul, item) {
            var templateString = this._autoCompleteOptions && this._autoCompleteOptions.renderItem && this._autoCompleteOptions.renderItem.templateCallback(item) || '';
            // sanitize any unauthorized html tags like script and others
            // for the remaining allowed tags we'll permit all attributes
            var sanitizedTemplateText = (DOMPurify.sanitize(templateString, {}) || '').toString();
            return $('<li></li>')
                .data('item.autocomplete', item)
                .append(sanitizedTemplateText)
                .appendTo(ul);
        };
        AutoCompleteFilter.prototype.renderCollectionItem = function (ul, item) {
            var isRenderHtmlEnabled = this.columnFilter && this.columnFilter.enableRenderHtml || false;
            var prefixText = item.labelPrefix || '';
            var labelText = item.label || '';
            var suffixText = item.labelSuffix || '';
            var finalText = prefixText + labelText + suffixText;
            // sanitize any unauthorized html tags like script and others
            // for the remaining allowed tags we'll permit all attributes
            var sanitizedText = (DOMPurify.sanitize(finalText, {}) || '').toString();
            var $liDiv = $('<div></div>')[isRenderHtmlEnabled ? 'html' : 'text'](sanitizedText);
            return $('<li></li>')
                .data('item.autocomplete', item)
                .append($liDiv)
                .appendTo(ul);
        };
        AutoCompleteFilter.ctorParameters = function () { return [
            { type: core$1.TranslateService },
            { type: CollectionService }
        ]; };
        AutoCompleteFilter = __decorate([
            core.Injectable()
        ], AutoCompleteFilter);
        return AutoCompleteFilter;
    }());

    function buildSelectOperatorHtmlString(optionValues) {
        var optionValueString = '';
        optionValues.forEach(function (option) {
            optionValueString += "<option value=\"" + option.operator + "\">" + htmlEncodedStringWithPadding(option.operator, 3) + option.description + "</option>";
        });
        return "<select class=\"form-control\">" + optionValueString + "</select>";
    }

    require('flatpickr');
    var CompoundDateFilter = /** @class */ (function () {
        function CompoundDateFilter(translate) {
            this.translate = translate;
            this._clearFilterTriggered = false;
            this._shouldTriggerQuery = true;
        }
        Object.defineProperty(CompoundDateFilter.prototype, "gridOptions", {
            /** Getter for the Grid Options pulled through the Grid Object */
            get: function () {
                return (this.grid && this.grid.getOptions) ? this.grid.getOptions() : {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CompoundDateFilter.prototype, "columnFilter", {
            /** Getter for the Column Filter */
            get: function () {
                return this.columnDef && this.columnDef.filter || {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CompoundDateFilter.prototype, "currentDate", {
            /** Getter for the Current Dates selected */
            get: function () {
                return this._currentDate;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CompoundDateFilter.prototype, "defaultOperator", {
            /** Getter to know what would be the default operator when none is specified */
            get: function () {
                return exports.OperatorType.empty;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CompoundDateFilter.prototype, "flatpickrOptions", {
            /** Getter for the Flatpickr Options */
            get: function () {
                return this._flatpickrOptions || {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CompoundDateFilter.prototype, "locales", {
            /** Getter for the single Locale texts provided by the user in main file or else use default English locales via the Constants */
            get: function () {
                return this.gridOptions.locales || Constants.locales;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CompoundDateFilter.prototype, "operator", {
            /** Getter for the Filter Operator */
            get: function () {
                return this._operator || this.columnFilter.operator || this.defaultOperator;
            },
            /** Setter for the Filter Operator */
            set: function (op) {
                this._operator = op;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Initialize the Filter
         */
        CompoundDateFilter.prototype.init = function (args) {
            var _this = this;
            if (!args) {
                throw new Error('[Angular-SlickGrid] A filter must always have an "init()" with valid arguments.');
            }
            this.grid = args.grid;
            this.callback = args.callback;
            this.columnDef = args.columnDef;
            this.operator = args.operator || '';
            this.searchTerms = (args.hasOwnProperty('searchTerms') ? args.searchTerms : []) || [];
            // date input can only have 1 search term, so we will use the 1st array index if it exist
            var searchTerm = (Array.isArray(this.searchTerms) && this.searchTerms.length >= 0) ? this.searchTerms[0] : '';
            // step 1, create the DOM Element of the filter which contain the compound Operator+Input
            // and initialize it if searchTerm is filled
            this.$filterElm = this.createDomElement(searchTerm);
            // step 3, subscribe to the keyup event and run the callback when that happens
            // also add/remove "filled" class for styling purposes
            this.$filterInputElm.keyup(function (e) {
                _this.onTriggerEvent(e);
            });
            this.$selectOperatorElm.change(function (e) {
                _this.onTriggerEvent(e);
            });
        };
        /**
         * Clear the filter value
         */
        CompoundDateFilter.prototype.clear = function (shouldTriggerQuery) {
            if (shouldTriggerQuery === void 0) { shouldTriggerQuery = true; }
            if (this.flatInstance && this.$selectOperatorElm) {
                this._clearFilterTriggered = true;
                this._shouldTriggerQuery = shouldTriggerQuery;
                this.searchTerms = [];
                this.$selectOperatorElm.val(0);
                this.flatInstance.clear();
            }
        };
        /**
         * destroy the filter
         */
        CompoundDateFilter.prototype.destroy = function () {
            if (this.flatInstance && typeof this.flatInstance.destroy === 'function') {
                this.flatInstance.destroy();
                if (this.flatInstance.element) {
                    destroyObjectDomElementProps(this.flatInstance);
                }
                this.flatInstance = null;
            }
            if (this.$filterElm) {
                this.$filterElm.off('keyup').remove();
            }
            if (this.$selectOperatorElm) {
                this.$selectOperatorElm.off('change').remove();
            }
            this.$filterElm = null;
            this.callback = null;
            this.onTriggerEvent = null;
        };
        CompoundDateFilter.prototype.hide = function () {
            if (this.flatInstance && typeof this.flatInstance.close === 'function') {
                this.flatInstance.close();
            }
        };
        CompoundDateFilter.prototype.show = function () {
            if (this.flatInstance && typeof this.flatInstance.open === 'function') {
                this.flatInstance.open();
            }
        };
        /** Set value(s) in the DOM element, we can optionally pass an operator and/or trigger a change event */
        CompoundDateFilter.prototype.setValues = function (values, operator) {
            if (this.flatInstance && values) {
                var newValue = Array.isArray(values) ? values[0] : values;
                this._currentDate = newValue;
                this.flatInstance.setDate(newValue);
            }
            // set the operator, in the DOM as well, when defined
            this.operator = operator || this.defaultOperator;
            if (operator && this.$selectOperatorElm) {
                var operatorShorthand = mapOperatorToShorthandDesignation(this.operator);
                this.$selectOperatorElm.val(operatorShorthand);
            }
        };
        //
        // private functions
        // ------------------
        CompoundDateFilter.prototype.buildDatePickerInput = function (searchTerm) {
            var _this = this;
            var inputFormat = mapFlatpickrDateFormatWithFieldType(this.columnFilter.type || this.columnDef.type || exports.FieldType.dateIso);
            var outputFormat = mapFlatpickrDateFormatWithFieldType(this.columnDef.outputType || this.columnFilter.type || this.columnDef.type || exports.FieldType.dateUtc);
            var userFilterOptions = (this.columnFilter && this.columnFilter.filterOptions || {});
            // get current locale, if user defined a custom locale just use or get it the Translate Service if it exist else just use English
            var currentLocale = (userFilterOptions && userFilterOptions.locale) || (this.translate && this.translate.currentLang) || this.gridOptions.locale || 'en';
            if (currentLocale && currentLocale.length > 2) {
                currentLocale = currentLocale.substring(0, 2);
            }
            // if we are preloading searchTerms, we'll keep them for reference
            if (searchTerm) {
                this._currentDate = searchTerm;
            }
            var pickerOptions = {
                defaultDate: searchTerm || '',
                altInput: true,
                altFormat: outputFormat,
                dateFormat: inputFormat,
                wrap: true,
                closeOnSelect: true,
                locale: (currentLocale !== 'en') ? this.loadFlatpickrLocale(currentLocale) : 'en',
                onChange: function (selectedDates, dateStr) {
                    _this._currentValue = dateStr;
                    _this._currentDate = Array.isArray(selectedDates) && selectedDates[0];
                    // when using the time picker, we can simulate a keyup event to avoid multiple backend request
                    // since backend request are only executed after user start typing, changing the time should be treated the same way
                    var customEvent;
                    if (pickerOptions.enableTime) {
                        customEvent = new CustomEvent('keyup');
                    }
                    _this.onTriggerEvent(customEvent);
                }
            };
            // add the time picker when format is UTC (Z) or has the 'h' (meaning hours)
            if (outputFormat && (outputFormat === 'Z' || outputFormat.toLowerCase().includes('h'))) {
                pickerOptions.enableTime = true;
            }
            // merge options with optional user's custom options
            this._flatpickrOptions = __assign({}, pickerOptions, userFilterOptions);
            var placeholder = (this.gridOptions) ? (this.gridOptions.defaultFilterPlaceholder || '') : '';
            if (this.columnFilter && this.columnFilter.placeholder) {
                placeholder = this.columnFilter.placeholder;
            }
            var $filterInputElm = $("<div class=\"flatpickr\"><input type=\"text\" class=\"form-control\" data-input placeholder=\"" + placeholder + "\"></div>");
            this.flatInstance = ($filterInputElm[0] && typeof $filterInputElm[0].flatpickr === 'function') ? $filterInputElm[0].flatpickr(this._flatpickrOptions) : Flatpickr__default__default($filterInputElm, this._flatpickrOptions);
            return $filterInputElm;
        };
        CompoundDateFilter.prototype.getOptionValues = function () {
            return [
                { operator: '', description: '' },
                { operator: '=', description: this.getOutputText('EQUAL_TO', 'TEXT_EQUAL_TO', 'Equal to') },
                { operator: '<', description: this.getOutputText('LESS_THAN', 'TEXT_LESS_THAN', 'Less than') },
                { operator: '<=', description: this.getOutputText('LESS_THAN_OR_EQUAL_TO', 'TEXT_LESS_THAN_OR_EQUAL_TO', 'Less than or equal to') },
                { operator: '>', description: this.getOutputText('GREATER_THAN', 'TEXT_GREATER_THAN', 'Greater than') },
                { operator: '>=', description: this.getOutputText('GREATER_THAN_OR_EQUAL_TO', 'TEXT_GREATER_THAN_OR_EQUAL_TO', 'Greater than or equal to') },
                { operator: '<>', description: this.getOutputText('NOT_EQUAL_TO', 'TEXT_NOT_EQUAL_TO', 'Not equal to') }
            ];
        };
        /** Get Locale, Translated or a Default Text if first two aren't detected */
        CompoundDateFilter.prototype.getOutputText = function (translationKey, localeText, defaultText) {
            if (this.gridOptions && this.gridOptions.enableTranslate && this.translate && this.translate.instant) {
                var translationPrefix = getTranslationPrefix(this.gridOptions);
                return this.translate.instant("" + translationPrefix + translationKey);
            }
            return this.locales && this.locales[localeText] || defaultText;
        };
        /**
         * Create the DOM element
         */
        CompoundDateFilter.prototype.createDomElement = function (searchTerm) {
            var fieldId = this.columnDef && this.columnDef.id;
            var $headerElm = this.grid.getHeaderRowColumn(fieldId);
            $($headerElm).empty();
            // create the DOM Select dropdown for the Operator
            var selectOperatorHtmlString = buildSelectOperatorHtmlString(this.getOptionValues());
            this.$selectOperatorElm = $(selectOperatorHtmlString);
            this.$filterInputElm = this.buildDatePickerInput(searchTerm);
            var $filterContainerElm = $("<div class=\"form-group search-filter filter-" + fieldId + "\"></div>");
            var $containerInputGroup = $("<div class=\"input-group flatpickr\"></div>");
            var $operatorInputGroupAddon = $("<div class=\"input-group-addon input-group-prepend operator\"></div>");
            /* the DOM element final structure will be
              <div class="input-group">
                <div class="input-group-addon input-group-prepend operator">
                  <select class="form-control"></select>
                </div>
                <div class=flatpickr>
                  <input type="text" class="form-control" data-input>
                </div>
              </div>
            */
            $operatorInputGroupAddon.append(this.$selectOperatorElm);
            $containerInputGroup.append($operatorInputGroupAddon);
            $containerInputGroup.append(this.$filterInputElm);
            // create the DOM element & add an ID and filter class
            $filterContainerElm.append($containerInputGroup);
            this.$filterInputElm.data('columnId', fieldId);
            if (this.operator) {
                var operatorShorthand = mapOperatorToShorthandDesignation(this.operator);
                this.$selectOperatorElm.val(operatorShorthand);
            }
            // if there's a search term, we will add the "filled" class for styling purposes
            if (searchTerm && searchTerm !== '') {
                this.$filterInputElm.addClass('filled');
                this._currentDate = searchTerm;
                this._currentValue = searchTerm;
            }
            // append the new DOM element to the header row
            if ($filterContainerElm && typeof $filterContainerElm.appendTo === 'function') {
                $filterContainerElm.appendTo($headerElm);
            }
            return $filterContainerElm;
        };
        /** Load a different set of locales for Flatpickr to be localized */
        CompoundDateFilter.prototype.loadFlatpickrLocale = function (language) {
            var locales = 'en';
            try {
                if (language !== 'en') {
                    // change locale if needed, Flatpickr reference: https://chmln.github.io/flatpickr/localization/
                    var localeDefault = require("flatpickr/dist/l10n/" + language + ".js").default;
                    locales = (localeDefault && localeDefault[language]) ? localeDefault[language] : 'en';
                }
            }
            catch (e) {
                console.warn("[Angular-Slickgrid - CompoundDate Filter] It seems that \"" + language + "\" is not a locale supported by Flatpickr, we will use \"en\" instead. "
                    + "To avoid seeing this message, you can specifically set \"filter: { filterOptions: { locale: 'en' } }\" in your column definition.");
                return 'en';
            }
            return locales;
        };
        CompoundDateFilter.prototype.onTriggerEvent = function (e) {
            if (this._clearFilterTriggered) {
                this.callback(e, { columnDef: this.columnDef, clearFilterTriggered: this._clearFilterTriggered, shouldTriggerQuery: this._shouldTriggerQuery });
                this.$filterElm.removeClass('filled');
            }
            else {
                var selectedOperator = this.$selectOperatorElm.find('option:selected').val();
                (this._currentValue) ? this.$filterElm.addClass('filled') : this.$filterElm.removeClass('filled');
                this.callback(e, { columnDef: this.columnDef, searchTerms: (this._currentValue ? [this._currentValue] : null), operator: selectedOperator || '', shouldTriggerQuery: this._shouldTriggerQuery });
            }
            // reset both flags for next use
            this._clearFilterTriggered = false;
            this._shouldTriggerQuery = true;
        };
        CompoundDateFilter = __decorate([
            __param(0, core.Optional())
        ], CompoundDateFilter);
        return CompoundDateFilter;
    }());

    var CompoundInputFilter = /** @class */ (function () {
        function CompoundInputFilter(translate) {
            this.translate = translate;
            this._clearFilterTriggered = false;
            this._shouldTriggerQuery = true;
            this._inputType = 'text';
        }
        Object.defineProperty(CompoundInputFilter.prototype, "columnFilter", {
            /** Getter for the Column Filter */
            get: function () {
                return this.columnDef && this.columnDef.filter || {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CompoundInputFilter.prototype, "defaultOperator", {
            /** Getter to know what would be the default operator when none is specified */
            get: function () {
                return exports.OperatorType.empty;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CompoundInputFilter.prototype, "gridOptions", {
            /** Getter for the Grid Options pulled through the Grid Object */
            get: function () {
                return (this.grid && this.grid.getOptions) ? this.grid.getOptions() : {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CompoundInputFilter.prototype, "inputType", {
            /** Getter of input type (text, number, password) */
            get: function () {
                return this._inputType;
            },
            /** Setter of input type (text, number, password) */
            set: function (type) {
                this._inputType = type;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CompoundInputFilter.prototype, "locales", {
            /** Getter for the single Locale texts provided by the user in main file or else use default English locales via the Constants */
            get: function () {
                return this.gridOptions.locales || Constants.locales;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CompoundInputFilter.prototype, "operator", {
            /** Getter of the Operator to use when doing the filter comparing */
            get: function () {
                return this._operator || this.defaultOperator;
            },
            /** Getter of the Operator to use when doing the filter comparing */
            set: function (op) {
                this._operator = op;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Initialize the Filter
         */
        CompoundInputFilter.prototype.init = function (args) {
            if (!args) {
                throw new Error('[Angular-SlickGrid] A filter must always have an "init()" with valid arguments.');
            }
            this.grid = args.grid;
            this.callback = args.callback;
            this.columnDef = args.columnDef;
            this.operator = args.operator;
            this.searchTerms = (args.hasOwnProperty('searchTerms') ? args.searchTerms : []) || [];
            // filter input can only have 1 search term, so we will use the 1st array index if it exist
            var searchTerm = (Array.isArray(this.searchTerms) && this.searchTerms.length >= 0) ? this.searchTerms[0] : '';
            // step 1, create the DOM Element of the filter which contain the compound Operator+Input
            // and initialize it if searchTerms is filled
            this.$filterElm = this.createDomElement(searchTerm);
            // step 3, subscribe to the input change event and run the callback when that happens
            // also add/remove "filled" class for styling purposes
            this.$filterInputElm.on('keyup input', this.onTriggerEvent.bind(this));
            this.$selectOperatorElm.on('change', this.onTriggerEvent.bind(this));
        };
        /**
         * Clear the filter value
         */
        CompoundInputFilter.prototype.clear = function (shouldTriggerQuery) {
            if (shouldTriggerQuery === void 0) { shouldTriggerQuery = true; }
            if (this.$filterElm && this.$selectOperatorElm) {
                this._clearFilterTriggered = true;
                this._shouldTriggerQuery = shouldTriggerQuery;
                this.searchTerms = [];
                this.$selectOperatorElm.val(0);
                this.$filterInputElm.val('');
                this.onTriggerEvent(null);
            }
        };
        /**
         * destroy the filter
         */
        CompoundInputFilter.prototype.destroy = function () {
            if (this.$filterElm && this.$selectOperatorElm) {
                this.$filterElm.off('keyup input').remove();
                this.$selectOperatorElm.off('change');
            }
            this.$filterElm = null;
            this.$selectOperatorElm = null;
            this.callback = null;
            this.onTriggerEvent = null;
        };
        /** Set value(s) on the DOM element */
        CompoundInputFilter.prototype.setValues = function (values, operator) {
            if (values) {
                var newValue = Array.isArray(values) ? values[0] : values;
                this.$filterInputElm.val(newValue);
            }
            // set the operator, in the DOM as well, when defined
            this.operator = operator || this.defaultOperator;
            if (operator && this.$selectOperatorElm) {
                var operatorShorthand = mapOperatorToShorthandDesignation(this.operator);
                this.$selectOperatorElm.val(operatorShorthand);
            }
        };
        //
        // private functions
        // ------------------
        CompoundInputFilter.prototype.buildInputHtmlString = function () {
            var placeholder = (this.gridOptions) ? (this.gridOptions.defaultFilterPlaceholder || '') : '';
            if (this.columnFilter && this.columnFilter.placeholder) {
                placeholder = this.columnFilter.placeholder;
            }
            return "<input type=\"" + (this._inputType || 'text') + "\" role=\"presentation\"  autocomplete=\"off\" class=\"form-control compound-input\" placeholder=\"" + placeholder + "\" /><span></span>";
        };
        CompoundInputFilter.prototype.getOptionValues = function () {
            var type = (this.columnDef.type && this.columnDef.type) ? this.columnDef.type : exports.FieldType.string;
            var optionValues = [];
            switch (type) {
                case exports.FieldType.string:
                case exports.FieldType.text:
                case exports.FieldType.readonly:
                case exports.FieldType.password:
                    optionValues = [
                        { operator: '', description: this.getOutputText('CONTAINS', 'TEXT_CONTAINS', 'Contains') },
                        { operator: '=', description: this.getOutputText('EQUALS', 'TEXT_EQUALS', 'Equals') },
                        { operator: 'a*', description: this.getOutputText('STARTS_WITH', 'TEXT_STARTS_WITH', 'Starts with') },
                        { operator: '*z', description: this.getOutputText('ENDS_WITH', 'TEXT_ENDS_WITH', 'Ends with') },
                    ];
                    break;
                default:
                    optionValues = [
                        { operator: '', description: '' },
                        { operator: '=', description: this.getOutputText('EQUAL_TO', 'TEXT_EQUAL_TO', 'Equal to') },
                        { operator: '<', description: this.getOutputText('LESS_THAN', 'TEXT_LESS_THAN', 'Less than') },
                        { operator: '<=', description: this.getOutputText('LESS_THAN_OR_EQUAL_TO', 'TEXT_LESS_THAN_OR_EQUAL_TO', 'Less than or equal to') },
                        { operator: '>', description: this.getOutputText('GREATER_THAN', 'TEXT_GREATER_THAN', 'Greater than') },
                        { operator: '>=', description: this.getOutputText('GREATER_THAN_OR_EQUAL_TO', 'TEXT_GREATER_THAN_OR_EQUAL_TO', 'Greater than or equal to') },
                        { operator: '<>', description: this.getOutputText('NOT_EQUAL_TO', 'TEXT_NOT_EQUAL_TO', 'Not equal to') }
                    ];
                    break;
            }
            return optionValues;
        };
        /** Get Locale, Translated or a Default Text if first two aren't detected */
        CompoundInputFilter.prototype.getOutputText = function (translationKey, localeText, defaultText) {
            if (this.gridOptions && this.gridOptions.enableTranslate && this.translate && this.translate.instant) {
                var translationPrefix = getTranslationPrefix(this.gridOptions);
                return this.translate.instant("" + translationPrefix + translationKey);
            }
            return this.locales && this.locales[localeText] || defaultText;
        };
        /**
         * Create the DOM element
         */
        CompoundInputFilter.prototype.createDomElement = function (searchTerm) {
            var fieldId = this.columnDef && this.columnDef.id;
            var $headerElm = this.grid.getHeaderRowColumn(fieldId);
            $($headerElm).empty();
            // create the DOM Select dropdown for the Operator
            var selectOperatorHtmlString = buildSelectOperatorHtmlString(this.getOptionValues());
            this.$selectOperatorElm = $(selectOperatorHtmlString);
            this.$filterInputElm = $(this.buildInputHtmlString());
            var $filterContainerElm = $("<div class=\"form-group search-filter filter-" + fieldId + "\"></div>");
            var $containerInputGroup = $("<div class=\"input-group\"></div>");
            var $operatorInputGroupAddon = $("<div class=\"input-group-addon input-group-prepend operator\"></div>");
            /* the DOM element final structure will be
              <div class="input-group">
                <div class="input-group-addon input-group-prepend operator">
                  <select class="form-control"></select>
                </div>
                <input class="form-control compount-input" type="text" />
              </div>
            */
            $operatorInputGroupAddon.append(this.$selectOperatorElm);
            $containerInputGroup.append($operatorInputGroupAddon);
            $containerInputGroup.append(this.$filterInputElm);
            // create the DOM element & add an ID and filter class
            $filterContainerElm.append($containerInputGroup);
            this.$filterInputElm.val(searchTerm);
            this.$filterInputElm.data('columnId', fieldId);
            if (this.operator) {
                var operatorShorthand = mapOperatorToShorthandDesignation(this.operator);
                this.$selectOperatorElm.val(operatorShorthand);
            }
            // if there's a search term, we will add the "filled" class for styling purposes
            if (searchTerm) {
                $filterContainerElm.addClass('filled');
            }
            // append the new DOM element to the header row
            if ($filterContainerElm && typeof $filterContainerElm.appendTo === 'function') {
                $filterContainerElm.appendTo($headerElm);
            }
            return $filterContainerElm;
        };
        CompoundInputFilter.prototype.onTriggerEvent = function (e) {
            // we'll use the "input" event for everything (keyup, change, mousewheel & spinner)
            // with 1 small exception, we need to use the keyup event to handle ENTER key, everything will be processed by the "input" event
            if (e && e.type === 'keyup' && e.key !== 'Enter') {
                return;
            }
            if (this._clearFilterTriggered) {
                this.callback(e, { columnDef: this.columnDef, clearFilterTriggered: this._clearFilterTriggered, shouldTriggerQuery: this._shouldTriggerQuery });
                this.$filterElm.removeClass('filled');
            }
            else {
                var selectedOperator = this.$selectOperatorElm.find('option:selected').val();
                var value = this.$filterInputElm.val();
                var enableWhiteSpaceTrim = this.gridOptions.enableFilterTrimWhiteSpace || this.columnFilter.enableTrimWhiteSpace;
                if (typeof value === 'string' && enableWhiteSpaceTrim) {
                    value = value.trim();
                }
                (value !== null && value !== undefined && value !== '') ? this.$filterElm.addClass('filled') : this.$filterElm.removeClass('filled');
                this.callback(e, { columnDef: this.columnDef, searchTerms: (value ? [value] : null), operator: selectedOperator || '', shouldTriggerQuery: this._shouldTriggerQuery });
            }
            // reset both flags for next use
            this._clearFilterTriggered = false;
            this._shouldTriggerQuery = true;
        };
        return CompoundInputFilter;
    }());

    var CompoundInputNumberFilter = /** @class */ (function (_super) {
        __extends(CompoundInputNumberFilter, _super);
        /** Initialize the Filter */
        function CompoundInputNumberFilter(translate) {
            var _this = _super.call(this, translate) || this;
            _this.translate = translate;
            _this.inputType = 'number';
            return _this;
        }
        return CompoundInputNumberFilter;
    }(CompoundInputFilter));

    var CompoundInputPasswordFilter = /** @class */ (function (_super) {
        __extends(CompoundInputPasswordFilter, _super);
        /** Initialize the Filter */
        function CompoundInputPasswordFilter(translate) {
            var _this = _super.call(this, translate) || this;
            _this.translate = translate;
            _this.inputType = 'password';
            return _this;
        }
        return CompoundInputPasswordFilter;
    }(CompoundInputFilter));

    var DEFAULT_MIN_VALUE = 0;
    var DEFAULT_MAX_VALUE = 100;
    var DEFAULT_STEP = 1;
    var CompoundSliderFilter = /** @class */ (function () {
        function CompoundSliderFilter(translate) {
            this.translate = translate;
            this._clearFilterTriggered = false;
            this._shouldTriggerQuery = true;
        }
        Object.defineProperty(CompoundSliderFilter.prototype, "columnFilter", {
            /** Getter for the Filter Operator */
            get: function () {
                return this.columnDef && this.columnDef.filter || {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CompoundSliderFilter.prototype, "defaultOperator", {
            /** Getter to know what would be the default operator when none is specified */
            get: function () {
                return exports.OperatorType.empty;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CompoundSliderFilter.prototype, "filterParams", {
            /** Getter for the Filter Generic Params */
            get: function () {
                return this.columnDef && this.columnDef.filter && this.columnDef.filter.params || {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CompoundSliderFilter.prototype, "filterProperties", {
            /** Getter for the `filter` properties */
            get: function () {
                return this.columnDef && this.columnDef.filter;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CompoundSliderFilter.prototype, "gridOptions", {
            /** Getter for the Grid Options pulled through the Grid Object */
            get: function () {
                return (this.grid && this.grid.getOptions) ? this.grid.getOptions() : {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CompoundSliderFilter.prototype, "locales", {
            /** Getter for the single Locale texts provided by the user in main file or else use default English locales via the Constants */
            get: function () {
                return this.gridOptions.locales || Constants.locales;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CompoundSliderFilter.prototype, "operator", {
            /** Getter for the Filter Operator */
            get: function () {
                return this._operator || this.columnFilter.operator || this.defaultOperator;
            },
            /** Setter for the Filter Operator */
            set: function (op) {
                this._operator = op;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Initialize the Filter
         */
        CompoundSliderFilter.prototype.init = function (args) {
            var _this = this;
            if (!args) {
                throw new Error('[Angular-SlickGrid] A filter must always have an "init()" with valid arguments.');
            }
            this.grid = args.grid;
            this.callback = args.callback;
            this.columnDef = args.columnDef;
            this.operator = args.operator || '';
            this.searchTerms = (args.hasOwnProperty('searchTerms') ? args.searchTerms : []) || [];
            // define the input & slider number IDs
            this._elementRangeInputId = "rangeInput_" + this.columnDef.field;
            this._elementRangeOutputId = "rangeOutput_" + this.columnDef.field;
            // filter input can only have 1 search term, so we will use the 1st array index if it exist
            var searchTerm = (Array.isArray(this.searchTerms) && this.searchTerms.length >= 0) ? this.searchTerms[0] : '';
            // step 1, create the DOM Element of the filter which contain the compound Operator+Input
            // and initialize it if searchTerm is filled
            this.$filterElm = this.createDomElement(searchTerm);
            // step 3, subscribe to the input change event and run the callback when that happens
            // also add/remove "filled" class for styling purposes
            this.$filterInputElm.on('change', this.onTriggerEvent.bind(this));
            this.$selectOperatorElm.on('change', this.onTriggerEvent.bind(this));
            // if user chose to display the slider number on the right side, then update it every time it changes
            // we need to use both "input" and "change" event to be all cross-browser
            if (!this.filterParams.hideSliderNumber) {
                this.$filterInputElm.on('input change', function (e) {
                    var value = e && e.target && e.target.value || '';
                    if (value) {
                        var elements = document.getElementsByClassName(_this._elementRangeOutputId);
                        if (elements.length) {
                            elements[0].innerHTML = value;
                        }
                    }
                });
            }
        };
        /**
         * Clear the filter value
         */
        CompoundSliderFilter.prototype.clear = function (shouldTriggerQuery) {
            if (shouldTriggerQuery === void 0) { shouldTriggerQuery = true; }
            if (this.$filterElm && this.$selectOperatorElm) {
                this._clearFilterTriggered = true;
                this._shouldTriggerQuery = shouldTriggerQuery;
                this.searchTerms = [];
                var clearedValue = this.filterParams.hasOwnProperty('sliderStartValue') ? this.filterParams.sliderStartValue : DEFAULT_MIN_VALUE;
                this._currentValue = +clearedValue;
                this.$selectOperatorElm.val(0);
                this.$filterInputElm.val(clearedValue);
                if (!this.filterParams.hideSliderNumber) {
                    this.$containerInputGroupElm.children('div.input-group-addon.input-group-append').children().last().html(clearedValue);
                }
                this.onTriggerEvent(undefined);
                this.$filterElm.removeClass('filled');
            }
        };
        /**
         * destroy the filter
         */
        CompoundSliderFilter.prototype.destroy = function () {
            if (this.$filterInputElm) {
                this.$filterInputElm.off('input change').remove();
                this.$selectOperatorElm.off('change').remove();
            }
            this.$filterInputElm = null;
            this.$filterElm = null;
            this.$selectOperatorElm = null;
            this.callback = null;
            this.onTriggerEvent = null;
        };
        /**
         * Get selected value retrieved from the slider element
         * @params selected items
         */
        CompoundSliderFilter.prototype.getValues = function () {
            return this._currentValue;
        };
        /** Set value(s) on the DOM element */
        CompoundSliderFilter.prototype.setValues = function (values, operator) {
            var newValue = Array.isArray(values) ? values[0] : values;
            this._currentValue = +newValue;
            this.$filterInputElm.val(newValue);
            this.$containerInputGroupElm.children('div.input-group-addon.input-group-append').children().last().html(newValue);
            // set the operator, in the DOM as well, when defined
            this.operator = operator || this.defaultOperator;
            if (operator && this.$selectOperatorElm) {
                var operatorShorthand = mapOperatorToShorthandDesignation(this.operator);
                this.$selectOperatorElm.val(operatorShorthand);
            }
        };
        //
        // private functions
        // ------------------
        /** Build HTML Template for the input range (slider) */
        CompoundSliderFilter.prototype.buildTemplateHtmlString = function () {
            var minValue = this.filterProperties.hasOwnProperty('minValue') ? this.filterProperties.minValue : DEFAULT_MIN_VALUE;
            var maxValue = this.filterProperties.hasOwnProperty('maxValue') ? this.filterProperties.maxValue : DEFAULT_MAX_VALUE;
            var defaultValue = this.filterParams.hasOwnProperty('sliderStartValue') ? this.filterParams.sliderStartValue : minValue;
            var step = this.filterProperties.hasOwnProperty('valueStep') ? this.filterProperties.valueStep : DEFAULT_STEP;
            return "<input type=\"range\" name=\"" + this._elementRangeInputId + "\"\n              defaultValue=\"" + defaultValue + "\" min=\"" + minValue + "\" max=\"" + maxValue + "\" step=\"" + step + "\"\n              class=\"form-control slider-filter-input range compound-slider " + this._elementRangeInputId + "\" />";
        };
        /** Build HTML Template for the text (number) that is shown appended to the slider */
        CompoundSliderFilter.prototype.buildTemplateSliderTextHtmlString = function () {
            var minValue = this.filterProperties.hasOwnProperty('minValue') ? this.filterProperties.minValue : DEFAULT_MIN_VALUE;
            var defaultValue = this.filterParams.hasOwnProperty('sliderStartValue') ? this.filterParams.sliderStartValue : minValue;
            return "<div class=\"input-group-addon input-group-append slider-value\"><span class=\"input-group-text " + this._elementRangeOutputId + "\">" + defaultValue + "</span></div>";
        };
        /** Get the available operator option values */
        CompoundSliderFilter.prototype.getOptionValues = function () {
            return [
                { operator: '', description: '' },
                { operator: '=', description: this.getOutputText('EQUAL_TO', 'TEXT_EQUAL_TO', 'Equal to') },
                { operator: '<', description: this.getOutputText('LESS_THAN', 'TEXT_LESS_THAN', 'Less than') },
                { operator: '<=', description: this.getOutputText('LESS_THAN_OR_EQUAL_TO', 'TEXT_LESS_THAN_OR_EQUAL_TO', 'Less than or equal to') },
                { operator: '>', description: this.getOutputText('GREATER_THAN', 'TEXT_GREATER_THAN', 'Greater than') },
                { operator: '>=', description: this.getOutputText('GREATER_THAN_OR_EQUAL_TO', 'TEXT_GREATER_THAN_OR_EQUAL_TO', 'Greater than or equal to') },
                { operator: '<>', description: this.getOutputText('NOT_EQUAL_TO', 'TEXT_NOT_EQUAL_TO', 'Not equal to') }
            ];
        };
        /** Get Locale, Translated or a Default Text if first two aren't detected */
        CompoundSliderFilter.prototype.getOutputText = function (translationKey, localeText, defaultText) {
            if (this.gridOptions && this.gridOptions.enableTranslate && this.translate && this.translate.instant) {
                var translationPrefix = getTranslationPrefix(this.gridOptions);
                return this.translate.instant("" + translationPrefix + translationKey);
            }
            return this.locales && this.locales[localeText] || defaultText;
        };
        /**
         * Create the DOM element
         */
        CompoundSliderFilter.prototype.createDomElement = function (searchTerm) {
            var fieldId = this.columnDef && this.columnDef.id;
            var minValue = this.filterProperties.hasOwnProperty('minValue') ? this.filterProperties.minValue : DEFAULT_MIN_VALUE;
            var startValue = this.filterParams.hasOwnProperty('sliderStartValue') ? this.filterParams.sliderStartValue : minValue;
            var $headerElm = this.grid.getHeaderRowColumn(this.columnDef.id);
            $($headerElm).empty();
            var searchTermInput = (searchTerm || '0');
            if (+searchTermInput < minValue) {
                searchTermInput = "" + minValue;
            }
            if (+searchTermInput < startValue) {
                searchTermInput = "" + startValue;
            }
            this._currentValue = +searchTermInput;
            // create the DOM Select dropdown for the Operator
            var selectOperatorHtmlString = buildSelectOperatorHtmlString(this.getOptionValues());
            this.$selectOperatorElm = $(selectOperatorHtmlString);
            this.$filterInputElm = $(this.buildTemplateHtmlString());
            var $filterContainerElm = $("<div class=\"form-group slider-container search-filter filter-" + fieldId + "\"></div>");
            this.$containerInputGroupElm = $("<div class=\"input-group search-filter filter-" + fieldId + "\"></div>");
            var $operatorInputGroupAddon = $("<span class=\"input-group-addon input-group-prepend operator\"></span>");
            /* the DOM element final structure will be
              <div class="input-group">
                <div class="input-group-addon input-group-prepend operator">
                  <select class="form-control"></select>
                </div>
                <input class="form-control" type="text" />
                <div class="input-group-addon input-group-prepend rangeOuput_percentComplete"><span class="input-group-text">0</span></div>
              </div>
            */
            $operatorInputGroupAddon.append(this.$selectOperatorElm);
            this.$containerInputGroupElm.append($operatorInputGroupAddon);
            this.$containerInputGroupElm.append(this.$filterInputElm);
            if (!this.filterParams.hideSliderNumber) {
                var $sliderTextInputAppendAddon = $(this.buildTemplateSliderTextHtmlString());
                $sliderTextInputAppendAddon.children().html(searchTermInput);
                this.$containerInputGroupElm.append($sliderTextInputAppendAddon);
            }
            // create the DOM element & add an ID and filter class
            $filterContainerElm.append(this.$containerInputGroupElm);
            this.$filterInputElm.val(searchTermInput);
            this.$filterInputElm.data('columnId', fieldId);
            if (this.operator) {
                var operatorShorthand = mapOperatorToShorthandDesignation(this.operator);
                this.$selectOperatorElm.val(operatorShorthand);
            }
            // if there's a search term, we will add the "filled" class for styling purposes
            if (searchTerm !== '') {
                $filterContainerElm.addClass('filled');
            }
            // append the new DOM element to the header row
            if ($filterContainerElm && typeof $filterContainerElm.appendTo === 'function') {
                $filterContainerElm.appendTo($headerElm);
            }
            return $filterContainerElm;
        };
        CompoundSliderFilter.prototype.onTriggerEvent = function (e) {
            var value = this.$filterInputElm.val();
            this._currentValue = +value;
            if (this._clearFilterTriggered) {
                this.$filterElm.removeClass('filled');
                this.callback(e, { columnDef: this.columnDef, clearFilterTriggered: this._clearFilterTriggered, shouldTriggerQuery: this._shouldTriggerQuery });
            }
            else {
                this.$filterElm.addClass('filled');
                var selectedOperator = this.$selectOperatorElm.find('option:selected').val();
                this.callback(e, { columnDef: this.columnDef, searchTerms: (value ? [value || '0'] : null), operator: selectedOperator || '', shouldTriggerQuery: this._shouldTriggerQuery });
            }
            // reset both flags for next use
            this._clearFilterTriggered = false;
            this._shouldTriggerQuery = true;
        };
        return CompoundSliderFilter;
    }());

    var InputFilter = /** @class */ (function () {
        function InputFilter() {
            this._clearFilterTriggered = false;
            this._shouldTriggerQuery = true;
            this._inputType = 'text';
        }
        Object.defineProperty(InputFilter.prototype, "columnFilter", {
            /** Getter for the Column Filter */
            get: function () {
                return this.columnDef && this.columnDef.filter || {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InputFilter.prototype, "defaultOperator", {
            /** Getter to know what would be the default operator when none is specified */
            get: function () {
                return exports.OperatorType.empty;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InputFilter.prototype, "inputType", {
            /** Getter of input type (text, number, password) */
            get: function () {
                return this._inputType;
            },
            /** Setter of input type (text, number, password) */
            set: function (type) {
                this._inputType = type;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InputFilter.prototype, "operator", {
            /** Getter of the Operator to use when doing the filter comparing */
            get: function () {
                return this.columnFilter && this.columnFilter.operator || this.defaultOperator;
            },
            /** Setter for the filter operator */
            set: function (operator) {
                if (this.columnFilter) {
                    this.columnFilter.operator = operator;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InputFilter.prototype, "gridOptions", {
            /** Getter for the Grid Options pulled through the Grid Object */
            get: function () {
                return (this.grid && this.grid.getOptions) ? this.grid.getOptions() : {};
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Initialize the Filter
         */
        InputFilter.prototype.init = function (args) {
            if (!args) {
                throw new Error('[Angular-SlickGrid] A filter must always have an "init()" with valid arguments.');
            }
            this.grid = args.grid;
            this.callback = args.callback;
            this.columnDef = args.columnDef;
            this.searchTerms = (args.hasOwnProperty('searchTerms') ? args.searchTerms : []) || [];
            // filter input can only have 1 search term, so we will use the 1st array index if it exist
            var searchTerm = (Array.isArray(this.searchTerms) && this.searchTerms.length >= 0) ? this.searchTerms[0] : '';
            // step 1, create HTML string template
            var filterTemplate = this.buildTemplateHtmlString();
            // step 2, create the DOM Element of the filter & initialize it if searchTerm is filled
            this.$filterElm = this.createDomElement(filterTemplate, searchTerm);
            // step 3, subscribe to the input change event and run the callback when that happens
            // also add/remove "filled" class for styling purposes
            this.$filterElm.on('keyup input', this.handleInputChange.bind(this));
        };
        /**
         * Clear the filter value
         */
        InputFilter.prototype.clear = function (shouldTriggerQuery) {
            if (shouldTriggerQuery === void 0) { shouldTriggerQuery = true; }
            if (this.$filterElm) {
                this._clearFilterTriggered = true;
                this._shouldTriggerQuery = shouldTriggerQuery;
                this.searchTerms = [];
                this.$filterElm.val('');
                this.$filterElm.trigger('input');
            }
        };
        /**
         * destroy the filter
         */
        InputFilter.prototype.destroy = function () {
            if (this.$filterElm) {
                this.$filterElm.off('keyup input').remove();
            }
            this.$filterElm = null;
            this.callback = null;
        };
        /** Set value(s) on the DOM element */
        InputFilter.prototype.setValues = function (values, operator) {
            if (values) {
                this.$filterElm.val(values);
            }
            // set the operator when defined
            this.operator = operator || this.defaultOperator;
        };
        //
        // protected functions
        // ------------------
        /**
         * Create the HTML template as a string
         */
        InputFilter.prototype.buildTemplateHtmlString = function () {
            var fieldId = this.columnDef && this.columnDef.id;
            var placeholder = (this.gridOptions) ? (this.gridOptions.defaultFilterPlaceholder || '') : '';
            if (this.columnFilter && this.columnFilter.placeholder) {
                placeholder = this.columnFilter.placeholder;
            }
            return "<input type=\"" + (this._inputType || 'text') + "\" role=\"presentation\" autocomplete=\"off\" class=\"form-control search-filter filter-" + fieldId + "\" placeholder=\"" + placeholder + "\"><span></span>";
        };
        /**
         * From the html template string, create a DOM element
         * @param filterTemplate
         */
        InputFilter.prototype.createDomElement = function (filterTemplate, searchTerm) {
            var fieldId = this.columnDef && this.columnDef.id;
            var $headerElm = this.grid.getHeaderRowColumn(fieldId);
            $($headerElm).empty();
            // create the DOM element & add an ID and filter class
            var $filterElm = $(filterTemplate);
            $filterElm.val(searchTerm);
            $filterElm.data('columnId', fieldId);
            // if there's a search term, we will add the "filled" class for styling purposes
            if (searchTerm) {
                $filterElm.addClass('filled');
            }
            // append the new DOM element to the header row
            if ($filterElm && typeof $filterElm.appendTo === 'function') {
                $filterElm.appendTo($headerElm);
            }
            return $filterElm;
        };
        InputFilter.prototype.handleInputChange = function (e) {
            // we'll use the "input" event for everything (keyup, change, mousewheel & spinner)
            // with 1 small exception, we need to use the keyup event to handle ENTER key, everything will be processed by the "input" event
            if (e && e.type === 'keyup' && e.key !== 'Enter') {
                return;
            }
            var value = e && e.target && e.target.value || '';
            var enableWhiteSpaceTrim = this.gridOptions.enableFilterTrimWhiteSpace || this.columnFilter.enableTrimWhiteSpace;
            if (typeof value === 'string' && enableWhiteSpaceTrim) {
                value = value.trim();
            }
            if (this._clearFilterTriggered) {
                this.callback(e, { columnDef: this.columnDef, clearFilterTriggered: this._clearFilterTriggered, shouldTriggerQuery: this._shouldTriggerQuery });
                this.$filterElm.removeClass('filled');
            }
            else {
                value === '' ? this.$filterElm.removeClass('filled') : this.$filterElm.addClass('filled');
                this.callback(e, { columnDef: this.columnDef, operator: this.operator, searchTerms: [value], shouldTriggerQuery: this._shouldTriggerQuery });
            }
            // reset both flags for next use
            this._clearFilterTriggered = false;
            this._shouldTriggerQuery = true;
        };
        return InputFilter;
    }());

    var InputMaskFilter = /** @class */ (function (_super) {
        __extends(InputMaskFilter, _super);
        /** Initialize the Filter */
        function InputMaskFilter() {
            var _this = _super.call(this) || this;
            _this.inputType = 'text';
            return _this;
        }
        Object.defineProperty(InputMaskFilter.prototype, "inputMask", {
            /** Getter of the input mask, when provided */
            get: function () {
                return this._inputMask;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Override the Filter init used by SlickGrid
         */
        InputMaskFilter.prototype.init = function (args) {
            var _this = this;
            if (!args) {
                throw new Error('[Angular-SlickGrid] A filter must always have an "init()" with valid arguments.');
            }
            this.grid = args.grid;
            this.callback = args.callback;
            this.columnDef = args.columnDef;
            this.searchTerms = (args.hasOwnProperty('searchTerms') ? args.searchTerms : []) || [];
            // get input mask from params (can be in columnDef or columnFilter params)
            if (this.columnDef && this.columnDef.params && this.columnDef.params.mask) {
                this._inputMask = this.columnDef.params.mask;
            }
            else if (this.columnFilter && this.columnFilter.params && this.columnFilter.params.mask) {
                this._inputMask = this.columnFilter.params.mask;
            }
            if (!this._inputMask) {
                throw new Error("[Angular-Slickgrid] The Filters.inputMask requires the mask to be passed in the filter params or the column definition params\n        for example:: this.columnDefinitions: [{ id: 'phone', field: 'phone', filter: { model: Filters.inputMask, params: { mask: '000-000-0000' }}}]");
            }
            // filter input can only have 1 search term, so we will use the 1st array index if it exist
            var searchTerm = (Array.isArray(this.searchTerms) && this.searchTerms.length >= 0) ? this.searchTerms[0] : '';
            // step 1, create HTML string template
            var filterTemplate = this.buildTemplateHtmlString();
            // step 2, create the DOM Element of the filter & initialize it if searchTerm is filled
            this.$filterElm = this.createDomElement(filterTemplate, searchTerm);
            // step 3, subscribe to the input change event and run the callback when that happens
            // also add/remove "filled" class for styling purposes
            this.$filterElm.on('keyup input', function (e) {
                var value = '';
                if (e && e.target && e.target.value) {
                    var targetValue = e.target.value;
                    var enableWhiteSpaceTrim = _this.gridOptions.enableFilterTrimWhiteSpace || _this.columnFilter.enableTrimWhiteSpace;
                    if (typeof targetValue === 'string' && enableWhiteSpaceTrim) {
                        targetValue = targetValue.trim();
                    }
                    // if it has a mask, we need to do a bit more work
                    // and replace the filter string by the masked output without triggering an event
                    var unmaskedValue = _this.unmaskValue(targetValue);
                    var maskedValue = _this.maskValue(unmaskedValue);
                    value = unmaskedValue;
                    if (e.keyCode >= 48) {
                        _this.$filterElm.val(maskedValue); // replace filter string with masked string
                        e.preventDefault();
                    }
                }
                if (_this._clearFilterTriggered) {
                    _this.callback(e, { columnDef: _this.columnDef, clearFilterTriggered: _this._clearFilterTriggered, shouldTriggerQuery: _this._shouldTriggerQuery });
                    _this.$filterElm.removeClass('filled');
                }
                else {
                    _this.$filterElm.addClass('filled');
                    _this.callback(e, { columnDef: _this.columnDef, operator: _this.operator, searchTerms: [value], shouldTriggerQuery: _this._shouldTriggerQuery });
                }
                // reset both flags for next use
                _this._clearFilterTriggered = false;
                _this._shouldTriggerQuery = true;
            });
        };
        /** From a regular string, we will use the mask to output a new string */
        InputMaskFilter.prototype.maskValue = function (inputValue) {
            var i = 0;
            var maskedValue = '';
            if (this._inputMask) {
                maskedValue = this._inputMask.replace(/[09A]/gi, function (match) {
                    // only replace the char when the mask is a 0 or 9 for a digit OR the mask is "A" and the char is a non-digit meaning a string char
                    if (((match === '0' || match === '9') && /\d+/g.test(inputValue[i])) // mask is 0 or 9 and value is a digit
                        || (match.toUpperCase() === 'A' && /[^\d]+/gi.test(inputValue[i])) // OR mask is an "A" and value is non-digit
                    ) {
                        return inputValue[i++] || '';
                    }
                    return '';
                });
            }
            return maskedValue;
        };
        /** From a masked string, we will remove the mask and make a regular string again */
        InputMaskFilter.prototype.unmaskValue = function (maskedValue) {
            // remove anything else but digits and chars from both the input mask and the input masked value for later comparison
            // e.g. (000) 000-0000 would return 0000000000
            var valueWithoutSymbols = maskedValue.replace(/[^0-9a-z]*/gi, '');
            var maskWithoutSymbols = this._inputMask.replace(/[^0-9a-z]*/gi, '');
            // then we can analyze if each char on each indexes equals what the mask requires, if not the char will be disregarded from the output
            // basically, if our mask is "0A0" and input value is "2ab", then only "2a" will be returned since the last char "b" is not part of the mask and is invalid
            var output = '';
            for (var i = 0; i < maskWithoutSymbols.length; i++) {
                if (valueWithoutSymbols[i]) {
                    if (((maskWithoutSymbols[i] === '0' || maskWithoutSymbols[i] === '9') && /\d+/g.test(valueWithoutSymbols[i])) // mask is 0 or 9 and value is a digit
                        || (maskWithoutSymbols[i].toUpperCase() === 'A' && /[^\d]+/gi.test(valueWithoutSymbols[i])) // OR mask is an "A" and value is non-digit
                    ) {
                        output += valueWithoutSymbols[i]; // valid and matches the Mask, so we can add it up to the string output
                    }
                }
            }
            return output;
        };
        return InputMaskFilter;
    }(InputFilter));

    var InputNumberFilter = /** @class */ (function (_super) {
        __extends(InputNumberFilter, _super);
        /** Initialize the Filter */
        function InputNumberFilter() {
            var _this = _super.call(this) || this;
            _this.inputType = 'number';
            return _this;
        }
        return InputNumberFilter;
    }(InputFilter));

    var InputPasswordFilter = /** @class */ (function (_super) {
        __extends(InputPasswordFilter, _super);
        /** Initialize the Filter */
        function InputPasswordFilter() {
            var _this = _super.call(this) || this;
            _this.inputType = 'password';
            return _this;
        }
        return InputPasswordFilter;
    }(InputFilter));

    var DOMPurify$1 = DOMPurify_; // patch to fix rollup to work
    var SelectFilter = /** @class */ (function () {
        /**
         * Initialize the Filter
         */
        function SelectFilter(translate, collectionService, isMultipleSelect) {
            if (isMultipleSelect === void 0) { isMultipleSelect = true; }
            this.translate = translate;
            this.collectionService = collectionService;
            this._isMultipleSelect = true;
            this._shouldTriggerQuery = true;
            this.isFilled = false;
            this.enableTranslateLabel = false;
            this.subscriptions = [];
            this._isMultipleSelect = isMultipleSelect;
        }
        Object.defineProperty(SelectFilter.prototype, "columnFilter", {
            /** Getter for the Column Filter itself */
            get: function () {
                return this.columnDef && this.columnDef.filter;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectFilter.prototype, "collectionOptions", {
            /** Getter for the Collection Options */
            get: function () {
                return this.columnDef && this.columnDef.filter && this.columnDef.filter.collectionOptions;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectFilter.prototype, "customStructure", {
            /** Getter for the Custom Structure if exist */
            get: function () {
                return this.columnDef && this.columnDef.filter && this.columnDef.filter.customStructure;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectFilter.prototype, "gridOptions", {
            /** Getter for the Grid Options pulled through the Grid Object */
            get: function () {
                return (this.grid && this.grid.getOptions) ? this.grid.getOptions() : {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectFilter.prototype, "defaultOperator", {
            /** Getter to know what would be the default operator when none is specified */
            get: function () {
                return this.isMultipleSelect ? exports.OperatorType.in : exports.OperatorType.equal;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectFilter.prototype, "isMultipleSelect", {
            /** Getter to know if the current filter is a multiple-select (false means it's a single select) */
            get: function () {
                return this._isMultipleSelect;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectFilter.prototype, "operator", {
            /** Getter for the filter operator */
            get: function () {
                return this.columnFilter && this.columnFilter.operator || this.defaultOperator;
            },
            /** Setter for the filter operator */
            set: function (operator) {
                if (this.columnFilter) {
                    this.columnFilter.operator = operator;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Initialize the filter template
         */
        SelectFilter.prototype.init = function (args) {
            if (!args) {
                throw new Error('[Angular-SlickGrid] A filter must always have an "init()" with valid arguments.');
            }
            this.grid = args.grid;
            this.callback = args.callback;
            this.columnDef = args.columnDef;
            this.searchTerms = (args.hasOwnProperty('searchTerms') ? args.searchTerms : []) || [];
            if (!this.grid || !this.columnDef || !this.columnFilter || (!this.columnFilter.collection && !this.columnFilter.collectionAsync)) {
                throw new Error("[Angular-SlickGrid] You need to pass a \"collection\" (or \"collectionAsync\") for the MultipleSelect/SingleSelect Filter to work correctly. Also each option should include a value/label pair (or value/labelKey when using Locale). For example:: { filter: model: Filters.multipleSelect, collection: [{ value: true, label: 'True' }, { value: false, label: 'False'}] }");
            }
            this.enableTranslateLabel = this.columnFilter.enableTranslateLabel;
            this.labelName = this.customStructure && this.customStructure.label || 'label';
            this.labelPrefixName = this.customStructure && this.customStructure.labelPrefix || 'labelPrefix';
            this.labelSuffixName = this.customStructure && this.customStructure.labelSuffix || 'labelSuffix';
            this.optionLabel = this.customStructure && this.customStructure.optionLabel || 'value';
            this.valueName = this.customStructure && this.customStructure.value || 'value';
            if (this.enableTranslateLabel && !this.gridOptions.enableTranslate && (!this.translate || typeof this.translate.instant !== 'function')) {
                throw new Error("[select-filter] The ngx-translate TranslateService is required for the Select Filter to work correctly when \"enableTranslateLabel\" is set.");
            }
            // get locales provided by user in forRoot or else use default English locales via the Constants
            this._locales = this.gridOptions && this.gridOptions.locales || Constants.locales;
            // create the multiple select element
            this.initMultipleSelect();
            // add placeholder when found
            var placeholder = this.gridOptions && this.gridOptions.defaultFilterPlaceholder || '';
            if (this.columnFilter && this.columnFilter.placeholder) {
                placeholder = this.columnFilter.placeholder;
            }
            this.defaultOptions.placeholder = placeholder || '';
            // always render the Select (dropdown) DOM element, even if user passed a "collectionAsync",
            // if that is the case, the Select will simply be without any options but we still have to render it (else SlickGrid would throw an error)
            var newCollection = this.columnFilter.collection || [];
            this.renderDomElement(newCollection);
            // on every Filter which have a "collection" or a "collectionAsync"
            // we will add (or replace) a Subject to the "collectionAsync" property so that user has possibility to change the collection
            // if "collectionAsync" is already set by the user, it will resolve it first then after it will replace it with a Subject
            var collectionAsync = this.columnFilter && this.columnFilter.collectionAsync;
            if (collectionAsync) {
                return this.renderOptionsAsync(collectionAsync); // create Subject after resolve (createCollectionAsyncSubject)
            }
            else {
                return new Promise(function (resolve) { return resolve(true); });
            }
        };
        /**
         * Clear the filter values
         */
        SelectFilter.prototype.clear = function (shouldTriggerQuery) {
            if (shouldTriggerQuery === void 0) { shouldTriggerQuery = true; }
            if (this.$filterElm && this.$filterElm.multipleSelect) {
                // reload the filter element by it's id, to make sure it's still a valid element (because of some issue in the GraphQL example)
                this.$filterElm.multipleSelect('setSelects', []);
                this.$filterElm.removeClass('filled');
                this.$filterElm.siblings('div .search-filter').removeClass('filled');
                this.searchTerms = [];
                this._shouldTriggerQuery = shouldTriggerQuery;
                this.callback(undefined, { columnDef: this.columnDef, clearFilterTriggered: true, shouldTriggerQuery: this._shouldTriggerQuery });
                // reset both flags for next use
                this._shouldTriggerQuery = true;
            }
        };
        /**
         * destroy the filter
         */
        SelectFilter.prototype.destroy = function () {
            // also dispose of all Subscriptions
            this.subscriptions = unsubscribeAllObservables(this.subscriptions);
            if (this.$filterElm && typeof this.$filterElm.multipleSelect === 'function') {
                this.$filterElm.multipleSelect('destroy');
                this.$filterElm.remove();
                var elementClassName = this.elementName.toString().replace('.', '\\.'); // make sure to escape any dot "." from CSS class to avoid console error
                $("[name=" + elementClassName + "].ms-drop").remove();
            }
            this.$filterElm = null;
            this.callback = null;
            this.onTriggerEvent = null;
        };
        /**
         * Get selected values retrieved from the multiple-selected element
         * @params selected items
         */
        SelectFilter.prototype.getValues = function () {
            if (this.$filterElm && typeof this.$filterElm.multipleSelect === 'function') {
                return this.$filterElm.multipleSelect('getSelects');
            }
            return [];
        };
        /** Set value(s) on the DOM element */
        SelectFilter.prototype.setValues = function (values, operator) {
            if (values && this.$filterElm && typeof this.$filterElm.multipleSelect === 'function') {
                values = Array.isArray(values) ? values : [values];
                this.$filterElm.multipleSelect('setSelects', values);
            }
            // set the operator when defined
            this.operator = operator || this.defaultOperator;
        };
        //
        // protected functions
        // ------------------
        /**
         * user might want to filter certain items of the collection
         * @param inputCollection
         * @return outputCollection filtered and/or sorted collection
         */
        SelectFilter.prototype.filterCollection = function (inputCollection) {
            var outputCollection = inputCollection;
            // user might want to filter certain items of the collection
            if (this.columnDef && this.columnFilter && this.columnFilter.collectionFilterBy) {
                var filterBy = this.columnFilter.collectionFilterBy;
                var filterCollectionBy = this.columnFilter.collectionOptions && this.columnFilter.collectionOptions.filterResultAfterEachPass || null;
                outputCollection = this.collectionService.filterCollection(outputCollection, filterBy, filterCollectionBy);
            }
            return outputCollection;
        };
        /**
         * user might want to sort the collection in a certain way
         * @param inputCollection
         * @return outputCollection filtered and/or sorted collection
         */
        SelectFilter.prototype.sortCollection = function (inputCollection) {
            var outputCollection = inputCollection;
            // user might want to sort the collection
            if (this.columnDef && this.columnFilter && this.columnFilter.collectionSortBy) {
                var sortBy = this.columnFilter.collectionSortBy;
                outputCollection = this.collectionService.sortCollection(this.columnDef, outputCollection, sortBy, this.enableTranslateLabel);
            }
            return outputCollection;
        };
        SelectFilter.prototype.renderOptionsAsync = function (collectionAsync) {
            return __awaiter(this, void 0, void 0, function () {
                var awaitedCollection;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            awaitedCollection = [];
                            if (!collectionAsync) return [3 /*break*/, 2];
                            return [4 /*yield*/, castToPromise(collectionAsync)];
                        case 1:
                            awaitedCollection = _a.sent();
                            this.renderDomElementFromCollectionAsync(awaitedCollection);
                            // because we accept Promises & HttpClient Observable only execute once
                            // we will re-create an RxJs Subject which will replace the "collectionAsync" which got executed once anyway
                            // doing this provide the user a way to call a "collectionAsync.next()"
                            this.createCollectionAsyncSubject();
                            _a.label = 2;
                        case 2: return [2 /*return*/, true];
                    }
                });
            });
        };
        /** Create or recreate an Observable Subject and reassign it to the "collectionAsync" object so user can call a "collectionAsync.next()" on it */
        SelectFilter.prototype.createCollectionAsyncSubject = function () {
            var _this = this;
            var newCollectionAsync = new rxjs.Subject();
            this.columnFilter.collectionAsync = newCollectionAsync;
            this.subscriptions.push(newCollectionAsync.subscribe(function (collection) { return _this.renderDomElementFromCollectionAsync(collection); }));
        };
        /**
         * When user use a CollectionAsync we will use the returned collection to render the filter DOM element
         * and reinitialize filter collection with this new collection
         */
        SelectFilter.prototype.renderDomElementFromCollectionAsync = function (collection) {
            if (this.collectionOptions && (this.collectionOptions.collectionInsideObjectProperty || this.collectionOptions.collectionInObjectProperty)) {
                var collectionInsideObjectProperty = this.collectionOptions.collectionInsideObjectProperty || this.collectionOptions.collectionInObjectProperty;
                collection = getDescendantProperty(collection, collectionInsideObjectProperty);
            }
            if (!Array.isArray(collection)) {
                throw new Error('Something went wrong while trying to pull the collection from the "collectionAsync" call in the Select Filter, the collection is not a valid array.');
            }
            // copy over the array received from the async call to the "collection" as the new collection to use
            // this has to be BEFORE the `collectionObserver().subscribe` to avoid going into an infinite loop
            this.columnFilter.collection = collection;
            // recreate Multiple Select after getting async collection
            this.renderDomElement(collection);
        };
        SelectFilter.prototype.renderDomElement = function (inputCollection) {
            if (!Array.isArray(inputCollection) && this.collectionOptions && (this.collectionOptions.collectionInsideObjectProperty || this.collectionOptions.collectionInObjectProperty)) {
                var collectionInsideObjectProperty = this.collectionOptions.collectionInsideObjectProperty || this.collectionOptions.collectionInObjectProperty;
                inputCollection = getDescendantProperty(inputCollection, collectionInsideObjectProperty);
            }
            if (!Array.isArray(inputCollection)) {
                throw new Error('The "collection" passed to the Select Filter is not a valid array.');
            }
            // make a copy of the collection so that we don't impact SelectEditor, this could happen when calling "addBlankEntry" or "addCustomFirstEntry"
            var collection = [];
            if (inputCollection.length > 0) {
                collection = __spread(inputCollection);
                inputCollection = null;
            }
            // user can optionally add a blank entry at the beginning of the collection
            // make sure however that it wasn't added more than once
            if (this.collectionOptions && this.collectionOptions.addBlankEntry && Array.isArray(collection) && collection.length > 0 && collection[0][this.valueName] !== '') {
                collection.unshift(this.createBlankEntry());
            }
            // user can optionally add his own custom entry at the beginning of the collection
            if (this.collectionOptions && this.collectionOptions.addCustomFirstEntry && Array.isArray(collection) && collection.length > 0 && collection[0][this.valueName] !== this.collectionOptions.addCustomFirstEntry[this.valueName]) {
                collection.unshift(this.collectionOptions.addCustomFirstEntry);
            }
            // user can optionally add his own custom entry at the end of the collection
            if (this.collectionOptions && this.collectionOptions.addCustomLastEntry && Array.isArray(collection) && collection.length > 0) {
                var lastCollectionIndex = collection.length - 1;
                if (collection[lastCollectionIndex][this.valueName] !== this.collectionOptions.addCustomLastEntry[this.valueName]) {
                    collection.push(this.collectionOptions.addCustomLastEntry);
                }
            }
            var newCollection = collection;
            // user might want to filter and/or sort certain items of the collection
            newCollection = this.filterCollection(newCollection);
            newCollection = this.sortCollection(newCollection);
            // step 1, create HTML string template
            var filterTemplate = this.buildTemplateHtmlString(newCollection, this.searchTerms);
            // step 2, create the DOM Element of the filter & pre-load search terms
            // also subscribe to the onClose event
            this.createDomElement(filterTemplate);
        };
        /** Create the HTML template as a string */
        SelectFilter.prototype.buildTemplateHtmlString = function (optionCollection, searchTerms) {
            var _this = this;
            var options = '';
            var columnId = this.columnDef && this.columnDef.id;
            var separatorBetweenLabels = this.collectionOptions && this.collectionOptions.separatorBetweenTextLabels || '';
            var isEnableTranslate = this.gridOptions && this.gridOptions.enableTranslate;
            var isRenderHtmlEnabled = this.columnFilter && this.columnFilter.enableRenderHtml || false;
            var sanitizedOptions = this.gridOptions && this.gridOptions.sanitizeHtmlOptions || {};
            // collection could be an Array of Strings OR Objects
            if (Array.isArray(optionCollection)) {
                if (optionCollection.every(function (x) { return typeof x === 'string'; })) {
                    optionCollection.forEach(function (option) {
                        var selected = (searchTerms.findIndex(function (term) { return term === option; }) >= 0) ? 'selected' : '';
                        options += "<option value=\"" + option + "\" label=\"" + option + "\" " + selected + ">" + option + "</option>";
                        // if there's at least 1 search term found, we will add the "filled" class for styling purposes
                        // on a single select, we'll also make sure the single value is not an empty string to consider this being filled
                        if ((selected && _this.isMultipleSelect) || (selected && !_this.isMultipleSelect && option !== '')) {
                            _this.isFilled = true;
                        }
                    });
                }
                else {
                    // array of objects will require a label/value pair unless a customStructure is passed
                    optionCollection.forEach(function (option) {
                        if (!option || (option[_this.labelName] === undefined && option.labelKey === undefined)) {
                            throw new Error("[select-filter] A collection with value/label (or value/labelKey when using Locale) is required to populate the Select list, for example:: { filter: model: Filters.multipleSelect, collection: [ { value: '1', label: 'One' } ]')");
                        }
                        var labelKey = (option.labelKey || option[_this.labelName]);
                        var selected = (searchTerms.findIndex(function (term) { return term === option[_this.valueName]; }) >= 0) ? 'selected' : '';
                        var labelText = ((option.labelKey || _this.enableTranslateLabel) && labelKey && isEnableTranslate) ? _this.translate && _this.translate.currentLang && _this.translate.instant(labelKey || ' ') : labelKey;
                        var prefixText = option[_this.labelPrefixName] || '';
                        var suffixText = option[_this.labelSuffixName] || '';
                        var optionLabel = option.hasOwnProperty(_this.optionLabel) ? option[_this.optionLabel] : '';
                        if (optionLabel && optionLabel.toString) {
                            optionLabel = optionLabel.toString().replace(/\"/g, '\''); // replace double quotes by single quotes to avoid interfering with regular html
                        }
                        // also translate prefix/suffix if enableTranslateLabel is true and text is a string
                        prefixText = (_this.enableTranslateLabel && isEnableTranslate && prefixText && typeof prefixText === 'string') ? _this.translate && _this.translate.currentLang && _this.translate.instant(prefixText || ' ') : prefixText;
                        suffixText = (_this.enableTranslateLabel && isEnableTranslate && suffixText && typeof suffixText === 'string') ? _this.translate && _this.translate.currentLang && _this.translate.instant(suffixText || ' ') : suffixText;
                        optionLabel = (_this.enableTranslateLabel && isEnableTranslate && optionLabel && typeof optionLabel === 'string') ? _this.translate && _this.translate.currentLang && _this.translate.instant(optionLabel || ' ') : optionLabel;
                        // add to a temp array for joining purpose and filter out empty text
                        var tmpOptionArray = [prefixText, (typeof labelText === 'string' || typeof labelText === 'number') ? labelText.toString() : labelText, suffixText].filter(function (text) { return text; });
                        var optionText = tmpOptionArray.join(separatorBetweenLabels);
                        // if user specifically wants to render html text, he needs to opt-in else it will stripped out by default
                        // also, the 3rd party lib will saninitze any html code unless it's encoded, so we'll do that
                        if (isRenderHtmlEnabled) {
                            // sanitize any unauthorized html tags like script and others
                            // for the remaining allowed tags we'll permit all attributes
                            var sanitizedText = (DOMPurify$1.sanitize(optionText, sanitizedOptions) || '').toString();
                            optionText = htmlEncode(sanitizedText);
                        }
                        // html text of each select option
                        var optionValue = option[_this.valueName];
                        if (optionValue === undefined || optionValue === null) {
                            optionValue = '';
                        }
                        options += "<option value=\"" + optionValue + "\" label=\"" + optionLabel + "\" " + selected + ">" + optionText + "</option>";
                        // if there's at least 1 search term found, we will add the "filled" class for styling purposes
                        // on a single select, we'll also make sure the single value is not an empty string to consider this being filled
                        if ((selected && _this.isMultipleSelect) || (selected && !_this.isMultipleSelect && option[_this.valueName] !== '')) {
                            _this.isFilled = true;
                        }
                    });
                }
            }
            return "<select class=\"ms-filter search-filter filter-" + columnId + "\" " + (this.isMultipleSelect ? 'multiple="multiple"' : '') + ">" + options + "</select>";
        };
        /** Create a blank entry that can be added to the collection. It will also reuse the same customStructure if need be */
        SelectFilter.prototype.createBlankEntry = function () {
            var _a;
            var blankEntry = (_a = {},
                _a[this.labelName] = '',
                _a[this.valueName] = '',
                _a);
            if (this.labelPrefixName) {
                blankEntry[this.labelPrefixName] = '';
            }
            if (this.labelSuffixName) {
                blankEntry[this.labelSuffixName] = '';
            }
            return blankEntry;
        };
        /**
         * From the html template string, create a DOM element
         * Subscribe to the onClose event and run the callback when that happens
         * @param filterTemplate
         */
        SelectFilter.prototype.createDomElement = function (filterTemplate) {
            var fieldId = this.columnDef && this.columnDef.id;
            // provide the name attribute to the DOM element which will be needed to auto-adjust drop position (dropup / dropdown)
            this.elementName = "filter-" + fieldId;
            this.defaultOptions.name = this.elementName;
            var $headerElm = this.grid.getHeaderRowColumn(fieldId);
            $($headerElm).empty();
            // create the DOM element & add an ID and filter class
            this.$filterElm = $(filterTemplate);
            if (typeof this.$filterElm.multipleSelect !== 'function') {
                throw new Error("multiple-select.js was not found, make sure to modify your \"angular-cli.json\" file and include \"../node_modules/angular-slickgrid/lib/multiple-select/multiple-select.js\" and it's css or SASS file");
            }
            this.$filterElm.attr('name', this.elementName);
            this.$filterElm.data('columnId', fieldId);
            // if there's a search term, we will add the "filled" class for styling purposes
            if (this.isFilled) {
                this.$filterElm.addClass('filled');
            }
            // append the new DOM element to the header row
            if (this.$filterElm && typeof this.$filterElm.appendTo === 'function') {
                this.$filterElm.appendTo($headerElm);
            }
            // merge options & attach multiSelect
            var filterOptions = __assign({}, this.defaultOptions, this.columnFilter.filterOptions);
            this.filterElmOptions = __assign({}, this.defaultOptions, filterOptions);
            this.$filterElm = this.$filterElm.multipleSelect(this.filterElmOptions);
        };
        /** Initialize the Multiple Select element and its options to use */
        SelectFilter.prototype.initMultipleSelect = function () {
            var _this = this;
            var isTranslateEnabled = this.gridOptions && this.gridOptions.enableTranslate;
            // default options used by this Filter, user can overwrite any of these by passing "otions"
            var options = {
                autoAdjustDropHeight: true,
                autoAdjustDropPosition: true,
                autoAdjustDropWidthByTextSize: true,
                container: 'body',
                filter: false,
                maxHeight: 275,
                single: true,
                textTemplate: function ($elm) {
                    // are we rendering HTML code? by default it is sanitized and won't be rendered
                    var isRenderHtmlEnabled = _this.columnDef && _this.columnDef.filter && _this.columnDef.filter.enableRenderHtml || false;
                    return isRenderHtmlEnabled ? $elm.text() : $elm.html();
                },
                onClose: function () {
                    // we will subscribe to the onClose event for triggering our callback
                    // also add/remove "filled" class for styling purposes
                    _this.onTriggerEvent(undefined);
                }
            };
            if (this.isMultipleSelect) {
                options.single = false;
                options.okButton = true;
                options.addTitle = true; // show tooltip of all selected items while hovering the filter
                var translationPrefix = getTranslationPrefix(this.gridOptions);
                options.countSelected = (isTranslateEnabled && this.translate && this.translate.instant) ? this.translate.instant(translationPrefix + "X_OF_Y_SELECTED") : this._locales && this._locales.TEXT_X_OF_Y_SELECTED;
                options.allSelected = (isTranslateEnabled && this.translate && this.translate.instant) ? this.translate.instant(translationPrefix + "ALL_SELECTED") : this._locales && this._locales.TEXT_ALL_SELECTED;
                options.okButtonText = (isTranslateEnabled && this.translate && this.translate.instant) ? this.translate.instant(translationPrefix + "OK") : this._locales && this._locales.TEXT_OK;
                options.selectAllText = (isTranslateEnabled && this.translate && this.translate.instant) ? this.translate.instant(translationPrefix + "SELECT_ALL") : this._locales && this._locales.TEXT_SELECT_ALL;
                options.selectAllDelimiter = ['', '']; // remove default square brackets of default text "[Select All]" => "Select All"
            }
            this.defaultOptions = options;
        };
        SelectFilter.prototype.onTriggerEvent = function (e) {
            var selectedItems = this.getValues();
            if (Array.isArray(selectedItems) && selectedItems.length > 1 || (selectedItems.length === 1 && selectedItems[0] !== '')) {
                this.isFilled = true;
                this.$filterElm.addClass('filled').siblings('div .search-filter').addClass('filled');
            }
            else {
                this.isFilled = false;
                this.$filterElm.removeClass('filled');
                this.$filterElm.siblings('div .search-filter').removeClass('filled');
            }
            this.searchTerms = selectedItems;
            this.callback(undefined, { columnDef: this.columnDef, operator: this.operator, searchTerms: selectedItems, shouldTriggerQuery: this._shouldTriggerQuery });
            // reset flag for next use
            this._shouldTriggerQuery = true;
        };
        SelectFilter = __decorate([
            __param(0, core.Optional())
        ], SelectFilter);
        return SelectFilter;
    }());

    var MultipleSelectFilter = /** @class */ (function (_super) {
        __extends(MultipleSelectFilter, _super);
        /**
         * Initialize the Filter
         */
        function MultipleSelectFilter(translate, collectionService) {
            var _this = _super.call(this, translate, collectionService, true) || this;
            _this.translate = translate;
            _this.collectionService = collectionService;
            return _this;
        }
        return MultipleSelectFilter;
    }(SelectFilter));

    var NativeSelectFilter = /** @class */ (function () {
        function NativeSelectFilter(translate) {
            this.translate = translate;
            this._clearFilterTriggered = false;
            this._shouldTriggerQuery = true;
            this._currentValues = [];
        }
        Object.defineProperty(NativeSelectFilter.prototype, "columnFilter", {
            /** Getter for the Column Filter itself */
            get: function () {
                return this.columnDef && this.columnDef.filter;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NativeSelectFilter.prototype, "defaultOperator", {
            /** Getter to know what would be the default operator when none is specified */
            get: function () {
                return exports.OperatorType.equal;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NativeSelectFilter.prototype, "gridOptions", {
            /** Getter for the Grid Options pulled through the Grid Object */
            get: function () {
                return (this.grid && this.grid.getOptions) ? this.grid.getOptions() : {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NativeSelectFilter.prototype, "operator", {
            get: function () {
                return this.columnFilter && this.columnFilter.operator || this.defaultOperator;
            },
            /** Setter for the filter operator */
            set: function (operator) {
                if (this.columnFilter) {
                    this.columnFilter.operator = operator;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Initialize the Filter
         */
        NativeSelectFilter.prototype.init = function (args) {
            var _this = this;
            if (!args) {
                throw new Error('[Angular-SlickGrid] A filter must always have an "init()" with valid arguments.');
            }
            this.grid = args.grid;
            this.callback = args.callback;
            this.columnDef = args.columnDef;
            this.searchTerms = (args.hasOwnProperty('searchTerms') ? args.searchTerms : []) || [];
            if (!this.grid || !this.columnDef || !this.columnFilter || !this.columnFilter.collection) {
                throw new Error("[Angular-SlickGrid] You need to pass a \"collection\" for the Native Select Filter to work correctly.");
            }
            if (this.columnFilter.enableTranslateLabel && !this.gridOptions.enableTranslate && (!this.translate || typeof this.translate.instant !== 'function')) {
                throw new Error("The ngx-translate TranslateService is required for the Native Select Filter to work correctly when \"enableTranslateLabel\" is set.");
            }
            // filter input can only have 1 search term, so we will use the 1st array index if it exist
            var searchTerm = (Array.isArray(this.searchTerms) && this.searchTerms.length >= 0) ? this.searchTerms[0] : '';
            if (typeof searchTerm === 'boolean' || typeof searchTerm === 'number') {
                searchTerm = "" + searchTerm;
            }
            // step 1, create HTML string template
            var filterTemplate = this.buildTemplateHtmlString();
            // step 2, create the DOM Element of the filter & initialize it if searchTerm is filled
            this.$filterElm = this.createDomElement(filterTemplate, searchTerm);
            // step 3, subscribe to the change event and run the callback when that happens
            // also add/remove "filled" class for styling purposes
            this.$filterElm.change(function (e) {
                var value = e && e.target && e.target.value || '';
                _this._currentValues = [value];
                if (_this._clearFilterTriggered) {
                    _this.callback(e, { columnDef: _this.columnDef, clearFilterTriggered: _this._clearFilterTriggered, shouldTriggerQuery: _this._shouldTriggerQuery });
                    _this.$filterElm.removeClass('filled');
                }
                else {
                    value === '' ? _this.$filterElm.removeClass('filled') : _this.$filterElm.addClass('filled');
                    _this.callback(e, { columnDef: _this.columnDef, operator: _this.operator, searchTerms: [value], shouldTriggerQuery: _this._shouldTriggerQuery });
                }
                // reset both flags for next use
                _this._clearFilterTriggered = false;
                _this._shouldTriggerQuery = true;
            });
        };
        /**
         * Clear the filter values
         */
        NativeSelectFilter.prototype.clear = function (shouldTriggerQuery) {
            if (shouldTriggerQuery === void 0) { shouldTriggerQuery = true; }
            if (this.$filterElm) {
                this._clearFilterTriggered = true;
                this._shouldTriggerQuery = shouldTriggerQuery;
                this.searchTerms = [];
                this._currentValues = [];
                this.$filterElm.val('');
                this.$filterElm.trigger('change');
            }
        };
        /**
         * destroy the filter
         */
        NativeSelectFilter.prototype.destroy = function () {
            if (this.$filterElm) {
                this.$filterElm.off('change').remove();
            }
            this.$filterElm = null;
            this.callback = null;
        };
        /**
         * Get selected values retrieved from the select element
         * @params selected items
         */
        NativeSelectFilter.prototype.getValues = function () {
            return this._currentValues;
        };
        /** Set value(s) on the DOM element */
        NativeSelectFilter.prototype.setValues = function (values, operator) {
            if (Array.isArray(values)) {
                this.$filterElm.val(values[0]);
                this._currentValues = values;
            }
            else if (values) {
                this.$filterElm.val(values);
                this._currentValues = [values];
            }
            // set the operator when defined
            this.operator = operator || this.defaultOperator;
        };
        //
        // private functions
        // ------------------
        NativeSelectFilter.prototype.buildTemplateHtmlString = function () {
            var _this = this;
            var collection = this.columnFilter && this.columnFilter.collection || [];
            if (!Array.isArray(collection)) {
                throw new Error('The "collection" passed to the Native Select Filter is not a valid array.');
            }
            var fieldId = this.columnDef && this.columnDef.id;
            var labelName = (this.columnDef.filter.customStructure) ? this.columnDef.filter.customStructure.label : 'label';
            var valueName = (this.columnDef.filter.customStructure) ? this.columnDef.filter.customStructure.value : 'value';
            var options = '';
            // collection could be an Array of Strings OR Objects
            if (collection.every(function (x) { return typeof x === 'string'; })) {
                collection.forEach(function (option) {
                    options += "<option value=\"" + option + "\" label=\"" + option + "\">" + option + "</option>";
                });
            }
            else {
                collection.forEach(function (option) {
                    if (!option || (option[labelName] === undefined && option.labelKey === undefined)) {
                        throw new Error("A collection with value/label (or value/labelKey when using Locale) is required to populate the Native Select Filter list, for example:: { filter: model: Filters.select, collection: [ { value: '1', label: 'One' } ]')");
                    }
                    var labelKey = option.labelKey || option[labelName];
                    var textLabel = ((option.labelKey || _this.columnDef.filter.enableTranslateLabel) && _this.translate && _this.translate.currentLang && _this.translate.instant) ? _this.translate.instant(labelKey || ' ') : labelKey;
                    options += "<option value=\"" + option[valueName] + "\">" + textLabel + "</option>";
                });
            }
            return "<select class=\"form-control search-filter filter-" + fieldId + "\">" + options + "</select>";
        };
        /**
         * From the html template string, create a DOM element
         * @param filterTemplate
         */
        NativeSelectFilter.prototype.createDomElement = function (filterTemplate, searchTerm) {
            var fieldId = this.columnDef && this.columnDef.id;
            var $headerElm = this.grid.getHeaderRowColumn(fieldId);
            $($headerElm).empty();
            // create the DOM element & add an ID and filter class
            var $filterElm = $(filterTemplate);
            var searchTermInput = (searchTerm || '');
            $filterElm.val(searchTermInput);
            $filterElm.data('columnId', fieldId);
            if (searchTermInput) {
                this._currentValues = [searchTermInput];
            }
            // append the new DOM element to the header row
            if ($filterElm && typeof $filterElm.appendTo === 'function') {
                $filterElm.appendTo($headerElm);
            }
            return $filterElm;
        };
        NativeSelectFilter = __decorate([
            __param(0, core.Optional())
        ], NativeSelectFilter);
        return NativeSelectFilter;
    }());

    var moment$4 = moment_; // patch to fix rollup "moment has no default export" issue, document here https://github.com/rollup/rollup/issues/670
    require('flatpickr');
    var DateRangeFilter = /** @class */ (function () {
        function DateRangeFilter(translate) {
            this.translate = translate;
            this._clearFilterTriggered = false;
            this._shouldTriggerQuery = true;
        }
        Object.defineProperty(DateRangeFilter.prototype, "gridOptions", {
            /** Getter for the Grid Options pulled through the Grid Object */
            get: function () {
                return (this.grid && this.grid.getOptions) ? this.grid.getOptions() : {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateRangeFilter.prototype, "columnFilter", {
            /** Getter for the Column Filter */
            get: function () {
                return this.columnDef && this.columnDef.filter || {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateRangeFilter.prototype, "currentDates", {
            /** Getter for the Current Dates selected */
            get: function () {
                return this._currentDates;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateRangeFilter.prototype, "defaultOperator", {
            /** Getter to know what would be the default operator when none is specified */
            get: function () {
                return this.gridOptions.defaultFilterRangeOperator || exports.OperatorType.rangeExclusive;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateRangeFilter.prototype, "flatpickrOptions", {
            /** Getter for the Flatpickr Options */
            get: function () {
                return this._flatpickrOptions || {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateRangeFilter.prototype, "operator", {
            /** Getter of the Operator to use when doing the filter comparing */
            get: function () {
                return this.columnFilter && this.columnFilter.operator || this.defaultOperator;
            },
            /** Setter for the filter operator */
            set: function (operator) {
                if (this.columnFilter) {
                    this.columnFilter.operator = operator;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Initialize the Filter
         */
        DateRangeFilter.prototype.init = function (args) {
            var _this = this;
            if (!args) {
                throw new Error('[Angular-SlickGrid] A filter must always have an "init()" with valid arguments.');
            }
            this.grid = args.grid;
            this.callback = args.callback;
            this.columnDef = args.columnDef;
            this.searchTerms = (args.hasOwnProperty('searchTerms') ? args.searchTerms : []) || [];
            // step 1, create the DOM Element of the filter which contain the compound Operator+Input
            this.$filterElm = this.createDomElement(this.searchTerms);
            // step 3, subscribe to the keyup event and run the callback when that happens
            // also add/remove "filled" class for styling purposes
            this.$filterInputElm.keyup(function (e) {
                _this.onTriggerEvent(e);
            });
        };
        /**
         * Clear the filter value
         */
        DateRangeFilter.prototype.clear = function (shouldTriggerQuery) {
            if (shouldTriggerQuery === void 0) { shouldTriggerQuery = true; }
            if (this.flatInstance) {
                this._clearFilterTriggered = true;
                this._shouldTriggerQuery = shouldTriggerQuery;
                this.searchTerms = [];
                this.flatInstance.clear();
            }
        };
        /**
         * destroy the filter
         */
        DateRangeFilter.prototype.destroy = function () {
            if (this.flatInstance && typeof this.flatInstance.destroy === 'function') {
                this.flatInstance.destroy();
                if (this.flatInstance.element) {
                    destroyObjectDomElementProps(this.flatInstance);
                }
            }
            if (this.$filterElm) {
                this.$filterElm.off('keyup').remove();
            }
            this.flatInstance = null;
            this.$filterElm = null;
            this.callback = null;
            this.onTriggerEvent = null;
        };
        DateRangeFilter.prototype.hide = function () {
            if (this.flatInstance && typeof this.flatInstance.close === 'function') {
                this.flatInstance.close();
            }
        };
        DateRangeFilter.prototype.show = function () {
            if (this.flatInstance && typeof this.flatInstance.open === 'function') {
                this.flatInstance.open();
            }
        };
        /**
         * Set value(s) on the DOM element
         * @params searchTerms
         */
        DateRangeFilter.prototype.setValues = function (searchTerms, operator) {
            var pickerValues = [];
            // get the picker values, if it's a string with the "..", we'll do the split else we'll use the array of search terms
            if (typeof searchTerms === 'string' || (Array.isArray(searchTerms) && typeof searchTerms[0] === 'string') && searchTerms[0].indexOf('..') > 0) {
                pickerValues = (typeof searchTerms === 'string') ? [searchTerms] : searchTerms[0].split('..');
            }
            else if (Array.isArray(searchTerms)) {
                pickerValues = searchTerms;
            }
            if (this.flatInstance && searchTerms) {
                this._currentDates = pickerValues;
                this.flatInstance.setDate(pickerValues);
            }
            // set the operator when defined
            this.operator = operator || this.defaultOperator;
        };
        //
        // private functions
        // ------------------
        DateRangeFilter.prototype.buildDatePickerInput = function (searchTerms) {
            var _this = this;
            var columnId = this.columnDef && this.columnDef.id || '';
            var inputFormat = mapFlatpickrDateFormatWithFieldType(this.columnFilter.type || this.columnDef.type || exports.FieldType.dateIso);
            var outputFormat = mapFlatpickrDateFormatWithFieldType(this.columnDef.outputType || this.columnFilter.type || this.columnDef.type || exports.FieldType.dateUtc);
            var userFilterOptions = (this.columnFilter && this.columnFilter.filterOptions || {});
            // get current locale, if user defined a custom locale just use or get it the Translate Service if it exist else just use English
            var currentLocale = (userFilterOptions && userFilterOptions.locale) || (this.translate && this.translate.currentLang) || this.gridOptions.locale || 'en';
            if (currentLocale.length > 2) {
                currentLocale = currentLocale.substring(0, 2);
            }
            var pickerValues = [];
            // get the picker values, if it's a string with the "..", we'll do the split else we'll use the array of search terms
            if (typeof searchTerms === 'string' || (Array.isArray(searchTerms) && typeof searchTerms[0] === 'string') && searchTerms[0].indexOf('..') > 0) {
                pickerValues = (typeof searchTerms === 'string') ? [searchTerms] : searchTerms[0].split('..');
            }
            else if (Array.isArray(searchTerms)) {
                pickerValues = searchTerms;
            }
            // if we are preloading searchTerms, we'll keep them for reference
            if (pickerValues) {
                this._currentDates = pickerValues;
                var outFormat_1 = mapMomentDateFormatWithFieldType(this.columnFilter.type || this.columnDef.type || exports.FieldType.dateIso);
                this._currentDateStrings = pickerValues.map(function (date) { return moment$4(date).format(outFormat_1); });
            }
            var pickerOptions = {
                defaultDate: pickerValues || '',
                altInput: true,
                altFormat: outputFormat,
                dateFormat: inputFormat,
                mode: 'range',
                wrap: true,
                closeOnSelect: true,
                locale: (currentLocale !== 'en') ? this.loadFlatpickrLocale(currentLocale) : 'en',
                onChange: function (selectedDates, dateStr, instance) {
                    if (Array.isArray(selectedDates)) {
                        _this._currentDates = selectedDates;
                        var outFormat_2 = mapMomentDateFormatWithFieldType(_this.columnDef.outputType || _this.columnFilter.type || _this.columnDef.type || exports.FieldType.dateIso);
                        _this._currentDateStrings = selectedDates.map(function (date) { return moment$4(date).format(outFormat_2); });
                        _this._currentValue = _this._currentDateStrings.join('..');
                    }
                    // when using the time picker, we can simulate a keyup event to avoid multiple backend request
                    // since backend request are only executed after user start typing, changing the time should be treated the same way
                    var newEvent = pickerOptions.enableTime ? new CustomEvent('keyup') : undefined;
                    _this.onTriggerEvent(newEvent);
                }
            };
            // add the time picker when format is UTC (Z) or has the 'h' (meaning hours)
            if (outputFormat && (outputFormat === 'Z' || outputFormat.toLowerCase().includes('h'))) {
                pickerOptions.enableTime = true;
            }
            // merge options with optional user's custom options
            this._flatpickrOptions = __assign({}, pickerOptions, userFilterOptions);
            var placeholder = (this.gridOptions) ? (this.gridOptions.defaultFilterPlaceholder || '') : '';
            if (this.columnFilter && this.columnFilter.placeholder) {
                placeholder = this.columnFilter.placeholder;
            }
            var $filterInputElm = $("<div class=\"flatpickr search-filter filter-" + columnId + "\"><input type=\"text\" class=\"form-control\" data-input placeholder=\"" + placeholder + "\"></div>");
            this.flatInstance = ($filterInputElm[0] && typeof $filterInputElm[0].flatpickr === 'function') ? $filterInputElm[0].flatpickr(this._flatpickrOptions) : Flatpickr__default__default($filterInputElm, this._flatpickrOptions);
            return $filterInputElm;
        };
        /**
         * Create the DOM element
         * @params searchTerms
         */
        DateRangeFilter.prototype.createDomElement = function (searchTerms) {
            var fieldId = this.columnDef && this.columnDef.id;
            var $headerElm = this.grid.getHeaderRowColumn(fieldId);
            $($headerElm).empty();
            // create the DOM Select dropdown for the Operator
            this.$filterInputElm = this.buildDatePickerInput(searchTerms);
            /* the DOM element final structure will be
              <div class=flatpickr>
                <input type="text" class="form-control" data-input>
              </div>
            */
            // create the DOM element & add an ID and filter class
            this.$filterInputElm.data('columnId', fieldId);
            // if there's a search term, we will add the "filled" class for styling purposes
            if (Array.isArray(searchTerms) && searchTerms.length > 0 && searchTerms[0] !== '') {
                this.$filterInputElm.addClass('filled');
                this._currentDates = searchTerms;
                this._currentValue = searchTerms[0];
            }
            // append the new DOM element to the header row
            if (this.$filterInputElm && typeof this.$filterInputElm.appendTo === 'function') {
                this.$filterInputElm.appendTo($headerElm);
            }
            return this.$filterInputElm;
        };
        /** Load a different set of locales for Flatpickr to be localized */
        DateRangeFilter.prototype.loadFlatpickrLocale = function (language) {
            var locales = 'en';
            try {
                if (language !== 'en') {
                    // change locale if needed, Flatpickr reference: https://chmln.github.io/flatpickr/localization/
                    var localeDefault = require("flatpickr/dist/l10n/" + language + ".js").default;
                    locales = (localeDefault && localeDefault[language]) ? localeDefault[language] : 'en';
                }
            }
            catch (e) {
                console.warn("[Angular-Slickgrid - DateRange Filter] It seems that \"" + language + "\" is not a locale supported by Flatpickr, we will use \"en\" instead. "
                    + "To avoid seeing this message, you can specifically set \"filter: { filterOptions: { locale: 'en' } }\" in your column definition.");
                return 'en';
            }
            return locales;
        };
        DateRangeFilter.prototype.onTriggerEvent = function (e) {
            if (this._clearFilterTriggered) {
                this.callback(e, { columnDef: this.columnDef, clearFilterTriggered: this._clearFilterTriggered, shouldTriggerQuery: this._shouldTriggerQuery });
                this.$filterElm.removeClass('filled');
            }
            else {
                (this._currentDateStrings) ? this.$filterElm.addClass('filled') : this.$filterElm.removeClass('filled');
                this.callback(e, { columnDef: this.columnDef, searchTerms: (this._currentDateStrings ? this._currentDateStrings : [this._currentValue]), operator: this.operator || '', shouldTriggerQuery: this._shouldTriggerQuery });
            }
            // reset both flags for next use
            this._clearFilterTriggered = false;
            this._shouldTriggerQuery = true;
        };
        DateRangeFilter = __decorate([
            __param(0, core.Optional())
        ], DateRangeFilter);
        return DateRangeFilter;
    }());

    var SingleSelectFilter = /** @class */ (function (_super) {
        __extends(SingleSelectFilter, _super);
        /**
         * Initialize the Filter
         */
        function SingleSelectFilter(translate, collectionService) {
            var _this = _super.call(this, translate, collectionService, false) || this;
            _this.translate = translate;
            _this.collectionService = collectionService;
            return _this;
        }
        return SingleSelectFilter;
    }(SelectFilter));

    var DEFAULT_MIN_VALUE$1 = 0;
    var DEFAULT_MAX_VALUE$1 = 100;
    var DEFAULT_STEP$1 = 1;
    var SliderFilter = /** @class */ (function () {
        function SliderFilter() {
            this._clearFilterTriggered = false;
            this._shouldTriggerQuery = true;
        }
        Object.defineProperty(SliderFilter.prototype, "columnFilter", {
            /** Getter for the Column Filter */
            get: function () {
                return this.columnDef && this.columnDef.filter || {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SliderFilter.prototype, "defaultOperator", {
            /** Getter to know what would be the default operator when none is specified */
            get: function () {
                return exports.OperatorType.equal;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SliderFilter.prototype, "filterParams", {
            /** Getter for the Filter Generic Params */
            get: function () {
                return this.columnDef && this.columnDef.filter && this.columnDef.filter.params || {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SliderFilter.prototype, "filterProperties", {
            /** Getter for the `filter` properties */
            get: function () {
                return this.columnDef && this.columnDef.filter;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SliderFilter.prototype, "operator", {
            get: function () {
                return this.columnFilter && this.columnFilter.operator || this.defaultOperator;
            },
            /** Setter for the filter operator */
            set: function (operator) {
                if (this.columnFilter) {
                    this.columnFilter.operator = operator;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Initialize the Filter
         */
        SliderFilter.prototype.init = function (args) {
            var _this = this;
            if (!args) {
                throw new Error('[Angular-SlickGrid] A filter must always have an "init()" with valid arguments.');
            }
            this.grid = args.grid;
            this.callback = args.callback;
            this.columnDef = args.columnDef;
            this.searchTerms = (args.hasOwnProperty('searchTerms') ? args.searchTerms : []) || [];
            // define the input & slider number IDs
            this._elementRangeInputId = "rangeInput_" + this.columnDef.field;
            this._elementRangeOutputId = "rangeOutput_" + this.columnDef.field;
            // filter input can only have 1 search term, so we will use the 1st array index if it exist
            var searchTerm = (Array.isArray(this.searchTerms) && this.searchTerms.length >= 0) ? this.searchTerms[0] : '';
            // step 1, create HTML string template
            var filterTemplate = this.buildTemplateHtmlString();
            // step 2, create the DOM Element of the filter & initialize it if searchTerm is filled
            this.$filterElm = this.createDomElement(filterTemplate, searchTerm);
            // step 3, subscribe to the change event and run the callback when that happens
            // also add/remove "filled" class for styling purposes
            this.$filterInputElm.change(function (e) {
                var value = e && e.target && e.target.value;
                _this._currentValue = +value;
                if (_this._clearFilterTriggered) {
                    _this.$filterElm.removeClass('filled');
                    _this.callback(e, { columnDef: _this.columnDef, clearFilterTriggered: _this._clearFilterTriggered, searchTerms: [], shouldTriggerQuery: _this._shouldTriggerQuery });
                }
                else {
                    _this.$filterElm.addClass('filled');
                    _this.callback(e, { columnDef: _this.columnDef, operator: _this.operator, searchTerms: [value || '0'], shouldTriggerQuery: _this._shouldTriggerQuery });
                }
                // reset both flags for next use
                _this._clearFilterTriggered = false;
                _this._shouldTriggerQuery = true;
            });
            // if user chose to display the slider number on the right side, then update it every time it changes
            // we need to use both "input" and "change" event to be all cross-browser
            if (!this.filterParams.hideSliderNumber) {
                this.$filterInputElm.on('input change', function (e) {
                    var value = e && e.target && e.target.value;
                    if (value !== undefined && value !== null) {
                        var elements = document.getElementsByClassName(_this._elementRangeOutputId);
                        if (elements.length) {
                            elements[0].innerHTML = value;
                        }
                    }
                });
            }
        };
        /**
         * Clear the filter value
         */
        SliderFilter.prototype.clear = function (shouldTriggerQuery) {
            if (shouldTriggerQuery === void 0) { shouldTriggerQuery = true; }
            if (this.$filterElm) {
                this._clearFilterTriggered = true;
                this._shouldTriggerQuery = shouldTriggerQuery;
                this.searchTerms = [];
                var clearedValue = this.filterParams.hasOwnProperty('sliderStartValue') ? this.filterParams.sliderStartValue : DEFAULT_MIN_VALUE$1;
                this._currentValue = +clearedValue;
                this.$filterInputElm.val(clearedValue);
                this.$filterNumberElm.html(clearedValue);
                this.$filterInputElm.trigger('change');
            }
        };
        /**
         * destroy the filter
         */
        SliderFilter.prototype.destroy = function () {
            if (this.$filterInputElm) {
                this.$filterInputElm.off('input change').remove();
            }
            this.$filterInputElm = null;
            this.$filterElm = null;
            this.callback = null;
        };
        /**
         * Get selected value retrieved from the slider element
         * @params selected items
         */
        SliderFilter.prototype.getValues = function () {
            return this._currentValue;
        };
        /** Set value(s) on the DOM element */
        SliderFilter.prototype.setValues = function (values, operator) {
            if (Array.isArray(values)) {
                this.$filterInputElm.val("" + values[0]);
                this.$filterNumberElm.html("" + values[0]);
                this._currentValue = +values[0];
            }
            else if (values) {
                this.$filterInputElm.val(values);
                this._currentValue = +values;
            }
            // set the operator when defined
            this.operator = operator || this.defaultOperator;
        };
        //
        // private functions
        // ------------------
        /**
         * Create the HTML template as a string
         */
        SliderFilter.prototype.buildTemplateHtmlString = function () {
            var fieldId = this.columnDef && this.columnDef.id;
            var minValue = this.filterProperties.hasOwnProperty('minValue') ? this.filterProperties.minValue : DEFAULT_MIN_VALUE$1;
            var maxValue = this.filterProperties.hasOwnProperty('maxValue') ? this.filterProperties.maxValue : DEFAULT_MAX_VALUE$1;
            var defaultValue = this.filterParams.hasOwnProperty('sliderStartValue') ? this.filterParams.sliderStartValue : minValue;
            var step = this.filterProperties.hasOwnProperty('valueStep') ? this.filterProperties.valueStep : DEFAULT_STEP$1;
            if (this.filterParams.hideSliderNumber) {
                return "\n      <div class=\"search-filter slider-container filter-" + fieldId + "\">\n        <input type=\"range\" name=\"" + this._elementRangeInputId + "\"\n          defaultValue=\"" + defaultValue + "\" value=\"" + defaultValue + "\"\n          min=\"" + minValue + "\" max=\"" + maxValue + "\" step=\"" + step + "\"\n          class=\"form-control slider-filter-input range " + this._elementRangeInputId + "\" />\n      </div>";
            }
            return "\n      <div class=\"input-group slider-container search-filter filter-" + fieldId + "\">\n        <input type=\"range\" name=\"" + this._elementRangeInputId + "\"\n          defaultValue=\"" + defaultValue + "\" value=\"" + defaultValue + "\"\n          min=\"" + minValue + "\" max=\"" + maxValue + "\" step=\"" + step + "\"\n          class=\"form-control slider-filter-input range " + this._elementRangeInputId + "\" />\n        <div class=\"input-group-addon input-group-append slider-value\">\n          <span class=\"input-group-text " + this._elementRangeOutputId + "\">" + defaultValue + "</span>\n        </div>\n      </div>";
        };
        /**
         * From the html template string, create a DOM element
         * @param filterTemplate string
         * @param searchTerm optional preset search terms
         */
        SliderFilter.prototype.createDomElement = function (filterTemplate, searchTerm) {
            var columnId = this.columnDef && this.columnDef.id;
            var minValue = this.filterProperties.hasOwnProperty('minValue') ? this.filterProperties.minValue : DEFAULT_MIN_VALUE$1;
            var startValue = this.filterParams.hasOwnProperty('sliderStartValue') ? this.filterParams.sliderStartValue : minValue;
            var $headerElm = this.grid.getHeaderRowColumn(columnId);
            $($headerElm).empty();
            // create the DOM element & add an ID and filter class
            var $filterElm = $(filterTemplate);
            var searchTermInput = (searchTerm || '0');
            if (+searchTermInput < minValue) {
                searchTermInput = "" + minValue;
            }
            if (+searchTermInput < startValue) {
                searchTermInput = "" + startValue;
            }
            this._currentValue = +searchTermInput;
            this.$filterInputElm = $filterElm.children('input');
            this.$filterNumberElm = $filterElm.children('div.input-group-addon.input-group-append').children();
            this.$filterInputElm.val(searchTermInput);
            this.$filterNumberElm.html(searchTermInput);
            $filterElm.data('columnId', columnId);
            // if there's a search term, we will add the "filled" class for styling purposes
            if (searchTerm) {
                $filterElm.addClass('filled');
            }
            // append the new DOM element to the header row
            if ($filterElm && typeof $filterElm.appendTo === 'function') {
                $filterElm.appendTo($headerElm);
            }
            return $filterElm;
        };
        return SliderFilter;
    }());

    var DEFAULT_MIN_VALUE$2 = 0;
    var DEFAULT_MAX_VALUE$2 = 100;
    var DEFAULT_STEP$2 = 1;
    /** A Slider Range Filter which uses jQuery UI, this is only meant to be used as a range filter (with 2 handles lowest & highest values) */
    var SliderRangeFilter = /** @class */ (function () {
        function SliderRangeFilter() {
            this._clearFilterTriggered = false;
            this._shouldTriggerQuery = true;
        }
        Object.defineProperty(SliderRangeFilter.prototype, "filterParams", {
            /** Getter for the Filter Generic Params */
            get: function () {
                return this.columnDef && this.columnDef.filter && this.columnDef.filter.params || {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SliderRangeFilter.prototype, "filterProperties", {
            /** Getter for the `filter` properties */
            get: function () {
                return this.columnDef && this.columnDef.filter;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SliderRangeFilter.prototype, "columnFilter", {
            /** Getter for the Column Filter */
            get: function () {
                return this.columnDef && this.columnDef.filter || {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SliderRangeFilter.prototype, "currentValues", {
            /** Getter for the Current Slider Values */
            get: function () {
                return this._currentValues;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SliderRangeFilter.prototype, "defaultOperator", {
            /** Getter to know what would be the default operator when none is specified */
            get: function () {
                return this.gridOptions.defaultFilterRangeOperator || exports.OperatorType.rangeExclusive;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SliderRangeFilter.prototype, "gridOptions", {
            /** Getter for the Grid Options pulled through the Grid Object */
            get: function () {
                return (this.grid && this.grid.getOptions) ? this.grid.getOptions() : {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SliderRangeFilter.prototype, "sliderOptions", {
            /** Getter for the JQuery UI Slider Options */
            get: function () {
                return this._sliderOptions || {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SliderRangeFilter.prototype, "operator", {
            /** Getter of the Operator to use when doing the filter comparing */
            get: function () {
                return this.columnFilter && this.columnFilter.operator || this.defaultOperator;
            },
            /** Setter for the filter operator */
            set: function (operator) {
                if (this.columnFilter) {
                    this.columnFilter.operator = operator;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Initialize the Filter
         */
        SliderRangeFilter.prototype.init = function (args) {
            if (!args) {
                throw new Error('[Angular-SlickGrid] A filter must always have an "init()" with valid arguments.');
            }
            this.grid = args.grid;
            this.callback = args.callback;
            this.columnDef = args.columnDef;
            this.searchTerms = (args.hasOwnProperty('searchTerms') ? args.searchTerms : []) || [];
            // step 1, create the DOM Element of the filter & initialize it if searchTerm is filled
            this.$filterElm = this.createDomElement(this.searchTerms);
        };
        /**
         * Clear the filter value
         */
        SliderRangeFilter.prototype.clear = function (shouldTriggerQuery) {
            if (shouldTriggerQuery === void 0) { shouldTriggerQuery = true; }
            if (this.$filterElm) {
                this._clearFilterTriggered = true;
                this._shouldTriggerQuery = shouldTriggerQuery;
                this.searchTerms = [];
                var lowestValue = this.filterParams.hasOwnProperty('sliderStartValue') ? this.filterParams.sliderStartValue : DEFAULT_MIN_VALUE$2;
                var highestValue = this.filterParams.hasOwnProperty('sliderEndValue') ? this.filterParams.sliderEndValue : DEFAULT_MAX_VALUE$2;
                this._currentValues = [lowestValue, highestValue];
                this.$filterElm.slider('values', [lowestValue, highestValue]);
                if (!this.filterParams.hideSliderNumbers) {
                    this.renderSliderValues(lowestValue, highestValue);
                }
                this.callback(null, { columnDef: this.columnDef, clearFilterTriggered: true, shouldTriggerQuery: shouldTriggerQuery });
                this.$filterContainerElm.removeClass('filled');
            }
        };
        /**
         * destroy the filter
         */
        SliderRangeFilter.prototype.destroy = function () {
            if (this.$filterElm) {
                this.$filterElm.off('change').remove();
                this.$filterContainerElm.remove();
            }
            this.$filterElm = null;
            this.$filterContainerElm = null;
            this.callback = null;
            this.onValueChanged = null;
        };
        /**
         * Render both slider values (low/high) on screen
         * @param lowestValue number
         * @param highestValue number
         */
        SliderRangeFilter.prototype.renderSliderValues = function (lowestValue, highestValue) {
            var columndId = this.columnDef && this.columnDef.id;
            var lowerElm = document.querySelector(".lowest-range-" + columndId);
            var highestElm = document.querySelector(".highest-range-" + columndId);
            if (lowerElm && lowerElm.innerHTML) {
                lowerElm.innerHTML = lowestValue.toString();
            }
            if (highestElm && highestElm.innerHTML) {
                highestElm.innerHTML = highestValue.toString();
            }
        };
        /**
         * Set value(s) on the DOM element
         * @params searchTerms
         */
        SliderRangeFilter.prototype.setValues = function (searchTerms, operator) {
            if (searchTerms) {
                var sliderValues = [];
                // get the slider values, if it's a string with the "..", we'll do the split else we'll use the array of search terms
                if (typeof searchTerms === 'string' || (Array.isArray(searchTerms) && typeof searchTerms[0] === 'string') && searchTerms[0].indexOf('..') > 0) {
                    sliderValues = (typeof searchTerms === 'string') ? [searchTerms] : searchTerms[0].split('..');
                }
                else if (Array.isArray(searchTerms)) {
                    sliderValues = searchTerms;
                }
                if (Array.isArray(sliderValues) && sliderValues.length === 2) {
                    this.$filterElm.slider('values', sliderValues);
                    if (!this.filterParams.hideSliderNumbers) {
                        this.renderSliderValues(sliderValues[0], sliderValues[1]);
                    }
                }
            }
            // set the operator when defined
            this.operator = operator || this.defaultOperator;
        };
        //
        // private functions
        // ------------------
        /**
         * From the html template string, create a DOM element
         * @param searchTerm optional preset search terms
         */
        SliderRangeFilter.prototype.createDomElement = function (searchTerms) {
            var _this = this;
            if (this.columnFilter && this.columnFilter.filterOptions && (this.columnFilter.filterOptions.change || this.columnFilter.filterOptions.slide)) {
                throw new Error("[Angular-Slickgrid] You cannot override the \"change\" and/or the \"slide\" callback methods\n        since they are used in SliderRange Filter itself, however any other methods can be used for example the \"create\", \"start\", \"stop\" methods.");
            }
            var fieldId = this.columnDef && this.columnDef.id;
            var $headerElm = this.grid.getHeaderRowColumn(fieldId);
            var minValue = this.filterProperties.hasOwnProperty('minValue') ? this.filterProperties.minValue : DEFAULT_MIN_VALUE$2;
            var maxValue = this.filterProperties.hasOwnProperty('maxValue') ? this.filterProperties.maxValue : DEFAULT_MAX_VALUE$2;
            var step = this.filterProperties.hasOwnProperty('valueStep') ? this.filterProperties.valueStep : DEFAULT_STEP$2;
            var defaultStartValue = DEFAULT_MIN_VALUE$2;
            var defaultEndValue = DEFAULT_MAX_VALUE$2;
            if (Array.isArray(searchTerms) && searchTerms.length > 1) {
                defaultStartValue = +searchTerms[0];
                defaultEndValue = +searchTerms[1];
            }
            else {
                defaultStartValue = +(this.filterParams.hasOwnProperty('sliderStartValue') ? this.filterParams.sliderStartValue : minValue);
                defaultEndValue = +(this.filterParams.hasOwnProperty('sliderEndValue') ? this.filterParams.sliderEndValue : maxValue);
            }
            $($headerElm).empty();
            // create the DOM element & add an ID and filter class
            var $lowestSliderValueElm = $("\n    <div class=\"input-group-addon input-group-prepend slider-range-value\">\n      <span class=\"input-group-text lowest-range-" + fieldId + "\">" + defaultStartValue + "</span>\n    </div>");
            var $highestSliderValueElm = $("\n    <div class=\"input-group-addon input-group-append slider-range-value\">\n      <span class=\"input-group-text highest-range-" + fieldId + "\">" + defaultEndValue + "</span>\n    </div>");
            this.$filterElm = $("<div class=\"filter-input filter-" + fieldId + "\"></div>");
            this.$filterContainerElm = $("<div class=\"input-group form-control search-filter slider-range-container slider-values filter-" + fieldId + "\">");
            if (this.filterParams.hideSliderNumbers) {
                this.$filterContainerElm.append(this.$filterElm);
            }
            else {
                this.$filterContainerElm.append($lowestSliderValueElm);
                this.$filterContainerElm.append(this.$filterElm);
                this.$filterContainerElm.append($highestSliderValueElm);
            }
            // if we are preloading searchTerms, we'll keep them for reference
            this._currentValues = [defaultStartValue, defaultEndValue];
            var definedOptions = {
                range: true,
                min: +minValue,
                max: +maxValue,
                step: +step,
                values: [defaultStartValue, defaultEndValue],
                change: function (e, ui) { return _this.onValueChanged(e, ui); },
                slide: function (e, ui) {
                    var values = ui.values;
                    if (!_this.filterParams.hideSliderNumbers && Array.isArray(values)) {
                        _this.renderSliderValues(values[0], values[1]);
                    }
                }
            };
            // merge options with optional user's custom options
            this._sliderOptions = __assign({}, definedOptions, this.columnFilter.filterOptions);
            this.$filterElm.slider(this._sliderOptions);
            // if there's a search term, we will add the "filled" class for styling purposes
            if (Array.isArray(searchTerms) && searchTerms.length > 0 && searchTerms[0] !== '') {
                this.$filterContainerElm.addClass('filled');
            }
            // append the new DOM element to the header row
            if (this.$filterContainerElm && typeof this.$filterContainerElm.appendTo === 'function') {
                this.$filterContainerElm.appendTo($headerElm);
            }
            return this.$filterElm;
        };
        /** On a value change event triggered */
        SliderRangeFilter.prototype.onValueChanged = function (e, ui) {
            var values = ui && Array.isArray(ui.values) ? ui.values : [];
            var value = values.join('..');
            if (this._clearFilterTriggered) {
                this.callback(e, { columnDef: this.columnDef, clearFilterTriggered: this._clearFilterTriggered, shouldTriggerQuery: this._shouldTriggerQuery });
                this.$filterContainerElm.removeClass('filled');
            }
            else {
                value === '' ? this.$filterContainerElm.removeClass('filled') : this.$filterContainerElm.addClass('filled');
                this.callback(e, { columnDef: this.columnDef, operator: this.operator, searchTerms: values, shouldTriggerQuery: this._shouldTriggerQuery });
            }
            // reset both flags for next use
            this._clearFilterTriggered = false;
            this._shouldTriggerQuery = true;
        };
        return SliderRangeFilter;
    }());

    var Filters = {
        /** AutoComplete Filter (using jQuery UI autocomplete feature) */
        autoComplete: AutoCompleteFilter,
        /** Compound Date Filter (compound of Operator + Date picker) */
        compoundDate: CompoundDateFilter,
        /** Alias to compoundInputText to Compound Input Filter (compound of Operator + Input Text) */
        compoundInput: CompoundInputFilter,
        /** Compound Input Number Filter (compound of Operator + Input of type Number) */
        compoundInputNumber: CompoundInputNumberFilter,
        /** Compound Input Password Filter (compound of Operator + Input of type Password, also note that only the text shown in the UI will be masked, filter query is still plain text) */
        compoundInputPassword: CompoundInputPasswordFilter,
        /** Compound Input Text Filter (compound of Operator + Input Text) */
        compoundInputText: CompoundInputFilter,
        /** Compound Slider Filter (compound of Operator + Slider) */
        compoundSlider: CompoundSliderFilter,
        /** Range Date Filter (uses the Flactpickr Date picker with range option) */
        dateRange: DateRangeFilter,
        /** Alias to inputText, input type text filter */
        input: InputFilter,
        /**
         * Input Filter of type text that will be formatted with a mask output
         * e.g.: column: { filter: { model: Filters.inputMask }, params: { mask: '(000) 000-0000' }}
         */
        inputMask: InputMaskFilter,
        /** Input Filter of type Number */
        inputNumber: InputNumberFilter,
        /** Input Filter of type Password (note that only the text shown in the UI will be masked, filter query is still plain text) */
        inputPassword: InputPasswordFilter,
        /** Default Filter, input type text filter */
        inputText: InputFilter,
        /** Multiple Select filter, which uses 3rd party lib "multiple-select.js" */
        multipleSelect: MultipleSelectFilter,
        /** Select filter, which uses native DOM element select */
        select: NativeSelectFilter,
        /** Single Select filter, which uses 3rd party lib "multiple-select.js" */
        singleSelect: SingleSelectFilter,
        /** Slider Filter (only 1 value) */
        slider: SliderFilter,
        /** Slider Range Filter, uses jQuery UI Range Slider (2 values, lowest/highest search range) */
        sliderRange: SliderRangeFilter,
    };

    /** Global Grid Options Defaults */
    var GlobalGridOptions = {
        alwaysShowVerticalScroll: true,
        autoEdit: false,
        asyncEditorLoading: false,
        autoFitColumnsOnFirstLoad: true,
        autoResize: {
            calculateAvailableSizeBy: 'window',
            bottomPadding: 20,
            minHeight: 180,
            minWidth: 300,
            sidePadding: 0
        },
        cellHighlightCssClass: 'slick-cell-modified',
        checkboxSelector: {
            cssClass: 'slick-cell-checkboxsel'
        },
        columnPicker: {
            fadeSpeed: 0,
            hideForceFitButton: false,
            hideSyncResizeButton: true,
            headerColumnValueExtractor: pickerHeaderColumnValueExtractor
        },
        cellMenu: {
            autoAdjustDrop: true,
            autoAlignSide: true,
            hideCloseButton: true,
            hideCommandSection: false,
            hideOptionSection: false,
        },
        contextMenu: {
            autoAdjustDrop: true,
            autoAlignSide: true,
            hideCloseButton: true,
            hideClearAllGrouping: false,
            hideCollapseAllGroups: false,
            hideCommandSection: false,
            hideCopyCellValueCommand: false,
            hideExpandAllGroups: false,
            hideExportCsvCommand: false,
            hideExportExcelCommand: false,
            hideExportTextDelimitedCommand: true,
            hideMenuOnScroll: true,
            hideOptionSection: false,
            iconCopyCellValueCommand: 'fa fa-clone',
            iconExportCsvCommand: 'fa fa-download',
            iconExportExcelCommand: 'fa fa-file-excel-o text-success',
            iconExportTextDelimitedCommand: 'fa fa-download',
            width: 200,
        },
        customFooterOptions: {
            dateFormat: 'yyyy-MM-dd, hh:mm aaaaa\'m\'',
            hideTotalItemCount: false,
            hideLastUpdateTimestamp: true,
            footerHeight: 20,
            leftContainerClass: 'col-xs-12 col-sm-5',
            rightContainerClass: 'col-xs-6 col-sm-7',
            metricSeparator: '|',
            metricTexts: {
                items: 'items',
                of: 'of',
                itemsKey: 'ITEMS',
                ofKey: 'OF',
            }
        },
        dataView: {
            syncGridSelection: true,
            syncGridSelectionWithBackendService: false,
        },
        datasetIdPropertyName: 'id',
        defaultColumnSortFieldId: 'id',
        defaultFilter: Filters.input,
        enableFilterTrimWhiteSpace: false,
        defaultFilterPlaceholder: '&#128269;',
        defaultFilterRangeOperator: exports.OperatorType.rangeExclusive,
        editable: false,
        enableAutoResize: true,
        enableAutoSizeColumns: true,
        enableCellNavigation: false,
        enableColumnPicker: true,
        enableColumnReorder: true,
        enableContextMenu: true,
        enableExcelExport: true,
        enableExport: false,
        enableGridMenu: true,
        enableHeaderMenu: true,
        enableEmptyDataWarningMessage: true,
        emptyDataWarning: {
            className: 'slick-empty-data-warning',
            message: 'No data to display.',
            messageKey: 'EMPTY_DATA_WARNING_MESSAGE',
            hideFrozenLeftWarning: false,
            hideFrozenRightWarning: false,
            leftViewportMarginLeft: '40%',
            rightViewportMarginLeft: '40%',
            frozenLeftViewportMarginLeft: '0px',
            frozenRightViewportMarginLeft: '40%',
        },
        enableMouseHoverHighlightRow: true,
        enableSorting: true,
        enableTextSelectionOnCells: true,
        explicitInitialization: true,
        excelExportOptions: {
            addGroupIndentation: true,
            exportWithFormatter: false,
            filename: 'export',
            format: exports.FileType.xlsx,
            groupingColumnHeaderTitle: 'Group By',
            groupCollapsedSymbol: '\u25B9',
            groupExpandedSymbol: '\u25BF',
            groupingAggregatorRowText: '',
            sanitizeDataExport: false,
        },
        exportOptions: {
            delimiter: exports.DelimiterType.comma,
            exportWithFormatter: false,
            filename: 'export',
            format: exports.FileType.csv,
            groupingColumnHeaderTitle: 'Group By',
            groupingAggregatorRowText: '',
            sanitizeDataExport: false,
            useUtf8WithBom: true
        },
        forceFitColumns: false,
        frozenHeaderWidthCalcDifferential: 1,
        gridMenu: {
            hideClearAllFiltersCommand: false,
            hideClearAllSortingCommand: false,
            hideClearFrozenColumnsCommand: true,
            hideExportCsvCommand: false,
            hideExportExcelCommand: false,
            hideExportTextDelimitedCommand: true,
            hideForceFitButton: false,
            hideRefreshDatasetCommand: false,
            hideSyncResizeButton: true,
            hideToggleFilterCommand: false,
            hideTogglePreHeaderCommand: false,
            iconCssClass: 'fa fa-bars',
            iconClearAllFiltersCommand: 'fa fa-filter text-danger',
            iconClearAllSortingCommand: 'fa fa-unsorted text-danger',
            iconClearFrozenColumnsCommand: 'fa fa-times',
            iconExportCsvCommand: 'fa fa-download',
            iconExportExcelCommand: 'fa fa-file-excel-o text-success',
            iconExportTextDelimitedCommand: 'fa fa-download',
            iconRefreshDatasetCommand: 'fa fa-refresh',
            iconToggleFilterCommand: 'fa fa-random',
            iconTogglePreHeaderCommand: 'fa fa-random',
            menuWidth: 16,
            resizeOnShowHeaderRow: true,
            useClickToRepositionMenu: false,
            headerColumnValueExtractor: pickerHeaderColumnValueExtractor
        },
        headerMenu: {
            autoAlign: true,
            autoAlignOffset: 12,
            minWidth: 140,
            iconClearFilterCommand: 'fa fa-filter text-danger',
            iconClearSortCommand: 'fa fa-unsorted',
            iconFreezeColumns: 'fa fa-thumb-tack',
            iconSortAscCommand: 'fa fa-sort-amount-asc',
            iconSortDescCommand: 'fa fa-sort-amount-desc',
            iconColumnHideCommand: 'fa fa-times',
            hideColumnHideCommand: false,
            hideClearFilterCommand: false,
            hideClearSortCommand: false,
            hideFreezeColumnsCommand: true,
            hideSortCommands: false
        },
        headerRowHeight: 35,
        multiColumnSort: true,
        numberedMultiColumnSort: true,
        tristateMultiColumnSort: false,
        sortColNumberInSeparateSpan: true,
        suppressActiveCellChangeOnEdit: true,
        pagination: {
            pageSizes: [10, 15, 20, 25, 30, 40, 50, 75, 100],
            pageSize: 25,
            totalItems: 0
        },
        // technically speaking the Row Detail requires the process & viewComponent but we'll ignore it just to set certain options
        // @ts-ignore
        rowDetailView: {
            cssClass: 'detail-view-toggle',
            panelRows: 1,
            keyPrefix: '__',
            useRowClick: false,
            useSimpleViewportCalc: true,
            saveDetailViewOnScroll: false,
        },
        rowHeight: 35,
        topPanelHeight: 35,
        translationNamespaceSeparator: ':',
    };
    /**
     * Value Extractor for both ColumnPicker & GridMenu Picker
     * when using Column Header Grouping, we'll prefix the column group title
     * else we'll simply return the column name title
     */
    function pickerHeaderColumnValueExtractor(column) {
        var headerGroup = column && column.columnGroup || '';
        if (headerGroup) {
            return headerGroup + ' - ' + column.name;
        }
        return column && column.name || '';
    }

    var SlickgridConfig = /** @class */ (function () {
        function SlickgridConfig() {
            this.options = GlobalGridOptions;
        }
        return SlickgridConfig;
    }());

    var FilterFactory = /** @class */ (function () {
        function FilterFactory(config, translate, collectionService) {
            this.config = config;
            this.translate = translate;
            this.collectionService = collectionService;
            this._options = this.config.options;
        }
        // Uses the User model to create a new User
        FilterFactory.prototype.createFilter = function (columnFilter) {
            var filter;
            if (columnFilter && columnFilter.model) {
                filter = typeof columnFilter.model === 'function' ? new columnFilter.model(this.translate, this.collectionService) : columnFilter.model;
            }
            // fallback to the default filter
            if (!filter && this._options.defaultFilter) {
                filter = new this._options.defaultFilter(this.translate, this.collectionService);
            }
            return filter;
        };
        FilterFactory.ctorParameters = function () { return [
            { type: SlickgridConfig },
            { type: core$1.TranslateService, decorators: [{ type: core.Optional }] },
            { type: CollectionService }
        ]; };
        FilterFactory = __decorate([
            core.Injectable(),
            __param(1, core.Optional())
        ], FilterFactory);
        return FilterFactory;
    }());

    var isequal = isequal_; // patch to fix rollup to work
    // timer for keeping track of user typing waits
    var timer;
    var DEFAULT_FILTER_TYPING_DEBOUNCE = 500;
    var FilterService = /** @class */ (function () {
        function FilterService(filterFactory, sharedService) {
            this.filterFactory = filterFactory;
            this.sharedService = sharedService;
            this._isFilterFirstRender = true;
            this._firstColumnIdRendered = '';
            this._filtersMetadata = [];
            this._columnFilters = {};
            this.httpCancelRequests$ = new rxjs.Subject(); // this will be used to cancel any pending http request
            this.onFilterChanged = new rxjs.Subject();
            this.onFilterCleared = new rxjs.Subject();
            this._eventHandler = new Slick.EventHandler();
            this._onSearchChange = new Slick.Event();
        }
        Object.defineProperty(FilterService.prototype, "eventHandler", {
            /** Getter of the SlickGrid Event Handler */
            get: function () {
                return this._eventHandler;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FilterService.prototype, "isFilterFirstRender", {
            /** Getter to know if the filter was already rendered or if it was its first time render */
            get: function () {
                return this._isFilterFirstRender;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FilterService.prototype, "onSearchChange", {
            /** Getter of the SlickGrid Event Handler */
            get: function () {
                return this._onSearchChange;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FilterService.prototype, "_gridOptions", {
            /** Getter for the Grid Options pulled through the Grid Object */
            get: function () {
                return (this._grid && this._grid.getOptions) ? this._grid.getOptions() : {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FilterService.prototype, "_columnDefinitions", {
            /** Getter for the Column Definitions pulled through the Grid Object */
            get: function () {
                return (this._grid && this._grid.getColumns) ? this._grid.getColumns() : [];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FilterService.prototype, "_dataView", {
            /** Getter of SlickGrid DataView object */
            get: function () {
                return (this._grid && this._grid.getData) ? this._grid.getData() : {};
            },
            enumerable: true,
            configurable: true
        });
        FilterService.prototype.init = function (grid) {
            this._grid = grid;
            if (this._gridOptions && this._gridOptions.enableTreeData && this._gridOptions.treeDataOptions) {
                this._grid.setSortColumns([{ columnId: this._gridOptions.treeDataOptions.columnId, sortAsc: true }]);
            }
        };
        FilterService.prototype.dispose = function () {
            // unsubscribe all SlickGrid events
            if (this._eventHandler && this._eventHandler.unsubscribeAll) {
                this._eventHandler.unsubscribeAll();
            }
            if (rxjs.isObservable(this.httpCancelRequests$)) {
                this.httpCancelRequests$.next(); // this cancels any pending http requests
            }
            this.disposeColumnFilters();
            this._onSearchChange = null;
            this.addFilterTemplateToHeaderRow = null;
            this.customLocalFilter = null;
            this.callbackSearchEvent = null;
            this.handleBackendOnSearchChange = null;
            this.handleLocalOnSearchChange = null;
        };
        /**
         * Dispose of the filters, since it's a singleton, we don't want to affect other grids with same columns
         */
        FilterService.prototype.disposeColumnFilters = function () {
            // we need to loop through all columnFilters and delete them 1 by 1
            // only trying to make columnFilter an empty (without looping) would not trigger a dataset change
            if (typeof this._columnFilters === 'object') {
                for (var columnId in this._columnFilters) {
                    if (columnId && this._columnFilters[columnId]) {
                        delete this._columnFilters[columnId];
                    }
                }
            }
            // also destroy each Filter instances
            if (Array.isArray(this._filtersMetadata)) {
                this._filtersMetadata.forEach(function (filter) {
                    if (filter && filter.destroy) {
                        filter.destroy(true);
                    }
                });
            }
            this._filtersMetadata = [];
        };
        /**
         * When clearing or disposing of all filters, we need to loop through all columnFilters and delete them 1 by 1
         * only trying to make columnFilter an empty (without looping) would not trigger a dataset change
         */
        FilterService.prototype.resetColumnFilters = function () {
            if (typeof this._columnFilters === 'object') {
                for (var columnId in this._columnFilters) {
                    if (columnId && this._columnFilters[columnId]) {
                        delete this._columnFilters[columnId];
                    }
                }
            }
        };
        /**
         * Bind a backend filter hook to the grid
         * @param grid SlickGrid Grid object
         */
        FilterService.prototype.bindBackendOnFilter = function (grid) {
            this._filtersMetadata = [];
            // subscribe to SlickGrid onHeaderRowCellRendered event to create filter template
            this._eventHandler.subscribe(grid.onHeaderRowCellRendered, this.handleBackendOnSearchChange.bind(this));
            // subscribe to the SlickGrid event and call the backend execution
            if (this._onSearchChange) {
                this._eventHandler.subscribe(this._onSearchChange, this.onBackendFilterChange.bind(this));
            }
        };
        FilterService.prototype.handleBackendOnSearchChange = function (_e, args) {
            // firstColumnIdRendered is null at first, so if it changes to being filled and equal, then we would know that it was already rendered
            // this is to avoid rendering the filter twice (only the Select Filter for now), rendering it again also clears the filter which has unwanted side effect
            if (args.column.id === this._firstColumnIdRendered) {
                this._isFilterFirstRender = false;
            }
            this.addFilterTemplateToHeaderRow(null, args, this._isFilterFirstRender);
            if (this._firstColumnIdRendered === '') {
                this._firstColumnIdRendered = args.column.id;
            }
        };
        /**
         * Bind a local filter hook to the grid
         * @param grid SlickGrid Grid object
         * @param dataView
         */
        FilterService.prototype.bindLocalOnFilter = function (grid) {
            this._filtersMetadata = [];
            this._dataView.setFilterArgs({ columnFilters: this._columnFilters, grid: this._grid, dataView: this._dataView });
            this._dataView.setFilter(this.customLocalFilter.bind(this));
            // bind any search filter change (e.g. input filter input change event)
            if (this._onSearchChange) {
                this._eventHandler.subscribe(this._onSearchChange, this.handleLocalOnSearchChange.bind(this));
                // subscribe to SlickGrid onHeaderRowCellRendered event to create filter template
                this._eventHandler.subscribe(grid.onHeaderRowCellRendered, this.addFilterTemplateToHeaderRow.bind(this));
            }
        };
        FilterService.prototype.handleLocalOnSearchChange = function (_e, args) {
            var isGridWithTreeData = this._gridOptions && this._gridOptions.enableTreeData || false;
            // When using Tree Data, we need to do it in 2 steps
            // step 1. we need to prefilter (search) the data prior, the result will be an array of IDs which are the node(s) and their parent nodes when necessary.
            // step 2. calling the DataView.refresh() is what triggers the final filtering, with "customLocalFilter()" which will decide which rows should persist
            if (isGridWithTreeData) {
                this._tmpPreFilteredData = this.preFilterTreeData(this._dataView.getItems(), this._columnFilters);
            }
            var columnId = args.columnId;
            if (columnId !== null) {
                this._dataView.refresh();
            }
            // emit an onFilterChanged event when it's not called by a clear filter
            if (args && !args.clearFilterTriggered) {
                this.emitFilterChanged(exports.EmitterType.local);
            }
        };
        FilterService.prototype.clearFilterByColumnId = function (event, columnId) {
            // get current column filter before clearing, this allow us to know if the filter was empty prior to calling the clear filter
            var currentColumnFilters = Object.keys(this._columnFilters);
            var currentColFilter;
            if (Array.isArray(currentColumnFilters)) {
                currentColFilter = currentColumnFilters.find(function (name) { return name === columnId; });
            }
            // find the filter object and call its clear method with true (the argument tells the method it was called by a clear filter)
            var colFilter = this._filtersMetadata.find(function (filter) { return filter.columnDef.id === columnId; });
            if (colFilter && colFilter.clear) {
                colFilter.clear(true);
            }
            var emitter = exports.EmitterType.local;
            var isBackendApi = this._gridOptions && this._gridOptions.backendServiceApi || false;
            // when using a backend service, we need to manually trigger a filter change but only if the filter was previously filled
            if (isBackendApi) {
                emitter = exports.EmitterType.remote;
                if (currentColFilter) {
                    this.onBackendFilterChange(event, { grid: this._grid, columnFilters: this._columnFilters });
                }
            }
            // emit an event when filter is cleared
            this.emitFilterChanged(emitter);
        };
        /** Clear the search filters (below the column titles) */
        FilterService.prototype.clearFilters = function (triggerChange) {
            var _this = this;
            if (triggerChange === void 0) { triggerChange = true; }
            this._filtersMetadata.forEach(function (filter) {
                if (filter && filter.clear) {
                    // clear element but don't trigger individual clear change,
                    // we'll do 1 trigger for all filters at once afterward
                    filter.clear(false);
                }
            });
            // also reset the columnFilters object and remove any filters from the object
            this.resetColumnFilters();
            // we also need to refresh the dataView and optionally the grid (it's optional since we use DataView)
            if (this._dataView && this._grid) {
                this._dataView.refresh();
                this._grid.invalidate();
            }
            // when using backend service, we need to query only once so it's better to do it here
            var backendApi = this._gridOptions && this._gridOptions.backendServiceApi;
            if (backendApi && triggerChange) {
                var callbackArgs_1 = { clearFilterTriggered: true, shouldTriggerQuery: triggerChange, grid: this._grid, columnFilters: this._columnFilters };
                var queryResponse = backendApi.service.processOnFilterChanged(undefined, callbackArgs_1);
                if (queryResponse instanceof Promise && queryResponse.then) {
                    // @deprecated, processOnFilterChanged in the future should be returned as a query string NOT as a Promise
                    console.warn("[Angular-Slickgrid] please note that the \"processOnFilterChanged\" from your Backend Service, should now return a string instead of a Promise.\n          Returning a Promise will be deprecated in the future.");
                    queryResponse.then(function (query) {
                        var totalItems = _this._gridOptions && _this._gridOptions.pagination && _this._gridOptions.pagination.totalItems;
                        executeBackendCallback(backendApi, query, callbackArgs_1, new Date(), totalItems, _this.emitFilterChanged.bind(_this));
                    });
                }
                else {
                    var query = queryResponse;
                    var totalItems = this._gridOptions && this._gridOptions.pagination && this._gridOptions.pagination.totalItems;
                    executeBackendCallback(backendApi, query, callbackArgs_1, new Date(), totalItems, this.emitFilterChanged.bind(this));
                }
            }
            // emit an event when filters are all cleared
            if (triggerChange) {
                this.onFilterCleared.next(true);
            }
        };
        /** Local Grid Filter search */
        FilterService.prototype.customLocalFilter = function (item, args) {
            var e_1, _a;
            var dataView = args && args.dataView;
            var grid = args && args.grid;
            var isGridWithTreeData = this._gridOptions && this._gridOptions.enableTreeData || false;
            var columnFilters = args && args.columnFilters || {};
            var treeDataOptions;
            // when the column is a Tree Data structure and the parent is collapsed, we won't go further and just continue with next row
            // so we always run this check even when there are no filter search, the reason is because the user might click on the expand/collapse
            if (isGridWithTreeData && this._gridOptions && this._gridOptions.treeDataOptions) {
                treeDataOptions = this._gridOptions.treeDataOptions;
                var collapsedPropName = treeDataOptions.collapsedPropName || '__collapsed';
                var parentPropName = treeDataOptions.parentPropName || '__parentId';
                var dataViewIdIdentifier = this._gridOptions.datasetIdPropertyName || 'id';
                if (item[parentPropName] !== null) {
                    var parent_1 = this._dataView.getItemById(item[parentPropName]);
                    while (parent_1) {
                        if (parent_1[collapsedPropName]) {
                            return false; // don't display any row that have their parent collapsed
                        }
                        parent_1 = this._dataView.getItemById(parent_1[parentPropName]);
                    }
                }
                // filter out any row items that aren't part of our pre-processed "preFilterTreeData()" result
                if (Array.isArray(this._tmpPreFilteredData)) {
                    return this._tmpPreFilteredData.includes(item[dataViewIdIdentifier]); // return true when found, false otherwise
                }
            }
            else {
                if (typeof columnFilters === 'object') {
                    try {
                        for (var _b = __values(Object.keys(columnFilters)), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var columnId = _c.value;
                            var columnFilter = columnFilters[columnId];
                            var conditionOptions = this.getFilterConditionOptionsOrBoolean(item, columnFilter, columnId, grid, dataView);
                            if (typeof conditionOptions === 'boolean') {
                                return conditionOptions;
                            }
                            if (!FilterConditions.executeMappedCondition(conditionOptions)) {
                                return false;
                            }
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
            }
            // if it reaches here, that means the row is valid and passed all filter
            return true;
        };
        FilterService.prototype.getFilterConditionOptionsOrBoolean = function (item, columnFilter, columnId, grid, dataView) {
            var columnIndex = grid.getColumnIndex(columnId);
            var columnDef = grid.getColumns()[columnIndex];
            // it might be a hidden column, if so it won't be part of the getColumns (because it we hide a column via setColumns)
            // when that happens we can try to get the column definition from all defined columns
            if (!columnDef && this.sharedService && Array.isArray(this.sharedService.allColumns)) {
                columnIndex = this.sharedService.allColumns.findIndex(function (col) { return col.field === columnId; });
                columnDef = this.sharedService.allColumns[columnIndex];
            }
            // if we still don't have a column definition then we should return then row anyway (true)
            if (!columnDef) {
                return true;
            }
            // Row Detail View plugin, if the row is padding we just get the value we're filtering on from it's parent
            if (this._gridOptions.enableRowDetailView) {
                var metadataPrefix = this._gridOptions.rowDetailView && this._gridOptions.rowDetailView.keyPrefix || '__';
                if (item[metadataPrefix + "isPadding"] && item[metadataPrefix + "parent"]) {
                    item = item[metadataPrefix + "parent"];
                }
            }
            var dataKey = columnDef.dataKey;
            var queryFieldName = (columnDef.filter && columnDef.filter.queryField) || columnDef.queryFieldFilter || columnDef.queryField || columnDef.field || '';
            if (typeof columnDef.queryFieldNameGetterFn === 'function') {
                queryFieldName = columnDef.queryFieldNameGetterFn(item);
            }
            var fieldType = (columnDef.filter && columnDef.filter.type) || columnDef.type || exports.FieldType.string;
            var filterSearchType = (columnDef.filterSearchType) ? columnDef.filterSearchType : null;
            var cellValue = item[queryFieldName];
            // when item is a complex object (dot "." notation), we need to filter the value contained in the object tree
            if (queryFieldName && queryFieldName.indexOf('.') >= 0) {
                cellValue = getDescendantProperty(item, queryFieldName);
            }
            // if we find searchTerms use them but make a deep copy so that we don't affect original array
            // we might have to overwrite the value(s) locally that are returned
            // e.g: we don't want to operator within the search value, since it will fail filter condition check trigger afterward
            var searchValues = (columnFilter && columnFilter.searchTerms) ? $.extend(true, [], columnFilter.searchTerms) : [];
            var fieldSearchValue = (Array.isArray(searchValues) && searchValues.length === 1) ? searchValues[0] : '';
            var matches = null;
            if (fieldType !== exports.FieldType.object) {
                fieldSearchValue = '' + fieldSearchValue; // make sure it's a string
                matches = fieldSearchValue.match(/^([<>!=\*]{0,2})(.*[^<>!=\*])([\*]?)$/); // group 1: Operator, 2: searchValue, 3: last char is '*' (meaning starts with, ex.: abc*)
            }
            var operator = columnFilter.operator || ((matches) ? matches[1] : '');
            var searchTerm = (!!matches) ? matches[2] : '';
            var lastValueChar = (!!matches) ? matches[3] : (operator === '*z' ? '*' : '');
            if (searchValues && searchValues.length > 1) {
                fieldSearchValue = searchValues.join(',');
            }
            else if (typeof fieldSearchValue === 'string') {
                // escaping the search value
                fieldSearchValue = fieldSearchValue.replace("'", "''"); // escape single quotes by doubling them
                if (operator === '*' || operator === 'a*' || operator === '*z' || lastValueChar === '*') {
                    operator = (operator === '*' || operator === '*z') ? exports.OperatorType.endsWith : exports.OperatorType.startsWith;
                }
            }
            // no need to query if search value is empty or if the search value is in fact equal to the operator
            if (searchTerm === '' && (!searchValues || (Array.isArray(searchValues) && (searchValues.length === 0 || searchValues.length === 1 && operator === searchValues[0])))) {
                return true;
            }
            // if search value has a regex match we will only keep the value without the operator
            // in this case we need to overwrite the returned search values to truncate operator from the string search
            if (Array.isArray(matches) && matches.length >= 1 && (Array.isArray(searchValues) && searchValues.length === 1)) {
                searchValues[0] = searchTerm;
            }
            // filter search terms should always be string type (even though we permit the end user to input numbers)
            // so make sure each term are strings, if user has some default search terms, we will cast them to string
            if (searchValues && Array.isArray(searchValues) && fieldType !== exports.FieldType.object) {
                for (var k = 0, ln = searchValues.length; k < ln; k++) {
                    // make sure all search terms are strings
                    searchValues[k] = ((searchValues[k] === undefined || searchValues[k] === null) ? '' : searchValues[k]) + '';
                }
            }
            // when using localization (i18n), we should use the formatter output to search as the new cell value
            if (columnDef && columnDef.params && columnDef.params.useFormatterOuputToFilter) {
                var idPropName = this._gridOptions.datasetIdPropertyName || 'id';
                var rowIndex = (dataView && typeof dataView.getIdxById === 'function') ? dataView.getIdxById(item[idPropName]) : 0;
                cellValue = (columnDef && typeof columnDef.formatter === 'function') ? columnDef.formatter(rowIndex, columnIndex, cellValue, columnDef, item, this._grid) : '';
            }
            // make sure cell value is always a string
            if (typeof cellValue === 'number') {
                cellValue = cellValue.toString();
            }
            var currentCellValue = cellValue;
            return {
                dataKey: dataKey,
                fieldType: fieldType,
                searchTerms: searchValues,
                cellValue: currentCellValue,
                operator: operator,
                cellValueLastChar: lastValueChar,
                filterSearchType: filterSearchType
            };
        };
        /**
         * When using Tree Data, we need to prefilter (search) the data prior, the result will be an array of IDs which are the node(s) and their parent nodes when necessary.
         * This will then be passed to the DataView setFilter(customLocalFilter), which will itself loop through the list of IDs and display/hide the row if found that array of IDs
         * We do this in 2 steps so that we can still use the DataSet setFilter()
         */
        FilterService.prototype.preFilterTreeData = function (inputArray, columnFilters) {
            var e_2, _a;
            var treeDataOptions = this._gridOptions && this._gridOptions.treeDataOptions;
            var parentPropName = treeDataOptions && treeDataOptions.parentPropName || '__parentId';
            var dataViewIdIdentifier = this._gridOptions && this._gridOptions.datasetIdPropertyName || 'id';
            var treeObj = {};
            var filteredChildrenAndParents = [];
            if (Array.isArray(inputArray)) {
                for (var i = 0; i < inputArray.length; i++) {
                    treeObj[inputArray[i][dataViewIdIdentifier]] = inputArray[i];
                    // as the filtered data is then used again as each subsequent letter
                    // we need to delete the .__used property, otherwise the logic below
                    // in the while loop (which checks for parents) doesn't work:
                    delete treeObj[inputArray[i][dataViewIdIdentifier]].__used;
                }
                for (var i = 0; i < inputArray.length; i++) {
                    var item = inputArray[i];
                    var matchFilter = true; // valid until proven otherwise
                    try {
                        // loop through all column filters and execute filter condition(s)
                        for (var _b = (e_2 = void 0, __values(Object.keys(columnFilters))), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var columnId = _c.value;
                            var columnFilter = columnFilters[columnId];
                            var conditionOptionResult = this.getFilterConditionOptionsOrBoolean(item, columnFilter, columnId, this._grid, this._dataView);
                            if (conditionOptionResult) {
                                var conditionResult = (typeof conditionOptionResult === 'boolean') ? conditionOptionResult : FilterConditions.executeMappedCondition(conditionOptionResult);
                                if (conditionResult) {
                                    // don't return true since we still need to check other keys in columnFilters
                                    continue;
                                }
                            }
                            matchFilter = false;
                            continue;
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                    // build an array from the matched filters, anything valid from filter condition
                    // will be pushed to the filteredChildrenAndParents array
                    if (matchFilter) {
                        var len = filteredChildrenAndParents.length;
                        // add child (id):
                        filteredChildrenAndParents.splice(len, 0, item[dataViewIdIdentifier]);
                        var parent_2 = treeObj[item[parentPropName]] || false;
                        while (parent_2) {
                            // only add parent (id) if not already added:
                            parent_2.__used || filteredChildrenAndParents.splice(len, 0, parent_2[dataViewIdIdentifier]);
                            // mark each parent as used to not use them again later:
                            treeObj[parent_2[dataViewIdIdentifier]].__used = true;
                            // try to find parent of the current parent, if exists:
                            parent_2 = treeObj[parent_2[parentPropName]] || false;
                        }
                    }
                }
            }
            return filteredChildrenAndParents;
        };
        FilterService.prototype.getColumnFilters = function () {
            return this._columnFilters;
        };
        FilterService.prototype.getFiltersMetadata = function () {
            return this._filtersMetadata;
        };
        FilterService.prototype.getCurrentLocalFilters = function () {
            var e_3, _a;
            var currentFilters = [];
            if (this._columnFilters) {
                try {
                    for (var _b = __values(Object.keys(this._columnFilters)), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var colId = _c.value;
                        var columnFilter = this._columnFilters[colId];
                        var filter = { columnId: colId || '' };
                        if (columnFilter && columnFilter.searchTerms) {
                            filter.searchTerms = columnFilter.searchTerms;
                        }
                        if (columnFilter.operator) {
                            filter.operator = columnFilter.operator;
                        }
                        if (Array.isArray(filter.searchTerms) && filter.searchTerms.length > 0 && filter.searchTerms[0] !== '') {
                            currentFilters.push(filter);
                        }
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
            }
            return currentFilters;
        };
        /**
         * A simple function that is binded to the subscriber and emit a change when the filter is called.
         * Other services, like Pagination, can then subscribe to it.
         * @param caller
         */
        FilterService.prototype.emitFilterChanged = function (caller) {
            if (caller === exports.EmitterType.remote && this._gridOptions && this._gridOptions.backendServiceApi) {
                var currentFilters = [];
                var backendService = this._gridOptions.backendServiceApi.service;
                if (backendService && backendService.getCurrentFilters) {
                    currentFilters = backendService.getCurrentFilters();
                }
                this.onFilterChanged.next(currentFilters);
            }
            else if (caller === exports.EmitterType.local) {
                this.onFilterChanged.next(this.getCurrentLocalFilters());
            }
        };
        FilterService.prototype.onBackendFilterChange = function (event, args) {
            return __awaiter(this, void 0, void 0, function () {
                var backendApi, startTime, debounceTypingDelay, isTriggeredByClearFilter, eventType, eventKeyCode, query, totalItems;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!args || !args.grid) {
                                throw new Error('Something went wrong when trying to bind the "onBackendFilterChange(event, args)" function, it seems that "args" is not populated correctly');
                            }
                            backendApi = this._gridOptions.backendServiceApi;
                            if (!backendApi || !backendApi.process || !backendApi.service) {
                                throw new Error("BackendServiceApi requires at least a \"process\" function and a \"service\" defined");
                            }
                            startTime = new Date();
                            // run a preProcess callback if defined
                            if (backendApi.preProcess) {
                                backendApi.preProcess();
                            }
                            debounceTypingDelay = 0;
                            isTriggeredByClearFilter = args && args.clearFilterTriggered;
                            eventType = event && event.type;
                            eventKeyCode = event && event.keyCode;
                            if (!isTriggeredByClearFilter && eventKeyCode !== exports.KeyCode.ENTER && (eventType === 'input' || eventType === 'keyup' || eventType === 'keydown')) {
                                debounceTypingDelay = backendApi.hasOwnProperty('filterTypingDebounce') ? backendApi.filterTypingDebounce : DEFAULT_FILTER_TYPING_DEBOUNCE;
                            }
                            if (!(args && args.shouldTriggerQuery)) return [3 /*break*/, 3];
                            // call the service to get a query back
                            // @deprecated TODO: remove async/await on next major change, refer to processOnFilterChanged in BackendService interface (with @deprecated)
                            clearTimeout(timer);
                            if (!(debounceTypingDelay > 0)) return [3 /*break*/, 1];
                            timer = setTimeout(function () { return __awaiter(_this, void 0, void 0, function () {
                                var query, totalItems;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, backendApi.service.processOnFilterChanged(event, args)];
                                        case 1:
                                            query = _a.sent();
                                            totalItems = this._gridOptions && this._gridOptions.pagination && this._gridOptions.pagination.totalItems;
                                            executeBackendCallback(backendApi, query, args, startTime, totalItems, this.emitFilterChanged.bind(this), this.httpCancelRequests$);
                                            return [2 /*return*/];
                                    }
                                });
                            }); }, debounceTypingDelay);
                            return [3 /*break*/, 3];
                        case 1: return [4 /*yield*/, backendApi.service.processOnFilterChanged(event, args)];
                        case 2:
                            query = _a.sent();
                            totalItems = this._gridOptions && this._gridOptions.pagination && this._gridOptions.pagination.totalItems;
                            executeBackendCallback(backendApi, query, args, startTime, totalItems, this.emitFilterChanged.bind(this), this.httpCancelRequests$);
                            _a.label = 3;
                        case 3: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * When user passes an array of preset filters, we need to pre-populate each column filter searchTerm(s)
         * The process is to loop through the preset filters array, find the associated column from columnDefinitions and fill in the filter object searchTerm(s)
         * This is basically the same as if we would manually add searchTerm(s) to a column filter object in the column definition, but we do it programmatically.
         * At the end of the day, when creating the Filter (DOM Element), it will use these searchTerm(s) so we can take advantage of that without recoding each Filter type (DOM element)
         */
        FilterService.prototype.populateColumnFilterSearchTermPresets = function (filters) {
            if (Array.isArray(filters) && filters.length > 0) {
                this._columnDefinitions.forEach(function (columnDef) {
                    // clear any columnDef searchTerms before applying Presets
                    if (columnDef.filter && columnDef.filter.searchTerms) {
                        delete columnDef.filter.searchTerms;
                    }
                    // from each presets, we will find the associated columnDef and apply the preset searchTerms & operator if there is
                    var columnPreset = filters.find(function (presetFilter) { return presetFilter.columnId === columnDef.id; });
                    if (columnPreset && columnPreset.searchTerms && Array.isArray(columnPreset.searchTerms)) {
                        columnDef.filter = columnDef.filter || {};
                        columnDef.filter.operator = columnPreset.operator || columnDef.filter.operator || '';
                        columnDef.filter.searchTerms = columnPreset.searchTerms;
                    }
                });
                // when we have a Filter Presets on a Tree Data View grid, we need to call the pre-filtering of tree data
                this.refreshTreeDataFilters();
            }
            return this._columnDefinitions;
        };
        /**
         * when we have a Filter Presets on a Tree Data View grid, we need to call the pre-filtering of tree data
         * we need to do this because Tree Data is the only type of grid that requires a pre-filter (preFilterTreeData) to be executed before the final filtering
         * @param filters
         */
        FilterService.prototype.refreshTreeDataFilters = function () {
            if (this._dataView && this._dataView.getItems && this._gridOptions && this._gridOptions.enableTreeData) {
                this._tmpPreFilteredData = this.preFilterTreeData(this._dataView.getItems(), this._columnFilters);
                this._dataView.refresh(); // and finally this refresh() is what triggers a DataView filtering check
            }
        };
        /**
         * Toggle the Filter Functionality
         * @param {boolean} isFilterDisabled - optionally force a disable/enable of the Sort Functionality? Defaults to True
         * @param {boolean} clearFiltersWhenDisabled - when disabling the Filter, do we also want to clear all the filters as well? Defaults to True
         */
        FilterService.prototype.disableFilterFunctionality = function (isFilterDisabled, clearFiltersWhenDisabled) {
            if (isFilterDisabled === void 0) { isFilterDisabled = true; }
            if (clearFiltersWhenDisabled === void 0) { clearFiltersWhenDisabled = true; }
            var prevShowFilterFlag = this._gridOptions.enableFiltering;
            var newShowFilterFlag = !prevShowFilterFlag;
            if (newShowFilterFlag !== isFilterDisabled) {
                if (clearFiltersWhenDisabled && isFilterDisabled) {
                    this.clearFilters();
                }
                this.disableAllFilteringCommands(isFilterDisabled);
                this._grid.setOptions({ enableFiltering: newShowFilterFlag }, false, true);
                this._grid.setHeaderRowVisibility(newShowFilterFlag);
                this._gridOptions.enableFiltering = !isFilterDisabled;
                this.sharedService.gridOptions = this._gridOptions;
                // when displaying header row, we'll call "setColumns" which in terms will recreate the header row filters
                this._grid.setColumns(this.sharedService.columnDefinitions);
            }
        };
        /**
         * Toggle the Filter Functionality (show/hide the header row filter bar as well)
         * @param {boolean} clearFiltersWhenDisabled - when disabling the filters, do we want to clear the filters before hiding the filters? Defaults to True
         */
        FilterService.prototype.toggleFilterFunctionality = function (clearFiltersWhenDisabled) {
            if (clearFiltersWhenDisabled === void 0) { clearFiltersWhenDisabled = true; }
            var prevShowFilterFlag = this._gridOptions.enableFiltering;
            this.disableFilterFunctionality(prevShowFilterFlag, clearFiltersWhenDisabled);
        };
        /**
         * Toggle the Header Row filter bar (this does not disable the Filtering itself, you can use "toggleFilterFunctionality()" instead, however this will reset any column positions)
         */
        FilterService.prototype.toggleHeaderFilterRow = function () {
            var showHeaderRow = this._gridOptions && this._gridOptions.showHeaderRow || false;
            showHeaderRow = !showHeaderRow; // inverse show header flag
            this._grid.setHeaderRowVisibility(showHeaderRow);
            // when displaying header row, we'll call "setColumns" which in terms will recreate the header row filters
            if (showHeaderRow === true) {
                this._grid.setColumns(this.sharedService.columnDefinitions);
            }
        };
        /**
         * Set the sort icons in the UI (ONLY the icons, it does not do any sorting)
         * The column sort icons are not necessarily inter-connected to the sorting functionality itself,
         * you can change the sorting icons separately by passing an array of columnId/sortAsc and that will change ONLY the icons
         * @param sortColumns
         */
        FilterService.prototype.setSortColumnIcons = function (sortColumns) {
            if (this._grid && Array.isArray(sortColumns)) {
                this._grid.setSortColumns(sortColumns);
            }
        };
        /**
         * Update Filters dynamically just by providing an array of filter(s).
         * You can also choose emit (default) a Filter Changed event that will be picked by the Grid State Service.
         *
         * Also for backend service only, you can choose to trigger a backend query (default) or not if you wish to do it later,
         * this could be useful when using updateFilters & updateSorting and you wish to only send the backend query once.
         * @param filters array
         * @param triggerEvent defaults to True, do we want to emit a filter changed event?
         * @param triggerBackendQuery defaults to True, which will query the backend.
         */
        FilterService.prototype.updateFilters = function (filters, emitChangedEvent, triggerBackendQuery, triggerOnSearchChangeEvent) {
            var _this = this;
            if (emitChangedEvent === void 0) { emitChangedEvent = true; }
            if (triggerBackendQuery === void 0) { triggerBackendQuery = true; }
            if (triggerOnSearchChangeEvent === void 0) { triggerOnSearchChangeEvent = false; }
            if (!this._filtersMetadata || this._filtersMetadata.length === 0 || !this._gridOptions || !this._gridOptions.enableFiltering) {
                throw new Error('[Angular-Slickgrid] in order to use "updateFilters" method, you need to have Filterable Columns defined in your grid and "enableFiltering" set in your Grid Options');
            }
            if (Array.isArray(filters)) {
                // start by clearing all filters (without triggering an event) before applying any new filters
                this.clearFilters(false);
                // pre-fill (value + operator) and render all filters in the DOM
                // loop through each Filters provided (which has a columnId property)
                // then find their associated Filter instances that were originally created in the grid
                filters.forEach(function (newFilter) {
                    var uiFilter = _this._filtersMetadata.find(function (filter) { return newFilter.columnId === filter.columnDef.id; });
                    if (newFilter && uiFilter) {
                        var newOperator = newFilter.operator || uiFilter.defaultOperator;
                        _this.updateColumnFilters(newFilter.searchTerms, uiFilter.columnDef, newOperator);
                        uiFilter.setValues(newFilter.searchTerms, newOperator);
                        if (triggerOnSearchChangeEvent) {
                            _this.callbackSearchEvent(null, { columnDef: uiFilter.columnDef, operator: newOperator, searchTerms: newFilter.searchTerms, shouldTriggerQuery: true });
                        }
                    }
                });
                var backendApi = this._gridOptions && this._gridOptions.backendServiceApi;
                // refresh the DataView and trigger an event after all filters were updated and rendered
                this._dataView.refresh();
                if (backendApi) {
                    var backendApiService = backendApi && backendApi.service;
                    if (backendApiService) {
                        backendApiService.updateFilters(filters, true);
                        if (triggerBackendQuery) {
                            refreshBackendDataset(this._gridOptions);
                        }
                    }
                }
                if (emitChangedEvent) {
                    var emitterType = backendApi ? exports.EmitterType.remote : exports.EmitterType.local;
                    this.emitFilterChanged(emitterType);
                }
            }
        };
        // --
        // private functions
        // -------------------
        /** Add all created filters (from their template) to the header row section area */
        FilterService.prototype.addFilterTemplateToHeaderRow = function (_event, args, isFilterFirstRender) {
            if (isFilterFirstRender === void 0) { isFilterFirstRender = true; }
            var columnDef = args.column;
            var columnId = columnDef && columnDef.id || '';
            if (columnDef && columnId !== 'selector' && columnDef.filterable) {
                var searchTerms = void 0;
                var operator = void 0;
                var newFilter_1 = this.filterFactory.createFilter(args.column.filter);
                operator = (columnDef && columnDef.filter && columnDef.filter.operator) || (newFilter_1 && newFilter_1.operator) || undefined;
                if (this._columnFilters[columnDef.id]) {
                    searchTerms = this._columnFilters[columnDef.id].searchTerms || undefined;
                    operator = this._columnFilters[columnDef.id].operator || undefined;
                }
                else if (columnDef.filter) {
                    // when hiding/showing (with Column Picker or Grid Menu), it will try to re-create yet again the filters (since SlickGrid does a re-render)
                    // because of that we need to first get searchTerm(s) from the columnFilters (that is what the user last typed in a filter search input)
                    searchTerms = columnDef.filter.searchTerms || undefined;
                    this.updateColumnFilters(searchTerms, columnDef, operator);
                }
                var filterArguments = {
                    grid: this._grid,
                    operator: operator,
                    searchTerms: searchTerms,
                    columnDef: columnDef,
                    callback: this.callbackSearchEvent.bind(this)
                };
                if (newFilter_1) {
                    newFilter_1.init(filterArguments, isFilterFirstRender);
                    var filterExistIndex = this._filtersMetadata.findIndex(function (filter) { return newFilter_1.columnDef.id === filter.columnDef.id; });
                    // add to the filters arrays or replace it when found
                    if (filterExistIndex === -1) {
                        this._filtersMetadata.push(newFilter_1);
                    }
                    else {
                        this._filtersMetadata[filterExistIndex] = newFilter_1;
                    }
                    // when hiding/showing (with Column Picker or Grid Menu), it will try to re-create yet again the filters (since SlickGrid does a re-render)
                    // we need to also set again the values in the DOM elements if the values were set by a searchTerm(s)
                    if (searchTerms && newFilter_1.setValues) {
                        newFilter_1.setValues(searchTerms);
                    }
                }
            }
        };
        /**
         * Callback method that is called and executed by the individual Filter (DOM element),
         * for example when user type in a word to search (which uses InputFilter), this Filter will execute the callback from an input change event.
         */
        FilterService.prototype.callbackSearchEvent = function (event, args) {
            if (args) {
                var searchTerm = ((event && event.target) ? event.target.value : undefined);
                var searchTerms = (args.searchTerms && Array.isArray(args.searchTerms)) ? args.searchTerms : (searchTerm ? [searchTerm] : undefined);
                var columnDef = args.columnDef || null;
                var columnId = columnDef && columnDef.id || '';
                var operator = args.operator || undefined;
                var hasSearchTerms = searchTerms && Array.isArray(searchTerms);
                var termsCount = hasSearchTerms && searchTerms && searchTerms.length;
                var oldColumnFilters = __assign({}, this._columnFilters);
                if (columnDef && columnId) {
                    if (!hasSearchTerms || termsCount === 0 || (termsCount === 1 && Array.isArray(searchTerms) && searchTerms[0] === '')) {
                        // delete the property from the columnFilters when it becomes empty
                        // without doing this, it would leave an incorrect state of the previous column filters when filtering on another column
                        delete this._columnFilters[columnId];
                    }
                    else {
                        var colId = '' + columnId;
                        var colFilter = {
                            columnId: colId,
                            columnDef: columnDef,
                            searchTerms: searchTerms,
                        };
                        if (operator) {
                            colFilter.operator = operator;
                        }
                        this._columnFilters[colId] = colFilter;
                    }
                }
                // event might have been created as a CustomEvent (e.g. CompoundDateFilter), without being a valid Slick.EventData,
                // if so we will create a new Slick.EventData and merge it with that CustomEvent to avoid having SlickGrid errors
                var eventData = (event && typeof event.isPropagationStopped !== 'function') ? $.extend({}, new Slick.EventData(), event) : event;
                // trigger an event only if Filters changed or if ENTER key was pressed
                var eventKey = event && event.key;
                var eventKeyCode = event && event.keyCode;
                if (this._onSearchChange && (eventKey === 'Enter' || eventKeyCode === exports.KeyCode.ENTER || !isequal(oldColumnFilters, this._columnFilters))) {
                    this._onSearchChange.notify({
                        clearFilterTriggered: args.clearFilterTriggered,
                        shouldTriggerQuery: args.shouldTriggerQuery,
                        columnId: columnId,
                        columnDef: columnDef,
                        columnFilters: this._columnFilters,
                        operator: operator,
                        searchTerms: searchTerms,
                        grid: this._grid
                    }, eventData);
                }
            }
        };
        /**
         * Loop through all column definitions and do the following thing
         * 1. loop through each Header Menu commands and change the "hidden" commands to show/hide depending if it's enabled/disabled
         * Also note that we aren't deleting any properties, we just toggle their flags so that we can reloop through at later point in time.
         * (if we previously deleted these properties we wouldn't be able to change them back since these properties wouldn't exist anymore, hence why we just hide the commands)
         * @param {boolean} isDisabling - are we disabling the filter functionality? Defaults to true
         */
        FilterService.prototype.disableAllFilteringCommands = function (isDisabling) {
            if (isDisabling === void 0) { isDisabling = true; }
            var columnDefinitions = this._grid.getColumns();
            // loop through column definition to hide/show header menu commands
            columnDefinitions.forEach(function (col) {
                if (col && col.header && col.header.menu) {
                    col.header.menu.items.forEach(function (menuItem) {
                        if (menuItem && typeof menuItem !== 'string') {
                            var menuCommand = menuItem.command;
                            if (menuCommand === 'clear-filter') {
                                menuItem.hidden = isDisabling;
                            }
                        }
                    });
                }
            });
            // loop through column definition to hide/show grid menu commands
            if (this._gridOptions && this._gridOptions.gridMenu && this._gridOptions.gridMenu.customItems) {
                this._gridOptions.gridMenu.customItems.forEach(function (menuItem) {
                    if (menuItem && typeof menuItem !== 'string') {
                        var menuCommand = menuItem.command;
                        if (menuCommand === 'clear-filter' || menuCommand === 'toggle-filter') {
                            menuItem.hidden = isDisabling;
                        }
                    }
                });
            }
            return columnDefinitions;
        };
        FilterService.prototype.updateColumnFilters = function (searchTerms, columnDef, operator) {
            if (searchTerms && columnDef) {
                this._columnFilters[columnDef.id] = {
                    columnId: columnDef.id,
                    columnDef: columnDef,
                    searchTerms: searchTerms,
                    operator: operator
                };
            }
        };
        FilterService.ctorParameters = function () { return [
            { type: FilterFactory },
            { type: SharedService }
        ]; };
        FilterService = __decorate([
            core.Injectable()
        ], FilterService);
        return FilterService;
    }());

    var SortService = /** @class */ (function () {
        function SortService(sharedService) {
            this.sharedService = sharedService;
            this._currentLocalSorters = [];
            this._isBackendGrid = false;
            this.httpCancelRequests$ = new rxjs.Subject(); // this will be used to cancel any pending http request
            this.onSortChanged = new rxjs.Subject();
            this.onSortCleared = new rxjs.Subject();
            this._eventHandler = new Slick.EventHandler();
        }
        Object.defineProperty(SortService.prototype, "eventHandler", {
            /** Getter of the SlickGrid Event Handler */
            get: function () {
                return this._eventHandler;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SortService.prototype, "_gridOptions", {
            /** Getter for the Grid Options pulled through the Grid Object */
            get: function () {
                return (this._grid && this._grid.getOptions) ? this._grid.getOptions() : {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SortService.prototype, "_columnDefinitions", {
            /** Getter for the Column Definitions pulled through the Grid Object */
            get: function () {
                return (this._grid && this._grid.getColumns) ? this._grid.getColumns() : [];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SortService.prototype, "_dataView", {
            /** Getter of SlickGrid DataView object */
            get: function () {
                return (this._grid && this._grid.getData) ? this._grid.getData() : {};
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Bind a backend sort (single/multi) hook to the grid
         * @param grid SlickGrid Grid object
         * @param dataView SlickGrid DataView object
         */
        SortService.prototype.bindBackendOnSort = function (grid) {
            this._isBackendGrid = true;
            this._grid = grid;
            // subscribe to the SlickGrid event and call the backend execution
            this._eventHandler.subscribe(grid.onSort, this.onBackendSortChanged.bind(this));
        };
        /**
         * Bind a local sort (single/multi) hook to the grid
         * @param grid SlickGrid Grid object
         * @param gridOptions Grid Options object
         * @param dataView
         */
        SortService.prototype.bindLocalOnSort = function (grid) {
            this._isBackendGrid = false;
            this._grid = grid;
            this.processTreeDataInitialSort();
            this._eventHandler.subscribe(grid.onSort, this.handleLocalOnSort.bind(this));
        };
        SortService.prototype.handleLocalOnSort = function (_e, args) {
            var _this = this;
            if (args && (args.sortCols || args.sortCol)) {
                // multiSort and singleSort are not exactly the same, but we want to structure it the same for the (for loop) after
                // also to avoid having to rewrite the for loop in the sort, we will make the singleSort an array of 1 object
                var sortColumns = (args.multiColumnSort) ? args.sortCols : new Array({ sortAsc: args.sortAsc, sortCol: args.sortCol });
                // keep current sorters
                this._currentLocalSorters = []; // reset current local sorters
                if (Array.isArray(sortColumns)) {
                    sortColumns.forEach(function (sortColumn) {
                        if (sortColumn.sortCol) {
                            _this._currentLocalSorters.push({
                                columnId: sortColumn.sortCol.id,
                                direction: sortColumn.sortAsc ? exports.SortDirection.ASC : exports.SortDirection.DESC
                            });
                        }
                    });
                }
                this.onLocalSortChanged(this._grid, sortColumns);
                this.emitSortChanged(exports.EmitterType.local);
            }
        };
        SortService.prototype.clearSortByColumnId = function (event, columnId) {
            // get previously sorted columns
            var allSortedCols = this.getCurrentColumnSorts();
            var sortedColsWithoutCurrent = this.getCurrentColumnSorts("" + columnId);
            if (Array.isArray(allSortedCols) && Array.isArray(sortedColsWithoutCurrent) && allSortedCols.length !== sortedColsWithoutCurrent.length) {
                if (this._gridOptions.backendServiceApi) {
                    this.onBackendSortChanged(event, { multiColumnSort: true, sortCols: sortedColsWithoutCurrent, grid: this._grid });
                }
                else if (this._dataView) {
                    this.onLocalSortChanged(this._grid, sortedColsWithoutCurrent, true, true);
                }
                else {
                    // when using customDataView, we will simply send it as a onSort event with notify
                    var isMultiSort = this._gridOptions && this._gridOptions.multiColumnSort || false;
                    var sortOutput = isMultiSort ? sortedColsWithoutCurrent : sortedColsWithoutCurrent[0];
                    this._grid.onSort.notify(sortOutput);
                }
                // update the grid sortColumns array which will at the same add the visual sort icon(s) on the UI
                var updatedSortColumns = sortedColsWithoutCurrent.map(function (col) {
                    return {
                        columnId: col && col.sortCol && col.sortCol.id,
                        sortAsc: col && col.sortAsc,
                        sortCol: col && col.sortCol,
                    };
                });
                this._grid.setSortColumns(updatedSortColumns); // add sort icon in UI
            }
            // when there's no more sorting, we re-sort by the default sort field, user can customize it "defaultColumnSortFieldId", defaults to "id"
            if (Array.isArray(sortedColsWithoutCurrent) && sortedColsWithoutCurrent.length === 0) {
                this.sortLocalGridByDefaultSortFieldId();
            }
        };
        /**
         * Clear Sorting
         * - 1st, remove the SlickGrid sort icons (this setSortColumns function call really does only that)
         * - 2nd, we also need to trigger a sort change
         *   - for a backend grid, we will trigger a backend sort changed with an empty sort columns array
         *   - however for a local grid, we need to pass a sort column and so we will sort by the 1st column
         * @param trigger query event after executing clear filter?
         */
        SortService.prototype.clearSorting = function (triggerQueryEvent) {
            if (triggerQueryEvent === void 0) { triggerQueryEvent = true; }
            if (this._grid && this._gridOptions && this._dataView) {
                // remove any sort icons (this setSortColumns function call really does only that)
                this._grid.setSortColumns([]);
                // we also need to trigger a sort change
                // for a backend grid, we will trigger a backend sort changed with an empty sort columns array
                // however for a local grid, we need to pass a sort column and so we will sort by the 1st column
                if (triggerQueryEvent) {
                    if (this._isBackendGrid) {
                        this.onBackendSortChanged(undefined, { grid: this._grid, sortCols: [], clearSortTriggered: true });
                    }
                    else {
                        if (this._columnDefinitions && Array.isArray(this._columnDefinitions)) {
                            this.sortLocalGridByDefaultSortFieldId();
                        }
                    }
                }
                else if (this._isBackendGrid) {
                    var backendService = this._gridOptions && this._gridOptions.backendServiceApi && this._gridOptions.backendServiceApi.service;
                    if (backendService && backendService.clearSorters) {
                        backendService.clearSorters();
                    }
                }
            }
            // set current sorter to empty & emit a sort changed event
            this._currentLocalSorters = [];
            // emit an event when sorts are all cleared
            this.onSortCleared.next(true);
        };
        SortService.prototype.dispose = function () {
            // unsubscribe all SlickGrid events
            if (this._eventHandler && this._eventHandler.unsubscribeAll) {
                this._eventHandler.unsubscribeAll();
            }
            if (rxjs.isObservable(this.httpCancelRequests$)) {
                this.httpCancelRequests$.next(); // this cancels any pending http requests
            }
        };
        /**
         * Toggle the Sorting Functionality
         * @param {boolean} isSortingDisabled - optionally force a disable/enable of the Sort Functionality? Defaults to True
         * @param {boolean} clearSortingWhenDisabled - when disabling the sorting, do we also want to clear the sorting as well? Defaults to True
         */
        SortService.prototype.disableSortFunctionality = function (isSortingDisabled, clearSortingWhenDisabled) {
            var _this = this;
            if (isSortingDisabled === void 0) { isSortingDisabled = true; }
            if (clearSortingWhenDisabled === void 0) { clearSortingWhenDisabled = true; }
            var prevSorting = this._gridOptions.enableSorting;
            var newSorting = !prevSorting;
            this._gridOptions.enableSorting = newSorting;
            var updatedColumnDefinitions;
            if (isSortingDisabled) {
                if (clearSortingWhenDisabled) {
                    this.clearSorting();
                }
                this._eventHandler.unsubscribeAll();
                updatedColumnDefinitions = this.disableAllSortingCommands(true);
            }
            else {
                updatedColumnDefinitions = this.disableAllSortingCommands(false);
                var onSortHandler = this._grid.onSort;
                this._eventHandler.subscribe(onSortHandler, function (e, args) { return _this.handleLocalOnSort(e, args); });
            }
            this._grid.setOptions({ enableSorting: this._gridOptions.enableSorting }, false, true);
            this.sharedService.gridOptions = this._gridOptions;
            // reset columns so that it recreate the column headers and remove/add the sort icon hints
            // basically without this, the sort icon hints were still showing up even after disabling the Sorting
            this._grid.setColumns(updatedColumnDefinitions);
        };
        /**
         * Toggle the Sorting functionality
         * @param {boolean} clearSortingWhenDisabled - when disabling the sorting, do we also want to clear the sorting as well? Defaults to True
         */
        SortService.prototype.toggleSortFunctionality = function (clearSortingOnDisable) {
            if (clearSortingOnDisable === void 0) { clearSortingOnDisable = true; }
            var previousSorting = this._gridOptions.enableSorting;
            this.disableSortFunctionality(previousSorting, clearSortingOnDisable);
        };
        /**
         * A simple function that is binded to the subscriber and emit a change when the sort is called.
         * Other services, like Pagination, can then subscribe to it.
         * @param sender
         */
        SortService.prototype.emitSortChanged = function (sender, currentLocalSorters) {
            if (sender === exports.EmitterType.remote && this._gridOptions && this._gridOptions.backendServiceApi) {
                var currentSorters = [];
                var backendService = this._gridOptions.backendServiceApi.service;
                if (backendService && backendService.getCurrentSorters) {
                    currentSorters = backendService.getCurrentSorters();
                }
                this.onSortChanged.next(currentSorters);
            }
            else if (sender === exports.EmitterType.local) {
                if (currentLocalSorters) {
                    this._currentLocalSorters = currentLocalSorters;
                }
                this.onSortChanged.next(this.getCurrentLocalSorters());
            }
        };
        SortService.prototype.getCurrentLocalSorters = function () {
            return this._currentLocalSorters;
        };
        /**
         * Get current column sorts,
         * If a column is passed as an argument, that will be exclusion so we won't add this column to our output array since it is already in the array.
         * The usage of this method is that we want to know the sort prior to calling the next sorting command
         */
        SortService.prototype.getCurrentColumnSorts = function (excludedColumnId) {
            var _this = this;
            // getSortColumns() only returns sortAsc & columnId, we want the entire column definition
            var oldSortColumns = this._grid && this._grid.getSortColumns();
            // get the column definition but only keep column which are not equal to our current column
            if (Array.isArray(oldSortColumns)) {
                var sortedCols = oldSortColumns.reduce(function (cols, col) {
                    if (!excludedColumnId || col.columnId !== excludedColumnId) {
                        cols.push({ sortCol: _this._columnDefinitions[_this._grid.getColumnIndex(col.columnId)], sortAsc: col.sortAsc });
                    }
                    return cols;
                }, []);
                return sortedCols;
            }
            return [];
        };
        /** Load defined Sorting (sorters) into the grid */
        SortService.prototype.loadGridSorters = function (sorters) {
            var _this = this;
            this._currentLocalSorters = []; // reset current local sorters
            var sortCols = [];
            if (Array.isArray(sorters)) {
                sorters.forEach(function (sorter) {
                    var gridColumn = _this._columnDefinitions.find(function (col) { return col.id === sorter.columnId; });
                    if (gridColumn) {
                        sortCols.push({
                            columnId: gridColumn.id,
                            sortAsc: ((sorter.direction.toUpperCase() === exports.SortDirection.ASC) ? true : false),
                            sortCol: gridColumn
                        });
                        // keep current sorters
                        _this._currentLocalSorters.push({
                            columnId: gridColumn.id + '',
                            direction: sorter.direction.toUpperCase()
                        });
                    }
                });
            }
            if (sortCols.length > 0) {
                this.onLocalSortChanged(this._grid, sortCols);
                this._grid.setSortColumns(sortCols); // use this to add sort icon(s) in UI
            }
            return sortCols;
        };
        /** Process the initial sort, typically it will sort ascending by the column that has the Tree Data unless user specifies a different initialSort */
        SortService.prototype.processTreeDataInitialSort = function () {
            // when a Tree Data view is defined, we must sort the data so that the UI works correctly
            if (this._gridOptions && this._gridOptions.enableTreeData && this._gridOptions.treeDataOptions) {
                // first presort it once by tree level
                var treeDataOptions_1 = this._gridOptions.treeDataOptions;
                var columnWithTreeData = this._columnDefinitions.find(function (col) { return col && col.id === treeDataOptions_1.columnId; });
                if (columnWithTreeData) {
                    var sortDirection = exports.SortDirection.ASC;
                    var sortTreeLevelColumn = { columnId: treeDataOptions_1.columnId, sortCol: columnWithTreeData, sortAsc: true };
                    // user could provide a custom sort field id, if so get that column and sort by it
                    if (treeDataOptions_1 && treeDataOptions_1.initialSort && treeDataOptions_1.initialSort.columnId) {
                        var initialSortColumnId_1 = treeDataOptions_1.initialSort.columnId;
                        var initialSortColumn = this._columnDefinitions.find(function (col) { return col.id === initialSortColumnId_1; });
                        sortDirection = (treeDataOptions_1.initialSort.direction || exports.SortDirection.ASC).toUpperCase();
                        sortTreeLevelColumn = { columnId: initialSortColumnId_1, sortCol: initialSortColumn, sortAsc: (sortDirection === exports.SortDirection.ASC) };
                    }
                    // when we have a valid column with Tree Data, we can sort by that column
                    if (sortTreeLevelColumn && sortTreeLevelColumn.columnId) {
                        this.updateSorting([{ columnId: sortTreeLevelColumn.columnId || '', direction: sortDirection }]);
                    }
                }
            }
        };
        SortService.prototype.onBackendSortChanged = function (event, args) {
            if (!args || !args.grid) {
                throw new Error('Something went wrong when trying to bind the "onBackendSortChanged(event, args)" function, it seems that "args" is not populated correctly');
            }
            var gridOptions = (args.grid && args.grid.getOptions) ? args.grid.getOptions() : {};
            var backendApi = gridOptions.backendServiceApi;
            if (!backendApi || !backendApi.process || !backendApi.service) {
                throw new Error("BackendServiceApi requires at least a \"process\" function and a \"service\" defined");
            }
            // keep start time & end timestamps & return it after process execution
            var startTime = new Date();
            if (backendApi.preProcess) {
                backendApi.preProcess();
            }
            // query backend
            var query = backendApi.service.processOnSortChanged(event, args);
            var totalItems = gridOptions && gridOptions.pagination && gridOptions.pagination.totalItems;
            executeBackendCallback(backendApi, query, args, startTime, totalItems, this.emitSortChanged.bind(this), this.httpCancelRequests$);
        };
        /** When a Sort Changes on a Local grid (JSON dataset) */
        SortService.prototype.onLocalSortChanged = function (grid, sortColumns, forceReSort, emitSortChanged) {
            if (forceReSort === void 0) { forceReSort = false; }
            if (emitSortChanged === void 0) { emitSortChanged = false; }
            var isTreeDataEnabled = this._gridOptions && this._gridOptions.enableTreeData || false;
            var dataView = grid && grid.getData && grid.getData();
            if (grid && dataView) {
                if (forceReSort && !isTreeDataEnabled) {
                    dataView.reSort();
                }
                if (isTreeDataEnabled && this.sharedService && Array.isArray(this.sharedService.hierarchicalDataset)) {
                    var hierarchicalDataset = this.sharedService.hierarchicalDataset;
                    this.sortTreeData(hierarchicalDataset, sortColumns);
                    var dataViewIdIdentifier = this._gridOptions && this._gridOptions.datasetIdPropertyName || 'id';
                    var treeDataOpt = this._gridOptions && this._gridOptions.treeDataOptions || { columnId: '' };
                    var treeDataOptions = __assign({}, treeDataOpt, { identifierPropName: treeDataOpt.identifierPropName || dataViewIdIdentifier });
                    var sortedFlatArray = convertHierarchicalViewToParentChildArray(hierarchicalDataset, treeDataOptions);
                    dataView.setItems(sortedFlatArray, this._gridOptions && this._gridOptions.datasetIdPropertyName || 'id');
                }
                else {
                    dataView.sort(this.sortComparers.bind(this, sortColumns));
                }
                grid.invalidate();
                grid.render();
                if (emitSortChanged) {
                    this.emitSortChanged(exports.EmitterType.local, sortColumns.map(function (col) {
                        return {
                            columnId: col.sortCol && col.sortCol.id || 'id',
                            direction: col.sortAsc ? exports.SortDirection.ASC : exports.SortDirection.DESC
                        };
                    }));
                }
            }
        };
        /** Call a local grid sort by its default sort field id (user can customize default field by configuring "defaultColumnSortFieldId" in the grid options, defaults to "id") */
        SortService.prototype.sortLocalGridByDefaultSortFieldId = function () {
            var sortColFieldId = this._gridOptions && this._gridOptions.defaultColumnSortFieldId || this._gridOptions.datasetIdPropertyName || 'id';
            var sortCol = { id: sortColFieldId, field: sortColFieldId };
            this.onLocalSortChanged(this._grid, new Array({ sortAsc: true, sortCol: sortCol, clearSortTriggered: true }));
        };
        SortService.prototype.sortComparers = function (sortColumns, dataRow1, dataRow2) {
            var e_1, _a;
            if (Array.isArray(sortColumns)) {
                try {
                    for (var sortColumns_1 = __values(sortColumns), sortColumns_1_1 = sortColumns_1.next(); !sortColumns_1_1.done; sortColumns_1_1 = sortColumns_1.next()) {
                        var sortColumn = sortColumns_1_1.value;
                        var result = this.sortComparer(sortColumn, dataRow1, dataRow2);
                        if (result !== undefined) {
                            return result;
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (sortColumns_1_1 && !sortColumns_1_1.done && (_a = sortColumns_1.return)) _a.call(sortColumns_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            return exports.SortDirectionNumber.neutral;
        };
        SortService.prototype.sortComparer = function (sortColumn, dataRow1, dataRow2, querySortField) {
            if (sortColumn && sortColumn.sortCol) {
                var columnDef = sortColumn.sortCol;
                var sortDirection = sortColumn.sortAsc ? exports.SortDirectionNumber.asc : exports.SortDirectionNumber.desc;
                var queryFieldName1 = querySortField || columnDef.queryFieldSorter || columnDef.queryField || columnDef.field;
                var queryFieldName2 = queryFieldName1;
                var fieldType = columnDef.type || exports.FieldType.string;
                // if user provided a query field name getter callback, we need to get the name on each item independently
                if (typeof columnDef.queryFieldNameGetterFn === 'function') {
                    queryFieldName1 = columnDef.queryFieldNameGetterFn(dataRow1);
                    queryFieldName2 = columnDef.queryFieldNameGetterFn(dataRow2);
                }
                var value1 = dataRow1[queryFieldName1];
                var value2 = dataRow2[queryFieldName2];
                // when item is a complex object (dot "." notation), we need to filter the value contained in the object tree
                if (queryFieldName1 && queryFieldName1.indexOf('.') >= 0) {
                    value1 = getDescendantProperty(dataRow1, queryFieldName1);
                }
                if (queryFieldName2 && queryFieldName2.indexOf('.') >= 0) {
                    value2 = getDescendantProperty(dataRow2, queryFieldName2);
                }
                // user could provide his own custom Sorter
                if (columnDef.sorter) {
                    var customSortResult = columnDef.sorter(value1, value2, sortDirection, columnDef);
                    if (customSortResult !== exports.SortDirectionNumber.neutral) {
                        return customSortResult;
                    }
                }
                else {
                    var sortResult = sortByFieldType(fieldType, value1, value2, sortDirection, columnDef);
                    if (sortResult !== exports.SortDirectionNumber.neutral) {
                        return sortResult;
                    }
                }
            }
            return undefined;
        };
        SortService.prototype.sortTreeData = function (hierarchicalArray, sortColumns) {
            var e_2, _a;
            if (Array.isArray(sortColumns)) {
                try {
                    for (var sortColumns_2 = __values(sortColumns), sortColumns_2_1 = sortColumns_2.next(); !sortColumns_2_1.done; sortColumns_2_1 = sortColumns_2.next()) {
                        var sortColumn = sortColumns_2_1.value;
                        this.sortTreeChild(hierarchicalArray, sortColumn, 0);
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (sortColumns_2_1 && !sortColumns_2_1.done && (_a = sortColumns_2.return)) _a.call(sortColumns_2);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        };
        /** Sort the Tree Children of a hierarchical dataset by recursion */
        SortService.prototype.sortTreeChild = function (hierarchicalArray, sortColumn, treeLevel) {
            var e_3, _a;
            var _this = this;
            var treeDataOptions = this._gridOptions && this._gridOptions.treeDataOptions;
            var childrenPropName = treeDataOptions && treeDataOptions.childrenPropName || 'children';
            hierarchicalArray.sort(function (a, b) { return _this.sortComparer(sortColumn, a, b) || exports.SortDirectionNumber.neutral; });
            try {
                // when item has a child, we'll sort recursively
                for (var hierarchicalArray_1 = __values(hierarchicalArray), hierarchicalArray_1_1 = hierarchicalArray_1.next(); !hierarchicalArray_1_1.done; hierarchicalArray_1_1 = hierarchicalArray_1.next()) {
                    var item = hierarchicalArray_1_1.value;
                    if (item) {
                        var hasChildren = item.hasOwnProperty(childrenPropName) && Array.isArray(item[childrenPropName]);
                        // when item has a child, we'll sort recursively
                        if (hasChildren) {
                            treeLevel++;
                            this.sortTreeChild(item[childrenPropName], sortColumn, treeLevel);
                            treeLevel--;
                        }
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (hierarchicalArray_1_1 && !hierarchicalArray_1_1.done && (_a = hierarchicalArray_1.return)) _a.call(hierarchicalArray_1);
                }
                finally { if (e_3) throw e_3.error; }
            }
        };
        /**
         * Update Sorting (sorters) dynamically just by providing an array of sorter(s).
         * You can also choose emit (default) a Sort Changed event that will be picked by the Grid State Service.
         *
         * Also for backend service only, you can choose to trigger a backend query (default) or not if you wish to do it later,
         * this could be useful when using updateFilters & updateSorting and you wish to only send the backend query once.
         * @param sorters array
         * @param triggerEvent defaults to True, do we want to emit a sort changed event?
         * @param triggerBackendQuery defaults to True, which will query the backend.
         */
        SortService.prototype.updateSorting = function (sorters, emitChangedEvent, triggerBackendQuery) {
            if (emitChangedEvent === void 0) { emitChangedEvent = true; }
            if (triggerBackendQuery === void 0) { triggerBackendQuery = true; }
            if (!this._gridOptions || !this._gridOptions.enableSorting) {
                throw new Error('[Angular-Slickgrid] in order to use "updateSorting" method, you need to have Sortable Columns defined in your grid and "enableSorting" set in your Grid Options');
            }
            if (Array.isArray(sorters)) {
                var backendApi = this._gridOptions && this._gridOptions.backendServiceApi;
                if (backendApi) {
                    var backendApiService = backendApi && backendApi.service;
                    if (backendApiService) {
                        backendApiService.updateSorters(undefined, sorters);
                        if (triggerBackendQuery) {
                            refreshBackendDataset(this._gridOptions);
                        }
                    }
                }
                else {
                    this.loadGridSorters(sorters);
                }
                if (emitChangedEvent) {
                    var emitterType = backendApi ? exports.EmitterType.remote : exports.EmitterType.local;
                    this.emitSortChanged(emitterType);
                }
            }
        };
        // --
        // private functions
        // -------------------
        /**
         * Loop through all column definitions and do the following 2 things
         * 1. disable/enable the "sortable" property of each column
         * 2. loop through each Header Menu commands and change the "hidden" commands to show/hide depending if it's enabled/disabled
         * Also note that we aren't deleting any properties, we just toggle their flags so that we can reloop through at later point in time.
         * (if we previously deleted these properties we wouldn't be able to change them back since these properties wouldn't exist anymore, hence why we just hide the commands)
         * @param {boolean} isDisabling - are we disabling the sort functionality? Defaults to true
         */
        SortService.prototype.disableAllSortingCommands = function (isDisabling) {
            if (isDisabling === void 0) { isDisabling = true; }
            var columnDefinitions = this._grid.getColumns();
            // loop through column definition to hide/show header menu commands
            columnDefinitions.forEach(function (col) {
                if (typeof col.sortable !== undefined) {
                    col.sortable = !isDisabling;
                }
                if (col && col.header && col.header.menu) {
                    col.header.menu.items.forEach(function (menuItem) {
                        if (menuItem && typeof menuItem !== 'string') {
                            var menuCommand = menuItem.command;
                            if (menuCommand === 'sort-asc' || menuCommand === 'sort-desc' || menuCommand === 'clear-sort') {
                                menuItem.hidden = isDisabling;
                            }
                        }
                    });
                }
            });
            // loop through column definition to hide/show grid menu commands
            if (this._gridOptions && this._gridOptions.gridMenu && this._gridOptions.gridMenu.customItems) {
                this._gridOptions.gridMenu.customItems.forEach(function (menuItem) {
                    if (menuItem && typeof menuItem !== 'string') {
                        var menuCommand = menuItem.command;
                        if (menuCommand === 'clear-sorting') {
                            menuItem.hidden = isDisabling;
                        }
                    }
                });
            }
            return columnDefinitions;
        };
        SortService.ctorParameters = function () { return [
            { type: SharedService }
        ]; };
        SortService = __decorate([
            core.Injectable()
        ], SortService);
        return SortService;
    }());

    var GridMenuExtension = /** @class */ (function () {
        function GridMenuExtension(excelExportService, exportService, extensionUtility, filterService, sharedService, sortService, translate) {
            this.excelExportService = excelExportService;
            this.exportService = exportService;
            this.extensionUtility = extensionUtility;
            this.filterService = filterService;
            this.sharedService = sharedService;
            this.sortService = sortService;
            this.translate = translate;
            this._areVisibleColumnDifferent = false;
            this._eventHandler = new Slick.EventHandler();
        }
        Object.defineProperty(GridMenuExtension.prototype, "eventHandler", {
            get: function () {
                return this._eventHandler;
            },
            enumerable: true,
            configurable: true
        });
        GridMenuExtension.prototype.dispose = function () {
            // unsubscribe all SlickGrid events
            this._eventHandler.unsubscribeAll();
            if (this._addon && this._addon.destroy) {
                this._addon.destroy();
            }
            if (this.sharedService.gridOptions && this.sharedService.gridOptions.gridMenu && this.sharedService.gridOptions.gridMenu.customItems) {
                this.sharedService.gridOptions.gridMenu = this._userOriginalGridMenu;
            }
            this.extensionUtility.nullifyFunctionNameStartingWithOn(this._gridMenuOptions);
            this._addon = null;
            this._gridMenuOptions = null;
        };
        /** Get the instance of the SlickGrid addon (control or plugin). */
        GridMenuExtension.prototype.getAddonInstance = function () {
            return this._addon;
        };
        /** Create the Header Menu and expose all the available hooks that user can subscribe (onCommand, onBeforeMenuShow, ...) */
        GridMenuExtension.prototype.register = function () {
            var _this = this;
            if (this.sharedService.gridOptions && this.sharedService.gridOptions.enableTranslate && (!this.translate || !this.translate.instant)) {
                throw new Error('[Angular-Slickgrid] requires "ngx-translate" to be installed and configured when the grid option "enableTranslate" is enabled.');
            }
            if (this.sharedService && this.sharedService.gridOptions && this.sharedService.gridOptions.gridMenu) {
                // keep original user grid menu, useful when switching locale to translate
                this._userOriginalGridMenu = __assign({}, this.sharedService.gridOptions.gridMenu);
                // get locales provided by user in forRoot or else use default English locales via the Constants
                this._locales = this.sharedService.gridOptions && this.sharedService.gridOptions.locales || Constants.locales;
                // dynamically import the SlickGrid plugin (addon) with RequireJS
                this.extensionUtility.loadExtensionDynamically(exports.ExtensionName.gridMenu);
                this._gridMenuOptions = __assign({}, this.getDefaultGridMenuOptions(), this.sharedService.gridOptions.gridMenu);
                this.sharedService.gridOptions.gridMenu = this._gridMenuOptions;
                // merge original user grid menu items with internal items
                // then sort all Grid Menu Custom Items (sorted by pointer, no need to use the return)
                var originalCustomItems = this._userOriginalGridMenu && Array.isArray(this._userOriginalGridMenu.customItems) ? this._userOriginalGridMenu.customItems : [];
                this._gridMenuOptions.customItems = __spread(originalCustomItems, this.addGridMenuCustomCommands(originalCustomItems));
                this.extensionUtility.translateItems(this._gridMenuOptions.customItems, 'titleKey', 'title');
                this.extensionUtility.sortItems(this._gridMenuOptions.customItems, 'positionOrder');
                this._addon = new Slick.Controls.GridMenu(this.sharedService.allColumns, this.sharedService.grid, this.sharedService.gridOptions);
                // hook all events
                if (this._gridMenuOptions) {
                    if (this._gridMenuOptions.onExtensionRegistered) {
                        this._gridMenuOptions.onExtensionRegistered(this._addon);
                    }
                    if (this._gridMenuOptions && typeof this._gridMenuOptions.onBeforeMenuShow === 'function') {
                        this._eventHandler.subscribe(this._addon.onBeforeMenuShow, function (e, args) {
                            _this._gridMenuOptions.onBeforeMenuShow(e, args);
                        });
                    }
                    if (this._gridMenuOptions && typeof this._gridMenuOptions.onAfterMenuShow === 'function') {
                        this._eventHandler.subscribe(this._addon.onAfterMenuShow, function (e, args) {
                            _this._gridMenuOptions.onAfterMenuShow(e, args);
                        });
                    }
                    this._eventHandler.subscribe(this._addon.onColumnsChanged, function (e, args) {
                        _this._areVisibleColumnDifferent = true;
                        if (_this._gridMenuOptions && typeof _this._gridMenuOptions.onColumnsChanged === 'function') {
                            _this._gridMenuOptions.onColumnsChanged(e, args);
                        }
                        if (args && Array.isArray(args.columns) && args.columns.length > _this.sharedService.visibleColumns.length) {
                            _this.sharedService.visibleColumns = args.columns;
                        }
                        // if we're using frozen columns, we need to readjust pinning when the new hidden column becomes visible again on the left pinning container
                        // we need to readjust frozenColumn index because SlickGrid freezes by index and has no knowledge of the columns themselves
                        var frozenColumnIndex = _this.sharedService.gridOptions.frozenColumn !== undefined ? _this.sharedService.gridOptions.frozenColumn : -1;
                        if (frozenColumnIndex >= 0) {
                            var isColumnShown = args.showing, columnId = args.columnId, allColumns = args.allColumns, visibleColumns = args.columns;
                            _this.extensionUtility.readjustFrozenColumnIndexWhenNeeded(columnId, frozenColumnIndex, isColumnShown, allColumns, visibleColumns);
                        }
                    });
                    this._eventHandler.subscribe(this._addon.onCommand, function (e, args) {
                        _this.executeGridMenuInternalCustomCommands(e, args);
                        if (_this._gridMenuOptions && typeof _this._gridMenuOptions.onCommand === 'function') {
                            _this._gridMenuOptions.onCommand(e, args);
                        }
                    });
                    this._eventHandler.subscribe(this._addon.onMenuClose, function (e, args) {
                        if (_this._gridMenuOptions && typeof _this._gridMenuOptions.onMenuClose === 'function') {
                            _this._gridMenuOptions.onMenuClose(e, args);
                        }
                        // we also want to resize the columns if the user decided to hide certain column(s)
                        if (_this.sharedService.grid && typeof _this.sharedService.grid.autosizeColumns === 'function') {
                            // make sure that the grid still exist (by looking if the Grid UID is found in the DOM tree)
                            var gridUid = _this.sharedService.grid.getUID();
                            if (_this._areVisibleColumnDifferent && gridUid && document.querySelector("." + gridUid) !== null) {
                                if (_this.sharedService.gridOptions && _this.sharedService.gridOptions.enableAutoSizeColumns) {
                                    _this.sharedService.grid.autosizeColumns();
                                }
                                _this._areVisibleColumnDifferent = false;
                            }
                        }
                    });
                }
                return this._addon;
            }
            return null;
        };
        /** Refresh the dataset through the Backend Service */
        GridMenuExtension.prototype.refreshBackendDataset = function (gridOptions) {
            // user can pass new set of grid options which will override current ones
            if (gridOptions) {
                this.sharedService.gridOptions = __assign({}, this.sharedService.gridOptions, gridOptions);
            }
            refreshBackendDataset(this.sharedService.gridOptions);
        };
        GridMenuExtension.prototype.showGridMenu = function (e) {
            this._addon.showGridMenu(e);
        };
        /** Translate the Grid Menu titles and column picker */
        GridMenuExtension.prototype.translateGridMenu = function () {
            // update the properties by pointers, that is the only way to get Grid Menu Control to see the new values
            // we also need to call the control init so that it takes the new Grid object with latest values
            if (this.sharedService && this.sharedService.gridOptions && this.sharedService.gridOptions.gridMenu) {
                this.sharedService.gridOptions.gridMenu.customItems = [];
                this.emptyGridMenuTitles();
                // merge original user grid menu items with internal items
                // then sort all Grid Menu Custom Items (sorted by pointer, no need to use the return)
                var originalCustomItems = this._userOriginalGridMenu && Array.isArray(this._userOriginalGridMenu.customItems) ? this._userOriginalGridMenu.customItems : [];
                this.sharedService.gridOptions.gridMenu.customItems = __spread(originalCustomItems, this.addGridMenuCustomCommands(originalCustomItems));
                this.extensionUtility.translateItems(this.sharedService.gridOptions.gridMenu.customItems, 'titleKey', 'title');
                this.extensionUtility.sortItems(this.sharedService.gridOptions.gridMenu.customItems, 'positionOrder');
                this.sharedService.gridOptions.gridMenu.columnTitle = this.extensionUtility.getPickerTitleOutputString('columnTitle', 'gridMenu');
                this.sharedService.gridOptions.gridMenu.forceFitTitle = this.extensionUtility.getPickerTitleOutputString('forceFitTitle', 'gridMenu');
                this.sharedService.gridOptions.gridMenu.syncResizeTitle = this.extensionUtility.getPickerTitleOutputString('syncResizeTitle', 'gridMenu');
                // translate all columns (including non-visible)
                // eventually deprecate the "headerKey" and use only the "nameKey"
                this.extensionUtility.translateItems(this.sharedService.allColumns, 'headerKey', 'name');
                this.extensionUtility.translateItems(this.sharedService.allColumns, 'nameKey', 'name');
                // update the Titles of each sections (command, customTitle, ...)
                if (this._addon && this._addon.updateAllTitles) {
                    this._addon.updateAllTitles(this.sharedService.gridOptions.gridMenu);
                }
            }
        };
        // --
        // private functions
        // ------------------
        /** Create Grid Menu with Custom Commands if user has enabled Filters and/or uses a Backend Service (OData, GraphQL) */
        GridMenuExtension.prototype.addGridMenuCustomCommands = function (originalCustomItems) {
            var backendApi = this.sharedService.gridOptions.backendServiceApi || null;
            var gridMenuCustomItems = [];
            var gridOptions = this.sharedService.gridOptions;
            var translationPrefix = getTranslationPrefix(gridOptions);
            // show grid menu: Clear Frozen Columns
            if (this.sharedService.gridOptions && this._gridMenuOptions && !this._gridMenuOptions.hideClearFrozenColumnsCommand) {
                var commandName_1 = 'clear-frozen-columns';
                if (!originalCustomItems.find(function (item) { return item.hasOwnProperty('command') && item.command === commandName_1; })) {
                    gridMenuCustomItems.push({
                        iconCssClass: this._gridMenuOptions.iconClearFrozenColumnsCommand || 'fa fa-times',
                        title: this.sharedService.gridOptions.enableTranslate ? this.translate.instant(translationPrefix + "CLEAR_FROZEN_COLUMNS") : this._locales && this._locales.TEXT_CLEAR_FROZEN_COLUMNS,
                        disabled: false,
                        command: commandName_1,
                        positionOrder: 49
                    });
                }
            }
            if (this.sharedService.gridOptions && (this.sharedService.gridOptions.enableFiltering && !this.sharedService.hideHeaderRowAfterPageLoad)) {
                // show grid menu: Clear all Filters
                if (this.sharedService.gridOptions && this._gridMenuOptions && !this._gridMenuOptions.hideClearAllFiltersCommand) {
                    var commandName_2 = 'clear-filter';
                    if (!originalCustomItems.find(function (item) { return item.hasOwnProperty('command') && item.command === commandName_2; })) {
                        gridMenuCustomItems.push({
                            iconCssClass: this._gridMenuOptions.iconClearAllFiltersCommand || 'fa fa-filter text-danger',
                            title: this.sharedService.gridOptions.enableTranslate ? this.translate.instant(translationPrefix + "CLEAR_ALL_FILTERS") : this._locales && this._locales.TEXT_CLEAR_ALL_FILTERS,
                            disabled: false,
                            command: commandName_2,
                            positionOrder: 50
                        });
                    }
                }
                // show grid menu: toggle filter row
                if (this.sharedService.gridOptions && this._gridMenuOptions && !this._gridMenuOptions.hideToggleFilterCommand) {
                    var commandName_3 = 'toggle-filter';
                    if (!originalCustomItems.find(function (item) { return item.hasOwnProperty('command') && item.command === commandName_3; })) {
                        gridMenuCustomItems.push({
                            iconCssClass: this._gridMenuOptions.iconToggleFilterCommand || 'fa fa-random',
                            title: this.sharedService.gridOptions.enableTranslate ? this.translate.instant(translationPrefix + "TOGGLE_FILTER_ROW") : this._locales && this._locales.TEXT_TOGGLE_FILTER_ROW,
                            disabled: false,
                            command: commandName_3,
                            positionOrder: 52
                        });
                    }
                }
                // show grid menu: refresh dataset
                if (this.sharedService.gridOptions && this._gridMenuOptions && !this._gridMenuOptions.hideRefreshDatasetCommand && backendApi) {
                    var commandName_4 = 'refresh-dataset';
                    if (!originalCustomItems.find(function (item) { return item.hasOwnProperty('command') && item.command === commandName_4; })) {
                        gridMenuCustomItems.push({
                            iconCssClass: this._gridMenuOptions.iconRefreshDatasetCommand || 'fa fa-refresh',
                            title: this.sharedService.gridOptions.enableTranslate ? this.translate.instant(translationPrefix + "REFRESH_DATASET") : this._locales && this._locales.TEXT_REFRESH_DATASET,
                            disabled: false,
                            command: commandName_4,
                            positionOrder: 56
                        });
                    }
                }
            }
            if (this.sharedService.gridOptions.showPreHeaderPanel) {
                // show grid menu: toggle pre-header row
                if (this.sharedService.gridOptions && this._gridMenuOptions && !this._gridMenuOptions.hideTogglePreHeaderCommand) {
                    var commandName_5 = 'toggle-preheader';
                    if (!originalCustomItems.find(function (item) { return item.hasOwnProperty('command') && item.command === commandName_5; })) {
                        gridMenuCustomItems.push({
                            iconCssClass: this._gridMenuOptions.iconTogglePreHeaderCommand || 'fa fa-random',
                            title: this.sharedService.gridOptions.enableTranslate ? this.translate.instant(translationPrefix + "TOGGLE_PRE_HEADER_ROW") : this._locales && this._locales.TEXT_TOGGLE_PRE_HEADER_ROW,
                            disabled: false,
                            command: commandName_5,
                            positionOrder: 52
                        });
                    }
                }
            }
            if (this.sharedService.gridOptions.enableSorting) {
                // show grid menu: Clear all Sorting
                if (this.sharedService.gridOptions && this._gridMenuOptions && !this._gridMenuOptions.hideClearAllSortingCommand) {
                    var commandName_6 = 'clear-sorting';
                    if (!originalCustomItems.find(function (item) { return item.hasOwnProperty('command') && item.command === commandName_6; })) {
                        gridMenuCustomItems.push({
                            iconCssClass: this._gridMenuOptions.iconClearAllSortingCommand || 'fa fa-unsorted text-danger',
                            title: this.sharedService.gridOptions.enableTranslate ? this.translate.instant(translationPrefix + "CLEAR_ALL_SORTING") : this._locales && this._locales.TEXT_CLEAR_ALL_SORTING,
                            disabled: false,
                            command: commandName_6,
                            positionOrder: 51
                        });
                    }
                }
            }
            // show grid menu: Export to file
            if (this.sharedService.gridOptions && this.sharedService.gridOptions.enableExport && this._gridMenuOptions && !this._gridMenuOptions.hideExportCsvCommand) {
                var commandName_7 = 'export-csv';
                if (!originalCustomItems.find(function (item) { return item.hasOwnProperty('command') && item.command === commandName_7; })) {
                    gridMenuCustomItems.push({
                        iconCssClass: this._gridMenuOptions.iconExportCsvCommand || 'fa fa-download',
                        title: this.sharedService.gridOptions.enableTranslate ? this.translate.instant(translationPrefix + "EXPORT_TO_CSV") : this._locales && this._locales.TEXT_EXPORT_TO_CSV,
                        disabled: false,
                        command: commandName_7,
                        positionOrder: 53
                    });
                }
            }
            // show grid menu: Export to Excel
            if (this.sharedService.gridOptions && this.sharedService.gridOptions.enableExcelExport && this._gridMenuOptions && !this._gridMenuOptions.hideExportExcelCommand) {
                var commandName_8 = 'export-excel';
                if (!originalCustomItems.find(function (item) { return item.hasOwnProperty('command') && item.command === commandName_8; })) {
                    gridMenuCustomItems.push({
                        iconCssClass: this._gridMenuOptions.iconExportExcelCommand || 'fa fa-file-excel-o text-success',
                        title: this.sharedService.gridOptions.enableTranslate ? this.translate.instant(translationPrefix + "EXPORT_TO_EXCEL") : this._locales && this._locales.TEXT_EXPORT_TO_EXCEL,
                        disabled: false,
                        command: commandName_8,
                        positionOrder: 54
                    });
                }
            }
            // show grid menu: export to text file as tab delimited
            if (this.sharedService.gridOptions && this.sharedService.gridOptions.enableExport && this._gridMenuOptions && !this._gridMenuOptions.hideExportTextDelimitedCommand) {
                var commandName_9 = 'export-text-delimited';
                if (!originalCustomItems.find(function (item) { return item.hasOwnProperty('command') && item.command === commandName_9; })) {
                    gridMenuCustomItems.push({
                        iconCssClass: this._gridMenuOptions.iconExportTextDelimitedCommand || 'fa fa-download',
                        title: this.sharedService.gridOptions.enableTranslate ? this.translate.instant(translationPrefix + "EXPORT_TO_TAB_DELIMITED") : this._locales && this._locales.TEXT_EXPORT_TO_TAB_DELIMITED,
                        disabled: false,
                        command: commandName_9,
                        positionOrder: 55
                    });
                }
            }
            // add the custom "Commands" title if there are any commands
            if (this.sharedService && this.sharedService.gridOptions && this._gridMenuOptions && (Array.isArray(gridMenuCustomItems) && gridMenuCustomItems.length > 0 || (Array.isArray(this._gridMenuOptions.customItems) && this._gridMenuOptions.customItems.length > 0))) {
                this._gridMenuOptions.customTitle = this._gridMenuOptions.customTitle || this.extensionUtility.getPickerTitleOutputString('customTitle', 'gridMenu');
            }
            return gridMenuCustomItems;
        };
        /**
         * Execute the Grid Menu Custom command callback that was triggered by the onCommand subscribe
         * These are the default internal custom commands
         * @param event
         * @param GridMenuItem args
         */
        GridMenuExtension.prototype.executeGridMenuInternalCustomCommands = function (e, args) {
            if (args && args.command) {
                switch (args.command) {
                    case 'clear-frozen-columns':
                        var visibleColumns = __spread(this.sharedService.visibleColumns);
                        this.sharedService.grid.setOptions({ frozenColumn: -1, enableMouseWheelScrollHandler: false });
                        if (Array.isArray(visibleColumns) && Array.isArray(this.sharedService.allColumns) && visibleColumns.length !== this.sharedService.allColumns.length) {
                            this.sharedService.grid.setColumns(visibleColumns);
                        }
                        break;
                    case 'clear-filter':
                        this.filterService.clearFilters();
                        this.sharedService.dataView.refresh();
                        break;
                    case 'clear-sorting':
                        this.sortService.clearSorting();
                        this.sharedService.dataView.refresh();
                        break;
                    case 'export-csv':
                        this.exportService.exportToFile({
                            delimiter: exports.DelimiterType.comma,
                            filename: 'export',
                            format: exports.FileType.csv,
                            useUtf8WithBom: true,
                        });
                        break;
                    case 'export-excel':
                        this.excelExportService.exportToExcel({
                            filename: 'export',
                            format: exports.FileType.xlsx,
                        });
                        break;
                    case 'export-text-delimited':
                        this.exportService.exportToFile({
                            delimiter: exports.DelimiterType.tab,
                            filename: 'export',
                            format: exports.FileType.txt,
                            useUtf8WithBom: true,
                        });
                        break;
                    case 'toggle-filter':
                        var showHeaderRow = this.sharedService && this.sharedService.gridOptions && this.sharedService.gridOptions.showHeaderRow || false;
                        showHeaderRow = !showHeaderRow; // inverse show header flag
                        this.sharedService.grid.setHeaderRowVisibility(showHeaderRow);
                        // when displaying header row, we'll call "setColumns" which in terms will recreate the header row filters
                        if (showHeaderRow === true) {
                            this.sharedService.grid.setColumns(this.sharedService.columnDefinitions);
                        }
                        break;
                    case 'toggle-toppanel':
                        var showTopPanel = this.sharedService && this.sharedService.gridOptions && this.sharedService.gridOptions.showTopPanel || false;
                        this.sharedService.grid.setTopPanelVisibility(!showTopPanel);
                        break;
                    case 'toggle-preheader':
                        var showPreHeaderPanel = this.sharedService && this.sharedService.gridOptions && this.sharedService.gridOptions.showPreHeaderPanel || false;
                        this.sharedService.grid.setPreHeaderPanelVisibility(!showPreHeaderPanel);
                        break;
                    case 'refresh-dataset':
                        this.refreshBackendDataset();
                        break;
                    default:
                        break;
                }
            }
        };
        GridMenuExtension.prototype.emptyGridMenuTitles = function () {
            if (this.sharedService && this.sharedService.gridOptions && this._gridMenuOptions) {
                this._gridMenuOptions.customTitle = '';
                this._gridMenuOptions.columnTitle = '';
                this._gridMenuOptions.forceFitTitle = '';
                this._gridMenuOptions.syncResizeTitle = '';
            }
        };
        /** @return default Grid Menu options */
        GridMenuExtension.prototype.getDefaultGridMenuOptions = function () {
            return {
                customTitle: undefined,
                columnTitle: this.extensionUtility.getPickerTitleOutputString('columnTitle', 'gridMenu'),
                forceFitTitle: this.extensionUtility.getPickerTitleOutputString('forceFitTitle', 'gridMenu'),
                syncResizeTitle: this.extensionUtility.getPickerTitleOutputString('syncResizeTitle', 'gridMenu'),
                iconCssClass: 'fa fa-bars',
                menuWidth: 18,
                customItems: [],
                hideClearAllFiltersCommand: false,
                hideRefreshDatasetCommand: false,
                hideToggleFilterCommand: false,
            };
        };
        GridMenuExtension.ctorParameters = function () { return [
            { type: ExcelExportService },
            { type: ExportService },
            { type: ExtensionUtility },
            { type: FilterService },
            { type: SharedService },
            { type: SortService },
            { type: core$1.TranslateService, decorators: [{ type: core.Optional }] }
        ]; };
        GridMenuExtension = __decorate([
            core.Injectable(),
            __param(6, core.Optional())
        ], GridMenuExtension);
        return GridMenuExtension;
    }());

    var GroupItemMetaProviderExtension = /** @class */ (function () {
        function GroupItemMetaProviderExtension(sharedService) {
            this.sharedService = sharedService;
        }
        GroupItemMetaProviderExtension.prototype.dispose = function () {
            if (this._addon && this._addon.destroy) {
                this._addon.destroy();
            }
            this._addon = null;
        };
        /** Get the instance of the SlickGrid addon (control or plugin). */
        GroupItemMetaProviderExtension.prototype.getAddonInstance = function () {
            return this._addon;
        };
        /** register the group item metadata provider to add expand/collapse group handlers */
        GroupItemMetaProviderExtension.prototype.register = function () {
            if (this.sharedService && this.sharedService.grid) {
                this._addon = this.sharedService.groupItemMetadataProvider || {};
                this.sharedService.grid.registerPlugin(this._addon);
                return this._addon;
            }
            return null;
        };
        GroupItemMetaProviderExtension.ctorParameters = function () { return [
            { type: SharedService }
        ]; };
        GroupItemMetaProviderExtension = __decorate([
            core.Injectable()
        ], GroupItemMetaProviderExtension);
        return GroupItemMetaProviderExtension;
    }());

    var HeaderButtonExtension = /** @class */ (function () {
        function HeaderButtonExtension(extensionUtility, sharedService) {
            this.extensionUtility = extensionUtility;
            this.sharedService = sharedService;
            this._eventHandler = new Slick.EventHandler();
        }
        Object.defineProperty(HeaderButtonExtension.prototype, "eventHandler", {
            get: function () {
                return this._eventHandler;
            },
            enumerable: true,
            configurable: true
        });
        HeaderButtonExtension.prototype.dispose = function () {
            // unsubscribe all SlickGrid events
            this._eventHandler.unsubscribeAll();
            if (this._addon && this._addon.destroy) {
                this._addon.destroy();
            }
            this.extensionUtility.nullifyFunctionNameStartingWithOn(this._headerButtonOptions);
            this._addon = null;
            this._headerButtonOptions = null;
        };
        /** Get the instance of the SlickGrid addon (control or plugin). */
        HeaderButtonExtension.prototype.getAddonInstance = function () {
            return this._addon;
        };
        // Header Button Plugin
        HeaderButtonExtension.prototype.register = function () {
            var _this = this;
            if (this.sharedService && this.sharedService.grid && this.sharedService.gridOptions) {
                // dynamically import the SlickGrid plugin (addon) with RequireJS
                this.extensionUtility.loadExtensionDynamically(exports.ExtensionName.headerButton);
                this._headerButtonOptions = this.sharedService.gridOptions.headerButton || {};
                this._addon = new Slick.Plugins.HeaderButtons(this._headerButtonOptions);
                this.sharedService.grid.registerPlugin(this._addon);
                // hook all events
                if (this._headerButtonOptions) {
                    if (this._headerButtonOptions.onExtensionRegistered) {
                        this._headerButtonOptions.onExtensionRegistered(this._addon);
                    }
                    this._eventHandler.subscribe(this._addon.onCommand, function (e, args) {
                        if (_this._headerButtonOptions && typeof _this._headerButtonOptions.onCommand === 'function') {
                            _this._headerButtonOptions.onCommand(e, args);
                        }
                    });
                }
                return this._addon;
            }
            return null;
        };
        HeaderButtonExtension.ctorParameters = function () { return [
            { type: ExtensionUtility },
            { type: SharedService }
        ]; };
        HeaderButtonExtension = __decorate([
            core.Injectable()
        ], HeaderButtonExtension);
        return HeaderButtonExtension;
    }());

    var HeaderMenuExtension = /** @class */ (function () {
        function HeaderMenuExtension(extensionUtility, filterService, sharedService, sortService, translate) {
            this.extensionUtility = extensionUtility;
            this.filterService = filterService;
            this.sharedService = sharedService;
            this.sortService = sortService;
            this.translate = translate;
            this._eventHandler = new Slick.EventHandler();
        }
        Object.defineProperty(HeaderMenuExtension.prototype, "eventHandler", {
            get: function () {
                return this._eventHandler;
            },
            enumerable: true,
            configurable: true
        });
        HeaderMenuExtension.prototype.dispose = function () {
            // unsubscribe all SlickGrid events
            this._eventHandler.unsubscribeAll();
            if (this._addon && this._addon.destroy) {
                this._addon.destroy();
            }
            this._addon = null;
        };
        /** Get the instance of the SlickGrid addon (control or plugin). */
        HeaderMenuExtension.prototype.getAddonInstance = function () {
            return this._addon;
        };
        /**
         * Create the Header Menu and expose all the available hooks that user can subscribe (onCommand, onBeforeMenuShow, ...)
         * @param grid
         * @param dataView
         * @param columnDefinitions
         */
        HeaderMenuExtension.prototype.register = function () {
            var _this = this;
            if (this.sharedService.gridOptions && this.sharedService.gridOptions.enableTranslate && (!this.translate || !this.translate.instant)) {
                throw new Error('[Angular-Slickgrid] requires "ngx-translate" to be installed and configured when the grid option "enableTranslate" is enabled.');
            }
            if (this.sharedService && this.sharedService.grid && this.sharedService.gridOptions) {
                // get locales provided by user in forRoot or else use default English locales via the Constants
                this._locales = this.sharedService.gridOptions && this.sharedService.gridOptions.locales || Constants.locales;
                // dynamically import the SlickGrid plugin (addon) with RequireJS
                this.extensionUtility.loadExtensionDynamically(exports.ExtensionName.headerMenu);
                this.sharedService.gridOptions.headerMenu = __assign({}, this.getDefaultHeaderMenuOptions(), this.sharedService.gridOptions.headerMenu);
                if (this.sharedService.gridOptions.enableHeaderMenu) {
                    this.sharedService.gridOptions.headerMenu = this.addHeaderMenuCustomCommands(this.sharedService.gridOptions, this.sharedService.columnDefinitions);
                }
                this._addon = new Slick.Plugins.HeaderMenu(this.sharedService.gridOptions.headerMenu);
                this.sharedService.grid.registerPlugin(this._addon);
                // hook all events
                if (this.sharedService.grid && this.sharedService.gridOptions.headerMenu) {
                    if (this.sharedService.gridOptions.headerMenu.onExtensionRegistered) {
                        this.sharedService.gridOptions.headerMenu.onExtensionRegistered(this._addon);
                    }
                    this._eventHandler.subscribe(this._addon.onCommand, function (e, args) {
                        _this.executeHeaderMenuInternalCommands(e, args);
                        if (_this.sharedService.gridOptions.headerMenu && typeof _this.sharedService.gridOptions.headerMenu.onCommand === 'function') {
                            _this.sharedService.gridOptions.headerMenu.onCommand(e, args);
                        }
                    });
                    if (this.sharedService.gridOptions.headerMenu && typeof this.sharedService.gridOptions.headerMenu.onBeforeMenuShow === 'function') {
                        this._eventHandler.subscribe(this._addon.onBeforeMenuShow, function (e, args) {
                            _this.sharedService.gridOptions.headerMenu.onBeforeMenuShow(e, args);
                        });
                    }
                    if (this.sharedService.gridOptions.headerMenu && typeof this.sharedService.gridOptions.headerMenu.onAfterMenuShow === 'function') {
                        this._eventHandler.subscribe(this._addon.onAfterMenuShow, function (e, args) {
                            _this.sharedService.gridOptions.headerMenu.onAfterMenuShow(e, args);
                        });
                    }
                }
                return this._addon;
            }
            return null;
        };
        /**
         * Create Header Menu with Custom Commands if user has enabled Header Menu
         * @param options
         * @param columnDefinitions
         * @return header menu
         */
        HeaderMenuExtension.prototype.addHeaderMenuCustomCommands = function (options, columnDefinitions) {
            var _this = this;
            var headerMenuOptions = options.headerMenu || {};
            var gridOptions = this.sharedService.gridOptions;
            var translationPrefix = getTranslationPrefix(gridOptions);
            if (columnDefinitions && Array.isArray(columnDefinitions) && options.enableHeaderMenu) {
                columnDefinitions.forEach(function (columnDef) {
                    if (columnDef && !columnDef.excludeFromHeaderMenu) {
                        if (!columnDef.header || !columnDef.header.menu) {
                            columnDef.header = {
                                menu: {
                                    items: []
                                }
                            };
                        }
                        var columnHeaderMenuItems = columnDef && columnDef.header && columnDef.header.menu && columnDef.header.menu.items || [];
                        // Freeze Column (pinning)
                        if (headerMenuOptions && !headerMenuOptions.hideFreezeColumnsCommand) {
                            if (columnHeaderMenuItems.filter(function (item) { return item.hasOwnProperty('command') && item.command === 'freeze-columns'; }).length === 0) {
                                columnHeaderMenuItems.push({
                                    iconCssClass: headerMenuOptions.iconFreezeColumns || 'fa fa-thumb-tack',
                                    title: options.enableTranslate ? _this.translate.instant(translationPrefix + "FREEZE_COLUMNS") : _this._locales && _this._locales.TEXT_FREEZE_COLUMNS,
                                    command: 'freeze-columns',
                                    positionOrder: 48
                                });
                            }
                            // add a divider (separator) between the top freeze columns commands and the rest of the commands
                            if (columnHeaderMenuItems.filter(function (item) { return item.positionOrder === 49; }).length === 0) {
                                columnHeaderMenuItems.push({ divider: true, command: '', positionOrder: 49 });
                            }
                        }
                        // Sorting Commands
                        if (options.enableSorting && columnDef.sortable && headerMenuOptions && !headerMenuOptions.hideSortCommands) {
                            if (columnHeaderMenuItems.filter(function (item) { return item.hasOwnProperty('command') && item.command === 'sort-asc'; }).length === 0) {
                                columnHeaderMenuItems.push({
                                    iconCssClass: headerMenuOptions.iconSortAscCommand || 'fa fa-sort-asc',
                                    title: options.enableTranslate ? _this.translate.instant(translationPrefix + "SORT_ASCENDING") : _this._locales && _this._locales.TEXT_SORT_ASCENDING,
                                    command: 'sort-asc',
                                    positionOrder: 50
                                });
                            }
                            if (columnHeaderMenuItems.filter(function (item) { return item.hasOwnProperty('command') && item.command === 'sort-desc'; }).length === 0) {
                                columnHeaderMenuItems.push({
                                    iconCssClass: headerMenuOptions.iconSortDescCommand || 'fa fa-sort-desc',
                                    title: options.enableTranslate ? _this.translate.instant(translationPrefix + "SORT_DESCENDING") : _this._locales && _this._locales.TEXT_SORT_DESCENDING,
                                    command: 'sort-desc',
                                    positionOrder: 51
                                });
                            }
                            // add a divider (separator) between the top sort commands and the other clear commands
                            if (columnHeaderMenuItems.filter(function (item) { return item.hasOwnProperty('command') && item.positionOrder === 52; }).length === 0) {
                                columnHeaderMenuItems.push({ divider: true, command: '', positionOrder: 52 });
                            }
                            if (!headerMenuOptions.hideClearSortCommand && columnHeaderMenuItems.filter(function (item) { return item.hasOwnProperty('command') && item.command === 'clear-sort'; }).length === 0) {
                                columnHeaderMenuItems.push({
                                    iconCssClass: headerMenuOptions.iconClearSortCommand || 'fa fa-unsorted',
                                    title: options.enableTranslate ? _this.translate.instant(translationPrefix + "REMOVE_SORT") : _this._locales && _this._locales.TEXT_REMOVE_SORT,
                                    command: 'clear-sort',
                                    positionOrder: 54
                                });
                            }
                        }
                        // Filtering Commands
                        if (options.enableFiltering && columnDef.filterable && headerMenuOptions && !headerMenuOptions.hideFilterCommands) {
                            if (!headerMenuOptions.hideClearFilterCommand && columnHeaderMenuItems.filter(function (item) { return item.hasOwnProperty('command') && item.command === 'clear-filter'; }).length === 0) {
                                columnHeaderMenuItems.push({
                                    iconCssClass: headerMenuOptions.iconClearFilterCommand || 'fa fa-filter',
                                    title: options.enableTranslate ? _this.translate.instant(translationPrefix + "REMOVE_FILTER") : _this._locales && _this._locales.TEXT_REMOVE_FILTER,
                                    command: 'clear-filter',
                                    positionOrder: 53
                                });
                            }
                        }
                        // Hide Column Command
                        if (headerMenuOptions && !headerMenuOptions.hideColumnHideCommand && columnHeaderMenuItems.filter(function (item) { return item.hasOwnProperty('command') && item.command === 'hide'; }).length === 0) {
                            columnHeaderMenuItems.push({
                                iconCssClass: headerMenuOptions.iconColumnHideCommand || 'fa fa-times',
                                title: options.enableTranslate ? _this.translate.instant(translationPrefix + "HIDE_COLUMN") : _this._locales && _this._locales.TEXT_HIDE_COLUMN,
                                command: 'hide',
                                positionOrder: 55
                            });
                        }
                        _this.extensionUtility.translateItems(columnHeaderMenuItems, 'titleKey', 'title');
                        _this.extensionUtility.sortItems(columnHeaderMenuItems, 'positionOrder');
                    }
                });
            }
            return headerMenuOptions;
        };
        /** Hide a column from the grid */
        HeaderMenuExtension.prototype.hideColumn = function (column) {
            if (this.sharedService.grid && this.sharedService.grid.getColumns && this.sharedService.grid.setColumns && this.sharedService.grid.getColumnIndex) {
                var columnIndex = this.sharedService.grid.getColumnIndex(column.id);
                var currentColumns = this.sharedService.grid.getColumns();
                // if we're using frozen columns, we need to readjust pinning when the new hidden column is on the left pinning container
                // we need to do this because SlickGrid freezes by index and has no knowledge of the columns themselves
                var frozenColumnIndex = this.sharedService.gridOptions.frozenColumn || -1;
                if (frozenColumnIndex >= 0 && frozenColumnIndex >= columnIndex) {
                    this.sharedService.grid.setOptions({ frozenColumn: frozenColumnIndex - 1 });
                }
                // then proceed with hiding the column in SlickGrid & trigger an event when done
                var visibleColumns = arrayRemoveItemByIndex(currentColumns, columnIndex);
                this.sharedService.visibleColumns = visibleColumns;
                this.sharedService.grid.setColumns(visibleColumns);
                this.sharedService.onHeaderMenuHideColumns.next(visibleColumns);
            }
        };
        /**
         * Translate the Header Menu titles, we need to loop through all column definition to re-translate them
         */
        HeaderMenuExtension.prototype.translateHeaderMenu = function () {
            if (this.sharedService.gridOptions && this.sharedService.gridOptions.headerMenu) {
                this.resetHeaderMenuTranslations(this.sharedService.visibleColumns);
            }
        };
        // --
        // private functions
        // ------------------
        /** @return default Header Menu options */
        HeaderMenuExtension.prototype.getDefaultHeaderMenuOptions = function () {
            return {
                autoAlignOffset: 12,
                minWidth: 140,
                hideColumnHideCommand: false,
                hideSortCommands: false,
                title: ''
            };
        };
        /**
         * Reset all the internal Menu options which have text to translate
         * @param header menu object
         */
        HeaderMenuExtension.prototype.resetHeaderMenuTranslations = function (columnDefinitions) {
            var _this = this;
            var gridOptions = this.sharedService.gridOptions;
            var translationPrefix = getTranslationPrefix(gridOptions);
            columnDefinitions.forEach(function (columnDef) {
                if (columnDef && columnDef.header && columnDef.header && columnDef.header.menu && columnDef.header.menu.items) {
                    if (!columnDef.excludeFromHeaderMenu) {
                        var columnHeaderMenuItems_1 = columnDef.header.menu.items || [];
                        columnHeaderMenuItems_1.forEach(function (item) {
                            if (item.hasOwnProperty('command')) {
                                switch (item.command) {
                                    case 'clear-filter':
                                        item.title = _this.translate.instant(translationPrefix + "REMOVE_FILTER") || _this._locales && _this._locales.TEXT_REMOVE_FILTER;
                                        break;
                                    case 'clear-sort':
                                        item.title = _this.translate.instant(translationPrefix + "REMOVE_SORT") || _this._locales && _this._locales.TEXT_REMOVE_SORT;
                                        break;
                                    case 'freeze-columns':
                                        item.title = _this.translate.instant(translationPrefix + "FREEZE_COLUMNS") || _this._locales && _this._locales.TEXT_FREEZE_COLUMNS;
                                        break;
                                    case 'sort-asc':
                                        item.title = _this.translate.instant(translationPrefix + "SORT_ASCENDING") || _this._locales && _this._locales.TEXT_SORT_ASCENDING;
                                        break;
                                    case 'sort-desc':
                                        item.title = _this.translate.instant(translationPrefix + "SORT_DESCENDING") || _this._locales && _this._locales.TEXT_SORT_DESCENDING;
                                        break;
                                    case 'hide':
                                        item.title = _this.translate.instant(translationPrefix + "HIDE_COLUMN") || _this._locales && _this._locales.TEXT_HIDE_COLUMN;
                                        break;
                                }
                            }
                            // re-translate if there's a "titleKey"
                            if (_this.sharedService.gridOptions && _this.sharedService.gridOptions.enableTranslate) {
                                _this.extensionUtility.translateItems(columnHeaderMenuItems_1, 'titleKey', 'title');
                            }
                        });
                    }
                }
            });
        };
        /** Clear the Filter on the current column (if it's actually filtered) */
        HeaderMenuExtension.prototype.clearColumnFilter = function (event, args) {
            if (args && args.column) {
                this.filterService.clearFilterByColumnId(event, args.column.id);
            }
        };
        /** Clear the Sort on the current column (if it's actually sorted) */
        HeaderMenuExtension.prototype.clearColumnSort = function (event, args) {
            if (args && args.column && this.sharedService) {
                this.sortService.clearSortByColumnId(event, args.column.id);
            }
        };
        /** Execute the Header Menu Commands that was triggered by the onCommand subscribe */
        HeaderMenuExtension.prototype.executeHeaderMenuInternalCommands = function (event, args) {
            if (args && args.command) {
                switch (args.command) {
                    case 'hide':
                        this.hideColumn(args.column);
                        if (this.sharedService.gridOptions && this.sharedService.gridOptions.enableAutoSizeColumns) {
                            this.sharedService.grid.autosizeColumns();
                        }
                        break;
                    case 'clear-filter':
                        this.clearColumnFilter(event, args);
                        break;
                    case 'clear-sort':
                        this.clearColumnSort(event, args);
                        break;
                    case 'freeze-columns':
                        var visibleColumns = __spread(this.sharedService.visibleColumns);
                        var columnPosition = visibleColumns.findIndex(function (col) { return col.id === args.column.id; });
                        this.sharedService.grid.setOptions({ frozenColumn: columnPosition, enableMouseWheelScrollHandler: true });
                        this.sharedService.frozenVisibleColumnId = args.column.id;
                        // to freeze columns, we need to take only the visible columns and we also need to use setColumns() when some of them are hidden
                        // to make sure that we only use the visible columns, not doing this would show back some of the hidden columns
                        if (Array.isArray(visibleColumns) && Array.isArray(this.sharedService.allColumns) && visibleColumns.length !== this.sharedService.allColumns.length) {
                            this.sharedService.grid.setColumns(visibleColumns);
                        }
                        break;
                    case 'sort-asc':
                    case 'sort-desc':
                        var isSortingAsc = (args.command === 'sort-asc');
                        this.sortColumn(event, args, isSortingAsc);
                        break;
                    default:
                        break;
                }
            }
        };
        /** Sort the current column */
        HeaderMenuExtension.prototype.sortColumn = function (event, args, isSortingAsc) {
            if (isSortingAsc === void 0) { isSortingAsc = true; }
            if (args && args.column) {
                // get previously sorted columns
                var columnDef = args.column;
                var sortedColsWithoutCurrent = this.sortService.getCurrentColumnSorts(args.column.id + '');
                var emitterType = void 0;
                // add to the column array, the column sorted by the header menu
                sortedColsWithoutCurrent.push({ columnId: columnDef.id, sortCol: columnDef, sortAsc: isSortingAsc });
                if (this.sharedService.gridOptions.backendServiceApi) {
                    this.sortService.onBackendSortChanged(event, { multiColumnSort: true, sortCols: sortedColsWithoutCurrent, grid: this.sharedService.grid });
                    emitterType = exports.EmitterType.remote;
                }
                else if (this.sharedService.dataView) {
                    this.sortService.onLocalSortChanged(this.sharedService.grid, sortedColsWithoutCurrent);
                    emitterType = exports.EmitterType.local;
                }
                else {
                    // when using customDataView, we will simply send it as a onSort event with notify
                    var isMultiSort = this.sharedService && this.sharedService.gridOptions && this.sharedService.gridOptions.multiColumnSort || false;
                    var sortOutput = isMultiSort ? sortedColsWithoutCurrent : sortedColsWithoutCurrent[0];
                    args.grid.onSort.notify(sortOutput);
                }
                // update the this.sharedService.gridObj sortColumns array which will at the same add the visual sort icon(s) on the UI
                var newSortColumns = sortedColsWithoutCurrent.map(function (col) {
                    return {
                        columnId: col && col.sortCol && col.sortCol.id,
                        sortAsc: col && col.sortAsc,
                        sortCol: col && col.sortCol,
                    };
                });
                // add sort icon in UI
                this.sharedService.grid.setSortColumns(newSortColumns);
                // if we have an emitter type set, we will emit a sort changed
                // for the Grid State Service to see the change.
                // We also need to pass current sorters changed to the emitSortChanged method
                if (emitterType) {
                    var currentLocalSorters_1 = [];
                    newSortColumns.forEach(function (sortCol) {
                        currentLocalSorters_1.push({
                            columnId: sortCol.columnId + '',
                            direction: sortCol.sortAsc ? 'ASC' : 'DESC'
                        });
                    });
                    this.sortService.emitSortChanged(emitterType, currentLocalSorters_1);
                }
            }
        };
        HeaderMenuExtension.ctorParameters = function () { return [
            { type: ExtensionUtility },
            { type: FilterService },
            { type: SharedService },
            { type: SortService },
            { type: core$1.TranslateService, decorators: [{ type: core.Optional }] }
        ]; };
        HeaderMenuExtension = __decorate([
            core.Injectable(),
            __param(4, core.Optional())
        ], HeaderMenuExtension);
        return HeaderMenuExtension;
    }());

    var DOMPurify$2 = DOMPurify_; // patch to fix rollup to work
    var ROW_DETAIL_CONTAINER_PREFIX = 'container_';
    var PRELOAD_CONTAINER_PREFIX = 'container_loading';
    var RowDetailViewExtension = /** @class */ (function () {
        function RowDetailViewExtension(angularUtilService, appRef, extensionUtility, filterService, sharedService) {
            this.angularUtilService = angularUtilService;
            this.appRef = appRef;
            this.extensionUtility = extensionUtility;
            this.filterService = filterService;
            this.sharedService = sharedService;
            this._views = [];
            this._subscriptions = [];
            this._eventHandler = new Slick.EventHandler();
        }
        Object.defineProperty(RowDetailViewExtension.prototype, "datasetIdPropName", {
            get: function () {
                return this.gridOptions.datasetIdPropertyName || 'id';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RowDetailViewExtension.prototype, "eventHandler", {
            get: function () {
                return this._eventHandler;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RowDetailViewExtension.prototype, "gridOptions", {
            get: function () {
                return this.sharedService && this.sharedService.gridOptions || {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RowDetailViewExtension.prototype, "rowDetailViewOptions", {
            get: function () {
                return this.gridOptions.rowDetailView;
            },
            enumerable: true,
            configurable: true
        });
        /** Dispose of the RowDetailView Extension */
        RowDetailViewExtension.prototype.dispose = function () {
            // unsubscribe all SlickGrid events
            this._eventHandler.unsubscribeAll();
            if (this._addon && this._addon.destroy) {
                this._addon.destroy();
            }
            this.extensionUtility.nullifyFunctionNameStartingWithOn(this._addonOptions);
            this._addonOptions = null;
            // also unsubscribe all RxJS subscriptions
            this._subscriptions = unsubscribeAllObservables(this._subscriptions);
            this.disposeAllViewComponents();
        };
        /** Dispose of all the opened Row Detail Panels Angular View Components */
        RowDetailViewExtension.prototype.disposeAllViewComponents = function () {
            var _this = this;
            this._views.forEach(function (compRef) { return _this.disposeViewComponent(compRef); });
            this._views = [];
        };
        /**
         * Create the plugin before the Grid creation, else it will behave oddly.
         * Mostly because the column definitions might change after the grid creation
         */
        RowDetailViewExtension.prototype.create = function (columnDefinitions, gridOptions) {
            var _this = this;
            if (columnDefinitions && gridOptions) {
                // dynamically import the SlickGrid plugin (addon) with RequireJS
                this.extensionUtility.loadExtensionDynamically(exports.ExtensionName.rowDetailView);
                if (!gridOptions.rowDetailView) {
                    throw new Error('The Row Detail View requires options to be passed via the "rowDetailView" property of the Grid Options');
                }
                if (gridOptions && gridOptions.rowDetailView) {
                    if (!this._addon) {
                        if (typeof gridOptions.rowDetailView.process === 'function') {
                            // we need to keep the user "process" method and replace it with our own execution method
                            // we do this because when we get the item detail, we need to call "onAsyncResponse.notify" for the plugin to work
                            this._userProcessFn = gridOptions.rowDetailView.process; // keep user's process method
                            gridOptions.rowDetailView.process = function (item) { return _this.onProcessing(item); }; // replace process method & run our internal one
                        }
                        else {
                            throw new Error('You need to provide a "process" function for the Row Detail Extension to work properly');
                        }
                        // load the Preload & RowDetail Templates (could be straight HTML or Angular View/ViewModel)
                        // when those are Angular View/ViewModel, we need to create View Component & provide the html containers to the Plugin (preTemplate/postTemplate methods)
                        if (!gridOptions.rowDetailView.preTemplate) {
                            this._preloadComponent = gridOptions && gridOptions.rowDetailView && gridOptions.rowDetailView.preloadComponent;
                            gridOptions.rowDetailView.preTemplate = function () { return DOMPurify$2.sanitize("<div class=\"" + PRELOAD_CONTAINER_PREFIX + "\"></div>"); };
                        }
                        if (!gridOptions.rowDetailView.postTemplate) {
                            this._viewComponent = gridOptions && gridOptions.rowDetailView && gridOptions.rowDetailView.viewComponent;
                            gridOptions.rowDetailView.postTemplate = function (itemDetail) { return DOMPurify$2.sanitize("<div class=\"" + ROW_DETAIL_CONTAINER_PREFIX + itemDetail[_this.datasetIdPropName] + "\"></div>"); };
                        }
                        // finally register the Row Detail View Plugin
                        this._addonOptions = gridOptions.rowDetailView;
                        this._addon = new Slick.Plugins.RowDetailView(this._addonOptions);
                    }
                    var iconColumn = this._addon.getColumnDefinition();
                    if (typeof iconColumn === 'object') {
                        iconColumn.excludeFromExport = true;
                        iconColumn.excludeFromColumnPicker = true;
                        iconColumn.excludeFromGridMenu = true;
                        iconColumn.excludeFromQuery = true;
                        iconColumn.excludeFromHeaderMenu = true;
                        // column index position in the grid
                        var columnPosition = gridOptions && gridOptions.rowDetailView && gridOptions.rowDetailView.columnIndexPosition || 0;
                        if (columnPosition > 0) {
                            columnDefinitions.splice(columnPosition, 0, iconColumn);
                        }
                        else {
                            columnDefinitions.unshift(iconColumn);
                        }
                    }
                }
                return this._addon;
            }
            return null;
        };
        /** Get the instance of the SlickGrid addon (control or plugin). */
        RowDetailViewExtension.prototype.getAddonInstance = function () {
            return this._addon;
        };
        RowDetailViewExtension.prototype.register = function (rowSelectionPlugin) {
            var _this = this;
            if (this.sharedService && this.sharedService.grid && this.sharedService.gridOptions) {
                // the plugin has to be created BEFORE the grid (else it behaves oddly), but we can only watch grid events AFTER the grid is created
                this.sharedService.grid.registerPlugin(this._addon);
                // this also requires the Row Selection Model to be registered as well
                if (!rowSelectionPlugin || !this.sharedService.grid.getSelectionModel()) {
                    this.extensionUtility.loadExtensionDynamically(exports.ExtensionName.rowSelection);
                    rowSelectionPlugin = new Slick.RowSelectionModel(this.sharedService.gridOptions.rowSelectionOptions || { selectActiveRow: true });
                    this.sharedService.grid.setSelectionModel(rowSelectionPlugin);
                }
                // hook all events
                if (this.sharedService.grid && this.rowDetailViewOptions) {
                    if (this.rowDetailViewOptions.onExtensionRegistered) {
                        this.rowDetailViewOptions.onExtensionRegistered(this._addon);
                    }
                    this._eventHandler.subscribe(this._addon.onAsyncResponse, function (e, args) {
                        if (_this.rowDetailViewOptions && typeof _this.rowDetailViewOptions.onAsyncResponse === 'function') {
                            _this.rowDetailViewOptions.onAsyncResponse(e, args);
                        }
                    });
                    this._eventHandler.subscribe(this._addon.onAsyncEndUpdate, function (e, args) {
                        // triggers after backend called "onAsyncResponse.notify()"
                        _this.renderViewModel(args && args.item);
                        if (_this.rowDetailViewOptions && typeof _this.rowDetailViewOptions.onAsyncEndUpdate === 'function') {
                            _this.rowDetailViewOptions.onAsyncEndUpdate(e, args);
                        }
                    });
                    this._eventHandler.subscribe(this._addon.onAfterRowDetailToggle, function (e, args) {
                        // display preload template & re-render all the other Detail Views after toggling
                        // the preload View will eventually go away once the data gets loaded after the "onAsyncEndUpdate" event
                        _this.renderPreloadView();
                        _this.renderAllViewComponents();
                        if (_this.rowDetailViewOptions && typeof _this.rowDetailViewOptions.onAfterRowDetailToggle === 'function') {
                            _this.rowDetailViewOptions.onAfterRowDetailToggle(e, args);
                        }
                    });
                    this._eventHandler.subscribe(this._addon.onBeforeRowDetailToggle, function (e, args) {
                        // before toggling row detail, we need to create View Component if it doesn't exist
                        _this.onBeforeRowDetailToggle(e, args);
                        if (_this.rowDetailViewOptions && typeof _this.rowDetailViewOptions.onBeforeRowDetailToggle === 'function') {
                            _this.rowDetailViewOptions.onBeforeRowDetailToggle(e, args);
                        }
                    });
                    this._eventHandler.subscribe(this._addon.onRowBackToViewportRange, function (e, args) {
                        // when row is back to viewport range, we will re-render the View Component(s)
                        _this.onRowBackToViewportRange(e, args);
                        if (_this.rowDetailViewOptions && typeof _this.rowDetailViewOptions.onRowBackToViewportRange === 'function') {
                            _this.rowDetailViewOptions.onRowBackToViewportRange(e, args);
                        }
                    });
                    this._eventHandler.subscribe(this._addon.onRowOutOfViewportRange, function (e, args) {
                        if (_this.rowDetailViewOptions && typeof _this.rowDetailViewOptions.onRowOutOfViewportRange === 'function') {
                            _this.rowDetailViewOptions.onRowOutOfViewportRange(e, args);
                        }
                    });
                    // --
                    // hook some events needed by the Plugin itself
                    this._eventHandler.subscribe(this.sharedService.grid.onColumnsReordered, function () { return _this.redrawAllViewComponents(); });
                    // on sort, all row detail are collapsed so we can dispose of all the Views as well
                    this._eventHandler.subscribe(this.sharedService.grid.onSort, function () { return _this.disposeAllViewComponents(); });
                    // on filter changed, we need to re-render all Views
                    this._subscriptions.push(this.filterService.onFilterChanged.subscribe(function () { return _this.redrawAllViewComponents(); }));
                }
                return this._addon;
            }
            return null;
        };
        /** Redraw (re-render) all the expanded row detail View Components */
        RowDetailViewExtension.prototype.redrawAllViewComponents = function () {
            var _this = this;
            this._views.forEach(function (compRef) {
                _this.redrawViewComponent(compRef);
            });
        };
        /** Render all the expanded row detail View Components */
        RowDetailViewExtension.prototype.renderAllViewComponents = function () {
            var _this = this;
            this._views.forEach(function (view) {
                if (view && view.dataContext) {
                    _this.renderViewModel(view.dataContext);
                }
            });
        };
        /** Redraw the necessary View Component */
        RowDetailViewExtension.prototype.redrawViewComponent = function (createdView) {
            var containerElements = document.getElementsByClassName("" + ROW_DETAIL_CONTAINER_PREFIX + createdView.id);
            if (containerElements && containerElements.length >= 0) {
                this.renderViewModel(createdView.dataContext);
            }
        };
        /** Render (or re-render) the View Component (Row Detail) */
        RowDetailViewExtension.prototype.renderPreloadView = function () {
            var containerElements = document.getElementsByClassName("" + PRELOAD_CONTAINER_PREFIX);
            if (containerElements && containerElements.length >= 0) {
                this.angularUtilService.createAngularComponentAppendToDom(this._preloadComponent, containerElements[containerElements.length - 1], true);
            }
        };
        /** Render (or re-render) the View Component (Row Detail) */
        RowDetailViewExtension.prototype.renderViewModel = function (item) {
            var _this = this;
            var containerElements = document.getElementsByClassName("" + ROW_DETAIL_CONTAINER_PREFIX + item[this.datasetIdPropName]);
            if (containerElements && containerElements.length > 0) {
                var componentOutput = this.angularUtilService.createAngularComponentAppendToDom(this._viewComponent, containerElements[containerElements.length - 1], true);
                if (componentOutput && componentOutput.componentRef && componentOutput.componentRef.instance) {
                    // pass a few properties to the Row Detail template component
                    Object.assign(componentOutput.componentRef.instance, {
                        model: item,
                        addon: this._addon,
                        grid: this.sharedService.grid,
                        dataView: this.sharedService.dataView,
                        parent: this.rowDetailViewOptions && this.rowDetailViewOptions.parent,
                    });
                    var viewObj = this._views.find(function (obj) { return obj.id === item[_this.datasetIdPropName]; });
                    if (viewObj) {
                        viewObj.componentRef = componentOutput.componentRef;
                    }
                    return viewObj;
                }
            }
            return null;
        };
        // --
        // private functions
        // ------------------
        RowDetailViewExtension.prototype.disposeViewComponent = function (expandedView) {
            var compRef = expandedView && expandedView.componentRef;
            if (compRef) {
                this.appRef.detachView(compRef.hostView);
                compRef.destroy();
                return expandedView;
            }
            return null;
        };
        /**
         * notify the onAsyncResponse with the "args.item" (required property)
         * the plugin will then use item to populate the row detail panel with the "postTemplate"
         * @param item
         */
        RowDetailViewExtension.prototype.notifyTemplate = function (item) {
            if (this._addon) {
                this._addon.onAsyncResponse.notify({ item: item }, undefined, this);
            }
        };
        /**
         * On Processing, we will notify the plugin with the new item detail once backend server call completes
         * @param item
         */
        RowDetailViewExtension.prototype.onProcessing = function (item) {
            return __awaiter(this, void 0, void 0, function () {
                var awaitedItemDetail, userProcessFn, response;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!(item && typeof this._userProcessFn === 'function')) return [3 /*break*/, 5];
                            awaitedItemDetail = void 0;
                            userProcessFn = this._userProcessFn(item);
                            return [4 /*yield*/, userProcessFn];
                        case 1:
                            response = _a.sent();
                            if (!response.hasOwnProperty(this.datasetIdPropName)) return [3 /*break*/, 2];
                            awaitedItemDetail = response; // from Promise
                            return [3 /*break*/, 4];
                        case 2:
                            if (!(response && response instanceof rxjs.Observable || response instanceof Promise)) return [3 /*break*/, 4];
                            return [4 /*yield*/, castToPromise(response)];
                        case 3:
                            awaitedItemDetail = _a.sent(); // from Angular-http-client
                            _a.label = 4;
                        case 4:
                            if (!awaitedItemDetail || !awaitedItemDetail.hasOwnProperty(this.datasetIdPropName)) {
                                throw new Error("[Angular-Slickgrid] could not process the Row Detail, you must make sure that your \"process\" callback\n          (a Promise or an HttpClient call returning an Observable) returns an item object that has an \"" + this.datasetIdPropName + "\" property");
                            }
                            // notify the plugin with the new item details
                            this.notifyTemplate(awaitedItemDetail || {});
                            _a.label = 5;
                        case 5: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Just before the row get expanded or collapsed we will do the following
         * First determine if the row is expanding or collapsing,
         * if it's expanding we will add it to our View Components reference array if we don't already have it
         * or if it's collapsing we will remove it from our View Components reference array
         */
        RowDetailViewExtension.prototype.onBeforeRowDetailToggle = function (e, args) {
            var _this = this;
            // expanding
            if (args && args.item && args.item.__collapsed) {
                // expanding row detail
                var viewInfo = {
                    id: args.item[this.datasetIdPropName],
                    dataContext: args.item
                };
                var idPropName = this.gridOptions.datasetIdPropertyName || 'id';
                addToArrayWhenNotExists(this._views, viewInfo, idPropName);
            }
            else {
                // collapsing, so dispose of the View/Component
                var foundViewIndex = this._views.findIndex(function (view) { return view.id === args.item[_this.datasetIdPropName]; });
                if (foundViewIndex >= 0 && this._views.hasOwnProperty(foundViewIndex)) {
                    var compRef = this._views[foundViewIndex].componentRef;
                    this.appRef.detachView(compRef.hostView);
                    compRef.destroy();
                    this._views.splice(foundViewIndex, 1);
                }
            }
        };
        /** When Row comes back to Viewport Range, we need to redraw the View */
        RowDetailViewExtension.prototype.onRowBackToViewportRange = function (e, args) {
            var _this = this;
            if (args && args.item) {
                this._views.forEach(function (view) {
                    if (view.id === args.item[_this.datasetIdPropName]) {
                        _this.redrawViewComponent(view);
                    }
                });
            }
        };
        RowDetailViewExtension.ctorParameters = function () { return [
            { type: AngularUtilService },
            { type: core.ApplicationRef },
            { type: ExtensionUtility },
            { type: FilterService },
            { type: SharedService }
        ]; };
        RowDetailViewExtension = __decorate([
            core.Injectable()
        ], RowDetailViewExtension);
        return RowDetailViewExtension;
    }());

    var RowMoveManagerExtension = /** @class */ (function () {
        function RowMoveManagerExtension(extensionUtility, sharedService) {
            this.extensionUtility = extensionUtility;
            this.sharedService = sharedService;
            this._eventHandler = new Slick.EventHandler();
        }
        Object.defineProperty(RowMoveManagerExtension.prototype, "eventHandler", {
            get: function () {
                return this._eventHandler;
            },
            enumerable: true,
            configurable: true
        });
        RowMoveManagerExtension.prototype.dispose = function () {
            // unsubscribe all SlickGrid events
            this._eventHandler.unsubscribeAll();
            if (this._addon && this._addon.destroy) {
                this._addon.destroy();
                this._addon = null;
            }
            if (this._rowSelectionPlugin && this._rowSelectionPlugin.destroy) {
                this._rowSelectionPlugin.destroy();
            }
        };
        /**
         * Create the plugin before the Grid creation to avoid having odd behaviors.
         * Mostly because the column definitions might change after the grid creation, so we want to make sure to add it before then
         */
        RowMoveManagerExtension.prototype.create = function (columnDefinitions, gridOptions) {
            if (Array.isArray(columnDefinitions) && gridOptions) {
                this._addon = this.loadAddonWhenNotExists(columnDefinitions, gridOptions);
                var newRowMoveColumn = this._addon.getColumnDefinition();
                var rowMoveColDef = Array.isArray(columnDefinitions) && columnDefinitions.find(function (col) { return col && col.behavior === 'selectAndMove'; });
                var finalRowMoveColumn = rowMoveColDef ? rowMoveColDef : newRowMoveColumn;
                // set some exclusion properties since we don't want this column to be part of the export neither the list of column in the pickers
                if (typeof finalRowMoveColumn === 'object') {
                    finalRowMoveColumn.excludeFromExport = true;
                    finalRowMoveColumn.excludeFromColumnPicker = true;
                    finalRowMoveColumn.excludeFromGridMenu = true;
                    finalRowMoveColumn.excludeFromQuery = true;
                    finalRowMoveColumn.excludeFromHeaderMenu = true;
                }
                // only add the new column if it doesn't already exist
                if (!rowMoveColDef) {
                    // column index position in the grid
                    var columnPosition = gridOptions && gridOptions.rowMoveManager && gridOptions.rowMoveManager.columnIndexPosition || 0;
                    if (columnPosition > 0) {
                        columnDefinitions.splice(columnPosition, 0, finalRowMoveColumn);
                    }
                    else {
                        columnDefinitions.unshift(finalRowMoveColumn);
                    }
                }
                return this._addon;
            }
            return null;
        };
        RowMoveManagerExtension.prototype.loadAddonWhenNotExists = function (columnDefinitions, gridOptions) {
            if (Array.isArray(columnDefinitions) && gridOptions) {
                // dynamically import the SlickGrid plugin (addon) with RequireJS
                this.extensionUtility.loadExtensionDynamically(exports.ExtensionName.rowMoveManager);
                if (!this._addon) {
                    this._addon = new Slick.RowMoveManager(gridOptions && gridOptions.rowMoveManager || { cancelEditOnDrag: true });
                }
                return this._addon;
            }
            return null;
        };
        /** Get the instance of the SlickGrid addon (control or plugin). */
        RowMoveManagerExtension.prototype.getAddonInstance = function () {
            return this._addon;
        };
        RowMoveManagerExtension.prototype.register = function (rowSelectionPlugin) {
            var _this = this;
            if (this.sharedService && this.sharedService.grid && this.sharedService.gridOptions) {
                // dynamically import the SlickGrid plugin (addon) with RequireJS
                this.extensionUtility.loadExtensionDynamically(exports.ExtensionName.rowMoveManager);
                // this also requires the Row Selection Model to be registered as well
                if (!rowSelectionPlugin || !this.sharedService.grid.getSelectionModel()) {
                    this.extensionUtility.loadExtensionDynamically(exports.ExtensionName.rowSelection);
                    rowSelectionPlugin = new Slick.RowSelectionModel(this.sharedService.gridOptions.rowSelectionOptions || {});
                    this.sharedService.grid.setSelectionModel(rowSelectionPlugin);
                }
                this._rowSelectionPlugin = rowSelectionPlugin;
                this.sharedService.grid.registerPlugin(this._addon);
                // hook all events
                if (this.sharedService.grid && this.sharedService.gridOptions.rowMoveManager) {
                    if (this.sharedService.gridOptions.rowMoveManager.onExtensionRegistered) {
                        this.sharedService.gridOptions.rowMoveManager.onExtensionRegistered(this._addon);
                    }
                    this._eventHandler.subscribe(this._addon.onBeforeMoveRows, function (e, args) {
                        if (_this.sharedService.gridOptions.rowMoveManager && typeof _this.sharedService.gridOptions.rowMoveManager.onBeforeMoveRows === 'function') {
                            _this.sharedService.gridOptions.rowMoveManager.onBeforeMoveRows(e, args);
                        }
                    });
                    this._eventHandler.subscribe(this._addon.onMoveRows, function (e, args) {
                        if (_this.sharedService.gridOptions.rowMoveManager && typeof _this.sharedService.gridOptions.rowMoveManager.onMoveRows === 'function') {
                            _this.sharedService.gridOptions.rowMoveManager.onMoveRows(e, args);
                        }
                    });
                }
                return this._addon;
            }
            return null;
        };
        RowMoveManagerExtension.ctorParameters = function () { return [
            { type: ExtensionUtility },
            { type: SharedService }
        ]; };
        RowMoveManagerExtension = __decorate([
            core.Injectable()
        ], RowMoveManagerExtension);
        return RowMoveManagerExtension;
    }());

    var RowSelectionExtension = /** @class */ (function () {
        function RowSelectionExtension(extensionUtility, sharedService) {
            this.extensionUtility = extensionUtility;
            this.sharedService = sharedService;
        }
        RowSelectionExtension.prototype.dispose = function () {
            if (this._addon && this._addon.destroy) {
                this._addon.destroy();
            }
            this._addon = null;
        };
        /** Get the instance of the SlickGrid addon (control or plugin). */
        RowSelectionExtension.prototype.getAddonInstance = function () {
            return this._addon;
        };
        RowSelectionExtension.prototype.register = function () {
            if (this.sharedService && this.sharedService.grid && this.sharedService.gridOptions) {
                // dynamically import the SlickGrid plugin (addon) with RequireJS
                this.extensionUtility.loadExtensionDynamically(exports.ExtensionName.rowSelection);
                this._addon = new Slick.RowSelectionModel(this.sharedService.gridOptions.rowSelectionOptions || {});
                this.sharedService.grid.setSelectionModel(this._addon);
                return this._addon;
            }
            return null;
        };
        RowSelectionExtension.ctorParameters = function () { return [
            { type: ExtensionUtility },
            { type: SharedService }
        ]; };
        RowSelectionExtension = __decorate([
            core.Injectable()
        ], RowSelectionExtension);
        return RowSelectionExtension;
    }());

    var ExtensionService = /** @class */ (function () {
        function ExtensionService(autoTooltipExtension, cellExternalCopyExtension, cellMenuExtension, checkboxSelectorExtension, columnPickerExtension, contextMenuExtension, draggableGroupingExtension, gridMenuExtension, groupItemMetaExtension, headerButtonExtension, headerMenuExtension, rowDetailViewExtension, rowMoveManagerExtension, rowSelectionExtension, sharedService, translate) {
            this.autoTooltipExtension = autoTooltipExtension;
            this.cellExternalCopyExtension = cellExternalCopyExtension;
            this.cellMenuExtension = cellMenuExtension;
            this.checkboxSelectorExtension = checkboxSelectorExtension;
            this.columnPickerExtension = columnPickerExtension;
            this.contextMenuExtension = contextMenuExtension;
            this.draggableGroupingExtension = draggableGroupingExtension;
            this.gridMenuExtension = gridMenuExtension;
            this.groupItemMetaExtension = groupItemMetaExtension;
            this.headerButtonExtension = headerButtonExtension;
            this.headerMenuExtension = headerMenuExtension;
            this.rowDetailViewExtension = rowDetailViewExtension;
            this.rowMoveManagerExtension = rowMoveManagerExtension;
            this.rowSelectionExtension = rowSelectionExtension;
            this.sharedService = sharedService;
            this.translate = translate;
            this._extensionCreatedList = {};
            this._extensionList = {};
        }
        Object.defineProperty(ExtensionService.prototype, "extensionList", {
            get: function () {
                return this._extensionList;
            },
            enumerable: true,
            configurable: true
        });
        /** Dispose of all the controls & plugins */
        ExtensionService.prototype.dispose = function () {
            var e_1, _a, e_2, _b;
            this.sharedService.grid = null;
            this.sharedService.visibleColumns = [];
            try {
                // dispose of each control/plugin & reset the list
                for (var _c = __values(Object.keys(this._extensionList)), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var extensionName = _d.value;
                    if (this._extensionList.hasOwnProperty(extensionName)) {
                        var extension = this._extensionList[extensionName];
                        if (extension && extension.class && extension.class.dispose) {
                            extension.class.dispose();
                        }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            try {
                for (var _e = __values(Object.keys(this._extensionList)), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var key = _f.value;
                    delete this._extensionList[key];
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_2) throw e_2.error; }
            }
        };
        /** Get all columns (includes visible and non-visible) */
        ExtensionService.prototype.getAllColumns = function () {
            return this.sharedService.allColumns || [];
        };
        /** Get only visible columns */
        ExtensionService.prototype.getVisibleColumns = function () {
            return this.sharedService.visibleColumns || [];
        };
        /**
         * Get an Extension by it's name
         *  @param name
         */
        ExtensionService.prototype.getExtensionByName = function (name) {
            if (this._extensionList && this._extensionList[name]) {
                return this._extensionList[name];
            }
            return undefined;
        };
        /**
         * Get the instance of the SlickGrid addon (control or plugin).
         * This is the raw addon coming directly from SlickGrid itself, not to confuse with Angular-Slickgrid extension
         *  @param name
         */
        ExtensionService.prototype.getSlickgridAddonInstance = function (name) {
            var extension = this.getExtensionByName(name);
            if (extension && extension.class && (extension.instance || extension.addon)) {
                if (extension.class && extension.class.getAddonInstance) {
                    return extension.class.getAddonInstance();
                }
                return extension.instance;
            }
            return null;
        };
        /** Auto-resize all the column in the grid to fit the grid width */
        ExtensionService.prototype.autoResizeColumns = function () {
            this.sharedService.grid.autosizeColumns();
        };
        /** Bind/Create different Controls or Plugins after the Grid is created */
        ExtensionService.prototype.bindDifferentExtensions = function () {
            var _this = this;
            if (this.sharedService && this.sharedService.gridOptions) {
                // make sure all columns are translated before creating ColumnPicker/GridMenu Controls
                // this is to avoid having hidden columns not being translated on first load
                if (this.sharedService.gridOptions.enableTranslate) {
                    // eventually deprecate the "headerKey" and use only the "nameKey"
                    this.translateItems(this.sharedService.allColumns, 'headerKey', 'name');
                    this.translateItems(this.sharedService.allColumns, 'nameKey', 'name');
                }
                // Auto Tooltip Plugin
                if (this.sharedService.gridOptions.enableAutoTooltip) {
                    if (this.autoTooltipExtension && this.autoTooltipExtension.register) {
                        var instance = this.autoTooltipExtension.register();
                        this._extensionList[exports.ExtensionName.autoTooltip] = { name: exports.ExtensionName.autoTooltip, class: this.autoTooltipExtension, addon: instance, instance: instance };
                    }
                }
                // Cell External Copy Manager Plugin (Excel Like)
                if (this.sharedService.gridOptions.enableExcelCopyBuffer) {
                    if (this.cellExternalCopyExtension && this.cellExternalCopyExtension.register) {
                        var instance = this.cellExternalCopyExtension.register();
                        this._extensionList[exports.ExtensionName.cellExternalCopyManager] = { name: exports.ExtensionName.cellExternalCopyManager, class: this.cellExternalCopyExtension, addon: instance, instance: instance };
                    }
                }
                // (Action) Cell Menu Plugin
                if (this.sharedService.gridOptions.enableCellMenu) {
                    if (this.cellMenuExtension && this.cellMenuExtension.register) {
                        var instance = this.cellMenuExtension.register();
                        this._extensionList[exports.ExtensionName.cellMenu] = { name: exports.ExtensionName.cellMenu, class: this.cellMenuExtension, addon: instance, instance: instance };
                    }
                }
                // Row Selection Plugin
                // this extension should be registered BEFORE the CheckboxSelector, RowDetail or RowMoveManager since it can be use by these 2 plugins
                if (!this.getExtensionByName(exports.ExtensionName.rowSelection) && (this.sharedService.gridOptions.enableRowSelection || this.sharedService.gridOptions.enableCheckboxSelector || this.sharedService.gridOptions.enableRowDetailView || this.sharedService.gridOptions.enableRowMoveManager)) {
                    if (this.rowSelectionExtension && this.rowSelectionExtension.register) {
                        var instance = this.rowSelectionExtension.register();
                        this._extensionList[exports.ExtensionName.rowSelection] = { name: exports.ExtensionName.rowSelection, class: this.rowSelectionExtension, addon: instance, instance: instance };
                    }
                }
                // Checkbox Selector Plugin
                if (this.sharedService.gridOptions.enableCheckboxSelector) {
                    if (this.checkboxSelectorExtension && this.checkboxSelectorExtension.register) {
                        var rowSelectionExtension = this.getExtensionByName(exports.ExtensionName.rowSelection);
                        this.checkboxSelectorExtension.register(rowSelectionExtension);
                        var createdExtension = this.getCreatedExtensionByName(exports.ExtensionName.checkboxSelector); // get the instance from when it was really created earlier
                        var instance = createdExtension && createdExtension.instance;
                        this._extensionList[exports.ExtensionName.checkboxSelector] = { name: exports.ExtensionName.checkboxSelector, class: this.checkboxSelectorExtension, addon: instance, instance: instance };
                    }
                }
                // Column Picker Control
                if (this.sharedService.gridOptions.enableColumnPicker) {
                    if (this.columnPickerExtension && this.columnPickerExtension.register) {
                        var instance = this.columnPickerExtension.register();
                        this._extensionList[exports.ExtensionName.columnPicker] = { name: exports.ExtensionName.columnPicker, class: this.columnPickerExtension, addon: instance, instance: instance };
                    }
                }
                // Context Menu Control
                if (this.sharedService.gridOptions.enableContextMenu) {
                    if (this.contextMenuExtension && this.contextMenuExtension.register) {
                        var instance = this.contextMenuExtension.register();
                        this._extensionList[exports.ExtensionName.contextMenu] = { name: exports.ExtensionName.contextMenu, class: this.contextMenuExtension, addon: instance, instance: instance };
                    }
                }
                // Draggable Grouping Plugin
                if (this.sharedService.gridOptions.enableDraggableGrouping) {
                    if (this.draggableGroupingExtension && this.draggableGroupingExtension.register) {
                        var instance = this.draggableGroupingExtension.register();
                        this._extensionList[exports.ExtensionName.draggableGrouping] = { name: exports.ExtensionName.draggableGrouping, class: this.draggableGroupingExtension, addon: instance, instance: instance };
                    }
                }
                // Grid Menu Control
                if (this.sharedService.gridOptions.enableGridMenu) {
                    if (this.gridMenuExtension && this.gridMenuExtension.register) {
                        var instance = this.gridMenuExtension.register();
                        this._extensionList[exports.ExtensionName.gridMenu] = { name: exports.ExtensionName.gridMenu, class: this.gridMenuExtension, addon: instance, instance: instance };
                    }
                }
                // Grouping Plugin
                // register the group item metadata provider to add expand/collapse group handlers
                if (this.sharedService.gridOptions.enableDraggableGrouping || this.sharedService.gridOptions.enableGrouping) {
                    if (this.groupItemMetaExtension && this.groupItemMetaExtension.register) {
                        var instance = this.groupItemMetaExtension.register();
                        this._extensionList[exports.ExtensionName.groupItemMetaProvider] = { name: exports.ExtensionName.groupItemMetaProvider, class: this.groupItemMetaExtension, addon: instance, instance: instance };
                    }
                }
                // Header Button Plugin
                if (this.sharedService.gridOptions.enableHeaderButton) {
                    if (this.headerButtonExtension && this.headerButtonExtension.register) {
                        var instance = this.headerButtonExtension.register();
                        this._extensionList[exports.ExtensionName.headerButton] = { name: exports.ExtensionName.headerButton, class: this.headerButtonExtension, addon: instance, instance: instance };
                    }
                }
                // Header Menu Plugin
                if (this.sharedService.gridOptions.enableHeaderMenu) {
                    if (this.headerMenuExtension && this.headerMenuExtension.register) {
                        var instance = this.headerMenuExtension.register();
                        this._extensionList[exports.ExtensionName.headerMenu] = { name: exports.ExtensionName.headerMenu, class: this.headerMenuExtension, addon: instance, instance: instance };
                    }
                }
                // Row Detail View Plugin
                if (this.sharedService.gridOptions.enableRowDetailView) {
                    if (this.rowDetailViewExtension && this.rowDetailViewExtension.register) {
                        var rowSelectionExtension = this.getExtensionByName(exports.ExtensionName.rowSelection);
                        this.rowDetailViewExtension.register(rowSelectionExtension);
                        var createdExtension = this.getCreatedExtensionByName(exports.ExtensionName.rowDetailView); // get the plugin from when it was really created earlier
                        var instance = createdExtension && createdExtension.instance;
                        this._extensionList[exports.ExtensionName.rowDetailView] = { name: exports.ExtensionName.rowDetailView, class: this.rowDetailViewExtension, addon: instance, instance: instance };
                    }
                }
                // Row Move Manager Plugin
                if (this.sharedService.gridOptions.enableRowMoveManager && this.rowMoveManagerExtension && this.rowMoveManagerExtension.register) {
                    var rowSelectionExtension = this.getExtensionByName(exports.ExtensionName.rowSelection);
                    this.rowMoveManagerExtension.register(rowSelectionExtension);
                    var createdExtension = this.getCreatedExtensionByName(exports.ExtensionName.rowMoveManager); // get the instance from when it was really created earlier
                    var instance = createdExtension && createdExtension.instance;
                    this._extensionList[exports.ExtensionName.rowMoveManager] = { name: exports.ExtensionName.rowMoveManager, class: this.rowMoveManagerExtension, addon: instance, instance: instance };
                }
                // manually register other plugins
                if (this.sharedService.gridOptions.registerPlugins !== undefined) {
                    var grid_1 = this.sharedService.grid;
                    var gridOptions = this.sharedService.gridOptions;
                    if (Array.isArray(gridOptions.registerPlugins)) {
                        gridOptions.registerPlugins.forEach(function (plugin) {
                            grid_1.registerPlugin(plugin);
                            var instance = grid_1.getPluginByName(plugin && plugin.name || '');
                            _this._extensionList[exports.ExtensionName.noname] = { name: exports.ExtensionName.noname, class: null, addon: instance, instance: instance };
                        });
                    }
                    else {
                        var plugin = gridOptions.registerPlugins;
                        grid_1.registerPlugin(plugin);
                        var instance = grid_1.getPluginByName(plugin && plugin.name || '');
                        this._extensionList[exports.ExtensionName.noname] = { name: exports.ExtensionName.noname, class: null, addon: instance, instance: instance };
                    }
                }
            }
        };
        /**
         * Bind/Create certain plugins before the Grid creation to avoid having odd behaviors.
         * Mostly because the column definitions might change after the grid creation, so we want to make sure to add it before then
         * @param columnDefinitions
         * @param options
         */
        ExtensionService.prototype.createExtensionsBeforeGridCreation = function (columnDefinitions, options) {
            if (options.enableCheckboxSelector) {
                if (!this.getCreatedExtensionByName(exports.ExtensionName.checkboxSelector)) {
                    var checkboxInstance = this.checkboxSelectorExtension.create(columnDefinitions, options);
                    this._extensionCreatedList[exports.ExtensionName.checkboxSelector] = { name: exports.ExtensionName.checkboxSelector, addon: checkboxInstance, instance: checkboxInstance, class: this.checkboxSelectorExtension };
                }
            }
            if (options.enableRowMoveManager) {
                if (!this.getCreatedExtensionByName(exports.ExtensionName.rowMoveManager)) {
                    var rowMoveInstance = this.rowMoveManagerExtension.create(columnDefinitions, options);
                    this._extensionCreatedList[exports.ExtensionName.rowMoveManager] = { name: exports.ExtensionName.rowMoveManager, addon: rowMoveInstance, instance: rowMoveInstance, class: this.rowMoveManagerExtension };
                }
            }
            if (options.enableRowDetailView) {
                if (!this.getCreatedExtensionByName(exports.ExtensionName.rowDetailView)) {
                    var rowDetailInstance = this.rowDetailViewExtension.create(columnDefinitions, options);
                    this._extensionCreatedList[exports.ExtensionName.rowDetailView] = { name: exports.ExtensionName.rowDetailView, addon: rowDetailInstance, instance: rowDetailInstance, class: this.rowDetailViewExtension };
                }
            }
            if (options.enableDraggableGrouping) {
                if (!this.getCreatedExtensionByName(exports.ExtensionName.draggableGrouping)) {
                    var draggableInstance = this.draggableGroupingExtension.create(options);
                    options.enableColumnReorder = draggableInstance.getSetupColumnReorder;
                    this._extensionCreatedList[exports.ExtensionName.draggableGrouping] = { name: exports.ExtensionName.draggableGrouping, addon: draggableInstance, instance: draggableInstance, class: draggableInstance.getSetupColumnReorder };
                }
            }
        };
        /** Hide a column from the grid */
        ExtensionService.prototype.hideColumn = function (column) {
            if (this.sharedService && this.sharedService.grid && this.sharedService.grid.getColumns && this.sharedService.grid.setColumns) {
                var columnIndex = this.sharedService.grid.getColumnIndex(column.id);
                this.sharedService.visibleColumns = this.removeColumnByIndex(this.sharedService.grid.getColumns(), columnIndex);
                this.sharedService.grid.setColumns(this.sharedService.visibleColumns);
            }
        };
        /** Refresh the dataset through the Backend Service */
        ExtensionService.prototype.refreshBackendDataset = function (gridOptions) {
            this.gridMenuExtension.refreshBackendDataset(gridOptions);
        };
        /**
         * Remove a column from the grid by it's index in the grid
         * @param columns input
         * @param index
         */
        ExtensionService.prototype.removeColumnByIndex = function (columns, index) {
            if (Array.isArray(columns)) {
                return columns.filter(function (el, i) { return index !== i; });
            }
            return columns;
        };
        /** Translate the Cell Menu titles, we need to loop through all column definition to re-translate them */
        ExtensionService.prototype.translateCellMenu = function () {
            if (this.cellMenuExtension && this.cellMenuExtension.translateCellMenu) {
                this.cellMenuExtension.translateCellMenu();
            }
        };
        /** Translate the Column Picker and it's last 2 checkboxes */
        ExtensionService.prototype.translateColumnPicker = function () {
            if (this.columnPickerExtension && this.columnPickerExtension.translateColumnPicker) {
                this.columnPickerExtension.translateColumnPicker();
            }
        };
        /** Translate the Context Menu titles, we need to loop through all column definition to re-translate them */
        ExtensionService.prototype.translateContextMenu = function () {
            if (this.contextMenuExtension && this.contextMenuExtension.translateContextMenu) {
                this.contextMenuExtension.translateContextMenu();
            }
        };
        /**
         * Translate the Header Menu titles, we need to loop through all column definition to re-translate them
         */
        ExtensionService.prototype.translateGridMenu = function () {
            if (this.gridMenuExtension && this.gridMenuExtension.translateGridMenu) {
                this.gridMenuExtension.translateGridMenu();
            }
        };
        /**
         * Translate the Header Menu titles, we need to loop through all column definition to re-translate them
         */
        ExtensionService.prototype.translateHeaderMenu = function () {
            if (this.headerMenuExtension && this.headerMenuExtension.translateHeaderMenu) {
                this.headerMenuExtension.translateHeaderMenu();
            }
        };
        /**
         * Translate manually the header titles.
         * We could optionally pass a locale (that will change currently loaded locale), else it will use current locale
         * @param locale to use
         * @param new column definitions (optional)
         */
        ExtensionService.prototype.translateColumnHeaders = function (locale, newColumnDefinitions) {
            if (this.sharedService && this.sharedService.gridOptions && this.sharedService.gridOptions.enableTranslate && (!this.translate || !this.translate.instant)) {
                throw new Error('[Angular-Slickgrid] requires "ngx-translate" to be installed and configured when the grid option "enableTranslate" is enabled.');
            }
            if (locale) {
                this.translate.use(locale);
            }
            var columnDefinitions = newColumnDefinitions;
            if (!columnDefinitions) {
                columnDefinitions = this.sharedService.columnDefinitions;
            }
            // eventually deprecate the "headerKey" and use only the "nameKey"
            this.translateItems(columnDefinitions, 'headerKey', 'name');
            this.translateItems(this.sharedService.allColumns, 'headerKey', 'name');
            this.translateItems(columnDefinitions, 'nameKey', 'name');
            this.translateItems(this.sharedService.allColumns, 'nameKey', 'name');
            // re-render the column headers
            this.renderColumnHeaders(columnDefinitions, Array.isArray(newColumnDefinitions));
            this.gridMenuExtension.translateGridMenu();
        };
        /**
         * Render (or re-render) the column headers from column definitions.
         * calling setColumns() will trigger a grid re-render
         */
        ExtensionService.prototype.renderColumnHeaders = function (newColumnDefinitions, forceColumnDefinitionsOverwrite) {
            if (forceColumnDefinitionsOverwrite === void 0) { forceColumnDefinitionsOverwrite = false; }
            var collection = newColumnDefinitions;
            if (!collection) {
                collection = this.sharedService.columnDefinitions;
            }
            if (Array.isArray(collection) && this.sharedService.grid && this.sharedService.grid.setColumns) {
                if (collection.length > this.sharedService.allColumns.length || forceColumnDefinitionsOverwrite) {
                    this.sharedService.allColumns = collection;
                }
                this.sharedService.grid.setColumns(collection);
            }
            // dispose of previous Column Picker instance, then re-register it and don't forget to overwrite previous instance ref
            if (this.sharedService.gridOptions.enableColumnPicker) {
                this.columnPickerExtension.dispose();
                var instance = this.columnPickerExtension.register();
                var extension = this.getExtensionByName(exports.ExtensionName.columnPicker);
                if (extension) {
                    extension.addon = instance;
                    extension.instance = instance;
                }
            }
            // dispose of previous Grid Menu instance, then re-register it and don't forget to overwrite previous instance ref
            if (this.sharedService.gridOptions.enableGridMenu) {
                this.gridMenuExtension.dispose();
                var instance = this.gridMenuExtension.register();
                var extension = this.getExtensionByName(exports.ExtensionName.gridMenu);
                if (extension) {
                    extension.addon = instance;
                    extension.instance = instance;
                }
            }
        };
        //
        // private functions
        // -------------------
        /**
         * Get an Extension that was created by calling its "create" method (there are only 3 extensions which uses this method)
         *  @param name
         */
        ExtensionService.prototype.getCreatedExtensionByName = function (name) {
            if (this._extensionCreatedList && this._extensionCreatedList.hasOwnProperty(name)) {
                return this._extensionCreatedList[name];
            }
            return undefined;
        };
        /** Translate an array of items from an input key and assign translated value to the output key */
        ExtensionService.prototype.translateItems = function (items, inputKey, outputKey) {
            var e_3, _a;
            if (this.sharedService.gridOptions && this.sharedService.gridOptions.enableTranslate && (!this.translate || !this.translate.instant)) {
                throw new Error('[Angular-Slickgrid] requires "ngx-translate" to be installed and configured when the grid option "enableTranslate" is enabled.');
            }
            if (Array.isArray(items)) {
                try {
                    for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
                        var item = items_1_1.value;
                        if (item[inputKey]) {
                            item[outputKey] = this.translate && this.translate.currentLang && this.translate.instant(item[inputKey]);
                        }
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
            }
        };
        ExtensionService.ctorParameters = function () { return [
            { type: AutoTooltipExtension },
            { type: CellExternalCopyManagerExtension },
            { type: CellMenuExtension },
            { type: CheckboxSelectorExtension },
            { type: ColumnPickerExtension },
            { type: ContextMenuExtension },
            { type: DraggableGroupingExtension },
            { type: GridMenuExtension },
            { type: GroupItemMetaProviderExtension },
            { type: HeaderButtonExtension },
            { type: HeaderMenuExtension },
            { type: RowDetailViewExtension },
            { type: RowMoveManagerExtension },
            { type: RowSelectionExtension },
            { type: SharedService },
            { type: core$1.TranslateService, decorators: [{ type: core.Optional }] }
        ]; };
        ExtensionService = __decorate([
            core.Injectable(),
            __param(15, core.Optional())
        ], ExtensionService);
        return ExtensionService;
    }());

    /**
     * This GraphqlQueryBuilder class is a lib that already exist
     * but was causing issues with TypeScript, RequireJS and other bundler/packagers
     * and so I rewrote it in pure TypeScript.
     *
     * The previous lib can be viewed here at this Github
     * https://github.com/codemeasandwich/graphql-query-builder
     */
    var GraphqlQueryBuilder = /** @class */ (function () {
        /* Constructor, query/mutator you wish to use, and an alias or filter arguments. */
        function GraphqlQueryBuilder(queryFnName, aliasOrFilter) {
            this.queryFnName = queryFnName;
            this.head = [];
            if (typeof aliasOrFilter === 'string') {
                this.alias = aliasOrFilter;
            }
            else if (typeof aliasOrFilter === 'object') {
                this.filter(aliasOrFilter);
            }
            else if (aliasOrFilter === undefined && arguments.length === 2) {
                throw new TypeError("You have passed undefined as Second argument to \"Query\"");
            }
            else if (aliasOrFilter !== undefined) {
                throw new TypeError("Second argument to \"Query\" should be an alias name(String) or filter arguments(Object). What was passed is: " + aliasOrFilter);
            }
        }
        /**
         * The parameters to run the query against.
         * @param filters An object mapping attribute to values
         */
        GraphqlQueryBuilder.prototype.filter = function (filters) {
            var e_1, _a;
            try {
                for (var _b = __values(Object.keys(filters)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var prop = _c.value;
                    if (typeof filters[prop] === 'function') {
                        continue;
                    }
                    var val = this.getGraphQLValue(filters[prop]);
                    if (val === '{}') {
                        continue;
                    }
                    this.head.push(prop + ":" + val);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return this;
        };
        /**
         * Outlines the properties you wish to be returned from the query.
         * @param properties representing each attribute you want Returned
         */
        GraphqlQueryBuilder.prototype.find = function () {
            var searches = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                searches[_i] = arguments[_i];
            }
            if (!searches || !Array.isArray(searches) || searches.length === 0) {
                throw new TypeError("find value can not be >>falsy<<");
            }
            // if its a string.. it may have other values
            // else it sould be an Object or Array of maped values
            var searchKeys = (searches.length === 1 && Array.isArray(searches[0])) ? searches[0] : searches;
            this.body = this.parceFind(searchKeys);
            return this;
        };
        /**
         * set an alias for this result.
         * @param alias
         */
        GraphqlQueryBuilder.prototype.setAlias = function (alias) {
            this.alias = alias;
        };
        /**
         * Return to the formatted query string
         * @return
         */
        GraphqlQueryBuilder.prototype.toString = function () {
            if (this.body === undefined) {
                throw new ReferenceError("return properties are not defined. use the 'find' function to defined them");
            }
            return ((this.alias) ? (this.alias + ':') : '') + " " + this.queryFnName + " " + ((this.head.length > 0) ? '(' + this.head.join(',') + ')' : '') + "  { " + this.body + " }";
        };
        // --
        // PRIVATE FUNCTIONS
        // -----------------
        GraphqlQueryBuilder.prototype.parceFind = function (_levelA) {
            var propsA = _levelA.map(function (currentValue, index) {
                var itemX = _levelA[index];
                if (itemX instanceof GraphqlQueryBuilder) {
                    return itemX.toString();
                }
                else if (!Array.isArray(itemX) && typeof itemX === 'object') {
                    var propsAA = Object.keys(itemX);
                    if (1 !== propsAA.length) {
                        throw new RangeError("Alias objects should only have one value. was passed: " + JSON.stringify(itemX));
                    }
                    var propS = propsAA[0];
                    var item = itemX[propS];
                    if (Array.isArray(item)) {
                        return new GraphqlQueryBuilder(propS).find(item);
                    }
                    return propS + " : " + item + " ";
                }
                else if (typeof itemX === 'string') {
                    return itemX;
                }
                else {
                    throw new RangeError("cannot handle Find value of " + itemX);
                }
            });
            return propsA.join(',');
        };
        GraphqlQueryBuilder.prototype.getGraphQLValue = function (value) {
            var _this = this;
            if (typeof value === 'string') {
                value = JSON.stringify(value);
            }
            else if (Array.isArray(value)) {
                value = value.map(function (item) {
                    return _this.getGraphQLValue(item);
                }).join();
                value = "[" + value + "]";
            }
            else if (value instanceof Date) {
                value = JSON.stringify(value);
            }
            else if (value !== null && typeof value === 'object') {
                value = this.objectToString(value);
            }
            return value;
        };
        GraphqlQueryBuilder.prototype.objectToString = function (obj) {
            var e_2, _a;
            var sourceA = [];
            try {
                for (var _b = __values(Object.keys(obj)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var prop = _c.value;
                    if (typeof obj[prop] === 'function') {
                        continue;
                    }
                    sourceA.push(prop + ":" + this.getGraphQLValue(obj[prop]));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return "{" + sourceA.join() + "}";
        };
        return GraphqlQueryBuilder;
    }());

    var DEFAULT_ITEMS_PER_PAGE = 25;
    var DEFAULT_PAGE_SIZE = 20;
    var GraphqlService = /** @class */ (function () {
        function GraphqlService() {
            this._currentFilters = [];
            this._currentSorters = [];
            this._datasetIdPropName = 'id';
            this.defaultPaginationOptions = {
                first: DEFAULT_ITEMS_PER_PAGE,
                offset: 0
            };
        }
        Object.defineProperty(GraphqlService.prototype, "columnDefinitions", {
            /** Getter for the Column Definitions */
            get: function () {
                return this._columnDefinitions;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GraphqlService.prototype, "_gridOptions", {
            /** Getter for the Grid Options pulled through the Grid Object */
            get: function () {
                return (this._grid && this._grid.getOptions) ? this._grid.getOptions() : {};
            },
            enumerable: true,
            configurable: true
        });
        /** Initialization of the service, which acts as a constructor */
        GraphqlService.prototype.init = function (serviceOptions, pagination, grid) {
            this._grid = grid;
            this.options = serviceOptions || { datasetName: '', columnDefinitions: [] };
            this.pagination = pagination;
            this._datasetIdPropName = this._gridOptions.datasetIdPropertyName || 'id';
            if (grid && grid.getColumns) {
                this._columnDefinitions = (serviceOptions && serviceOptions.columnDefinitions) || grid.getColumns();
            }
        };
        /**
         * Build the GraphQL query, since the service include/exclude cursor, the output query will be different.
         * @param serviceOptions GraphqlServiceOption
         */
        GraphqlService.prototype.buildQuery = function () {
            var e_1, _a, e_2, _b;
            if (!this.options || !this.options.datasetName || (!this._columnDefinitions && !Array.isArray(this.options.columnDefinitions))) {
                throw new Error('GraphQL Service requires the "datasetName" property to properly build the GraphQL query');
            }
            // get the column definitions and exclude some if they were tagged as excluded
            var columnDefinitions = this._columnDefinitions || this.options.columnDefinitions;
            columnDefinitions = columnDefinitions.filter(function (column) { return !column.excludeFromQuery; });
            var queryQb = new GraphqlQueryBuilder('query');
            var datasetQb = new GraphqlQueryBuilder(this.options.datasetName);
            var nodesQb = new GraphqlQueryBuilder('nodes');
            // get all the columnds Ids for the filters to work
            var columnIds = [];
            if (columnDefinitions && Array.isArray(columnDefinitions)) {
                try {
                    for (var columnDefinitions_1 = __values(columnDefinitions), columnDefinitions_1_1 = columnDefinitions_1.next(); !columnDefinitions_1_1.done; columnDefinitions_1_1 = columnDefinitions_1.next()) {
                        var column = columnDefinitions_1_1.value;
                        columnIds.push(column.field);
                        // if extra "fields" are passed, also push them to columnIds
                        if (column.fields) {
                            columnIds.push.apply(columnIds, __spread(column.fields));
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (columnDefinitions_1_1 && !columnDefinitions_1_1.done && (_a = columnDefinitions_1.return)) _a.call(columnDefinitions_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            // Slickgrid also requires the "id" (or the dataset defined unique ide) field to be part of DataView
            // add it to the GraphQL query if it wasn't already part of the list
            if (columnIds.indexOf(this._datasetIdPropName) === -1) {
                columnIds.unshift(this._datasetIdPropName);
            }
            var columnsQuery = this.buildFilterQuery(columnIds);
            var graphqlNodeFields = [];
            if (this._gridOptions.enablePagination !== false) {
                if (this.options.isWithCursor) {
                    // ...pageInfo { hasNextPage, endCursor }, edges { cursor, node { _columns_ } }, totalCount: 100
                    var edgesQb = new GraphqlQueryBuilder('edges');
                    var pageInfoQb = new GraphqlQueryBuilder('pageInfo');
                    pageInfoQb.find('hasNextPage', 'hasPreviousPage', 'endCursor', 'startCursor');
                    nodesQb.find(columnsQuery);
                    edgesQb.find(['cursor']);
                    graphqlNodeFields = ['totalCount', nodesQb, pageInfoQb, edgesQb];
                }
                else {
                    // ...nodes { _columns_ }, totalCount: 100
                    nodesQb.find(columnsQuery);
                    graphqlNodeFields = ['totalCount', nodesQb];
                }
                // all properties to be returned by the query
                datasetQb.find(graphqlNodeFields);
            }
            else {
                // include all columns to be returned
                datasetQb.find(columnsQuery);
            }
            // add dataset filters, could be Pagination and SortingFilters and/or FieldFilters
            var datasetFilters = {};
            // only add pagination if it's enabled in the grid options
            if (this._gridOptions.enablePagination !== false) {
                datasetFilters = __assign({}, this.options.paginationOptions, { first: ((this.options.paginationOptions && this.options.paginationOptions.first) ? this.options.paginationOptions.first : ((this.pagination && this.pagination.pageSize) ? this.pagination.pageSize : null)) || this.defaultPaginationOptions.first });
                if (!this.options.isWithCursor) {
                    datasetFilters.offset = ((this.options.paginationOptions && this.options.paginationOptions.hasOwnProperty('offset')) ? +this.options.paginationOptions['offset'] : 0);
                }
            }
            if (this.options.sortingOptions && Array.isArray(this.options.sortingOptions) && this.options.sortingOptions.length > 0) {
                // orderBy: [{ field:x, direction: 'ASC' }]
                datasetFilters.orderBy = this.options.sortingOptions;
            }
            if (this.options.filteringOptions && Array.isArray(this.options.filteringOptions) && this.options.filteringOptions.length > 0) {
                // filterBy: [{ field: date, operator: '>', value: '2000-10-10' }]
                datasetFilters.filterBy = this.options.filteringOptions;
            }
            if (this.options.addLocaleIntoQuery) {
                // first: 20, ... locale: "en-CA"
                datasetFilters.locale = this._gridOptions && this._gridOptions.i18n && this._gridOptions.i18n.currentLang || this._gridOptions.locale || 'en';
            }
            if (this.options.extraQueryArguments) {
                try {
                    // first: 20, ... userId: 123
                    for (var _c = __values(this.options.extraQueryArguments), _d = _c.next(); !_d.done; _d = _c.next()) {
                        var queryArgument = _d.value;
                        datasetFilters[queryArgument.field] = queryArgument.value;
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
            // with pagination:: query { users(first: 20, offset: 0, orderBy: [], filterBy: []) { totalCount: 100, nodes: { _columns_ }}}
            // without pagination:: query { users(orderBy: [], filterBy: []) { _columns_ }}
            datasetQb.filter(datasetFilters);
            queryQb.find(datasetQb);
            var enumSearchProperties = ['direction:', 'field:', 'operator:'];
            return this.trimDoubleQuotesOnEnumField(queryQb.toString(), enumSearchProperties, this.options.keepArgumentFieldDoubleQuotes || false);
        };
        /**
         * From an input array of strings, we want to build a GraphQL query string.
         * The process has to take the dot notation and parse it into a valid GraphQL query
         * Following this SO answer https://stackoverflow.com/a/47705476/1212166
         *
         * INPUT
         *  ['firstName', 'lastName', 'billing.address.street', 'billing.address.zip']
         * OUTPUT
         * firstName, lastName, billing{address{street, zip}}
         * @param inputArray
         */
        GraphqlService.prototype.buildFilterQuery = function (inputArray) {
            var set = function (o, a) {
                if (o === void 0) { o = {}; }
                var k = a.shift();
                o[k] = a.length ? set(o[k], a) : null;
                return o;
            };
            var output = inputArray.reduce(function (o, a) { return set(o, a.split('.')); }, {});
            return JSON.stringify(output)
                .replace(/\"|\:|null/g, '')
                .replace(/^\{/, '')
                .replace(/\}$/, '');
        };
        GraphqlService.prototype.clearFilters = function () {
            this._currentFilters = [];
            this.updateOptions({ filteringOptions: [] });
        };
        GraphqlService.prototype.clearSorters = function () {
            this._currentSorters = [];
            this.updateOptions({ sortingOptions: [] });
        };
        /**
         * Get an initialization of Pagination options
         * @return Pagination Options
         */
        GraphqlService.prototype.getInitPaginationOptions = function () {
            var paginationFirst = this.pagination ? this.pagination.pageSize : DEFAULT_ITEMS_PER_PAGE;
            return (this.options && this.options.isWithCursor) ? { first: paginationFirst } : { first: paginationFirst, offset: 0 };
        };
        /** Get the GraphQL dataset name */
        GraphqlService.prototype.getDatasetName = function () {
            return this.options.datasetName || '';
        };
        /** Get the Filters that are currently used by the grid */
        GraphqlService.prototype.getCurrentFilters = function () {
            return this._currentFilters;
        };
        /** Get the Pagination that is currently used by the grid */
        GraphqlService.prototype.getCurrentPagination = function () {
            return this._currentPagination;
        };
        /** Get the Sorters that are currently used by the grid */
        GraphqlService.prototype.getCurrentSorters = function () {
            return this._currentSorters;
        };
        /*
         * Reset the pagination options
         */
        GraphqlService.prototype.resetPaginationOptions = function () {
            var paginationOptions;
            if (this.options && this.options.isWithCursor) {
                // first, last, after, before
                paginationOptions = {
                    after: '',
                    before: undefined,
                    last: undefined
                };
            }
            else {
                // first, last, offset
                paginationOptions = ((this.options && this.options.paginationOptions) || this.getInitPaginationOptions());
                paginationOptions.offset = 0;
            }
            // save current pagination as Page 1 and page size as "first" set size
            this._currentPagination = {
                pageNumber: 1,
                pageSize: paginationOptions.first || DEFAULT_PAGE_SIZE,
            };
            this.updateOptions({ paginationOptions: paginationOptions });
        };
        GraphqlService.prototype.updateOptions = function (serviceOptions) {
            this.options = __assign({}, this.options, serviceOptions);
        };
        /*
         * FILTERING
         */
        GraphqlService.prototype.processOnFilterChanged = function (event, args) {
            var gridOptions = this._gridOptions;
            var backendApi = gridOptions.backendServiceApi;
            if (backendApi === undefined) {
                throw new Error('Something went wrong in the GraphqlService, "backendServiceApi" is not initialized');
            }
            // keep current filters & always save it as an array (columnFilters can be an object when it is dealt by SlickGrid Filter)
            this._currentFilters = this.castFilterToColumnFilters(args.columnFilters);
            if (!args || !args.grid) {
                throw new Error('Something went wrong when trying create the GraphQL Backend Service, it seems that "args" is not populated correctly');
            }
            // loop through all columns to inspect filters & set the query
            this.updateFilters(args.columnFilters, false);
            this.resetPaginationOptions();
            return this.buildQuery();
        };
        /*
         * PAGINATION
         * With cursor, the query can have 4 arguments (first, after, last, before), for example:
         *   users (first:20, after:"YXJyYXljb25uZWN0aW9uOjM=") {
         *     totalCount
         *     pageInfo {
         *       hasNextPage
         *       hasPreviousPage
         *       endCursor
         *       startCursor
         *     }
         *     edges {
         *       cursor
         *       node {
         *         name
         *         gender
         *       }
         *     }
         *   }
         * Without cursor, the query can have 3 arguments (first, last, offset), for example:
         *   users (first:20, offset: 10) {
         *     totalCount
         *     nodes {
         *       name
         *       gender
         *     }
         *   }
         */
        GraphqlService.prototype.processOnPaginationChanged = function (event, args) {
            var pageSize = +(args.pageSize || ((this.pagination) ? this.pagination.pageSize : DEFAULT_PAGE_SIZE));
            this.updatePagination(args.newPage, pageSize);
            // build the GraphQL query which we will use in the WebAPI callback
            return this.buildQuery();
        };
        /*
         * SORTING
         * we will use sorting as per a Facebook suggestion on a Github issue (with some small changes)
         * https://github.com/graphql/graphql-relay-js/issues/20#issuecomment-220494222
         *
         *  users (first: 20, offset: 10, orderBy: [{field: lastName, direction: ASC}, {field: firstName, direction: DESC}]) {
         *    totalCount
         *    nodes {
         *      name
         *      gender
         *    }
         *  }
         */
        // @deprecated note, we should remove "SortChangedArgs" and only use: ColumnSort | MultiColumnSort
        GraphqlService.prototype.processOnSortChanged = function (event, args) {
            var sortColumns = (args.multiColumnSort) ? args.sortCols : new Array({ sortCol: args.sortCol, sortAsc: args.sortAsc });
            // loop through all columns to inspect sorters & set the query
            this.updateSorters(sortColumns);
            // build the GraphQL query which we will use in the WebAPI callback
            return this.buildQuery();
        };
        /**
         * loop through all columns to inspect filters & update backend service filteringOptions
         * @param columnFilters
         */
        GraphqlService.prototype.updateFilters = function (columnFilters, isUpdatedByPresetOrDynamically) {
            var searchByArray = [];
            var searchValue;
            // on filter preset load, we need to keep current filters
            if (isUpdatedByPresetOrDynamically) {
                this._currentFilters = this.castFilterToColumnFilters(columnFilters);
            }
            var _loop_1 = function (columnId) {
                if (columnFilters.hasOwnProperty(columnId)) {
                    var columnFilter_1 = columnFilters[columnId];
                    // if user defined some "presets", then we need to find the filters from the column definitions instead
                    var columnDef = void 0;
                    if (isUpdatedByPresetOrDynamically && Array.isArray(this_1._columnDefinitions)) {
                        columnDef = this_1._columnDefinitions.find(function (column) { return column.id === columnFilter_1.columnId; });
                    }
                    else {
                        columnDef = columnFilter_1.columnDef;
                    }
                    if (!columnDef) {
                        throw new Error('[GraphQL Service]: Something went wrong in trying to get the column definition of the specified filter (or preset filters). Did you make a typo on the filter columnId?');
                    }
                    var fieldName = (columnDef.filter && columnDef.filter.queryField) || columnDef.queryFieldFilter || columnDef.queryField || columnDef.field || columnDef.name || '';
                    var searchTerms = columnFilter_1 && columnFilter_1.searchTerms || [];
                    var fieldSearchValue = (Array.isArray(searchTerms) && searchTerms.length === 1) ? searchTerms[0] : '';
                    if (typeof fieldSearchValue === 'undefined') {
                        fieldSearchValue = '';
                    }
                    if (!fieldName) {
                        throw new Error("GraphQL filter could not find the field name to query the search, your column definition must include a valid \"field\" or \"name\" (optionally you can also use the \"queryfield\").");
                    }
                    fieldSearchValue = '' + fieldSearchValue; // make sure it's a string
                    var matches = fieldSearchValue.match(/^([<>!=\*]{0,2})(.*[^<>!=\*])([\*]?)$/); // group 1: Operator, 2: searchValue, 3: last char is '*' (meaning starts with, ex.: abc*)
                    var operator = columnFilter_1.operator || ((matches) ? matches[1] : '');
                    searchValue = (!!matches) ? matches[2] : '';
                    var lastValueChar = (!!matches) ? matches[3] : (operator === '*z' ? '*' : '');
                    // no need to query if search value is empty
                    if (fieldName && searchValue === '' && searchTerms.length === 0) {
                        return "continue";
                    }
                    if (Array.isArray(searchTerms) && searchTerms.length === 1 && typeof searchTerms[0] === 'string' && searchTerms[0].indexOf('..') > 0) {
                        searchTerms = searchTerms[0].split('..');
                        if (!operator) {
                            operator = exports.OperatorType.rangeExclusive;
                        }
                    }
                    if (typeof searchValue === 'string') {
                        // escaping the search value
                        searchValue = searchValue.replace("'", "''"); // escape single quotes by doubling them
                        if (operator === '*' || operator === 'a*' || operator === '*z' || lastValueChar === '*') {
                            operator = ((operator === '*' || operator === '*z') ? 'EndsWith' : 'StartsWith');
                        }
                    }
                    // if we didn't find an Operator but we have a Column Operator inside the Filter (DOM Element), we should use its default Operator
                    // multipleSelect is "IN", while singleSelect is "EQ", else don't map any operator
                    if (!operator && columnDef.filter) {
                        operator = columnDef.filter.operator;
                    }
                    // when having more than 1 search term (we need to create a CSV string for GraphQL "IN" or "NOT IN" filter search)
                    if (searchTerms && searchTerms.length > 1 && (operator === 'IN' || operator === 'NIN' || operator === 'NOTIN' || operator === 'NOT IN' || operator === 'NOT_IN')) {
                        searchValue = searchTerms.join(',');
                    }
                    else if (searchTerms && searchTerms.length === 2 && (!operator || operator === exports.OperatorType.rangeExclusive || operator === exports.OperatorType.rangeInclusive)) {
                        if (!operator) {
                            operator = exports.OperatorType.rangeExclusive;
                        }
                        searchByArray.push({ field: fieldName, operator: (operator === exports.OperatorType.rangeInclusive ? 'GE' : 'GT'), value: searchTerms[0] });
                        searchByArray.push({ field: fieldName, operator: (operator === exports.OperatorType.rangeInclusive ? 'LE' : 'LT'), value: searchTerms[1] });
                        return "continue";
                    }
                    // if we still don't have an operator find the proper Operator to use by it's field type
                    if (!operator) {
                        operator = mapOperatorByFieldType(columnDef.type || exports.FieldType.string);
                    }
                    // build the search array
                    searchByArray.push({ field: fieldName, operator: mapOperatorType(operator), value: searchValue });
                }
            };
            var this_1 = this;
            for (var columnId in columnFilters) {
                _loop_1(columnId);
            }
            // update the service options with filters for the buildQuery() to work later
            this.updateOptions({ filteringOptions: searchByArray });
        };
        /**
         * Update the pagination component with it's new page number and size
         * @param newPage
         * @param pageSize
         */
        GraphqlService.prototype.updatePagination = function (newPage, pageSize) {
            this._currentPagination = {
                pageNumber: newPage,
                pageSize: pageSize,
            };
            var paginationOptions;
            if (this.options && this.options.isWithCursor) {
                paginationOptions = {
                    first: pageSize
                };
            }
            else {
                paginationOptions = {
                    first: pageSize,
                    offset: (newPage > 1) ? ((newPage - 1) * pageSize) : 0 // recalculate offset but make sure the result is always over 0
                };
            }
            // unless user specifically set "enablePagination" to False, we'll update pagination options in every other cases
            if (this._gridOptions && (this._gridOptions.enablePagination || !this._gridOptions.hasOwnProperty('enablePagination'))) {
                this.updateOptions({ paginationOptions: paginationOptions });
            }
        };
        /**
         * loop through all columns to inspect sorters & update backend service sortingOptions
         * @param columnFilters
         */
        GraphqlService.prototype.updateSorters = function (sortColumns, presetSorters) {
            var e_3, _a;
            var _this = this;
            var currentSorters = [];
            var graphqlSorters = [];
            if (!sortColumns && presetSorters) {
                // make the presets the current sorters, also make sure that all direction are in uppercase for GraphQL
                currentSorters = presetSorters;
                currentSorters.forEach(function (sorter) { return sorter.direction = sorter.direction.toUpperCase(); });
                // display the correct sorting icons on the UI, for that it requires (columnId, sortAsc) properties
                var tmpSorterArray = currentSorters.map(function (sorter) {
                    var columnDef = _this._columnDefinitions.find(function (column) { return column.id === sorter.columnId; });
                    graphqlSorters.push({
                        field: columnDef ? ((columnDef.queryFieldSorter || columnDef.queryField || columnDef.field) + '') : (sorter.columnId + ''),
                        direction: sorter.direction
                    });
                    // return only the column(s) found in the Column Definitions ELSE null
                    if (columnDef) {
                        return {
                            columnId: sorter.columnId,
                            sortAsc: sorter.direction.toUpperCase() === exports.SortDirection.ASC
                        };
                    }
                    return null;
                });
                // set the sort icons, but also make sure to filter out null values (that happens when columnDef is not found)
                if (Array.isArray(tmpSorterArray)) {
                    this._grid.setSortColumns(tmpSorterArray.filter(function (sorter) { return sorter; }));
                }
            }
            else if (sortColumns && !presetSorters) {
                // build the orderBy array, it could be multisort, example
                // orderBy:[{field: lastName, direction: ASC}, {field: firstName, direction: DESC}]
                if (Array.isArray(sortColumns) && sortColumns.length > 0) {
                    try {
                        for (var sortColumns_1 = __values(sortColumns), sortColumns_1_1 = sortColumns_1.next(); !sortColumns_1_1.done; sortColumns_1_1 = sortColumns_1.next()) {
                            var column = sortColumns_1_1.value;
                            if (column && column.sortCol) {
                                currentSorters.push({
                                    columnId: column.sortCol.id + '',
                                    direction: column.sortAsc ? exports.SortDirection.ASC : exports.SortDirection.DESC
                                });
                                var fieldName = (column.sortCol.queryFieldSorter || column.sortCol.queryField || column.sortCol.field || '') + '';
                                if (fieldName) {
                                    graphqlSorters.push({
                                        field: fieldName,
                                        direction: column.sortAsc ? exports.SortDirection.ASC : exports.SortDirection.DESC
                                    });
                                }
                            }
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (sortColumns_1_1 && !sortColumns_1_1.done && (_a = sortColumns_1.return)) _a.call(sortColumns_1);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                }
            }
            // keep current Sorters and update the service options with the new sorting
            this._currentSorters = currentSorters;
            this.updateOptions({ sortingOptions: graphqlSorters });
        };
        /**
         * A function which takes an input string and removes double quotes only
         * on certain fields are identified as GraphQL enums (except fields with dot notation)
         * For example let say we identified ("direction:", "sort") as word which are GraphQL enum fields
         * then the result will be:
         * FROM
         * query { users (orderBy:[{field:"firstName", direction:"ASC"} }]) }
         * TO
         * query { users (orderBy:[{field: firstName, direction: ASC}})}
         *
         * EXCEPTIONS (fields with dot notation "." which are inside a "field:")
         * these fields will keep double quotes while everything else will be stripped of double quotes
         * query { users (orderBy:[{field:"billing.street.name", direction: "ASC"} }
         * TO
         * query { users (orderBy:[{field:"billing.street.name", direction: ASC}}
         * @param inputStr input string
         * @param enumSearchWords array of enum words to filter
         * @returns outputStr output string
         */
        GraphqlService.prototype.trimDoubleQuotesOnEnumField = function (inputStr, enumSearchWords, keepArgumentFieldDoubleQuotes) {
            var patternWordInQuotes = "s?((field:s*)?\".*?\")";
            var patternRegex = enumSearchWords.join(patternWordInQuotes + '|');
            patternRegex += patternWordInQuotes; // the last one should also have the pattern but without the pipe "|"
            // example with (field: & direction:):  /field:s?(".*?")|direction:s?(".*?")/
            var reg = new RegExp(patternRegex, 'g');
            return inputStr.replace(reg, function (group1, group2, group3) {
                // remove double quotes except when the string starts with a "field:"
                var removeDoubleQuotes = true;
                if (group1.startsWith('field:') && keepArgumentFieldDoubleQuotes) {
                    removeDoubleQuotes = false;
                }
                var rep = removeDoubleQuotes ? group1.replace(/"/g, '') : group1;
                return rep;
            });
        };
        //
        // private functions
        // -------------------
        /**
         * Cast provided filters (could be in multiple formats) into an array of CurrentFilter
         * @param columnFilters
         */
        GraphqlService.prototype.castFilterToColumnFilters = function (columnFilters) {
            // keep current filters & always save it as an array (columnFilters can be an object when it is dealt by SlickGrid Filter)
            var filtersArray = (typeof columnFilters === 'object') ? Object.keys(columnFilters).map(function (key) { return columnFilters[key]; }) : columnFilters;
            if (!Array.isArray(filtersArray)) {
                return [];
            }
            return filtersArray.map(function (filter) {
                var tmpFilter = { columnId: filter.columnId || '' };
                if (filter.operator) {
                    tmpFilter.operator = filter.operator;
                }
                if (Array.isArray(filter.searchTerms)) {
                    tmpFilter.searchTerms = filter.searchTerms;
                }
                return tmpFilter;
            });
        };
        return GraphqlService;
    }());

    var OdataQueryBuilderService = /** @class */ (function () {
        function OdataQueryBuilderService() {
            this._odataOptions = {
                filterQueue: [],
                orderBy: ''
            };
            this._defaultSortBy = '';
            this._columnFilters = {};
        }
        /*
          * Build the OData query string from all the options provided
          * @return string OData query
          */
        OdataQueryBuilderService.prototype.buildQuery = function () {
            if (!this._odataOptions) {
                throw new Error('Odata Service requires certain options like "top" for it to work');
            }
            this._odataOptions.filterQueue = [];
            var queryTmpArray = [];
            // When enableCount is set, add it to the OData query
            if (this._odataOptions.enableCount === true) {
                var countQuery = (this._odataOptions.version >= 4) ? '$count=true' : '$inlinecount=allpages';
                queryTmpArray.push(countQuery);
            }
            if (this._odataOptions.top) {
                queryTmpArray.push("$top=" + this._odataOptions.top);
            }
            if (this._odataOptions.skip) {
                queryTmpArray.push("$skip=" + this._odataOptions.skip);
            }
            if (this._odataOptions.orderBy) {
                var argument = '';
                if (Array.isArray(this._odataOptions.orderBy)) {
                    argument = this._odataOptions.orderBy.join(','); // csv, that will form a query, for example: $orderby=RoleName asc, Id desc
                }
                else {
                    argument = this._odataOptions.orderBy;
                }
                queryTmpArray.push("$orderby=" + argument);
            }
            if (this._odataOptions.filterBy || this._odataOptions.filter) {
                var filterBy = this._odataOptions.filter || this._odataOptions.filterBy;
                if (filterBy) {
                    this._filterCount = 1;
                    this._odataOptions.filterQueue = [];
                    var filterStr = filterBy;
                    if (Array.isArray(filterBy)) {
                        this._filterCount = filterBy.length;
                        filterStr = filterBy.join(" " + (this._odataOptions.filterBySeparator || 'and') + " ");
                    }
                    if (typeof filterStr === 'string') {
                        if (!(filterStr[0] === '(' && filterStr.slice(-1) === ')')) {
                            this.addToFilterQueueWhenNotExists("(" + filterStr + ")");
                        }
                        else {
                            this.addToFilterQueueWhenNotExists(filterStr);
                        }
                    }
                }
            }
            if (this._odataOptions.filterQueue.length > 0) {
                var query = this._odataOptions.filterQueue.join(" " + (this._odataOptions.filterBySeparator || 'and') + " ");
                this._odataOptions.filter = query; // overwrite with
                queryTmpArray.push("$filter=" + query);
            }
            // join all the odata functions by a '&'
            return queryTmpArray.join('&');
        };
        OdataQueryBuilderService.prototype.getFilterCount = function () {
            return this._filterCount;
        };
        Object.defineProperty(OdataQueryBuilderService.prototype, "columnFilters", {
            get: function () {
                return this._columnFilters;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OdataQueryBuilderService.prototype, "options", {
            get: function () {
                return this._odataOptions;
            },
            set: function (options) {
                this._odataOptions = options;
            },
            enumerable: true,
            configurable: true
        });
        OdataQueryBuilderService.prototype.removeColumnFilter = function (fieldName) {
            if (this._columnFilters && this._columnFilters.hasOwnProperty(fieldName)) {
                delete this._columnFilters[fieldName];
            }
        };
        OdataQueryBuilderService.prototype.saveColumnFilter = function (fieldName, value, searchTerms) {
            this._columnFilters[fieldName] = {
                search: searchTerms,
                value: value
            };
        };
        /**
         * Change any OData options that will be used to build the query
         * @param object options
         */
        OdataQueryBuilderService.prototype.updateOptions = function (options) {
            var e_1, _a;
            try {
                for (var _b = __values(Object.keys(options)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var property = _c.value;
                    if (options.hasOwnProperty(property)) {
                        this._odataOptions[property] = options[property]; // replace of the property
                    }
                    // we need to keep the defaultSortBy for references whenever the user removes his Sorting
                    // then we would revert to the defaultSortBy and the only way is to keep a hard copy here
                    if (property === 'orderBy' || property === 'sortBy') {
                        var sortBy = options[property];
                        // make sure first char of each orderBy field is capitalize
                        if (this._odataOptions.caseType === exports.CaseType.pascalCase) {
                            if (Array.isArray(sortBy)) {
                                sortBy.forEach(function (field, index, inputArray) {
                                    inputArray[index] = titleCase(field);
                                });
                            }
                            else {
                                sortBy = titleCase(options[property]);
                            }
                        }
                        this._odataOptions.orderBy = sortBy;
                        this._defaultSortBy = sortBy;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        //
        // private functions
        // -------------------
        OdataQueryBuilderService.prototype.addToFilterQueueWhenNotExists = function (filterStr) {
            if (this._odataOptions.filterQueue && this._odataOptions.filterQueue.indexOf(filterStr) === -1) {
                this._odataOptions.filterQueue.push(filterStr);
            }
        };
        return OdataQueryBuilderService;
    }());

    var DEFAULT_ITEMS_PER_PAGE$1 = 25;
    var DEFAULT_PAGE_SIZE$1 = 20;
    var GridOdataService = /** @class */ (function () {
        function GridOdataService() {
            this._currentFilters = [];
            this._currentSorters = [];
            this.defaultOptions = {
                top: DEFAULT_ITEMS_PER_PAGE$1,
                orderBy: '',
                caseType: exports.CaseType.pascalCase
            };
            this._odataService = new OdataQueryBuilderService();
        }
        Object.defineProperty(GridOdataService.prototype, "columnDefinitions", {
            /** Getter for the Column Definitions */
            get: function () {
                return this._columnDefinitions;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GridOdataService.prototype, "odataService", {
            /** Getter for the Odata Service */
            get: function () {
                return this._odataService;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GridOdataService.prototype, "_gridOptions", {
            /** Getter for the Grid Options pulled through the Grid Object */
            get: function () {
                return (this._grid && this._grid.getOptions) ? this._grid.getOptions() : {};
            },
            enumerable: true,
            configurable: true
        });
        GridOdataService.prototype.init = function (serviceOptions, pagination, grid) {
            this._grid = grid;
            var mergedOptions = __assign({}, this.defaultOptions, serviceOptions);
            // unless user specifically set "enablePagination" to False, we'll add "top" property for the pagination in every other cases
            if (this._gridOptions && !this._gridOptions.enablePagination) {
                // save current pagination as Page 1 and page size as "top"
                this._odataService.options = __assign({}, mergedOptions, { top: null });
                this._currentPagination = null;
            }
            else {
                var topOption = (pagination && pagination.pageSize) ? pagination.pageSize : this.defaultOptions.top;
                this._odataService.options = __assign({}, mergedOptions, { top: topOption });
                this._currentPagination = {
                    pageNumber: 1,
                    pageSize: this._odataService.options.top || this.defaultOptions.top || DEFAULT_PAGE_SIZE$1,
                };
            }
            this.options = this._odataService.options;
            this.pagination = pagination;
            if (grid && grid.getColumns) {
                this._columnDefinitions = serviceOptions && serviceOptions.columnDefinitions || grid.getColumns();
                this._columnDefinitions = this._columnDefinitions.filter(function (column) { return !column.excludeFromQuery; });
            }
        };
        GridOdataService.prototype.buildQuery = function () {
            return this._odataService.buildQuery();
        };
        GridOdataService.prototype.clearFilters = function () {
            this._currentFilters = [];
            this.updateFilters([]);
        };
        GridOdataService.prototype.clearSorters = function () {
            this._currentSorters = [];
            this.updateSorters([]);
        };
        GridOdataService.prototype.updateOptions = function (serviceOptions) {
            this.options = __assign({}, this.options, serviceOptions);
            this._odataService.options = this.options;
        };
        GridOdataService.prototype.removeColumnFilter = function (fieldName) {
            this._odataService.removeColumnFilter(fieldName);
        };
        /** Get the Filters that are currently used by the grid */
        GridOdataService.prototype.getCurrentFilters = function () {
            return this._currentFilters;
        };
        /** Get the Pagination that is currently used by the grid */
        GridOdataService.prototype.getCurrentPagination = function () {
            return this._currentPagination;
        };
        /** Get the Sorters that are currently used by the grid */
        GridOdataService.prototype.getCurrentSorters = function () {
            return this._currentSorters;
        };
        /**
         * Mapper for mathematical operators (ex.: <= is "le", > is "gt")
         * @param string operator
         * @returns string map
         */
        GridOdataService.prototype.mapOdataOperator = function (operator) {
            var map = '';
            switch (operator) {
                case '<':
                    map = 'lt';
                    break;
                case '<=':
                    map = 'le';
                    break;
                case '>':
                    map = 'gt';
                    break;
                case '>=':
                    map = 'ge';
                    break;
                case '<>':
                case '!=':
                    map = 'ne';
                    break;
                case '=':
                case '==':
                default:
                    map = 'eq';
                    break;
            }
            return map;
        };
        /*
         * Reset the pagination options
         */
        GridOdataService.prototype.resetPaginationOptions = function () {
            this._odataService.updateOptions({
                skip: 0
            });
        };
        GridOdataService.prototype.saveColumnFilter = function (fieldName, value, terms) {
            this._odataService.saveColumnFilter(fieldName, value, terms);
        };
        /*
         * FILTERING
         */
        GridOdataService.prototype.processOnFilterChanged = function (event, args) {
            var gridOptions = this._gridOptions;
            var backendApi = gridOptions.backendServiceApi;
            if (backendApi === undefined) {
                throw new Error('Something went wrong in the GridOdataService, "backendServiceApi" is not initialized');
            }
            // keep current filters & always save it as an array (columnFilters can be an object when it is dealt by SlickGrid Filter)
            this._currentFilters = this.castFilterToColumnFilters(args.columnFilters);
            if (!args || !args.grid) {
                throw new Error('Something went wrong when trying create the GridOdataService, it seems that "args" is not populated correctly');
            }
            // loop through all columns to inspect filters & set the query
            this.updateFilters(args.columnFilters);
            this.resetPaginationOptions();
            return this._odataService.buildQuery();
        };
        /*
         * PAGINATION
         */
        GridOdataService.prototype.processOnPaginationChanged = function (event, args) {
            var pageSize = +(args.pageSize || ((this.pagination) ? this.pagination.pageSize : DEFAULT_PAGE_SIZE$1));
            this.updatePagination(args.newPage, pageSize);
            // build the OData query which we will use in the WebAPI callback
            return this._odataService.buildQuery();
        };
        /*
         * SORTING
         */
        GridOdataService.prototype.processOnSortChanged = function (event, args) {
            var sortColumns = (args.multiColumnSort) ? args.sortCols : new Array({ sortCol: args.sortCol, sortAsc: args.sortAsc });
            // loop through all columns to inspect sorters & set the query
            this.updateSorters(sortColumns);
            // build the OData query which we will use in the WebAPI callback
            return this._odataService.buildQuery();
        };
        /**
         * loop through all columns to inspect filters & update backend service filters
         * @param columnFilters
         */
        GridOdataService.prototype.updateFilters = function (columnFilters, isUpdatedByPresetOrDynamically) {
            var searchBy = '';
            var searchByArray = [];
            var odataVersion = this._odataService && this._odataService.options && this._odataService.options.version || 2;
            // on filter preset load, we need to keep current filters
            if (isUpdatedByPresetOrDynamically) {
                this._currentFilters = this.castFilterToColumnFilters(columnFilters);
            }
            var _loop_1 = function (columnId) {
                if (columnFilters.hasOwnProperty(columnId)) {
                    var columnFilter_1 = columnFilters[columnId];
                    // if user defined some "presets", then we need to find the filters from the column definitions instead
                    var columnDef = void 0;
                    if (isUpdatedByPresetOrDynamically && Array.isArray(this_1._columnDefinitions)) {
                        columnDef = this_1._columnDefinitions.find(function (column) {
                            return column.id === columnFilter_1.columnId;
                        });
                    }
                    else {
                        columnDef = columnFilter_1.columnDef;
                    }
                    if (!columnDef) {
                        throw new Error('[GridOData Service]: Something went wrong in trying to get the column definition of the specified filter (or preset filters). Did you make a typo on the filter columnId?');
                    }
                    var fieldName = (columnDef.filter && columnDef.filter.queryField) || columnDef.queryFieldFilter || columnDef.queryField || columnDef.field || columnDef.name || '';
                    var fieldType = columnDef.type || exports.FieldType.string;
                    var searchTerms = (columnFilter_1 ? columnFilter_1.searchTerms : null) || [];
                    var fieldSearchValue = (Array.isArray(searchTerms) && searchTerms.length === 1) ? searchTerms[0] : '';
                    if (typeof fieldSearchValue === 'undefined') {
                        fieldSearchValue = '';
                    }
                    if (!fieldName) {
                        throw new Error("GridOData filter could not find the field name to query the search, your column definition must include a valid \"field\" or \"name\" (optionally you can also use the \"queryfield\").");
                    }
                    fieldSearchValue = '' + fieldSearchValue; // make sure it's a string
                    var matches = fieldSearchValue.match(/^([<>!=\*]{0,2})(.*[^<>!=\*])([\*]?)$/); // group 1: Operator, 2: searchValue, 3: last char is '*' (meaning starts with, ex.: abc*)
                    var operator = columnFilter_1.operator || ((matches) ? matches[1] : '');
                    var searchValue = (!!matches) ? matches[2] : '';
                    var lastValueChar = (!!matches) ? matches[3] : (operator === '*z' || operator === exports.OperatorType.endsWith) ? '*' : '';
                    var bypassOdataQuery = columnFilter_1.bypassBackendQuery || false;
                    // no need to query if search value is empty
                    if (fieldName && searchValue === '' && searchTerms.length <= 1) {
                        this_1.removeColumnFilter(fieldName);
                        return "continue";
                    }
                    if (Array.isArray(searchTerms) && searchTerms.length === 1 && typeof searchTerms[0] === 'string' && searchTerms[0].indexOf('..') > 0) {
                        searchTerms = searchTerms[0].split('..');
                        if (!operator) {
                            operator = exports.OperatorType.rangeExclusive;
                        }
                    }
                    // escaping the search value
                    searchValue = searchValue.replace("'", "''"); // escape single quotes by doubling them
                    searchValue = encodeURIComponent(searchValue); // encode URI of the final search value
                    // if we didn't find an Operator but we have a Column Operator inside the Filter (DOM Element), we should use its default Operator
                    // multipleSelect is "IN", while singleSelect is "EQ", else don't map any operator
                    if (!operator && columnDef.filter) {
                        operator = columnDef.filter.operator;
                    }
                    // if we still don't have an operator find the proper Operator to use by it's field type
                    if (!operator) {
                        operator = mapOperatorByFieldType(columnDef.type || exports.FieldType.string);
                    }
                    // extra query arguments
                    if (bypassOdataQuery) {
                        // push to our temp array and also trim white spaces
                        if (fieldName) {
                            this_1.saveColumnFilter(fieldName, fieldSearchValue, searchTerms);
                        }
                    }
                    else {
                        searchBy = '';
                        // titleCase the fieldName so that it matches the WebApi names
                        if (this_1._odataService.options.caseType === exports.CaseType.pascalCase) {
                            fieldName = titleCase(fieldName || '');
                        }
                        if (fieldType === exports.FieldType.date) {
                            searchBy = this_1.filterBySearchDate(fieldName, operator, searchTerms, odataVersion);
                        }
                        else if (searchTerms && searchTerms.length > 1 && (operator === 'IN' || operator === 'NIN' || operator === 'NOTIN' || operator === 'NOT IN' || operator === 'NOT_IN')) {
                            // when having more than 1 search term (then check if we have a "IN" or "NOT IN" filter search)
                            var tmpSearchTerms = [];
                            if (operator === 'IN') {
                                // example:: (Stage eq "Expired" or Stage eq "Renewal")
                                for (var j = 0, lnj = searchTerms.length; j < lnj; j++) {
                                    if (fieldType === exports.FieldType.string || fieldType === exports.FieldType.text || fieldType === exports.FieldType.readonly) {
                                        var searchVal = encodeURIComponent(searchTerms[j].replace("'", "''"));
                                        tmpSearchTerms.push(fieldName + " eq '" + searchVal + "'");
                                    }
                                    else {
                                        // Single quote escape is not needed for non string type
                                        tmpSearchTerms.push(fieldName + " eq " + searchTerms[j]);
                                    }
                                }
                                searchBy = tmpSearchTerms.join(' or ');
                                if (!(typeof searchBy === 'string' && searchBy[0] === '(' && searchBy.slice(-1) === ')')) {
                                    searchBy = "(" + searchBy + ")";
                                }
                            }
                            else {
                                // example:: (Stage ne "Expired" and Stage ne "Renewal")
                                for (var k = 0, lnk = searchTerms.length; k < lnk; k++) {
                                    var searchVal = encodeURIComponent(searchTerms[k].replace("'", "''"));
                                    tmpSearchTerms.push(fieldName + " ne '" + searchVal + "'");
                                }
                                searchBy = tmpSearchTerms.join(' and ');
                                if (!(typeof searchBy === 'string' && searchBy[0] === '(' && searchBy.slice(-1) === ')')) {
                                    searchBy = "(" + searchBy + ")";
                                }
                            }
                        }
                        else if (operator === '*' || operator === 'a*' || operator === '*z' || lastValueChar === '*' || operator === exports.OperatorType.startsWith || operator === exports.OperatorType.endsWith) {
                            // first/last character is a '*' will be a startsWith or endsWith
                            searchBy = (operator === '*' || operator === '*z' || operator === exports.OperatorType.endsWith) ? "endswith(" + fieldName + ", '" + searchValue + "')" : "startswith(" + fieldName + ", '" + searchValue + "')";
                        }
                        else if (fieldType === exports.FieldType.string || fieldType === exports.FieldType.text || fieldType === exports.FieldType.readonly) {
                            // string field needs to be in single quotes
                            if (operator === '' || operator === exports.OperatorType.contains || operator === exports.OperatorType.notContains) {
                                searchBy = this_1.odataQueryVersionWrapper('substring', odataVersion, fieldName, searchValue);
                                if (operator === exports.OperatorType.notContains) {
                                    searchBy = "not " + searchBy;
                                }
                            }
                            else if (operator === exports.OperatorType.rangeExclusive || operator === exports.OperatorType.rangeInclusive) {
                                // example:: (Duration >= 5 and Duration <= 10)
                                searchBy = this_1.filterBySearchTermRange(fieldName, operator, searchTerms);
                            }
                            else {
                                searchBy = fieldName + " " + this_1.mapOdataOperator(operator) + " '" + searchValue + "'";
                            }
                        }
                        else {
                            if (operator === exports.OperatorType.rangeExclusive || operator === exports.OperatorType.rangeInclusive) {
                                // example:: (Duration >= 5 and Duration <= 10)
                                searchBy = this_1.filterBySearchTermRange(fieldName, operator, searchTerms);
                            }
                            else {
                                // any other field type (or undefined type)
                                searchValue = (fieldType === exports.FieldType.number || fieldType === exports.FieldType.boolean) ? searchValue : "'" + searchValue + "'";
                                searchBy = fieldName + " " + this_1.mapOdataOperator(operator) + " " + searchValue;
                            }
                        }
                        // push to our temp array and also trim white spaces
                        if (searchBy !== '') {
                            searchByArray.push(searchBy.trim());
                            this_1.saveColumnFilter(fieldName || '', fieldSearchValue, searchValue);
                        }
                    }
                }
            };
            var this_1 = this;
            // loop through all columns to inspect filters
            for (var columnId in columnFilters) {
                _loop_1(columnId);
            }
            // update the service options with filters for the buildQuery() to work later
            this._odataService.updateOptions({
                filter: (searchByArray.length > 0) ? searchByArray.join(' and ') : '',
                skip: undefined
            });
        };
        /**
         * Update the pagination component with it's new page number and size
         * @param newPage
         * @param pageSize
         */
        GridOdataService.prototype.updatePagination = function (newPage, pageSize) {
            this._currentPagination = {
                pageNumber: newPage,
                pageSize: pageSize,
            };
            // unless user specifically set "enablePagination" to False, we'll update pagination options in every other cases
            if (this._gridOptions && (this._gridOptions.enablePagination || !this._gridOptions.hasOwnProperty('enablePagination'))) {
                this._odataService.updateOptions({
                    top: pageSize,
                    skip: (newPage - 1) * pageSize
                });
            }
        };
        /**
         * loop through all columns to inspect sorters & update backend service orderBy
         * @param columnFilters
         */
        GridOdataService.prototype.updateSorters = function (sortColumns, presetSorters) {
            var e_1, _a;
            var _this = this;
            var currentSorters = [];
            var odataSorters = [];
            if (!sortColumns && presetSorters) {
                // make the presets the current sorters, also make sure that all direction are in lowercase for OData
                currentSorters = presetSorters;
                currentSorters.forEach(function (sorter) { return sorter.direction = sorter.direction.toLowerCase(); });
                // display the correct sorting icons on the UI, for that it requires (columnId, sortAsc) properties
                var tmpSorterArray = currentSorters.map(function (sorter) {
                    var columnDef = _this._columnDefinitions.find(function (column) { return column.id === sorter.columnId; });
                    odataSorters.push({
                        field: columnDef ? ((columnDef.queryFieldSorter || columnDef.queryField || columnDef.field) + '') : (sorter.columnId + ''),
                        direction: sorter.direction
                    });
                    // return only the column(s) found in the Column Definitions ELSE null
                    if (columnDef) {
                        return {
                            columnId: sorter.columnId,
                            sortAsc: sorter.direction.toUpperCase() === exports.SortDirection.ASC
                        };
                    }
                    return null;
                });
                // set the sort icons, but also make sure to filter out null values (that happens when columnDef is not found)
                if (Array.isArray(tmpSorterArray)) {
                    this._grid.setSortColumns(tmpSorterArray);
                }
            }
            else if (sortColumns && !presetSorters) {
                // build the SortBy string, it could be multisort, example: customerNo asc, purchaserName desc
                if (sortColumns && sortColumns.length === 0) {
                    // TODO fix this line
                    // currentSorters = new Array(this.defaultOptions.orderBy); // when empty, use the default sort
                }
                else {
                    if (sortColumns) {
                        try {
                            for (var sortColumns_1 = __values(sortColumns), sortColumns_1_1 = sortColumns_1.next(); !sortColumns_1_1.done; sortColumns_1_1 = sortColumns_1.next()) {
                                var columnDef = sortColumns_1_1.value;
                                if (columnDef.sortCol) {
                                    var fieldName = (columnDef.sortCol.queryFieldSorter || columnDef.sortCol.queryField || columnDef.sortCol.field) + '';
                                    var columnFieldName = (columnDef.sortCol.field || columnDef.sortCol.id) + '';
                                    var queryField = (columnDef.sortCol.queryFieldSorter || columnDef.sortCol.queryField || columnDef.sortCol.field || '') + '';
                                    if (this._odataService.options.caseType === exports.CaseType.pascalCase) {
                                        fieldName = titleCase(fieldName);
                                        columnFieldName = titleCase(columnFieldName);
                                        queryField = titleCase(queryField);
                                    }
                                    if (columnFieldName !== '') {
                                        currentSorters.push({
                                            columnId: columnFieldName,
                                            direction: columnDef.sortAsc ? 'asc' : 'desc'
                                        });
                                    }
                                    if (queryField !== '') {
                                        odataSorters.push({
                                            field: queryField,
                                            direction: columnDef.sortAsc ? exports.SortDirection.ASC : exports.SortDirection.DESC
                                        });
                                    }
                                }
                            }
                        }
                        catch (e_1_1) { e_1 = { error: e_1_1 }; }
                        finally {
                            try {
                                if (sortColumns_1_1 && !sortColumns_1_1.done && (_a = sortColumns_1.return)) _a.call(sortColumns_1);
                            }
                            finally { if (e_1) throw e_1.error; }
                        }
                    }
                }
            }
            // transform the sortby array into a CSV string for OData
            currentSorters = currentSorters || [];
            var csvString = odataSorters.map(function (sorter) {
                var str = '';
                if (sorter && sorter.field) {
                    var sortField = (_this._odataService.options.caseType === exports.CaseType.pascalCase) ? titleCase(sorter.field) : sorter.field;
                    str = sortField + " " + (sorter && sorter.direction && sorter.direction.toLowerCase() || '');
                }
                return str;
            }).join(',');
            this._odataService.updateOptions({
                orderBy: csvString
            });
            // keep current Sorters and update the service options with the new sorting
            this._currentSorters = currentSorters;
            // build the OData query which we will use in the WebAPI callback
            return this._odataService.buildQuery();
        };
        //
        // private functions
        // -------------------
        /**
         * Cast provided filters (could be in multiple format) into an array of ColumnFilter
         * @param columnFilters
         */
        GridOdataService.prototype.castFilterToColumnFilters = function (columnFilters) {
            // keep current filters & always save it as an array (columnFilters can be an object when it is dealt by SlickGrid Filter)
            var filtersArray = (typeof columnFilters === 'object') ? Object.keys(columnFilters).map(function (key) { return columnFilters[key]; }) : columnFilters;
            if (!Array.isArray(filtersArray)) {
                return [];
            }
            return filtersArray.map(function (filter) {
                var tmpFilter = { columnId: filter.columnId || '' };
                if (filter.operator) {
                    tmpFilter.operator = filter.operator;
                }
                if (Array.isArray(filter.searchTerms)) {
                    tmpFilter.searchTerms = filter.searchTerms;
                }
                return tmpFilter;
            });
        };
        GridOdataService.prototype.odataQueryVersionWrapper = function (queryType, version, fieldName, searchValue) {
            if (searchValue === void 0) { searchValue = ''; }
            var query = '';
            switch (queryType) {
                case 'dateTime':
                    query = version >= 4 ? searchValue : "DateTime'" + searchValue + "'";
                    break;
                case 'substring':
                    query = version >= 4 ? "contains(" + fieldName + ", '" + searchValue + "')" : "substringof('" + searchValue + "', " + fieldName + ")";
                    break;
            }
            return query;
        };
        /**
         * Filter by a search date, the searchTerms might be a single value or range of dates (2 searchTerms OR 1 string separated by 2 dots "date1..date2")
         * Also depending on the OData version number, the output will be different, previous version must wrap dates with DateTime
         * - version 2-3:: Finish gt DateTime'2019-08-12T00:00:00Z'
         * - version 4:: Finish gt 2019-08-12T00:00:00Z
         */
        GridOdataService.prototype.filterBySearchDate = function (fieldName, operator, searchTerms, version) {
            var query = '';
            var searchValues = [];
            if (Array.isArray(searchTerms) && searchTerms.length > 1) {
                searchValues = searchTerms;
                if (operator !== exports.OperatorType.rangeExclusive && operator !== exports.OperatorType.rangeInclusive && this._gridOptions.defaultFilterRangeOperator) {
                    operator = this._gridOptions.defaultFilterRangeOperator;
                }
            }
            // single search value
            if (searchValues.length === 0 && Array.isArray(searchTerms) && searchTerms.length === 1 && searchTerms[0]) {
                var searchValue1 = this.odataQueryVersionWrapper('dateTime', version, fieldName, parseUtcDate(searchTerms[0], true));
                if (searchValue1) {
                    return fieldName + " " + this.mapOdataOperator(operator) + " " + searchValue1;
                }
            }
            // multiple search value (date range)
            if (Array.isArray(searchValues) && searchValues.length === 2 && searchValues[0] && searchValues[1]) {
                // date field needs to be UTC and within DateTime function
                var searchValue1 = this.odataQueryVersionWrapper('dateTime', version, fieldName, parseUtcDate(searchValues[0], true));
                var searchValue2 = this.odataQueryVersionWrapper('dateTime', version, fieldName, parseUtcDate(searchValues[1], true));
                if (searchValue1 && searchValue2) {
                    if (operator === exports.OperatorType.rangeInclusive) {
                        // example:: (Finish >= DateTime'2019-08-11T00:00:00Z' and Finish <= DateTime'2019-09-12T00:00:00Z')
                        query = "(" + fieldName + " ge " + searchValue1 + " and " + fieldName + " le " + searchValue2 + ")";
                    }
                    else if (operator === exports.OperatorType.rangeExclusive) {
                        // example:: (Finish > DateTime'2019-08-11T00:00:00Z' and Finish < DateTime'2019-09-12T00:00:00Z')
                        query = "(" + fieldName + " gt " + searchValue1 + " and " + fieldName + " lt " + searchValue2 + ")";
                    }
                }
            }
            return query;
        };
        /**
         * Filter by a range of searchTerms (2 searchTerms OR 1 string separated by 2 dots "value1..value2")
         */
        GridOdataService.prototype.filterBySearchTermRange = function (fieldName, operator, searchTerms) {
            var query = '';
            if (Array.isArray(searchTerms) && searchTerms.length === 2) {
                if (operator === exports.OperatorType.rangeInclusive) {
                    // example:: (Duration >= 5 and Duration <= 10)
                    query = "(" + fieldName + " ge " + searchTerms[0] + " and " + fieldName + " le " + searchTerms[1] + ")";
                }
                else if (operator === exports.OperatorType.rangeExclusive) {
                    // example:: (Duration > 5 and Duration < 10)
                    query = "(" + fieldName + " gt " + searchTerms[0] + " and " + fieldName + " lt " + searchTerms[1] + ")";
                }
            }
            return query;
        };
        GridOdataService = __decorate([
            core.Injectable()
        ], GridOdataService);
        return GridOdataService;
    }());

    var isequal$1 = isequal_; // patch to fix rollup to work
    var GridStateService = /** @class */ (function () {
        function GridStateService(extensionService, filterService, sharedService, sortService) {
            this.extensionService = extensionService;
            this.filterService = filterService;
            this.sharedService = sharedService;
            this.sortService = sortService;
            this._columns = [];
            this._currentColumns = [];
            this._subscriptions = [];
            this._selectedRowDataContextIds = []; // used with row selection
            this._selectedFilteredRowDataContextIds = []; // used with row selection
            this._wasRecheckedAfterPageChange = true; // used with row selection & pagination
            this.onGridStateChanged = new rxjs.Subject();
            this._eventHandler = new Slick.EventHandler();
        }
        Object.defineProperty(GridStateService.prototype, "_gridOptions", {
            /** Getter for the Grid Options pulled through the Grid Object */
            get: function () {
                return (this._grid && this._grid.getOptions) ? this._grid.getOptions() : {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GridStateService.prototype, "datasetIdPropName", {
            get: function () {
                return this._gridOptions.datasetIdPropertyName || 'id';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GridStateService.prototype, "selectedRowDataContextIds", {
            /** Getter of the selected data context object IDs */
            get: function () {
                return this._selectedRowDataContextIds;
            },
            /** Setter of the selected data context object IDs */
            set: function (dataContextIds) {
                this._selectedRowDataContextIds = dataContextIds;
                // since this is coming from a preset, we also need to update the filtered IDs
                this._selectedFilteredRowDataContextIds = dataContextIds;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Initialize the Grid State Service
         * @param grid
         */
        GridStateService.prototype.init = function (grid, dataView) {
            this._grid = grid;
            this._dataView = dataView;
            this.subscribeToAllGridChanges(grid);
        };
        /** Dispose of all the SlickGrid & Angular subscriptions */
        GridStateService.prototype.dispose = function () {
            // unsubscribe all SlickGrid events
            this._eventHandler.unsubscribeAll();
            // also unsubscribe all Angular Subscriptions
            this._subscriptions = unsubscribeAllObservables(this._subscriptions);
            this._currentColumns = [];
            this._columns = [];
        };
        /**
         * Get the current grid state (filters/sorters/pagination)
         * @return grid state
         */
        GridStateService.prototype.getCurrentGridState = function (args) {
            var gridState = {
                columns: this.getCurrentColumns(),
                filters: this.getCurrentFilters(),
                sorters: this.getCurrentSorters(),
            };
            var currentPagination = this.getCurrentPagination();
            if (currentPagination) {
                gridState.pagination = currentPagination;
            }
            if (this.hasRowSelectionEnabled()) {
                var currentRowSelection = this.getCurrentRowSelections(args && args.requestRefreshRowFilteredRow);
                if (currentRowSelection) {
                    gridState.rowSelection = currentRowSelection;
                }
            }
            return gridState;
        };
        /**
         * Get the Columns (and their state: visibility/position) that are currently applied in the grid
         * @return current columns
         */
        GridStateService.prototype.getColumns = function () {
            return this._columns;
        };
        /**
         * From an array of Grid Column Definitions, get the associated Current Columns
         * @param gridColumns
         */
        GridStateService.prototype.getAssociatedCurrentColumns = function (gridColumns) {
            var currentColumns = [];
            if (gridColumns && Array.isArray(gridColumns)) {
                gridColumns.forEach(function (column, index) {
                    if (column && column.id) {
                        currentColumns.push({
                            columnId: column.id,
                            cssClass: column.cssClass || '',
                            headerCssClass: column.headerCssClass || '',
                            width: column.width || 0
                        });
                    }
                });
            }
            this._currentColumns = currentColumns;
            return currentColumns;
        };
        /**
         * From an array of Current Columns, get the associated Grid Column Definitions
         * @param grid
         * @param currentColumns
         */
        GridStateService.prototype.getAssociatedGridColumns = function (grid, currentColumns) {
            var columns = [];
            var gridColumns = grid.getColumns();
            if (currentColumns && Array.isArray(currentColumns)) {
                currentColumns.forEach(function (currentColumn, index) {
                    var gridColumn = gridColumns.find(function (c) { return c.id === currentColumn.columnId; });
                    if (gridColumn && gridColumn.id) {
                        columns.push(__assign({}, gridColumn, { cssClass: currentColumn.cssClass, headerCssClass: currentColumn.headerCssClass, width: currentColumn.width }));
                    }
                });
            }
            this._columns = columns;
            return columns;
        };
        /**
         * Get the Columns (and their states: visibility/position/width) that are currently applied in the grid
         * @return current columns
         */
        GridStateService.prototype.getCurrentColumns = function () {
            var currentColumns = [];
            if (this._currentColumns && Array.isArray(this._currentColumns) && this._currentColumns.length > 0) {
                currentColumns = this._currentColumns;
            }
            else {
                currentColumns = this.getAssociatedCurrentColumns(this._grid.getColumns());
            }
            return currentColumns;
        };
        /**
         * Get the Filters (and their state, columnId, searchTerm(s)) that are currently applied in the grid
         * @return current filters
         */
        GridStateService.prototype.getCurrentFilters = function () {
            if (this._gridOptions && this._gridOptions.backendServiceApi) {
                var backendService = this._gridOptions.backendServiceApi.service;
                if (backendService && backendService.getCurrentFilters) {
                    return backendService.getCurrentFilters();
                }
            }
            else if (this.filterService && this.filterService.getCurrentLocalFilters) {
                return this.filterService.getCurrentLocalFilters();
            }
            return null;
        };
        /**
         * Get current Pagination (and its state, pageNumber, pageSize) that are currently applied in the grid
         * @return current pagination state
         */
        GridStateService.prototype.getCurrentPagination = function () {
            if (this._gridOptions.enablePagination) {
                if (this._gridOptions && this._gridOptions.backendServiceApi) {
                    var backendService = this._gridOptions.backendServiceApi.service;
                    if (backendService && backendService.getCurrentPagination) {
                        return backendService.getCurrentPagination();
                    }
                }
                else {
                    return this.sharedService.currentPagination;
                }
            }
            return null;
        };
        /**
         * Get the current Row Selections (and its state, gridRowIndexes, dataContextIds, filteredDataContextIds) that are currently applied in the grid
         * @return current row selection
         */
        GridStateService.prototype.getCurrentRowSelections = function (requestRefreshFilteredRow) {
            if (requestRefreshFilteredRow === void 0) { requestRefreshFilteredRow = true; }
            if (this._grid && this._gridOptions && this._dataView && this.hasRowSelectionEnabled()) {
                if (this._grid.getSelectedRows && this._dataView.mapRowsToIds) {
                    var filteredDataContextIds = [];
                    var gridRowIndexes = this._dataView.mapIdsToRows(this._selectedRowDataContextIds || []); // note that this will return only what is visible in current page
                    var dataContextIds = this._selectedRowDataContextIds;
                    // user might request to refresh the filtered selection dataset
                    // typically always True, except when "reEvaluateRowSelectionAfterFilterChange" is called and we don't need to refresh the filtered dataset twice
                    if (requestRefreshFilteredRow === true) {
                        filteredDataContextIds = this.refreshFilteredRowSelections();
                    }
                    filteredDataContextIds = this._selectedFilteredRowDataContextIds;
                    return { gridRowIndexes: gridRowIndexes, dataContextIds: dataContextIds, filteredDataContextIds: filteredDataContextIds };
                }
            }
            return null;
        };
        /**
         * Get the current Sorters (and their state, columnId, direction) that are currently applied in the grid
         * @return current sorters
         */
        GridStateService.prototype.getCurrentSorters = function () {
            if (this._gridOptions && this._gridOptions.backendServiceApi) {
                var backendService = this._gridOptions.backendServiceApi.service;
                if (backendService && backendService.getCurrentSorters) {
                    return backendService.getCurrentSorters();
                }
            }
            else if (this.sortService && this.sortService.getCurrentLocalSorters) {
                return this.sortService.getCurrentLocalSorters();
            }
            return null;
        };
        /** Check whether the row selection needs to be preserved */
        GridStateService.prototype.needToPreserveRowSelection = function () {
            var preservedRowSelection = false;
            if (this._gridOptions && this._gridOptions.dataView && this._gridOptions.dataView.hasOwnProperty('syncGridSelection')) {
                var syncGridSelection = this._gridOptions.dataView.syncGridSelection;
                if (typeof syncGridSelection === 'boolean') {
                    preservedRowSelection = this._gridOptions.dataView.syncGridSelection;
                }
                else {
                    preservedRowSelection = syncGridSelection.preserveHidden;
                }
                // if the result is True but the grid is using a Backend Service, we will do an extra flag check the reason is because it might have some unintended behaviors
                // with the BackendServiceApi because technically the data in the page changes the DataView on every page.
                if (preservedRowSelection && this._gridOptions.backendServiceApi && this._gridOptions.dataView.hasOwnProperty('syncGridSelectionWithBackendService')) {
                    preservedRowSelection = this._gridOptions.dataView.syncGridSelectionWithBackendService;
                }
            }
            return preservedRowSelection;
        };
        GridStateService.prototype.resetColumns = function (columnDefinitions) {
            var columns = columnDefinitions || this._columns;
            var currentColumns = this.getAssociatedCurrentColumns(columns);
            this.onGridStateChanged.next({ change: { newValues: currentColumns, type: exports.GridStateType.columns }, gridState: this.getCurrentGridState() });
        };
        /** if we use Row Selection or the Checkbox Selector, we need to reset any selection */
        GridStateService.prototype.resetRowSelectionWhenRequired = function () {
            if (!this.needToPreserveRowSelection() && (this._gridOptions.enableRowSelection || this._gridOptions.enableCheckboxSelector)) {
                // this also requires the Row Selection Model to be registered as well
                var rowSelectionExtension = this.extensionService && this.extensionService.getExtensionByName && this.extensionService.getExtensionByName(exports.ExtensionName.rowSelection);
                if (rowSelectionExtension && rowSelectionExtension.instance) {
                    this._grid.setSelectedRows([]);
                }
            }
        };
        /**
         * Subscribe to all necessary SlickGrid or Service Events that deals with a Grid change,
         * when triggered, we will publish a Grid State Event with current Grid State
         */
        GridStateService.prototype.subscribeToAllGridChanges = function (grid) {
            var _this = this;
            // Subscribe to Event Emitter of Filter changed
            this._subscriptions.push(this.filterService.onFilterChanged.subscribe(function (currentFilters) {
                _this.resetRowSelectionWhenRequired();
                // trigger a Grid State filter change, however don't reevaluate the filtered row selections, we'll do that on the next Grid State change below
                _this.onGridStateChanged.next({ change: { newValues: currentFilters, type: exports.GridStateType.filter }, gridState: _this.getCurrentGridState({ requestRefreshRowFilteredRow: !_this.hasRowSelectionEnabled() }) });
                // when Row Selection is enabled, we also need to re-evaluate the row selection with the leftover filtered dataset
                if (_this.hasRowSelectionEnabled()) {
                    _this.reEvaluateRowSelectionAfterFilterChange();
                }
            }));
            // Subscribe to Event Emitter of Filter cleared
            this._subscriptions.push(this.filterService.onFilterCleared.subscribe(function () {
                _this.resetRowSelectionWhenRequired();
                _this.onGridStateChanged.next({ change: { newValues: [], type: exports.GridStateType.filter }, gridState: _this.getCurrentGridState() });
            }));
            // Subscribe to Event Emitter of Sort changed
            this._subscriptions.push(this.sortService.onSortChanged.subscribe(function (currentSorters) {
                _this.resetRowSelectionWhenRequired();
                _this.onGridStateChanged.next({ change: { newValues: currentSorters, type: exports.GridStateType.sorter }, gridState: _this.getCurrentGridState() });
            }));
            // Subscribe to Event Emitter of Sort cleared
            this._subscriptions.push(this.sortService.onSortCleared.subscribe(function () {
                _this.resetRowSelectionWhenRequired();
                _this.onGridStateChanged.next({ change: { newValues: [], type: exports.GridStateType.sorter }, gridState: _this.getCurrentGridState() });
            }));
            // Subscribe to ColumnPicker and/or GridMenu for show/hide Columns visibility changes
            this.bindExtensionAddonEventToGridStateChange(exports.ExtensionName.columnPicker, 'onColumnsChanged');
            this.bindExtensionAddonEventToGridStateChange(exports.ExtensionName.gridMenu, 'onColumnsChanged');
            // subscribe to Column Resize & Reordering
            this.bindSlickGridColumnChangeEventToGridStateChange('onColumnsReordered', grid);
            this.bindSlickGridColumnChangeEventToGridStateChange('onColumnsResized', grid);
            // subscribe to Row Selection changes (when enabled)
            if (this._gridOptions.enableRowSelection || this._gridOptions.enableCheckboxSelector) {
                this.bindSlickGridRowSelectionToGridStateChange();
            }
            // subscribe to HeaderMenu (hide column)
            this._subscriptions.push(this.sharedService.onHeaderMenuHideColumns.subscribe(function (visibleColumns) {
                var currentColumns = _this.getAssociatedCurrentColumns(visibleColumns);
                _this.onGridStateChanged.next({ change: { newValues: currentColumns, type: exports.GridStateType.columns }, gridState: _this.getCurrentGridState() });
            }));
        };
        // --
        // private methods
        // ------------------
        /**
         * Bind a SlickGrid Extension Event to a Grid State change event
         * @param extension name
         * @param grid
         */
        GridStateService.prototype.bindExtensionAddonEventToGridStateChange = function (extensionName, eventName) {
            var _this = this;
            var extension = this.extensionService && this.extensionService.getExtensionByName && this.extensionService.getExtensionByName(extensionName);
            var slickEvent = extension && extension.instance && extension.instance[eventName];
            if (slickEvent && slickEvent.subscribe) {
                this._eventHandler.subscribe(slickEvent, function (e, args) {
                    var columns = args && args.columns;
                    var currentColumns = _this.getAssociatedCurrentColumns(columns);
                    _this.onGridStateChanged.next({ change: { newValues: currentColumns, type: exports.GridStateType.columns }, gridState: _this.getCurrentGridState() });
                });
            }
        };
        /**
         * Bind a Grid Event (of Column changes) to a Grid State change event
         * @param event name
         * @param grid
         */
        GridStateService.prototype.bindSlickGridColumnChangeEventToGridStateChange = function (eventName, grid) {
            var _this = this;
            var slickGridEvent = grid && grid[eventName];
            if (slickGridEvent && slickGridEvent.subscribe) {
                this._eventHandler.subscribe(slickGridEvent, function () {
                    var columns = grid.getColumns();
                    var currentColumns = _this.getAssociatedCurrentColumns(columns);
                    _this.onGridStateChanged.next({ change: { newValues: currentColumns, type: exports.GridStateType.columns }, gridState: _this.getCurrentGridState() });
                });
            }
        };
        /**
         * Bind a Grid Event of Row Selection change to a Grid State change event
         * For the row selection, we can't just use the getSelectedRows() since this will only return the visible rows shown in the UI which is not enough.
         * The process is much more complex, what we have to do instead is the following
         * 1. when changing a row selection, we'll add the new selection if it's not yet in the global array of selected IDs
         * 2. when deleting a row selection, we'll remove the selection from our global array of selected IDs (unless it came from a page change)
         * 3. if we use Pagination and we change page, we'll keep track with a flag (this flag will be used to skip any deletion when we're changing page)
         * 4. after the Page or DataView is changed or updated, we'll do an extra (and delayed) check to make sure that what we have in our global array of selected IDs is displayed on screen
         */
        GridStateService.prototype.bindSlickGridRowSelectionToGridStateChange = function () {
            var _this = this;
            if (this._grid && this._gridOptions && this._dataView) {
                this._eventHandler.subscribe(this._dataView.onBeforePagingInfoChanged, function () {
                    _this._wasRecheckedAfterPageChange = false; // reset the page check flag, to skip deletions on page change (used in code below)
                });
                this._eventHandler.subscribe(this._dataView.onPagingInfoChanged, function () {
                    // when user changes page, the selected row indexes might not show up
                    // we can check to make sure it is but it has to be in a delay so it happens after the first "onSelectedRowsChanged" is triggered
                    setTimeout(function () {
                        var shouldBeSelectedRowIndexes = _this._dataView.mapIdsToRows(_this._selectedRowDataContextIds || []);
                        var currentSelectedRowIndexes = _this._grid.getSelectedRows();
                        if (!isequal$1(shouldBeSelectedRowIndexes, currentSelectedRowIndexes)) {
                            _this._grid.setSelectedRows(shouldBeSelectedRowIndexes);
                        }
                    });
                });
                this._eventHandler.subscribe(this._grid.onSelectedRowsChanged, function (e, args) {
                    if (Array.isArray(args.rows) && Array.isArray(args.previousSelectedRows)) {
                        var newSelectedRows_1 = args.rows;
                        var prevSelectedRows_1 = args.previousSelectedRows;
                        var newSelectedAdditions = newSelectedRows_1.filter(function (i) { return prevSelectedRows_1.indexOf(i) < 0; });
                        var newSelectedDeletions = prevSelectedRows_1.filter(function (i) { return newSelectedRows_1.indexOf(i) < 0; });
                        // deletion might happen when user is changing page, if that is the case then skip the deletion since it's only a visual deletion (current page)
                        // if it's not a page change (when the flag is true), then proceed with the deletion in our global array of selected IDs
                        if (_this._wasRecheckedAfterPageChange && newSelectedDeletions.length > 0) {
                            var toDeleteDataIds = _this._dataView.mapRowsToIds(newSelectedDeletions) || [];
                            toDeleteDataIds.forEach(function (removeId) {
                                _this._selectedRowDataContextIds.splice(_this._selectedRowDataContextIds.indexOf(removeId), 1);
                            });
                        }
                        // if we have newly added selected row(s), let's update our global array of selected IDs
                        if (newSelectedAdditions.length > 0) {
                            var toAddDataIds = _this._dataView.mapRowsToIds(newSelectedAdditions) || [];
                            toAddDataIds.forEach(function (dataId) {
                                if (_this._selectedRowDataContextIds.indexOf(dataId) === -1) {
                                    _this._selectedRowDataContextIds.push(dataId);
                                }
                            });
                        }
                        // we set this flag which will be used on the 2nd time the "onSelectedRowsChanged" event is called
                        // when it's the first time, we skip deletion and this is what this flag is for
                        _this._wasRecheckedAfterPageChange = true;
                        // form our full selected row IDs, let's make sure these indexes are selected in the grid, if not then let's call a reselect
                        // this could happen if the previous step was a page change
                        var shouldBeSelectedRowIndexes = _this._dataView.mapIdsToRows(_this._selectedRowDataContextIds || []);
                        var currentSelectedRowIndexes = _this._grid.getSelectedRows();
                        if (!isequal$1(shouldBeSelectedRowIndexes, currentSelectedRowIndexes)) {
                            _this._grid.setSelectedRows(shouldBeSelectedRowIndexes);
                        }
                        var filteredDataContextIds = _this.refreshFilteredRowSelections();
                        var newValues = { gridRowIndexes: _this._grid.getSelectedRows(), dataContextIds: _this._selectedRowDataContextIds, filteredDataContextIds: filteredDataContextIds };
                        _this.onGridStateChanged.next({ change: { newValues: newValues, type: exports.GridStateType.rowSelection }, gridState: _this.getCurrentGridState() });
                    }
                });
            }
        };
        /** Check wether the grid has the Row Selection enabled */
        GridStateService.prototype.hasRowSelectionEnabled = function () {
            var selectionModel = this._grid.getSelectionModel();
            var isRowSelectionEnabled = this._gridOptions.enableRowSelection || this._gridOptions.enableCheckboxSelector;
            return (isRowSelectionEnabled && selectionModel);
        };
        GridStateService.prototype.reEvaluateRowSelectionAfterFilterChange = function () {
            var currentSelectedRowIndexes = this._grid.getSelectedRows();
            var previousSelectedFilteredRowDataContextIds = this._selectedFilteredRowDataContextIds.slice();
            var filteredDataContextIds = this.refreshFilteredRowSelections();
            // when selection changed, we'll send a Grid State event with the selection changes
            if (!isequal$1(this._selectedFilteredRowDataContextIds, previousSelectedFilteredRowDataContextIds)) {
                var newValues = { gridRowIndexes: currentSelectedRowIndexes, dataContextIds: this._selectedRowDataContextIds, filteredDataContextIds: filteredDataContextIds };
                this.onGridStateChanged.next({ change: { newValues: newValues, type: exports.GridStateType.rowSelection }, gridState: this.getCurrentGridState({ requestRefreshRowFilteredRow: false }) });
            }
        };
        /** When a Filter is triggered or when user request it, we will refresh the filtered selection array and return it */
        GridStateService.prototype.refreshFilteredRowSelections = function () {
            var _this = this;
            var tmpFilteredArray = [];
            var filteredDataset = this._dataView.getFilteredItems() || [];
            if (Array.isArray(this._selectedRowDataContextIds)) {
                var selectedFilteredRowDataContextIds = __spread(this._selectedRowDataContextIds); // take a fresh copy of all selections before filtering the row ids
                tmpFilteredArray = selectedFilteredRowDataContextIds.filter(function (selectedRowId) {
                    return filteredDataset.findIndex(function (item) { return item[_this.datasetIdPropName] === selectedRowId; }) > -1;
                });
                this._selectedFilteredRowDataContextIds = tmpFilteredArray;
            }
            return tmpFilteredArray;
        };
        GridStateService.ctorParameters = function () { return [
            { type: ExtensionService },
            { type: FilterService },
            { type: SharedService },
            { type: SortService }
        ]; };
        GridStateService = __decorate([
            core.Injectable()
        ], GridStateService);
        return GridStateService;
    }());

    var highlightTimerEnd;
    var GridServiceDeleteOptionDefaults = { triggerEvent: true };
    var GridServiceInsertOptionDefaults = { highlightRow: true, position: 'top', resortGrid: false, selectRow: false, triggerEvent: true };
    var GridServiceUpdateOptionDefaults = { highlightRow: true, selectRow: false, scrollRowIntoView: false, triggerEvent: true };
    var HideColumnOptionDefaults = { autoResizeColumns: true, triggerEvent: true, hideFromColumnPicker: false, hideFromGridMenu: false };
    var GridService = /** @class */ (function () {
        function GridService(extensionService, filterService, gridStateService, sharedService, sortService) {
            this.extensionService = extensionService;
            this.filterService = filterService;
            this.gridStateService = gridStateService;
            this.sharedService = sharedService;
            this.sortService = sortService;
            this.onItemAdded = new rxjs.Subject();
            this.onItemDeleted = new rxjs.Subject();
            this.onItemUpdated = new rxjs.Subject();
            this.onItemUpserted = new rxjs.Subject();
            this.onColumnsChanged = new rxjs.Subject();
        }
        Object.defineProperty(GridService.prototype, "_gridOptions", {
            /** Getter for the Grid Options pulled through the Grid Object */
            get: function () {
                return (this._grid && this._grid.getOptions) ? this._grid.getOptions() : {};
            },
            enumerable: true,
            configurable: true
        });
        GridService.prototype.dispose = function () {
            if (this._rowSelectionPlugin && this._rowSelectionPlugin.destroy) {
                this._rowSelectionPlugin.destroy();
            }
        };
        GridService.prototype.init = function (grid, dataView) {
            this._grid = grid;
            this._dataView = dataView;
        };
        /** Clear all Filters & Sorts */
        GridService.prototype.clearAllFiltersAndSorts = function () {
            // call both clear Filters & Sort but only trigger the last one to avoid sending multiple backend queries
            if (this.sortService && this.sortService.clearSorting) {
                this.sortService.clearSorting(false); // skip event trigger on this one
            }
            if (this.filterService && this.filterService.clearFilters) {
                this.filterService.clearFilters();
            }
        };
        /**
         * Get all column set in the grid, that is all visible/hidden columns
         * and also include any extra columns used by some plugins (like Row Selection, Row Detail, ...)
         */
        GridService.prototype.getAllColumnDefinitions = function () {
            return this.sharedService.allColumns;
        };
        /** Get only visible column definitions and also include any extra columns by some plugins (like Row Selection, Row Detail, ...) */
        GridService.prototype.getVisibleColumnDefinitions = function () {
            return this.sharedService.visibleColumns;
        };
        /**
         * From a SlickGrid Event triggered get the Column Definition and Item Data Context
         *
         * For example the SlickGrid onClick will return cell arguments when subscribing to it.
         * From these cellArgs, we want to get the Column Definition and Item Data
         * @param cell event args
         * @return object with columnDef and dataContext
         */
        GridService.prototype.getColumnFromEventArguments = function (args) {
            if (!args || !args.grid || !args.grid.getColumns || !args.grid.getDataItem) {
                throw new Error('To get the column definition and data, we need to have these arguments passed as objects (row, cell, grid)');
            }
            return {
                row: args.row,
                cell: args.cell,
                columnDef: args.grid.getColumns()[args.cell],
                dataContext: args.grid.getDataItem(args.row),
                dataView: this._dataView,
                grid: this._grid
            };
        };
        /** Get data item by it's row index number */
        GridService.prototype.getDataItemByRowNumber = function (rowNumber) {
            if (!this._grid || typeof this._grid.getDataItem !== 'function') {
                throw new Error("We could not find SlickGrid Grid object or it's \"getDataItem\" method");
            }
            return this._grid.getDataItem(rowNumber);
        };
        /** Chain the item Metadata with our implementation of Metadata at given row index */
        GridService.prototype.getItemRowMetadataToHighlight = function (previousItemMetadata) {
            var _this = this;
            return function (rowNumber) {
                var item = _this._dataView.getItem(rowNumber);
                var meta = { cssClasses: '' };
                if (typeof previousItemMetadata === 'function') {
                    meta = previousItemMetadata(rowNumber);
                }
                if (!meta) {
                    meta = { cssClasses: '' };
                }
                if (item && item._dirty) {
                    meta.cssClasses = (meta && meta.cssClasses || '') + ' dirty';
                }
                if (item && item.rowClass && meta) {
                    meta.cssClasses += " " + item.rowClass;
                    meta.cssClasses += " row" + rowNumber;
                }
                return meta;
            };
        };
        /**
           * @deprecated Hide a Column from the Grid (the column will just become hidden and will still show up in columnPicker/gridMenu)
           * @see hideColumnById
           * @param column
           */
        GridService.prototype.hideColumn = function (column) {
            if (this._grid && this._grid.getColumns && this._grid.setColumns && this._grid.getColumnIndex) {
                var columnIndex = this._grid.getColumnIndex(column.id);
                if (columnIndex >= 0) {
                    this.hideColumnByIndex(columnIndex);
                }
            }
        };
        /**
         * @deprecated Hide a Column from the Grid by its column definition index (the column will just become hidden and will still show up in columnPicker/gridMenu)
         * @see hideColumnById Please use "hideColumnById(id)" or "hideColumnByIds([ids])" instead since it has a lot more options
         * @param columnIndex - column definition index
         * @param triggerEvent - do we want to trigger an event (onHeaderMenuColumnsChanged) when column becomes hidden? Defaults to true.
         */
        GridService.prototype.hideColumnByIndex = function (columnIndex, triggerEvent) {
            if (triggerEvent === void 0) { triggerEvent = true; }
            if (this._grid && this._grid.getColumns && this._grid.setColumns) {
                var currentColumns = this._grid.getColumns();
                var visibleColumns = arrayRemoveItemByIndex(currentColumns, columnIndex);
                this.sharedService.visibleColumns = visibleColumns;
                this._grid.setColumns(visibleColumns);
                if (triggerEvent) {
                    this.onColumnsChanged.next(visibleColumns);
                }
            }
        };
        /**
         * Hide a Column from the Grid by its column definition id, the column will just become hidden and will still show up in columnPicker/gridMenu
         * @param {string | number} columnId - column definition id
         * @param {boolean} triggerEvent - do we want to trigger an event (onHeaderMenuColumnsChanged) when column becomes hidden? Defaults to true.
         * @return {number} columnIndex - column index position when found or -1
         */
        GridService.prototype.hideColumnById = function (columnId, options) {
            options = __assign({}, HideColumnOptionDefaults, options);
            if (this._grid && this._grid.getColumns && this._grid.setColumns) {
                var currentColumns = this._grid.getColumns();
                var colIndexFound = currentColumns.findIndex(function (col) { return col.id === columnId; });
                if (colIndexFound >= 0) {
                    var visibleColumns = arrayRemoveItemByIndex(currentColumns, colIndexFound);
                    this.sharedService.visibleColumns = visibleColumns;
                    this._grid.setColumns(visibleColumns);
                    var columnIndexFromAllColumns = this.sharedService.allColumns.findIndex(function (col) { return col.id === columnId; });
                    if (columnIndexFromAllColumns) {
                        if (options && options.hideFromColumnPicker) {
                            this.sharedService.allColumns[columnIndexFromAllColumns].excludeFromColumnPicker = true;
                        }
                        if (options && options.hideFromGridMenu) {
                            this.sharedService.allColumns[columnIndexFromAllColumns].excludeFromGridMenu = true;
                        }
                    }
                    // do we want to auto-resize the columns in the grid after hidding some? most often yes
                    if (options && options.autoResizeColumns) {
                        this._grid.autosizeColumns();
                    }
                    // do we want to trigger an event after hidding
                    if (options && options.triggerEvent) {
                        this.onColumnsChanged.next(visibleColumns);
                    }
                    return colIndexFound;
                }
            }
            return -1;
        };
        /**
         * Hide a Column from the Grid by its column definition id(s), the column will just become hidden and will still show up in columnPicker/gridMenu
         * @param {Array<string | number>} columnIds - column definition ids, can be a single string and an array of strings
         * @param {boolean} triggerEvent - do we want to trigger an event (onHeaderMenuColumnsChanged) when column becomes hidden? Defaults to true.
         */
        GridService.prototype.hideColumnByIds = function (columnIds, options) {
            var e_1, _a;
            options = __assign({}, HideColumnOptionDefaults, options);
            if (Array.isArray(columnIds)) {
                try {
                    for (var columnIds_1 = __values(columnIds), columnIds_1_1 = columnIds_1.next(); !columnIds_1_1.done; columnIds_1_1 = columnIds_1.next()) {
                        var columnId = columnIds_1_1.value;
                        // hide each column by its id but wait after the for loop to auto resize columns in the grid
                        this.hideColumnById(columnId, __assign({}, options, { triggerEvent: false, autoResizeColumns: false }));
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (columnIds_1_1 && !columnIds_1_1.done && (_a = columnIds_1.return)) _a.call(columnIds_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                // do we want to auto-resize the columns in the grid after hidding some? most often yes
                if (options && options.autoResizeColumns) {
                    this._grid.autosizeColumns();
                }
                // do we want to trigger an event after hidding
                if (options && options.triggerEvent) {
                    this.onColumnsChanged.next(this.sharedService.visibleColumns);
                }
            }
        };
        /**
         * Highlight then fade a row for x seconds.
         * The implementation follows this SO answer: https://stackoverflow.com/a/19985148/1212166
         * @param rowNumber
         * @param fadeDelay
         */
        GridService.prototype.highlightRow = function (rowNumber, fadeDelay, fadeOutDelay) {
            var _this = this;
            if (fadeDelay === void 0) { fadeDelay = 1500; }
            if (fadeOutDelay === void 0) { fadeOutDelay = 300; }
            // create a SelectionModel if there's not one yet
            if (!this._grid.getSelectionModel() && Slick && Slick.RowSelectionModel) {
                this._rowSelectionPlugin = new Slick.RowSelectionModel(this._gridOptions.rowSelectionOptions || {});
                this._grid.setSelectionModel(this._rowSelectionPlugin);
            }
            if (Array.isArray(rowNumber)) {
                rowNumber.forEach(function (row) { return _this.highlightRowByMetadata(row, fadeDelay, fadeOutDelay); });
            }
            else {
                this.highlightRowByMetadata(rowNumber, fadeDelay, fadeOutDelay);
            }
        };
        GridService.prototype.highlightRowByMetadata = function (rowNumber, fadeDelay, fadeOutDelay) {
            var _this = this;
            if (fadeDelay === void 0) { fadeDelay = 1500; }
            if (fadeOutDelay === void 0) { fadeOutDelay = 300; }
            this._dataView.getItemMetadata = this.getItemRowMetadataToHighlight(this._dataView.getItemMetadata);
            var item = this._dataView.getItem(rowNumber);
            var idPropName = this._gridOptions.datasetIdPropertyName || 'id';
            if (item && item[idPropName]) {
                item.rowClass = 'highlight';
                this._dataView.updateItem(item[idPropName], item);
                this.renderGrid();
                // fade out
                clearTimeout(highlightTimerEnd);
                highlightTimerEnd = setTimeout(function () {
                    item.rowClass = 'highlight-end';
                    _this._dataView.updateItem(item[idPropName], item);
                    _this.renderGrid();
                }, fadeOutDelay);
                // delete the row's CSS highlight classes once the delay is passed
                setTimeout(function () {
                    if (item && item[idPropName]) {
                        delete item.rowClass;
                        if (_this._dataView.getIdxById(item[idPropName]) !== undefined) {
                            _this._dataView.updateItem(item[idPropName], item);
                            _this.renderGrid();
                        }
                    }
                }, fadeDelay + fadeOutDelay);
            }
        };
        /** Get the Data Item from a grid row index */
        GridService.prototype.getDataItemByRowIndex = function (index) {
            if (!this._grid || typeof this._grid.getDataItem !== 'function') {
                throw new Error('We could not find SlickGrid Grid object and/or "getDataItem" method');
            }
            return this._grid.getDataItem(index);
        };
        /** Get the Data Item from an array of grid row indexes */
        GridService.prototype.getDataItemByRowIndexes = function (indexes) {
            var _this = this;
            if (!this._grid || typeof this._grid.getDataItem !== 'function') {
                throw new Error('We could not find SlickGrid Grid object and/or "getDataItem" method');
            }
            var dataItems = [];
            if (Array.isArray(indexes)) {
                indexes.forEach(function (idx) {
                    dataItems.push(_this._grid.getDataItem(idx));
                });
            }
            return dataItems;
        };
        /** Get the currently selected row indexes */
        GridService.prototype.getSelectedRows = function () {
            if (!this._grid || typeof this._grid.getSelectedRows !== 'function') {
                throw new Error('We could not find SlickGrid Grid object and/or "getSelectedRows" method');
            }
            return this._grid.getSelectedRows();
        };
        /** Get the currently selected rows item data */
        GridService.prototype.getSelectedRowsDataItem = function () {
            if (!this._grid || typeof this._grid.getSelectedRows !== 'function') {
                throw new Error('We could not find SlickGrid Grid object and/or "getSelectedRows" method');
            }
            var selectedRowIndexes = this._grid.getSelectedRows();
            return this.getDataItemByRowIndexes(selectedRowIndexes);
        };
        /** Select the selected row by a row index */
        GridService.prototype.setSelectedRow = function (rowIndex) {
            if (this._grid && this._grid.setSelectedRows) {
                this._grid.setSelectedRows([rowIndex]);
            }
        };
        /** Set selected rows with provided array of row indexes */
        GridService.prototype.setSelectedRows = function (rowIndexes) {
            if (this._grid && this._grid.setSelectedRows) {
                this._grid.setSelectedRows(rowIndexes);
            }
        };
        /** Re-Render the Grid */
        GridService.prototype.renderGrid = function () {
            if (this._grid && typeof this._grid.invalidate === 'function') {
                this._grid.invalidate();
                this._grid.render();
            }
        };
        /**
         * Reset the grid to it's original state (clear any filters, sorting & pagination if exists) .
         * The column definitions could be passed as argument to reset (this can be used after a Grid State reset)
         * The reset will clear the Filters & Sort, then will reset the Columns to their original state
         */
        GridService.prototype.resetGrid = function (columnDefinitions) {
            // reset columns to original states & refresh the grid
            if (this._grid && this._dataView) {
                var originalColumns = this.extensionService.getAllColumns();
                if (Array.isArray(originalColumns) && originalColumns.length > 0) {
                    // set the grid columns to it's original column definitions
                    this._grid.setColumns(originalColumns);
                    if (this._gridOptions && this._gridOptions.enableAutoSizeColumns) {
                        this._grid.autosizeColumns();
                    }
                    this.gridStateService.resetColumns(columnDefinitions);
                }
            }
            if (this.filterService && this.filterService.clearFilters) {
                this.filterService.clearFilters();
            }
            if (this.sortService && this.sortService.clearSorting) {
                this.sortService.clearSorting();
            }
        };
        /** @deprecated please use "addItem" method instead */
        GridService.prototype.addItemToDatagrid = function (item, shouldHighlightRow, shouldResortGrid, shouldTriggerEvent, shouldSelectRow) {
            if (shouldHighlightRow === void 0) { shouldHighlightRow = true; }
            if (shouldResortGrid === void 0) { shouldResortGrid = false; }
            if (shouldTriggerEvent === void 0) { shouldTriggerEvent = true; }
            if (shouldSelectRow === void 0) { shouldSelectRow = true; }
            console.warn('[Angular-Slickgrid - GridService] please consider using the new "addItem" method since "addItemToDatagrid" will be deprecated in the future.');
            return this.addItem(item, { highlightRow: shouldHighlightRow, resortGrid: shouldResortGrid, triggerEvent: shouldTriggerEvent, selectRow: shouldSelectRow });
        };
        /** @deprecated please use "addItems" method instead */
        GridService.prototype.addItemsToDatagrid = function (items, shouldHighlightRow, shouldResortGrid, shouldTriggerEvent, shouldSelectRow) {
            if (shouldHighlightRow === void 0) { shouldHighlightRow = true; }
            if (shouldResortGrid === void 0) { shouldResortGrid = false; }
            if (shouldTriggerEvent === void 0) { shouldTriggerEvent = true; }
            if (shouldSelectRow === void 0) { shouldSelectRow = true; }
            console.warn('[Angular-Slickgrid - GridService] please consider using the new "addItems" method since "addItemsToDatagrid" will be deprecated in the future.');
            return this.addItems(items, { highlightRow: shouldHighlightRow, resortGrid: shouldResortGrid, triggerEvent: shouldTriggerEvent, selectRow: shouldSelectRow });
        };
        /**
         * Add an item (data item) to the datagrid, by default it will highlight (flashing) the inserted row but we can disable it too
         * @param item object which must contain a unique "id" property and any other suitable properties
         * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, resortGrid, selectRow, triggerEvent)
         * @return rowIndex: typically index 0 when adding to position "top" or a different number when adding to the "bottom"
         */
        GridService.prototype.addItem = function (item, options) {
            options = __assign({}, GridServiceInsertOptionDefaults, options);
            if (!this._grid || !this._gridOptions || !this._dataView) {
                throw new Error('We could not find SlickGrid Grid, DataView objects');
            }
            var idPropName = this._gridOptions.datasetIdPropertyName || 'id';
            if (!item || !(idPropName in item)) {
                throw new Error("Adding an item requires the item to include an \"" + idPropName + "\" property");
            }
            // insert position top/bottom, defaults to top
            // when position is top we'll call insert at index 0, else call addItem which just push to the DataView array
            if (options && options.position === 'bottom') {
                this._dataView.addItem(item);
            }
            else {
                this._dataView.insertItem(0, item); // insert at index 0
            }
            // row number in the grid, by default it will be on first row (top is the default)
            var rowNumber = 0;
            // do we want the item to be sorted in the grid, when set to False it will insert on first row (defaults to false)
            if (options.resortGrid) {
                this._dataView.reSort();
                // find the row number in the grid and if user wanted to see highlighted row
                // we need to do it here after resort and get each row number because it possibly changes after the sort
                rowNumber = this._dataView.getRowById(item[idPropName]);
            }
            else {
                // scroll to row index 0 when inserting on top else scroll to the bottom where it got inserted
                rowNumber = (options && options.position === 'bottom') ? this._dataView.getRowById(item[idPropName]) : 0;
                this._grid.scrollRowIntoView(rowNumber);
            }
            // if highlight is enabled, we'll highlight the row we just added
            if (options.highlightRow) {
                this.highlightRow(rowNumber);
            }
            // if row selection (checkbox selector) is enabled, we'll select the row in the grid
            if (options.selectRow && this._gridOptions && (this._gridOptions.enableCheckboxSelector || this._gridOptions.enableRowSelection)) {
                this.setSelectedRow(rowNumber);
            }
            // do we want to trigger an event after adding the item
            if (options.triggerEvent) {
                this.onItemAdded.next(item);
            }
            return rowNumber;
        };
        /**
         * Add item array (data item) to the datagrid, by default it will highlight (flashing) the inserted row but we can disable it too
         * @param item object arrays, which must contain unique "id" property and any other suitable properties
         * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, resortGrid, selectRow, triggerEvent)
         */
        GridService.prototype.addItems = function (items, options) {
            var _this = this;
            options = __assign({}, GridServiceInsertOptionDefaults, options);
            var idPropName = this._gridOptions.datasetIdPropertyName || 'id';
            var rowNumbers = [];
            // loop through all items to add
            if (!Array.isArray(items)) {
                return [this.addItem(items, options)];
            }
            else {
                this._dataView.beginUpdate();
                items.forEach(function (item) { return _this.addItem(item, __assign({}, options, { highlightRow: false, resortGrid: false, triggerEvent: false, selectRow: false })); });
                this._dataView.endUpdate();
            }
            // do we want the item to be sorted in the grid, when set to False it will insert on first row (defaults to false)
            if (options.resortGrid) {
                this._dataView.reSort();
            }
            // scroll to row index 0 when inserting on top else scroll to the bottom where it got inserted
            (options && options.position === 'bottom') ? this._grid.navigateBottom() : this._grid.navigateTop();
            // get row numbers of all new inserted items
            // we need to do it after resort and get each row number because it possibly changed after the sort
            items.forEach(function (item) { return rowNumbers.push(_this._dataView.getRowById(item[idPropName])); });
            // if user wanted to see highlighted row
            if (options.highlightRow) {
                this.highlightRow(rowNumbers);
            }
            // select the row in the grid
            if (options.selectRow && this._gridOptions && (this._gridOptions.enableCheckboxSelector || this._gridOptions.enableRowSelection)) {
                this.setSelectedRows(rowNumbers);
            }
            // do we want to trigger an event after adding the item
            if (options.triggerEvent) {
                this.onItemAdded.next(items);
            }
            return rowNumbers;
        };
        /** @deprecated please use "deleteItem" method instead */
        GridService.prototype.deleteDataGridItem = function (item, shouldTriggerEvent) {
            if (shouldTriggerEvent === void 0) { shouldTriggerEvent = true; }
            console.warn('[Angular-Slickgrid - GridService] please consider using the new "deleteItem" method since "deleteDataGridItem" will be deprecated in the future.');
            this.deleteItem(item, { triggerEvent: shouldTriggerEvent });
        };
        /** @deprecated please use "deleteItems" method instead */
        GridService.prototype.deleteDataGridItems = function (items, shouldTriggerEvent) {
            if (shouldTriggerEvent === void 0) { shouldTriggerEvent = true; }
            console.warn('[Angular-Slickgrid - GridService] please consider using the new "deleteItems" method since "deleteDataGridItems" will be deprecated in the future.');
            this.deleteItems(items, { triggerEvent: shouldTriggerEvent });
        };
        /** @deprecated please use "deleteItemById" method instead */
        GridService.prototype.deleteDataGridItemById = function (itemId, shouldTriggerEvent) {
            if (shouldTriggerEvent === void 0) { shouldTriggerEvent = true; }
            console.warn('[Angular-Slickgrid - GridService] please consider using the new "deleteItemById" method since "deleteDataGridItemById" will be deprecated in the future.');
            this.deleteItemById(itemId, { triggerEvent: shouldTriggerEvent });
        };
        /** @deprecated please use "deleteItemByIds" method instead */
        GridService.prototype.deleteDataGridItemByIds = function (itemIds, shouldTriggerEvent) {
            if (shouldTriggerEvent === void 0) { shouldTriggerEvent = true; }
            console.warn('[Angular-Slickgrid - GridService] please consider using the new "deleteItemByIds" method since "deleteDataGridItemByIds" will be deprecated in the future.');
            this.deleteItemByIds(itemIds, { triggerEvent: shouldTriggerEvent });
        };
        /**
         * Delete an existing item from the datagrid (dataView)
         * @param item object which must contain a unique "id" property and any other suitable properties
         * @param options: provide the possibility to do certain actions after or during the upsert (triggerEvent)
         * @return item id deleted
         */
        GridService.prototype.deleteItem = function (item, options) {
            options = __assign({}, GridServiceDeleteOptionDefaults, options);
            var idPropName = this._gridOptions.datasetIdPropertyName || 'id';
            if (!item || !(idPropName in item)) {
                throw new Error("Deleting an item requires the item to include an \"" + idPropName + "\" property");
            }
            return this.deleteItemById(item[idPropName], options);
        };
        /**
         * Delete an array of existing items from the datagrid
         * @param item object which must contain a unique "id" property and any other suitable properties
         * @param options: provide the possibility to do certain actions after or during the upsert (triggerEvent)
         * @return item id deleted
         */
        GridService.prototype.deleteItems = function (items, options) {
            var _this = this;
            options = __assign({}, GridServiceDeleteOptionDefaults, options);
            var idPropName = this._gridOptions.datasetIdPropertyName || 'id';
            // when it's not an array, we can call directly the single item delete
            if (!Array.isArray(items)) {
                this.deleteItem(items, options);
                return [items[idPropName]];
            }
            this._dataView.beginUpdate();
            var itemIds = [];
            items.forEach(function (item) {
                if (item && item[idPropName] !== undefined) {
                    itemIds.push(item[idPropName]);
                }
                _this.deleteItem(item, __assign({}, options, { triggerEvent: false }));
            });
            this._dataView.endUpdate();
            // do we want to trigger an event after deleting the item
            if (options.triggerEvent) {
                this.onItemDeleted.next(items);
            }
            return itemIds;
        };
        /**
         * Delete an existing item from the datagrid (dataView) by it's id
         * @param itemId: item unique id
         * @param options: provide the possibility to do certain actions after or during the upsert (triggerEvent)
         * @return item id deleted
         */
        GridService.prototype.deleteItemById = function (itemId, options) {
            options = __assign({}, GridServiceDeleteOptionDefaults, options);
            if (itemId === null || itemId === undefined) {
                throw new Error("Cannot delete a row without a valid \"id\"");
            }
            // when user has row selection enabled, we should clear any selection to avoid confusion after a delete
            var isSyncGridSelectionEnabled = this.gridStateService && this.gridStateService.needToPreserveRowSelection() || false;
            if (!isSyncGridSelectionEnabled && this._grid && this._gridOptions && (this._gridOptions.enableCheckboxSelector || this._gridOptions.enableRowSelection)) {
                this.setSelectedRows([]);
            }
            // delete the item from the dataView
            this._dataView.deleteItem(itemId);
            // do we want to trigger an event after deleting the item
            if (options.triggerEvent) {
                this.onItemDeleted.next(itemId);
            }
            return itemId;
        };
        /**
         * Delete an array of existing items from the datagrid
         * @param itemIds array of item unique IDs
         * @param options: provide the possibility to do certain actions after or during the upsert (triggerEvent)
         */
        GridService.prototype.deleteItemByIds = function (itemIds, options) {
            options = __assign({}, GridServiceDeleteOptionDefaults, options);
            // when it's not an array, we can call directly the single item delete
            if (Array.isArray(itemIds)) {
                this._dataView.beginUpdate();
                for (var i = 0; i < itemIds.length; i++) {
                    if (itemIds[i] !== null) {
                        this.deleteItemById(itemIds[i], { triggerEvent: false });
                    }
                }
                this._dataView.endUpdate();
                // do we want to trigger an event after deleting the item
                if (options.triggerEvent) {
                    this.onItemDeleted.next(itemIds);
                }
                return itemIds;
            }
            return [];
        };
        /** @deprecated please use "updateItem" method instead */
        GridService.prototype.updateDataGridItem = function (item, shouldHighlightRow, shouldTriggerEvent, shouldSelectRow) {
            if (shouldHighlightRow === void 0) { shouldHighlightRow = true; }
            if (shouldTriggerEvent === void 0) { shouldTriggerEvent = true; }
            if (shouldSelectRow === void 0) { shouldSelectRow = true; }
            console.warn('[Angular-Slickgrid - GridService] please consider using the new "updateItem" method since "updateDataGridItem" will be deprecated in the future.');
            return this.updateItem(item, { highlightRow: shouldHighlightRow, triggerEvent: shouldTriggerEvent, selectRow: shouldSelectRow });
        };
        /** @deprecated please use "updateItems" method instead */
        GridService.prototype.updateDataGridItems = function (items, shouldHighlightRow, shouldTriggerEvent, shouldSelectRow) {
            if (shouldHighlightRow === void 0) { shouldHighlightRow = true; }
            if (shouldTriggerEvent === void 0) { shouldTriggerEvent = true; }
            if (shouldSelectRow === void 0) { shouldSelectRow = true; }
            console.warn('[Angular-Slickgrid - GridService] please consider using the new "updateItems" method since "updateDataGridItems" will be deprecated in the future.');
            return this.updateItems(items, { highlightRow: shouldHighlightRow, triggerEvent: shouldTriggerEvent, selectRow: shouldSelectRow });
        };
        /** @deprecated please use "updateItemById" method instead */
        GridService.prototype.updateDataGridItemById = function (itemId, item, shouldHighlightRow, shouldTriggerEvent, shouldSelectRow) {
            if (shouldHighlightRow === void 0) { shouldHighlightRow = true; }
            if (shouldTriggerEvent === void 0) { shouldTriggerEvent = true; }
            if (shouldSelectRow === void 0) { shouldSelectRow = true; }
            console.warn('[Angular-Slickgrid - GridService] please consider using the new "updateItemById" method since "updateDataGridItemById" will be deprecated in the future.');
            return this.updateItemById(itemId, item, { highlightRow: shouldHighlightRow, triggerEvent: shouldTriggerEvent, selectRow: shouldSelectRow });
        };
        /**
         * Update an existing item with new properties inside the datagrid
         * @param item object which must contain a unique "id" property and any other suitable properties
         * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, selectRow, triggerEvent)
         * @return grid row index
         */
        GridService.prototype.updateItem = function (item, options) {
            options = __assign({}, GridServiceUpdateOptionDefaults, options);
            var idPropName = this._gridOptions.datasetIdPropertyName || 'id';
            var itemId = (!item || !(idPropName in item)) ? undefined : item[idPropName];
            if (itemId === undefined) {
                throw new Error("Calling Update of an item requires the item to include an \"" + idPropName + "\" property");
            }
            return this.updateItemById(itemId, item, options);
        };
        /**
         * Update an array of existing items with new properties inside the datagrid
         * @param item object arrays, which must contain unique "id" property and any other suitable properties
         * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, selectRow, triggerEvent)
         * @return grid row indexes
         */
        GridService.prototype.updateItems = function (items, options) {
            var _this = this;
            options = __assign({}, GridServiceUpdateOptionDefaults, options);
            // when it's not an array, we can call directly the single item update
            if (!Array.isArray(items)) {
                return [this.updateItem(items, options)];
            }
            this._dataView.beginUpdate();
            var gridRowNumbers = [];
            items.forEach(function (item) {
                gridRowNumbers.push(_this.updateItem(item, __assign({}, options, { highlightRow: false, selectRow: false, triggerEvent: false })));
            });
            this._dataView.endUpdate();
            // only highlight at the end, all at once
            // we have to do this because doing highlight 1 by 1 would only re-select the last highlighted row which is wrong behavior
            if (options.highlightRow) {
                this.highlightRow(gridRowNumbers);
            }
            // select the row in the grid
            if (options.selectRow && this._gridOptions && (this._gridOptions.enableCheckboxSelector || this._gridOptions.enableRowSelection)) {
                this.setSelectedRows(gridRowNumbers);
            }
            // do we want to trigger an event after updating the item
            if (options.triggerEvent) {
                this.onItemUpdated.next(items);
            }
            return gridRowNumbers;
        };
        /**
         * Update an existing item in the datagrid by it's id and new properties
         * @param itemId: item unique id
         * @param item object which must contain a unique "id" property and any other suitable properties
         * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, selectRow, triggerEvent)
         * @return grid row number
         */
        GridService.prototype.updateItemById = function (itemId, item, options) {
            options = __assign({}, GridServiceUpdateOptionDefaults, options);
            if (itemId === undefined) {
                throw new Error("Cannot update a row without a valid \"id\"");
            }
            var rowNumber = this._dataView.getRowById(itemId);
            if (!item || rowNumber === undefined) {
                throw new Error("The item to update in the grid was not found with id: " + itemId);
            }
            if (this._dataView.getIdxById(itemId) !== undefined) {
                // Update the item itself inside the dataView
                this._dataView.updateItem(itemId, item);
                this._grid.updateRow(rowNumber);
                // do we want to scroll to the row so that it shows in the Viewport (UI)
                if (options.scrollRowIntoView) {
                    this._grid.scrollRowIntoView(rowNumber);
                }
                // highlight the row we just updated, if defined
                if (options.highlightRow) {
                    this.highlightRow(rowNumber);
                }
                // select the row in the grid
                if (options.selectRow && this._gridOptions && (this._gridOptions.enableCheckboxSelector || this._gridOptions.enableRowSelection)) {
                    this.setSelectedRow(rowNumber);
                }
                // do we want to trigger an event after updating the item
                if (options.triggerEvent) {
                    this.onItemUpdated.next(item);
                }
            }
            return rowNumber;
        };
        /**
         * Insert a row into the grid if it doesn't already exist or update if it does.
         * @param item object which must contain a unique "id" property and any other suitable properties
         * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, resortGrid, selectRow, triggerEvent)
         */
        GridService.prototype.upsertItem = function (item, options) {
            options = __assign({}, GridServiceInsertOptionDefaults, options);
            var idPropName = this._gridOptions.datasetIdPropertyName || 'id';
            var itemId = (!item || !(idPropName in item)) ? undefined : item[idPropName];
            if (itemId === undefined) {
                throw new Error("Calling Upsert of an item requires the item to include an \"" + idPropName + "\" property");
            }
            return this.upsertItemById(itemId, item, options);
        };
        /**
         * Update an array of existing items with new properties inside the datagrid
         * @param item object arrays, which must contain unique "id" property and any other suitable properties
         * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, resortGrid, selectRow, triggerEvent)
         * @return row numbers in the grid
         */
        GridService.prototype.upsertItems = function (items, options) {
            var _this = this;
            options = __assign({}, GridServiceInsertOptionDefaults, options);
            // when it's not an array, we can call directly the single item update
            if (!Array.isArray(items)) {
                return [this.upsertItem(items, options)];
            }
            this._dataView.beginUpdate();
            var upsertedRows = [];
            items.forEach(function (item) {
                upsertedRows.push(_this.upsertItem(item, __assign({}, options, { highlightRow: false, resortGrid: false, selectRow: false, triggerEvent: false })));
            });
            this._dataView.endUpdate();
            var rowNumbers = upsertedRows.map(function (upsertRow) { return upsertRow.added !== undefined ? upsertRow.added : upsertRow.updated; });
            // only highlight at the end, all at once
            // we have to do this because doing highlight 1 by 1 would only re-select the last highlighted row which is wrong behavior
            if (options.highlightRow) {
                this.highlightRow(rowNumbers);
            }
            // select the row in the grid
            if (options.selectRow && this._gridOptions && (this._gridOptions.enableCheckboxSelector || this._gridOptions.enableRowSelection)) {
                this.setSelectedRows(rowNumbers);
            }
            // do we want to trigger an event after updating the item
            if (options.triggerEvent) {
                this.onItemUpserted.next(items);
                var addedItems = upsertedRows.filter(function (upsertRow) { return upsertRow.added !== undefined; });
                if (Array.isArray(addedItems) && addedItems.length > 0) {
                    this.onItemAdded.next(addedItems);
                }
                var updatedItems = upsertedRows.filter(function (upsertRow) { return upsertRow.updated !== undefined; });
                if (Array.isArray(updatedItems) && updatedItems.length > 0) {
                    this.onItemUpdated.next(updatedItems);
                }
            }
            return upsertedRows;
        };
        /**
         * Update an existing item in the datagrid by it's id and new properties
         * @param itemId: item unique id
         * @param item object which must contain a unique "id" property and any other suitable properties
         * @param options: provide the possibility to do certain actions after or during the upsert (highlightRow, resortGrid, selectRow, triggerEvent)
         * @return grid row number in the grid
         */
        GridService.prototype.upsertItemById = function (itemId, item, options) {
            var isItemAdded = false;
            options = __assign({}, GridServiceInsertOptionDefaults, options);
            if (itemId === undefined) {
                throw new Error("Calling Upsert of an item requires the item to include a valid and unique \"id\" property");
            }
            var rowNumberAdded;
            var rowNumberUpdated;
            if (this._dataView.getRowById(itemId) === undefined) {
                rowNumberAdded = this.addItem(item, options);
                isItemAdded = true;
            }
            else {
                rowNumberUpdated = this.updateItem(item, { highlightRow: options.highlightRow, selectRow: options.selectRow, triggerEvent: options.triggerEvent });
                isItemAdded = false;
            }
            // do we want to trigger an event after updating the item
            if (options.triggerEvent) {
                this.onItemUpserted.next(item);
                isItemAdded ? this.onItemAdded.next(item) : this.onItemUpdated.next(item);
            }
            return { added: rowNumberAdded, updated: rowNumberUpdated };
        };
        GridService.ctorParameters = function () { return [
            { type: ExtensionService },
            { type: FilterService },
            { type: GridStateService },
            { type: SharedService },
            { type: SortService }
        ]; };
        GridService = __decorate([
            core.Injectable()
        ], GridService);
        return GridService;
    }());

    var GridEventService = /** @class */ (function () {
        function GridEventService() {
            this._eventHandler = new Slick.EventHandler();
        }
        Object.defineProperty(GridEventService.prototype, "eventHandler", {
            get: function () {
                return this._eventHandler;
            },
            enumerable: true,
            configurable: true
        });
        GridEventService.prototype.dispose = function () {
            this._eventHandler.unsubscribeAll();
            this.handleOnCellChange = null;
            this.handleOnCellClick = null;
        };
        /* OnCellChange Event */
        GridEventService.prototype.bindOnCellChange = function (grid, dataView) {
            var _this = this;
            // subscribe to this Slickgrid event of onCellChange
            this._eventHandler.subscribe(grid.onCellChange, function (e, args) {
                _this.handleOnCellChange.call(_this, grid, dataView, e, args);
            });
        };
        /* OnClick Event */
        GridEventService.prototype.bindOnClick = function (grid, dataView) {
            var _this = this;
            this._eventHandler.subscribe(grid.onClick, function (e, args) {
                _this.handleOnCellClick.call(_this, grid, dataView, e, args);
            });
        };
        //
        // private functions
        // ------------------
        /* OnCellChange Event Handler */
        GridEventService.prototype.handleOnCellChange = function (grid, dataView, e, args) {
            if (!e || !args || !grid || args.cell === undefined || !grid.getColumns || !grid.getDataItem) {
                return;
            }
            var column = grid.getColumns()[args.cell];
            // if the column definition has a onCellChange property (a callback function), then run it
            if (typeof column.onCellChange === 'function') {
                // add to the output gridOptions & dataView since we'll need them inside the AJAX column.onCellChange
                var returnedArgs = {
                    row: args.row,
                    cell: args.cell,
                    dataView: dataView,
                    grid: grid,
                    columnDef: column,
                    dataContext: grid.getDataItem(args.row)
                };
                // finally call up the Slick.column.onCellChanges.... function
                column.onCellChange(e, returnedArgs);
            }
        };
        /* OnCellClick Event Handler */
        GridEventService.prototype.handleOnCellClick = function (grid, dataView, e, args) {
            if (!e || !args || !grid || args.cell === undefined || !grid.getColumns || !grid.getDataItem) {
                return;
            }
            var column = grid && grid.getColumns && grid.getColumns()[args.cell];
            var gridOptions = grid && grid.getOptions && grid.getOptions() || {};
            // only when using autoCommitEdit, we will make the cell active (in focus) when clicked
            // setting the cell as active as a side effect and if autoCommitEdit is set to false then the Editors won't save correctly
            if (gridOptions.enableCellNavigation && (!gridOptions.editable || (gridOptions.editable && gridOptions.autoCommitEdit))) {
                grid.setActiveCell(args.row, args.cell);
            }
            // if the column definition has a onCellClick property (a callback function), then run it
            if (typeof column.onCellClick === 'function') {
                // add to the output gridOptions & dataView since we'll need them inside the AJAX column.onClick
                var returnedArgs = {
                    row: args.row,
                    cell: args.cell,
                    dataView: dataView,
                    grid: grid,
                    columnDef: column,
                    dataContext: grid.getDataItem(args.row)
                };
                // finally call up the Slick.column.onCellClick.... function
                column.onCellClick(e, returnedArgs);
            }
        };
        return GridEventService;
    }());

    // global constants, height/width are in pixels
    var DATAGRID_MIN_HEIGHT = 180;
    var DATAGRID_MIN_WIDTH = 300;
    var DATAGRID_BOTTOM_PADDING = 20;
    var DATAGRID_FOOTER_HEIGHT = 20;
    var DATAGRID_PAGINATION_HEIGHT = 35;
    var ResizerService = /** @class */ (function () {
        function ResizerService() {
            this._resizePaused = false;
            this.onGridAfterResize = new rxjs.Subject();
            this.onGridBeforeResize = new rxjs.Subject();
        }
        Object.defineProperty(ResizerService.prototype, "_gridOptions", {
            /** Getter for the Grid Options pulled through the Grid Object */
            get: function () {
                return (this._grid && this._grid.getOptions) ? this._grid.getOptions() : {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ResizerService.prototype, "_gridUid", {
            get: function () {
                return (this._grid && this._grid.getUID) ? this._grid.getUID() : this._gridOptions && this._gridOptions.gridId;
            },
            enumerable: true,
            configurable: true
        });
        ResizerService.prototype.init = function (grid, fixedDimensions) {
            if (!grid || !this._gridOptions) {
                throw new Error("\n      Angular-Slickgrid resizer requires a valid Grid object and Grid Options defined.\n      You can fix this by setting your gridOption to use \"enableAutoResize\" or create an instance of the ResizerService by calling bindAutoResizeDataGrid()");
            }
            this._grid = grid;
            var containerNode = grid && grid.getContainerNode && grid.getContainerNode() || '';
            this._gridDomElm = $(containerNode);
            var autoResizeOptions = this._gridOptions && this._gridOptions.autoResize || {};
            this._gridContainerElm = (autoResizeOptions && autoResizeOptions.containerId) ? $("#" + autoResizeOptions.containerId) : $("#" + this._gridOptions.gridContainerId);
            if (fixedDimensions) {
                this._fixedHeight = fixedDimensions.height;
                this._fixedWidth = fixedDimensions.width;
            }
        };
        /** Bind an auto resize trigger on the datagrid, if that is enable then it will resize itself to the available space
         * Options: we could also provide a % factor to resize on each height/width independently
         */
        ResizerService.prototype.bindAutoResizeDataGrid = function (newSizes) {
            // if we can't find the grid to resize, return without binding anything
            if (this._gridDomElm === undefined || this._gridDomElm.offset() === undefined) {
                return null;
            }
            // -- 1st resize the datagrid size at first load (we need this because the .on event is not triggered on first load)
            // -- also we add a slight delay (in ms) so that we resize after the grid render is done
            this.resizeGrid(10, newSizes);
            // -- 2nd bind a trigger on the Window DOM element, so that it happens also when resizing after first load
            // -- bind auto-resize to Window object only if it exist
            $(window).on("resize.grid." + this._gridUid, this.handleResizeGrid.bind(this, newSizes));
        };
        ResizerService.prototype.handleResizeGrid = function (newSizes, event) {
            this.onGridBeforeResize.next(event);
            if (!this._resizePaused) {
                // for some yet unknown reason, calling the resize twice removes any stuttering/flickering
                // when changing the height and makes it much smoother experience
                this.resizeGrid(0, newSizes);
                this.resizeGrid(0, newSizes);
            }
        };
        /**
         * Calculate the datagrid new height/width from the available space, also consider that a % factor might be applied to calculation
         * object gridOptions
         */
        ResizerService.prototype.calculateGridNewDimensions = function (gridOptions) {
            var autoResizeOptions = gridOptions && gridOptions.autoResize || {};
            if (!window || this._gridContainerElm === undefined || this._gridDomElm.offset() === undefined) {
                return null;
            }
            // calculate bottom padding
            // if using pagination, we need to add the pagination height to this bottom padding
            var bottomPadding = (autoResizeOptions && autoResizeOptions.bottomPadding !== undefined) ? autoResizeOptions.bottomPadding : DATAGRID_BOTTOM_PADDING;
            if (bottomPadding && gridOptions.enablePagination) {
                bottomPadding += DATAGRID_PAGINATION_HEIGHT;
            }
            // optionally show a custom footer with the data metrics (dataset length and last updated timestamp)
            if (bottomPadding && gridOptions.showCustomFooter) {
                bottomPadding += gridOptions.customFooterOptions && gridOptions.customFooterOptions.footerHeight || DATAGRID_FOOTER_HEIGHT;
            }
            var gridHeight = 0;
            var gridOffsetTop = 0;
            // which DOM element are we using to calculate the available size for the grid?
            if (autoResizeOptions.calculateAvailableSizeBy === 'container') {
                // uses the container's height to calculate grid height without any top offset
                gridHeight = this._gridContainerElm.height() || 0;
            }
            else {
                // uses the browser's window height with its top offset to calculate grid height
                gridHeight = window.innerHeight || 0;
                var coordOffsetTop = this._gridDomElm.offset();
                gridOffsetTop = (coordOffsetTop !== undefined) ? coordOffsetTop.top : 0;
            }
            var availableHeight = gridHeight - gridOffsetTop - bottomPadding;
            var availableWidth = this._gridContainerElm.width() || window.innerWidth || 0;
            var maxHeight = autoResizeOptions && autoResizeOptions.maxHeight || undefined;
            var minHeight = (autoResizeOptions && autoResizeOptions.minHeight !== undefined) ? autoResizeOptions.minHeight : DATAGRID_MIN_HEIGHT;
            var maxWidth = autoResizeOptions && autoResizeOptions.maxWidth || undefined;
            var minWidth = (autoResizeOptions && autoResizeOptions.minWidth !== undefined) ? autoResizeOptions.minWidth : DATAGRID_MIN_WIDTH;
            var newHeight = availableHeight;
            var newWidth = (autoResizeOptions && autoResizeOptions.sidePadding) ? availableWidth - autoResizeOptions.sidePadding : availableWidth;
            // optionally (when defined), make sure that grid height & width are within their thresholds
            if (newHeight < minHeight) {
                newHeight = minHeight;
            }
            if (maxHeight && newHeight > maxHeight) {
                newHeight = maxHeight;
            }
            if (newWidth < minWidth) {
                newWidth = minWidth;
            }
            if (maxWidth && newWidth > maxWidth) {
                newWidth = maxWidth;
            }
            // return the new dimensions unless a fixed height/width was defined
            return {
                height: this._fixedHeight || newHeight,
                width: this._fixedWidth || newWidth
            };
        };
        /**
         * Dispose function when element is destroyed
         */
        ResizerService.prototype.dispose = function () {
            $(window).off("resize.grid." + this._gridUid);
        };
        /**
         * Return the last resize dimensions used by the service
         * @return last dimensions
         */
        ResizerService.prototype.getLastResizeDimensions = function () {
            return this._lastDimensions;
        };
        /** Provide the possibility to pause the resizer for some time, until user decides to re-enabled it later if he wish to. */
        ResizerService.prototype.pauseResizer = function (isResizePaused) {
            this._resizePaused = isResizePaused;
        };
        /** Resize the datagrid to fit the browser height & width */
        ResizerService.prototype.resizeGrid = function (delay, newSizes) {
            var _this = this;
            if (delay === void 0) { delay = 10; }
            return new Promise(function (resolve) {
                // because of the javascript async nature, we might want to delay the resize a little bit
                delay = delay || 0;
                if (delay > 0) {
                    clearTimeout(_this._timer);
                    _this._timer = setTimeout(function () { return resolve(_this.resizeGridCallback(newSizes)); }, delay);
                }
                else {
                    resolve(_this.resizeGridCallback(newSizes));
                }
            });
        };
        ResizerService.prototype.resizeGridCallback = function (newSizes) {
            var lastDimensions = this.resizeGridWithDimensions(newSizes);
            this.onGridAfterResize.next(lastDimensions);
            return lastDimensions;
        };
        ResizerService.prototype.resizeGridWithDimensions = function (newSizes) {
            // calculate the available sizes with minimum height defined as a constant
            var availableDimensions = this.calculateGridNewDimensions(this._gridOptions);
            var gridContainerElm = $("#" + this._gridOptions.gridContainerId) || {};
            if ((newSizes || availableDimensions) && this._gridDomElm.length > 0) {
                // get the new sizes, if new sizes are passed (not 0), we will use them else use available space
                // basically if user passes 1 of the dimension, let say he passes just the height,
                // we will use the height as a fixed height but the width will be resized by it's available space
                var newHeight = (newSizes && newSizes.height) ? newSizes.height : availableDimensions.height;
                var newWidth = (newSizes && newSizes.width) ? newSizes.width : availableDimensions.width;
                // apply these new height/width to the datagrid
                if (!this._gridOptions.autoHeight) {
                    this._gridDomElm.height(newHeight);
                    gridContainerElm.height(newHeight);
                }
                this._gridDomElm.width(newWidth);
                gridContainerElm.width(newWidth);
                // resize the slickgrid canvas on all browser except some IE versions
                // exclude all IE below IE11
                // IE11 wants to be a better standard (W3C) follower (finally) they even changed their appName output to also have 'Netscape'
                if (new RegExp('MSIE [6-8]').exec(navigator.userAgent) === null && this._grid && this._grid.resizeCanvas) {
                    this._grid.resizeCanvas();
                }
                // also call the grid auto-size columns so that it takes available space when going bigger
                if (this._gridOptions && this._gridOptions.enableAutoSizeColumns && this._grid.autosizeColumns) {
                    // make sure that the grid still exist (by looking if the Grid UID is found in the DOM tree) to avoid SlickGrid error "missing stylesheet"
                    if (this._gridUid && $("." + this._gridUid).length > 0) {
                        this._grid.autosizeColumns();
                    }
                }
                // keep last resized dimensions & resolve them to the Promise
                this._lastDimensions = {
                    height: newHeight,
                    width: newWidth
                };
                if ((this._gridOptions.enablePagination || this._gridOptions.backendServiceApi)) {
                    this._lastDimensions.heightWithPagination = newHeight + DATAGRID_PAGINATION_HEIGHT;
                }
            }
            return this._lastDimensions;
        };
        return ResizerService;
    }());

    var GroupingAndColspanService = /** @class */ (function () {
        function GroupingAndColspanService(extensionUtility, extensionService, resizerService, sharedService) {
            this.extensionUtility = extensionUtility;
            this.extensionService = extensionService;
            this.resizerService = resizerService;
            this.sharedService = sharedService;
            this.subscriptions = [];
            this._eventHandler = new Slick.EventHandler();
        }
        Object.defineProperty(GroupingAndColspanService.prototype, "eventHandler", {
            /** Getter of the SlickGrid Event Handler */
            get: function () {
                return this._eventHandler;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GroupingAndColspanService.prototype, "_gridOptions", {
            /** Getter for the Grid Options pulled through the Grid Object */
            get: function () {
                return (this._grid && this._grid.getOptions) ? this._grid.getOptions() : {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GroupingAndColspanService.prototype, "_columnDefinitions", {
            /** Getter for the Column Definitions pulled through the Grid Object */
            get: function () {
                return (this._grid && this._grid.getColumns) ? this._grid.getColumns() : [];
            },
            enumerable: true,
            configurable: true
        });
        GroupingAndColspanService.prototype.init = function (grid, dataView) {
            var _this = this;
            this._grid = grid;
            if (grid && this._gridOptions) {
                // When dealing with Pre-Header Grouping colspan, we need to re-create the pre-header in multiple occasions
                // for all these events, we have to trigger a re-create
                if (this._gridOptions.createPreHeaderPanel) {
                    // on all following events, call the
                    this._eventHandler.subscribe(grid.onSort, function () { return _this.renderPreHeaderRowGroupingTitles(); });
                    this._eventHandler.subscribe(grid.onColumnsResized, function () { return _this.renderPreHeaderRowGroupingTitles(); });
                    this._eventHandler.subscribe(grid.onColumnsReordered, function () { return _this.renderPreHeaderRowGroupingTitles(); });
                    this._eventHandler.subscribe(dataView.onRowCountChanged, function () { return _this.renderPreHeaderRowGroupingTitles(); });
                    this.subscriptions.push(this.resizerService.onGridAfterResize.subscribe(function () { return _this.renderPreHeaderRowGroupingTitles(); }), this.sharedService.onHeaderMenuHideColumns.subscribe(function () { return _this.delayRenderPreHeaderRowGroupingTitles(0); }));
                    this._eventHandler.subscribe(grid.onSetOptions, function (_e, args) {
                        // when user changes frozen columns dynamically (e.g. from header menu), we need to re-render the pre-header of the grouping titles
                        if (args && args.optionsBefore && args.optionsAfter && args.optionsBefore.frozenColumn !== args.optionsAfter.frozenColumn) {
                            _this.delayRenderPreHeaderRowGroupingTitles(0);
                        }
                    });
                    // for both picker (columnPicker/gridMenu) we also need to re-create after hiding/showing columns
                    var columnPickerExtension = this.extensionService.getExtensionByName(exports.ExtensionName.columnPicker);
                    if (columnPickerExtension && columnPickerExtension.instance && columnPickerExtension.instance.onColumnsChanged) {
                        this._eventHandler.subscribe(columnPickerExtension.instance.onColumnsChanged, function () { return _this.renderPreHeaderRowGroupingTitles(); });
                    }
                    var gridMenuExtension = this.extensionService.getExtensionByName(exports.ExtensionName.gridMenu);
                    if (gridMenuExtension && gridMenuExtension.instance && gridMenuExtension.instance.onColumnsChanged && gridMenuExtension.instance.onMenuClose) {
                        this._eventHandler.subscribe(gridMenuExtension.instance.onColumnsChanged, function () { return _this.renderPreHeaderRowGroupingTitles(); });
                        this._eventHandler.subscribe(gridMenuExtension.instance.onMenuClose, function () { return _this.renderPreHeaderRowGroupingTitles(); });
                    }
                    // also not sure why at this point, but it seems that I need to call the 1st create in a delayed execution
                    // probably some kind of timing issues and delaying it until the grid is fully ready fixes this problem
                    this.delayRenderPreHeaderRowGroupingTitles(50);
                }
            }
        };
        GroupingAndColspanService.prototype.dispose = function () {
            // unsubscribe all SlickGrid events
            this._eventHandler.unsubscribeAll();
            // also unsubscribe all Angular Subscriptions
            this.subscriptions = unsubscribeAllObservables(this.subscriptions);
        };
        /** call "renderPreHeaderRowGroupingTitles()" with a setTimeout delay */
        GroupingAndColspanService.prototype.delayRenderPreHeaderRowGroupingTitles = function (delay) {
            var _this = this;
            if (delay === void 0) { delay = 0; }
            setTimeout(function () { return _this.renderPreHeaderRowGroupingTitles(); }, delay);
        };
        /** Create or Render the Pre-Header Row Grouping Titles */
        GroupingAndColspanService.prototype.renderPreHeaderRowGroupingTitles = function () {
            if (this._gridOptions && this._gridOptions.frozenColumn !== undefined && this._gridOptions.frozenColumn >= 0) {
                // Add column groups to left panel
                var $preHeaderPanel = $(this._grid.getPreHeaderPanelLeft());
                this.renderHeaderGroups($preHeaderPanel, 0, this._gridOptions.frozenColumn + 1);
                // Add column groups to right panel
                $preHeaderPanel = $(this._grid.getPreHeaderPanelRight());
                this.renderHeaderGroups($preHeaderPanel, this._gridOptions.frozenColumn + 1, this._columnDefinitions.length);
            }
            else {
                // regular grid (not a frozen grid)
                var $preHeaderPanel = $(this._grid.getPreHeaderPanel());
                this.renderHeaderGroups($preHeaderPanel, 0, this._columnDefinitions.length);
            }
        };
        GroupingAndColspanService.prototype.renderHeaderGroups = function (preHeaderPanel, start, end) {
            preHeaderPanel.empty()
                .addClass('slick-header-columns')
                .css('left', '-1000px')
                .width(this._grid.getHeadersWidth());
            preHeaderPanel.parent().addClass('slick-header');
            var headerColumnWidthDiff = this._grid.getHeaderColumnWidthDiff();
            var colDef;
            var header;
            var lastColumnGroup = '';
            var widthTotal = 0;
            var frozenHeaderWidthCalcDifferential = this._gridOptions && this._gridOptions.frozenHeaderWidthCalcDifferential || 0;
            var isFrozenGrid = (this._gridOptions && (this._gridOptions.frozenColumn !== undefined && this._gridOptions.frozenColumn >= 0));
            for (var i = start; i < end; i++) {
                colDef = this._columnDefinitions[i];
                if (colDef) {
                    if (lastColumnGroup === colDef.columnGroup && i > 0) {
                        widthTotal += colDef.width || 0;
                        if (header && header.width) {
                            header.width(widthTotal - headerColumnWidthDiff - frozenHeaderWidthCalcDifferential); // remove possible frozen border
                        }
                    }
                    else {
                        widthTotal = colDef.width || 0;
                        header = $("<div class=\"ui-state-default slick-header-column " + (isFrozenGrid ? 'frozen' : '') + "\" />")
                            .html("<span class=\"slick-column-name\">" + (colDef.columnGroup || '') + "</span>")
                            .width(widthTotal - headerColumnWidthDiff)
                            .appendTo(preHeaderPanel);
                    }
                    lastColumnGroup = colDef.columnGroup || '';
                }
            }
        };
        /** Translate Column Group texts and re-render them afterward. */
        GroupingAndColspanService.prototype.translateGroupingAndColSpan = function () {
            var currentColumnDefinitions = this._grid.getColumns();
            this.extensionUtility.translateItems(currentColumnDefinitions, 'columnGroupKey', 'columnGroup');
            this._grid.setColumns(currentColumnDefinitions);
            this.renderPreHeaderRowGroupingTitles();
        };
        GroupingAndColspanService.ctorParameters = function () { return [
            { type: ExtensionUtility },
            { type: ExtensionService },
            { type: ResizerService },
            { type: SharedService }
        ]; };
        GroupingAndColspanService = __decorate([
            core.Injectable()
        ], GroupingAndColspanService);
        return GroupingAndColspanService;
    }());

    var isequal$2 = isequal_; // patch to fix rollup to work
    var PaginationService = /** @class */ (function () {
        /** Constructor */
        function PaginationService(filterService, gridService, sharedService) {
            this.filterService = filterService;
            this.gridService = gridService;
            this.sharedService = sharedService;
            this._initialized = false;
            this._isLocalGrid = true;
            this._dataFrom = 1;
            this._dataTo = 1;
            this._pageCount = 1;
            this._pageNumber = 1;
            this._totalItems = 0;
            this._eventHandler = new Slick.EventHandler();
            this._subscriptions = [];
            this.onPaginationChanged = new rxjs.Subject();
            this.onPaginationVisibilityChanged = new rxjs.Subject();
        }
        Object.defineProperty(PaginationService.prototype, "paginationOptions", {
            get: function () {
                return this._paginationOptions;
            },
            set: function (paginationOptions) {
                this._paginationOptions = paginationOptions;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PaginationService.prototype, "availablePageSizes", {
            get: function () {
                return this._availablePageSizes;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PaginationService.prototype, "dataFrom", {
            get: function () {
                return this._dataFrom;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PaginationService.prototype, "dataTo", {
            get: function () {
                return this._dataTo;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PaginationService.prototype, "itemsPerPage", {
            get: function () {
                return this._itemsPerPage;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PaginationService.prototype, "pageCount", {
            get: function () {
                return this._pageCount;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PaginationService.prototype, "pageNumber", {
            get: function () {
                return this._pageNumber;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PaginationService.prototype, "totalItems", {
            get: function () {
                return this._totalItems;
            },
            set: function (totalItems) {
                this._totalItems = totalItems;
                if (this._initialized) {
                    this.refreshPagination();
                }
            },
            enumerable: true,
            configurable: true
        });
        PaginationService.prototype.init = function (grid, dataView, paginationOptions, backendServiceApi) {
            var _this = this;
            this._availablePageSizes = paginationOptions.pageSizes;
            this.dataView = dataView;
            this.grid = grid;
            this._backendServiceApi = backendServiceApi;
            this._paginationOptions = paginationOptions;
            this._isLocalGrid = !backendServiceApi;
            this._pageNumber = paginationOptions.pageNumber || 1;
            if (backendServiceApi && (!backendServiceApi.service || !backendServiceApi.process)) {
                throw new Error("BackendServiceApi requires the following 2 properties \"process\" and \"service\" to be defined.");
            }
            if (this._isLocalGrid && this.dataView) {
                this._eventHandler.subscribe(this.dataView.onPagingInfoChanged, function (e, pagingInfo) {
                    if (_this._totalItems !== pagingInfo.totalRows) {
                        _this.updateTotalItems(pagingInfo.totalRows);
                    }
                });
                dataView.setRefreshHints({ isFilterUnchanged: true });
                dataView.setPagingOptions({ pageSize: this.paginationOptions.pageSize, pageNum: (this._pageNumber - 1) }); // dataView page starts at 0 instead of 1
            }
            // Subscribe to Filter Clear & Changed and go back to page 1 when that happen
            this._subscriptions.push(this.filterService.onFilterChanged.subscribe(function () { return _this.resetPagination(); }));
            this._subscriptions.push(this.filterService.onFilterCleared.subscribe(function () { return _this.resetPagination(); }));
            // Subscribe to any dataview row count changed so that when Adding/Deleting item(s) through the DataView
            // that would trigger a refresh of the pagination numbers
            if (this.dataView) {
                this._subscriptions.push(this.gridService.onItemAdded.subscribe(function (items) { return _this.processOnItemAddedOrRemoved(items, true); }));
                this._subscriptions.push(this.gridService.onItemDeleted.subscribe(function (items) { return _this.processOnItemAddedOrRemoved(items, false); }));
            }
            this.refreshPagination(false, false);
            this._initialized = true;
        };
        PaginationService.prototype.dispose = function () {
            this._initialized = false;
            // unsubscribe all SlickGrid events
            this._eventHandler.unsubscribeAll();
            // also unsubscribe all Angular Subscriptions
            this._subscriptions = unsubscribeAllObservables(this._subscriptions);
        };
        PaginationService.prototype.getCurrentPageNumber = function () {
            return this._pageNumber;
        };
        PaginationService.prototype.getCurrentPagination = function () {
            return {
                pageNumber: this._pageNumber,
                pageSize: this._itemsPerPage,
                pageSizes: this._availablePageSizes,
            };
        };
        PaginationService.prototype.getFullPagination = function () {
            return {
                pageCount: this._pageCount,
                pageNumber: this._pageNumber,
                pageSize: this._itemsPerPage,
                pageSizes: this._availablePageSizes,
                totalItems: this._totalItems,
                dataFrom: this._dataFrom,
                dataTo: this._dataTo,
            };
        };
        PaginationService.prototype.getCurrentItemPerPage = function () {
            return this._itemsPerPage;
        };
        PaginationService.prototype.changeItemPerPage = function (itemsPerPage, event) {
            this._pageNumber = 1;
            this._pageCount = Math.ceil(this._totalItems / itemsPerPage);
            this._itemsPerPage = itemsPerPage;
            return this.processOnPageChanged(this._pageNumber, event);
        };
        PaginationService.prototype.goToFirstPage = function (event) {
            this._pageNumber = 1;
            return this.processOnPageChanged(this._pageNumber, event);
        };
        PaginationService.prototype.goToLastPage = function (event) {
            this._pageNumber = this._pageCount || 1;
            return this.processOnPageChanged(this._pageNumber, event);
        };
        PaginationService.prototype.goToNextPage = function (event) {
            if (this._pageNumber < this._pageCount) {
                this._pageNumber++;
                return this.processOnPageChanged(this._pageNumber, event);
            }
            else {
                return new Promise(function (resolve) { return resolve(false); });
            }
        };
        PaginationService.prototype.goToPageNumber = function (pageNumber, event) {
            var previousPageNumber = this._pageNumber;
            if (pageNumber < 1) {
                this._pageNumber = 1;
            }
            else if (pageNumber > this._pageCount) {
                this._pageNumber = this._pageCount;
            }
            else {
                this._pageNumber = pageNumber;
            }
            if (this._pageNumber !== previousPageNumber) {
                return this.processOnPageChanged(this._pageNumber, event);
            }
            else {
                return new Promise(function (resolve) { return resolve(false); });
            }
        };
        PaginationService.prototype.goToPreviousPage = function (event) {
            if (this._pageNumber > 1) {
                this._pageNumber--;
                return this.processOnPageChanged(this._pageNumber, event);
            }
            else {
                return new Promise(function (resolve) { return resolve(false); });
            }
        };
        PaginationService.prototype.refreshPagination = function (isPageNumberReset, triggerChangedEvent) {
            if (isPageNumberReset === void 0) { isPageNumberReset = false; }
            if (triggerChangedEvent === void 0) { triggerChangedEvent = true; }
            var previousPagination = __assign({}, this.getCurrentPagination());
            if (this._paginationOptions) {
                var pagination = this._paginationOptions;
                // set the number of items per page if not already set
                if (!this._itemsPerPage) {
                    if (this._isLocalGrid) {
                        this._itemsPerPage = pagination.pageSize;
                    }
                    else {
                        this._itemsPerPage = +((this._backendServiceApi && this._backendServiceApi.options && this._backendServiceApi.options.paginationOptions && this._backendServiceApi.options.paginationOptions.first) ? this._backendServiceApi.options.paginationOptions.first : pagination.pageSize);
                    }
                }
                // if totalItems changed, we should always go back to the first page and recalculation the From-To indexes
                if (isPageNumberReset || this._totalItems !== pagination.totalItems) {
                    if (isPageNumberReset) {
                        this._pageNumber = 1;
                        this.paginationOptions.pageNumber = 1;
                    }
                    else if (!this._initialized && pagination.pageNumber && pagination.pageNumber > 1) {
                        this._pageNumber = pagination.pageNumber || 1;
                    }
                    // when page number is set to 1 then also reset the "offset" of backend service
                    if (this._pageNumber === 1 && this._backendServiceApi) {
                        this._backendServiceApi.service.resetPaginationOptions();
                    }
                }
                // calculate and refresh the multiple properties of the pagination UI
                this._availablePageSizes = pagination.pageSizes;
                if (!this._totalItems && pagination.totalItems) {
                    this._totalItems = pagination.totalItems;
                }
                this.recalculateFromToIndexes();
            }
            this._pageCount = Math.ceil(this._totalItems / this._itemsPerPage);
            var currentPagination = this.getCurrentPagination();
            this.sharedService.currentPagination = currentPagination;
            if (triggerChangedEvent && !isequal$2(previousPagination, currentPagination)) {
                this.onPaginationChanged.next(currentPagination);
            }
        };
        PaginationService.prototype.processOnPageChanged = function (pageNumber, event) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.recalculateFromToIndexes();
                if (_this._isLocalGrid && _this.dataView) {
                    _this.dataView.setPagingOptions({ pageSize: _this._itemsPerPage, pageNum: (pageNumber - 1) }); // dataView page starts at 0 instead of 1
                    _this.onPaginationChanged.next(_this.getFullPagination());
                }
                else {
                    var itemsPerPage = +_this._itemsPerPage;
                    // keep start time & end timestamps & return it after process execution
                    var startTime_1 = new Date();
                    // run any pre-process, if defined, for example a spinner
                    if (_this._backendServiceApi.preProcess) {
                        _this._backendServiceApi.preProcess();
                    }
                    var query = _this._backendServiceApi.service.processOnPaginationChanged(event, { newPage: pageNumber, pageSize: itemsPerPage });
                    // the processes can be Promises or an Observables (like HttpClient)
                    var process_1 = _this._backendServiceApi.process(query);
                    if (process_1 instanceof Promise) {
                        process_1
                            .then(function (processResult) {
                            resolve(executeBackendProcessesCallback(startTime_1, processResult, _this._backendServiceApi, _this._totalItems));
                        })
                            .catch(function (error) {
                            onBackendError(error, _this._backendServiceApi);
                            reject(process_1);
                        });
                    }
                    else if (rxjs.isObservable(process_1)) {
                        _this._subscriptions.push(process_1.subscribe(function (processResult) {
                            resolve(executeBackendProcessesCallback(startTime_1, processResult, _this._backendServiceApi, _this._totalItems));
                        }, function (error) {
                            onBackendError(error, _this._backendServiceApi);
                            reject(process_1);
                        }));
                    }
                    _this.onPaginationChanged.next(_this.getFullPagination());
                }
            });
        };
        PaginationService.prototype.recalculateFromToIndexes = function () {
            if (this._totalItems === 0) {
                this._dataFrom = 0;
                this._dataTo = 1;
                this._pageNumber = 0;
            }
            else {
                this._dataFrom = this._pageNumber > 1 ? ((this._pageNumber * this._itemsPerPage) - this._itemsPerPage + 1) : 1;
                this._dataTo = (this._totalItems < this._itemsPerPage) ? this._totalItems : ((this._pageNumber || 1) * this._itemsPerPage);
                if (this._dataTo > this._totalItems) {
                    this._dataTo = this._totalItems;
                }
            }
            this._pageNumber = (this._totalItems > 0 && this._pageNumber === 0) ? 1 : this._pageNumber;
            // do a final check on the From/To and make sure they are not over or below min/max acceptable values
            if (this._dataTo > this._totalItems) {
                this._dataTo = this._totalItems;
            }
            else if (this._totalItems < this._itemsPerPage) {
                this._dataTo = this._totalItems;
            }
        };
        /** Reset the Pagination to first page and recalculate necessary numbers */
        PaginationService.prototype.resetPagination = function (triggerChangedEvent) {
            if (triggerChangedEvent === void 0) { triggerChangedEvent = true; }
            if (this._isLocalGrid) {
                // on a local grid we also need to reset the DataView paging to 1st page
                this.dataView.setPagingOptions({ pageSize: this._itemsPerPage, pageNum: 0 });
            }
            this.refreshPagination(true, triggerChangedEvent);
        };
        /**
         * Toggle the Pagination (show/hide), it will use the visible if defined else it will automatically inverse when called without argument
         *
         * IMPORTANT NOTE:
         * The Pagination must be created on initial page load, then only after can you toggle it.
         * Basically this method WILL NOT WORK to show the Pagination if it was not there from the start.
         */
        PaginationService.prototype.togglePaginationVisibility = function (visible) {
            if (this.grid && this.sharedService && this.sharedService.gridOptions) {
                var isVisible = visible !== undefined ? visible : !this.sharedService.gridOptions.enablePagination;
                this.sharedService.gridOptions.enablePagination = isVisible;
                this.onPaginationVisibilityChanged.next({ visible: isVisible });
                // make sure to reset the Pagination and go back to first page to avoid any issues with Pagination being offset
                if (isVisible) {
                    this.goToFirstPage();
                }
                // when using a local grid, we can reset the DataView pagination by changing its page size
                // page size of 0 would show all, hence cancel the pagination
                if (this._isLocalGrid) {
                    var pageSize = visible ? this._itemsPerPage : 0;
                    this.dataView.setPagingOptions({ pageSize: pageSize, pageNum: 0 });
                }
            }
        };
        // --
        // private functions
        // --------------------
        PaginationService.prototype.updateTotalItems = function (totalItems, triggerChangedEvent) {
            if (triggerChangedEvent === void 0) { triggerChangedEvent = false; }
            this._totalItems = totalItems;
            if (this._paginationOptions) {
                this._paginationOptions.totalItems = totalItems;
                this.refreshPagination(false, triggerChangedEvent);
            }
        };
        /**
         * When item is added or removed, we will refresh the numbers on the pagination however we won't trigger a backend change
         * This will have a side effect though, which is that the "To" count won't be matching the "items per page" count,
         * that is a necessary side effect to avoid triggering a backend query just to refresh the paging,
         * basically we assume that this offset is fine for the time being,
         * until user does an action which will refresh the data hence the pagination which will then become normal again
         */
        PaginationService.prototype.processOnItemAddedOrRemoved = function (items, isItemAdded) {
            if (isItemAdded === void 0) { isItemAdded = true; }
            if (items !== null) {
                var previousDataTo = this._dataTo;
                var itemCount = Array.isArray(items) ? items.length : 1;
                var itemCountWithDirection = isItemAdded ? +itemCount : -itemCount;
                // refresh the total count in the pagination and in the UI
                this._totalItems += itemCountWithDirection;
                this.recalculateFromToIndexes();
                // finally refresh the "To" count and we know it might be different than the "items per page" count
                // but this is necessary since we don't want an actual backend refresh
                this._dataTo = previousDataTo + itemCountWithDirection;
                this.onPaginationChanged.next(this.getFullPagination());
            }
        };
        PaginationService.ctorParameters = function () { return [
            { type: FilterService },
            { type: GridService },
            { type: SharedService }
        ]; };
        PaginationService = __decorate([
            core.Injectable()
        ], PaginationService);
        return PaginationService;
    }());

    var AvgAggregator = /** @class */ (function () {
        function AvgAggregator(field) {
            this._count = 0;
            this._field = field;
        }
        AvgAggregator.prototype.init = function () {
            this._count = 0;
            this._nonNullCount = 0;
            this._sum = 0;
        };
        AvgAggregator.prototype.accumulate = function (item) {
            var val = (item && item.hasOwnProperty(this._field)) ? item[this._field] : null;
            this._count++;
            if (val !== null && val !== undefined && val !== '' && !isNaN(val)) {
                this._nonNullCount++;
                this._sum += parseFloat(val);
            }
        };
        AvgAggregator.prototype.storeResult = function (groupTotals) {
            if (!groupTotals || groupTotals.avg === undefined) {
                groupTotals.avg = {};
            }
            if (this._nonNullCount !== 0) {
                groupTotals.avg[this._field] = this._sum / this._nonNullCount;
            }
        };
        return AvgAggregator;
    }());

    var MinAggregator = /** @class */ (function () {
        function MinAggregator(field) {
            this._field = field;
        }
        MinAggregator.prototype.init = function () {
            this._min = null;
        };
        MinAggregator.prototype.accumulate = function (item) {
            var val = (item && item.hasOwnProperty(this._field)) ? item[this._field] : null;
            if (val !== null && val !== undefined && val !== '' && !isNaN(val)) {
                if (this._min === null || this._min === undefined || val < this._min) {
                    this._min = parseFloat(val);
                }
            }
        };
        MinAggregator.prototype.storeResult = function (groupTotals) {
            if (!groupTotals || groupTotals.min === undefined) {
                groupTotals.min = {};
            }
            groupTotals.min[this._field] = this._min;
        };
        return MinAggregator;
    }());

    var MaxAggregator = /** @class */ (function () {
        function MaxAggregator(field) {
            this._field = field;
        }
        MaxAggregator.prototype.init = function () {
            this._max = null;
        };
        MaxAggregator.prototype.accumulate = function (item) {
            var val = (item && item.hasOwnProperty(this._field)) ? item[this._field] : null;
            if (val !== null && val !== undefined && val !== '' && !isNaN(val)) {
                if (this._max === null || this._max === undefined || val > this._max) {
                    this._max = parseFloat(val);
                }
            }
        };
        MaxAggregator.prototype.storeResult = function (groupTotals) {
            if (!groupTotals || groupTotals.max === undefined) {
                groupTotals.max = {};
            }
            groupTotals.max[this._field] = this._max;
        };
        return MaxAggregator;
    }());

    var SumAggregator = /** @class */ (function () {
        function SumAggregator(field) {
            this._sum = 0;
            this._field = field;
        }
        SumAggregator.prototype.init = function () {
            this._sum = 0;
        };
        SumAggregator.prototype.accumulate = function (item) {
            var val = (item && item.hasOwnProperty(this._field)) ? item[this._field] : null;
            if (val !== null && val !== undefined && val !== '' && !isNaN(val)) {
                this._sum += parseFloat(val);
            }
        };
        SumAggregator.prototype.storeResult = function (groupTotals) {
            if (!groupTotals || groupTotals.sum === undefined) {
                groupTotals.sum = {};
            }
            groupTotals.sum[this._field] = this._sum;
        };
        return SumAggregator;
    }());

    /** Provides a list of different Aggregators for the Group Formatter */
    var Aggregators = {
        Avg: AvgAggregator,
        Min: MinAggregator,
        Max: MaxAggregator,
        Sum: SumAggregator
    };

    function textValidator(inputValue, options) {
        var errorMsg = options.errorMessage;
        var isRequired = options.required;
        var minLength = options.minLength;
        var maxLength = options.maxLength;
        var operatorConditionalType = options.operatorConditionalType || 'inclusive';
        var mapValidation = {
            '{{minLength}}': minLength,
            '{{maxLength}}': maxLength
        };
        var isValid = true;
        var outputMsg = '';
        var inputValueLength = inputValue && inputValue.length || 0;
        if (options.validator) {
            return options.validator(inputValue, options.editorArgs);
        }
        // by default the editor is almost always valid (except when it's required but not provided)
        if (isRequired && inputValue === '') {
            isValid = false;
            outputMsg = errorMsg || Constants.VALIDATION_REQUIRED_FIELD;
        }
        else if (minLength !== undefined && maxLength !== undefined && ((operatorConditionalType === 'exclusive' && (inputValueLength <= minLength || inputValueLength >= maxLength)) || (operatorConditionalType === 'inclusive' && (inputValueLength < minLength || inputValueLength > maxLength)))) {
            // MIN & MAX Length provided
            // make sure text length is between minLength and maxLength
            isValid = false;
            outputMsg = errorMsg || Constants.VALIDATION_EDITOR_TEXT_LENGTH_BETWEEN.replace(/{{minLength}}|{{maxLength}}/gi, function (matched) { return mapValidation[matched]; });
        }
        else if (minLength !== undefined && inputValueLength !== null && ((operatorConditionalType === 'exclusive' && inputValueLength <= minLength) || (operatorConditionalType === 'inclusive' && inputValueLength !== null && inputValueLength < minLength))) {
            // MIN Length ONLY
            // when text length is shorter than minLength
            isValid = false;
            var defaultErrorMsg = operatorConditionalType === 'inclusive' ? Constants.VALIDATION_EDITOR_TEXT_MIN_LENGTH_INCLUSIVE : Constants.VALIDATION_EDITOR_TEXT_MIN_LENGTH;
            outputMsg = errorMsg || defaultErrorMsg.replace(/{{minLength}}/gi, function (matched) { return mapValidation[matched]; });
        }
        else if (maxLength !== undefined && inputValueLength !== null && ((operatorConditionalType === 'exclusive' && inputValueLength >= maxLength) || (operatorConditionalType === 'inclusive' && inputValueLength !== null && inputValueLength > maxLength))) {
            // MAX Length ONLY
            // when text length is longer than minLength
            isValid = false;
            var defaultErrorMsg = operatorConditionalType === 'inclusive' ? Constants.VALIDATION_EDITOR_TEXT_MAX_LENGTH_INCLUSIVE : Constants.VALIDATION_EDITOR_TEXT_MAX_LENGTH;
            outputMsg = errorMsg || defaultErrorMsg.replace(/{{maxLength}}/gi, function (matched) { return mapValidation[matched]; });
        }
        return { valid: isValid, msg: outputMsg };
    }

    var DOMPurify$3 = DOMPurify_; // patch to fix rollup to work
    // minimum length of chars to type before starting to start querying
    var MIN_LENGTH = 3;
    /*
     * An example of a 'detached' editor.
     * KeyDown events are also handled to provide handling for Tab, Shift-Tab, Esc and Ctrl-Enter.
     */
    var AutoCompleteEditor = /** @class */ (function () {
        function AutoCompleteEditor(args) {
            this.args = args;
            if (!args) {
                throw new Error('[Angular-SlickGrid] Something is wrong with this grid, an Editor must always have valid arguments.');
            }
            this.grid = args.grid;
            this.init();
        }
        Object.defineProperty(AutoCompleteEditor.prototype, "autoCompleteOptions", {
            /** Getter for the Autocomplete Option */
            get: function () {
                return this._autoCompleteOptions || {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AutoCompleteEditor.prototype, "editorCollection", {
            /** Get the Collection */
            get: function () {
                return this.columnDef && this.columnDef.internalColumnEditor && this.columnDef.internalColumnEditor.collection || [];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AutoCompleteEditor.prototype, "elementCollection", {
            /** Get the Final Collection used in the AutoCompleted Source (this may vary from the "collection" especially when providing a customStructure) */
            get: function () {
                return this._elementCollection;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AutoCompleteEditor.prototype, "columnDef", {
            /** Get Column Definition object */
            get: function () {
                return this.args && this.args.column;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AutoCompleteEditor.prototype, "columnEditor", {
            /** Get Column Editor object */
            get: function () {
                return this.columnDef && this.columnDef.internalColumnEditor || {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AutoCompleteEditor.prototype, "customStructure", {
            /** Getter for the Custom Structure if exist */
            get: function () {
                var customStructure = this.columnEditor && this.columnEditor.customStructure;
                var columnType = this.columnEditor && this.columnEditor.type || this.columnDef && this.columnDef.type;
                if (!customStructure && (columnType === exports.FieldType.object && this.columnDef && this.columnDef.dataKey && this.columnDef.labelKey)) {
                    customStructure = {
                        label: this.columnDef.labelKey,
                        value: this.columnDef.dataKey,
                    };
                }
                return customStructure;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AutoCompleteEditor.prototype, "hasAutoCommitEdit", {
            get: function () {
                return this.gridOptions.autoCommitEdit;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AutoCompleteEditor.prototype, "validator", {
            /** Get the Validator function, can be passed in Editor property or Column Definition */
            get: function () {
                return this.columnEditor.validator || this.columnDef.validator;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AutoCompleteEditor.prototype, "editorOptions", {
            get: function () {
                return this.columnEditor && this.columnEditor.editorOptions || {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AutoCompleteEditor.prototype, "instance", {
            /** jQuery UI AutoComplete instance */
            get: function () {
                return this._$editorElm.autocomplete('instance');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AutoCompleteEditor.prototype, "gridOptions", {
            /** Getter for the Grid Options pulled through the Grid Object */
            get: function () {
                return (this.grid && this.grid.getOptions) ? this.grid.getOptions() : {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AutoCompleteEditor.prototype, "editorDomElement", {
            /** Get the Editor DOM Element */
            get: function () {
                return this._$editorElm;
            },
            enumerable: true,
            configurable: true
        });
        AutoCompleteEditor.prototype.init = function () {
            this.labelName = this.customStructure && this.customStructure.label || 'label';
            this.valueName = this.customStructure && this.customStructure.value || 'value';
            this.labelPrefixName = this.customStructure && this.customStructure.labelPrefix || 'labelPrefix';
            this.labelSuffixName = this.customStructure && this.customStructure.labelSuffix || 'labelSuffix';
            // always render the DOM element, even if user passed a "collectionAsync",
            var newCollection = this.columnEditor.collection || [];
            this.renderDomElement(newCollection);
        };
        AutoCompleteEditor.prototype.destroy = function () {
            if (this._$editorElm) {
                this._$editorElm.autocomplete('destroy');
                this._$editorElm.off('keydown.nav').remove();
            }
            this._$editorElm = null;
            this._elementCollection = null;
        };
        AutoCompleteEditor.prototype.focus = function () {
            if (this._$editorElm) {
                this._$editorElm.focus().select();
            }
        };
        AutoCompleteEditor.prototype.getValue = function () {
            return this._$editorElm.val();
        };
        AutoCompleteEditor.prototype.setValue = function (value) {
            this._$editorElm.val(value);
        };
        AutoCompleteEditor.prototype.applyValue = function (item, state) {
            var _this = this;
            var newValue = state;
            var fieldName = this.columnDef && this.columnDef.field;
            // if we have a collection defined, we will try to find the string within the collection and return it
            if (Array.isArray(this.editorCollection) && this.editorCollection.length > 0) {
                newValue = findOrDefault(this.editorCollection, function (collectionItem) {
                    if (collectionItem && typeof state === 'object' && collectionItem.hasOwnProperty(_this.labelName)) {
                        return (collectionItem.hasOwnProperty(_this.labelName) && collectionItem[_this.labelName].toString()) === (state.hasOwnProperty(_this.labelName) && state[_this.labelName].toString());
                    }
                    else if (collectionItem && typeof state === 'string' && collectionItem.hasOwnProperty(_this.labelName)) {
                        return (collectionItem.hasOwnProperty(_this.labelName) && collectionItem[_this.labelName].toString()) === state;
                    }
                    return collectionItem && collectionItem.toString() === state;
                });
            }
            // is the field a complex object, "address.streetNumber"
            var isComplexObject = fieldName && fieldName.indexOf('.') > 0;
            // validate the value before applying it (if not valid we'll set an empty string)
            var validation = this.validate(newValue);
            newValue = (validation && validation.valid) ? newValue : '';
            // set the new value to the item datacontext
            if (isComplexObject) {
                setDeepValue(item, fieldName, newValue);
            }
            else {
                item[fieldName] = newValue;
            }
        };
        AutoCompleteEditor.prototype.isValueChanged = function () {
            var elmValue = this._$editorElm.val();
            var lastKeyEvent = this._lastInputEvent && this._lastInputEvent.keyCode;
            if (this.columnEditor && this.columnEditor.alwaysSaveOnEnterKey && lastKeyEvent === exports.KeyCode.ENTER) {
                return true;
            }
            return (!(elmValue === '' && (this._defaultTextValue === null || this._defaultTextValue === undefined))) && (elmValue !== this._defaultTextValue);
        };
        AutoCompleteEditor.prototype.loadValue = function (item) {
            var fieldName = this.columnDef && this.columnDef.field;
            if (item && fieldName !== undefined) {
                // is the field a complex object, "address.streetNumber"
                var isComplexObject = fieldName && fieldName.indexOf('.') > 0;
                var data = (isComplexObject) ? getDescendantProperty(item, fieldName) : item[fieldName];
                this._currentValue = data;
                this._defaultTextValue = typeof data === 'string' ? data : (data && data.hasOwnProperty(this.labelName) && data[this.labelName] || '');
                this._$editorElm.val(this._defaultTextValue);
                this._$editorElm.select();
            }
        };
        AutoCompleteEditor.prototype.save = function () {
            var validation = this.validate();
            var isValid = (validation && validation.valid) || false;
            if (this.hasAutoCommitEdit && isValid) {
                // do not use args.commitChanges() as this sets the focus to the next row.
                // also the select list will stay shown when clicking off the grid
                this.grid.getEditorLock().commitCurrentEdit();
            }
            else {
                this.args.commitChanges();
            }
        };
        AutoCompleteEditor.prototype.serializeValue = function () {
            var _a;
            // if you want to add the autocomplete functionality but want the user to be able to input a new option
            if (this.editorOptions.forceUserInput) {
                var minLength = this.editorOptions && this.editorOptions.hasOwnProperty('minLength') ? this.editorOptions.minLength : MIN_LENGTH;
                this._currentValue = this._$editorElm.val().length > minLength ? this._$editorElm.val() : this._currentValue;
            }
            // if user provided a custom structure, we will serialize the value returned from the object with custom structure
            if (this.customStructure && this._currentValue && this._currentValue.hasOwnProperty(this.valueName) && (this.columnDef && this.columnDef.type !== exports.FieldType.object && this.columnEditor && this.columnEditor.type !== exports.FieldType.object)) {
                return this._currentValue[this.valueName];
            }
            else if (this._currentValue && this._currentValue.value !== undefined) {
                // when object has a "value" property and its column is set as an Object type, we'll return an object with optional custom structure
                if (this.columnDef && this.columnDef.type === exports.FieldType.object || ((this.columnEditor && this.columnEditor.type) === exports.FieldType.object)) {
                    return _a = {},
                        _a[this.labelName] = this._currentValue.label,
                        _a[this.valueName] = this._currentValue.value,
                        _a;
                }
                return this._currentValue.value;
            }
            // if it falls here it might be that the user provided its own custom item with something else than the regular label/value pair
            // at this point it's only available when user provide a custom template for the autocomplete renderItem callback
            return this._currentValue;
        };
        AutoCompleteEditor.prototype.validate = function (inputValue) {
            var val = (inputValue !== undefined) ? inputValue : this._$editorElm && this._$editorElm.val && this._$editorElm.val();
            return textValidator(val, {
                editorArgs: this.args,
                errorMessage: this.columnEditor.errorMessage,
                minLength: this.columnEditor.minLength,
                maxLength: this.columnEditor.maxLength,
                operatorConditionalType: this.columnEditor.operatorConditionalType,
                required: this.columnEditor.required,
                validator: this.validator,
            });
        };
        //
        // private functions
        // ------------------
        // this function should be PRIVATE but for unit tests purposes we'll make it public until a better solution is found
        // a better solution would be to get the autocomplete DOM element to work with selection but I couldn't find how to do that in Jest
        AutoCompleteEditor.prototype.onSelect = function (_event, ui) {
            if (ui && ui.item) {
                var item = ui && ui.item;
                this._currentValue = item;
                // when the user defines a "renderItem" (or "_renderItem") template, then we assume the user defines his own custom structure of label/value pair
                // otherwise we know that jQueryUI always require a label/value pair, we can pull them directly
                var hasCustomRenderItemCallback = this.columnEditor && this.columnEditor.callbacks && this.columnEditor.callbacks.hasOwnProperty('_renderItem') || (this.columnEditor && this.columnEditor.editorOptions && this.columnEditor.editorOptions.renderItem) || false;
                var itemLabel = typeof item === 'string' ? item : (hasCustomRenderItemCallback ? item[this.labelName] : item.label);
                this.setValue(itemLabel);
                this.save();
            }
            return false;
        };
        AutoCompleteEditor.prototype.renderCustomItem = function (ul, item) {
            var templateString = this._autoCompleteOptions && this._autoCompleteOptions.renderItem && this._autoCompleteOptions.renderItem.templateCallback(item) || '';
            // sanitize any unauthorized html tags like script and others
            // for the remaining allowed tags we'll permit all attributes
            var sanitizedTemplateText = (DOMPurify$3.sanitize(templateString, {}) || '').toString();
            return $('<li></li>')
                .data('item.autocomplete', item)
                .append(sanitizedTemplateText)
                .appendTo(ul);
        };
        AutoCompleteEditor.prototype.renderCollectionItem = function (ul, item) {
            var isRenderHtmlEnabled = this.columnEditor && this.columnEditor.enableRenderHtml || false;
            var prefixText = item.labelPrefix || '';
            var labelText = item.label || '';
            var suffixText = item.labelSuffix || '';
            var finalText = prefixText + labelText + suffixText;
            // sanitize any unauthorized html tags like script and others
            // for the remaining allowed tags we'll permit all attributes
            var sanitizedText = (DOMPurify$3.sanitize(finalText, {}) || '').toString();
            var $liDiv = $('<div></div>')[isRenderHtmlEnabled ? 'html' : 'text'](sanitizedText);
            return $('<li></li>')
                .data('item.autocomplete', item)
                .append($liDiv)
                .appendTo(ul);
        };
        AutoCompleteEditor.prototype.renderDomElement = function (collection) {
            var e_1, _a;
            var _this = this;
            if (!Array.isArray(collection)) {
                throw new Error('The "collection" passed to the Autocomplete Editor is not a valid array.');
            }
            var columnId = this.columnDef && this.columnDef.id || '';
            var placeholder = this.columnEditor && this.columnEditor.placeholder || '';
            var title = this.columnEditor && this.columnEditor.title || '';
            this._$editorElm = $("<input type=\"text\" role=\"presentation\" autocomplete=\"off\" class=\"autocomplete editor-text editor-" + columnId + "\" placeholder=\"" + placeholder + "\" title=\"" + title + "\" />")
                .appendTo(this.args.container)
                .on('keydown.nav', function (event) {
                _this._lastInputEvent = event;
                if (event.keyCode === exports.KeyCode.LEFT || event.keyCode === exports.KeyCode.RIGHT) {
                    event.stopImmediatePropagation();
                }
            });
            // add a <span> in order to add spinner styling
            $("<span></span>").appendTo(this.args.container);
            // user might pass his own autocomplete options
            var autoCompleteOptions = this.columnEditor.editorOptions;
            // assign the collection to a temp variable before filtering/sorting the collection
            var finalCollection = collection;
            // user might provide his own custom structure
            // jQuery UI autocomplete requires a label/value pair, so we must remap them when user provide different ones
            if (Array.isArray(finalCollection)) {
                finalCollection = finalCollection.map(function (item) {
                    return { label: item[_this.labelName], value: item[_this.valueName], labelPrefix: item[_this.labelPrefixName] || '', labelSuffix: item[_this.labelSuffixName] || '' };
                });
            }
            // keep the final source collection used in the AutoComplete as reference
            this._elementCollection = finalCollection;
            // when user passes it's own autocomplete options
            // we still need to provide our own "select" callback implementation
            if (autoCompleteOptions && autoCompleteOptions.source) {
                autoCompleteOptions.select = function (event, ui) { return _this.onSelect(event, ui); };
                this._autoCompleteOptions = __assign({}, autoCompleteOptions);
                // when "renderItem" is defined, we need to add our custom style CSS class
                if (this._autoCompleteOptions.renderItem) {
                    this._autoCompleteOptions.classes = {
                        'ui-autocomplete': "autocomplete-custom-" + toKebabCase(this._autoCompleteOptions.renderItem.layout)
                    };
                }
                // create the jQueryUI AutoComplete
                this._$editorElm.autocomplete(this._autoCompleteOptions);
                // when "renderItem" is defined, we need to call the user's custom renderItem template callback
                if (this._autoCompleteOptions.renderItem) {
                    this._$editorElm.autocomplete('instance')._renderItem = this.renderCustomItem.bind(this);
                }
            }
            else {
                var definedOptions = {
                    source: finalCollection,
                    minLength: 0,
                    select: function (event, ui) { return _this.onSelect(event, ui); },
                };
                this._autoCompleteOptions = __assign({}, definedOptions, this.columnEditor.editorOptions);
                this._$editorElm.autocomplete(this._autoCompleteOptions);
                // we'll use our own renderer so that it works with label prefix/suffix and also with html rendering when enabled
                this._$editorElm.autocomplete('instance')._renderItem = this.renderCollectionItem.bind(this);
            }
            // in case the user wants to save even an empty value,
            // we need to subscribe to the onKeyDown event for that use case and clear the current value
            if (this.columnEditor.alwaysSaveOnEnterKey) {
                this._$editorElm.keydown(function (event) {
                    if (event.keyCode === exports.KeyCode.ENTER) {
                        _this._currentValue = null;
                    }
                });
            }
            // we could optionally trigger a search when clicking on the AutoComplete
            if (this.editorOptions.openSearchListOnFocus) {
                this._$editorElm.click(function () { return _this._$editorElm.autocomplete('search', _this._$editorElm.val()); });
            }
            // user might override any of the jQueryUI callback methods
            if (this.columnEditor.callbacks) {
                try {
                    for (var _b = __values(Object.keys(this.columnEditor.callbacks)), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var callback = _c.value;
                        if (typeof this.columnEditor.callbacks[callback] === 'function') {
                            this.instance[callback] = this.columnEditor.callbacks[callback];
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            this._$editorElm.on('focus', function () {
                _this._$editorElm.select();
                // we could optionally trigger a search to open the AutoComplete search list
                if (_this.editorOptions.openSearchListOnFocus) {
                    _this._$editorElm.autocomplete('search', _this._$editorElm.val());
                }
            });
            setTimeout(function () { return _this.focus(); }, 50);
        };
        return AutoCompleteEditor;
    }());

    /*
     * An example of a 'detached' editor.
     * KeyDown events are also handled to provide handling for Tab, Shift-Tab, Esc and Ctrl-Enter.
     */
    var CheckboxEditor = /** @class */ (function () {
        function CheckboxEditor(args) {
            this.args = args;
            if (!args) {
                throw new Error('[Angular-SlickGrid] Something is wrong with this grid, an Editor must always have valid arguments.');
            }
            this.grid = args.grid;
            this.init();
        }
        Object.defineProperty(CheckboxEditor.prototype, "columnDef", {
            /** Get Column Definition object */
            get: function () {
                return this.args && this.args.column;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CheckboxEditor.prototype, "columnEditor", {
            /** Get Column Editor object */
            get: function () {
                return this.columnDef && this.columnDef.internalColumnEditor || {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CheckboxEditor.prototype, "editorDomElement", {
            /** Get the Editor DOM Element */
            get: function () {
                return this._$input;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CheckboxEditor.prototype, "hasAutoCommitEdit", {
            get: function () {
                return this.args.grid.getOptions().autoCommitEdit;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CheckboxEditor.prototype, "validator", {
            /** Get the Validator function, can be passed in Editor property or Column Definition */
            get: function () {
                return this.columnEditor.validator || this.columnDef.validator;
            },
            enumerable: true,
            configurable: true
        });
        CheckboxEditor.prototype.init = function () {
            var _this = this;
            var fieldId = this.columnDef && this.columnDef.id;
            var title = this.columnEditor && this.columnEditor.title || '';
            this._$input = $("<input type=\"checkbox\" value=\"true\" class=\"editor-checkbox editor-" + fieldId + "\" title=\"" + title + "\" />");
            this._$input.appendTo(this.args.container);
            this.focus();
            // make the checkbox editor act like a regular checkbox that commit the value on click
            if (this.hasAutoCommitEdit) {
                this._$input.click(function () { return _this.save(); });
            }
        };
        CheckboxEditor.prototype.destroy = function () {
            this._$input.remove();
            this._$input = null;
        };
        CheckboxEditor.prototype.focus = function () {
            this._$input.focus();
        };
        CheckboxEditor.prototype.getValue = function () {
            return this._$input.prop('checked');
        };
        CheckboxEditor.prototype.setValue = function (val) {
            var isChecked = val ? true : false;
            this._$input.prop('checked', isChecked);
        };
        CheckboxEditor.prototype.applyValue = function (item, state) {
            var fieldName = this.columnDef && this.columnDef.field;
            var isComplexObject = fieldName && fieldName.indexOf('.') > 0; // is the field a complex object, "address.streetNumber"
            // validate the value before applying it (if not valid we'll set an empty string)
            var validation = this.validate(state);
            var newValue = (validation && validation.valid) ? state : '';
            // set the new value to the item datacontext
            if (isComplexObject) {
                setDeepValue(item, fieldName, newValue);
            }
            else {
                item[fieldName] = newValue;
            }
        };
        CheckboxEditor.prototype.isValueChanged = function () {
            return (this.serializeValue() !== this.originalValue);
        };
        CheckboxEditor.prototype.loadValue = function (item) {
            var fieldName = this.columnDef && this.columnDef.field;
            if (item && fieldName !== undefined) {
                // is the field a complex object, "address.streetNumber"
                var isComplexObject = fieldName && fieldName.indexOf('.') > 0;
                var value = (isComplexObject) ? getDescendantProperty(item, fieldName) : item[fieldName];
                this.originalValue = value;
                if (this.originalValue) {
                    this._$input.prop('checked', true);
                }
                else {
                    this._$input.prop('checked', false);
                }
            }
        };
        CheckboxEditor.prototype.save = function () {
            var validation = this.validate();
            var isValid = (validation && validation.valid) || false;
            if (this.hasAutoCommitEdit && isValid) {
                // do not use args.commitChanges() as this sets the focus to the next row.
                // also the select list will stay shown when clicking off the grid
                this.grid.getEditorLock().commitCurrentEdit();
            }
            else {
                this.args.commitChanges();
            }
        };
        CheckboxEditor.prototype.serializeValue = function () {
            return this._$input.prop('checked');
        };
        CheckboxEditor.prototype.validate = function (inputValue) {
            var isRequired = this.columnEditor.required;
            var isChecked = (inputValue !== undefined) ? inputValue : this._$input && this._$input.prop && this._$input.prop('checked');
            var errorMsg = this.columnEditor.errorMessage;
            if (this.validator) {
                return this.validator(isChecked, this.args);
            }
            // by default the editor is almost always valid (except when it's required but not provided)
            if (isRequired && !isChecked) {
                return {
                    valid: false,
                    msg: errorMsg || Constants.VALIDATION_REQUIRED_FIELD
                };
            }
            return {
                valid: true,
                msg: null
            };
        };
        return CheckboxEditor;
    }());

    var flatpickr = Flatpickr__default; // patch for rollup
    var moment$5 = moment_; // patch to fix rollup "moment has no default export" issue, document here https://github.com/rollup/rollup/issues/670
    require('flatpickr');
    /*
     * An example of a date picker editor using Flatpickr
     * https://chmln.github.io/flatpickr
     */
    var DateEditor = /** @class */ (function () {
        function DateEditor(args) {
            this.args = args;
            if (!args) {
                throw new Error('[Angular-SlickGrid] Something is wrong with this grid, an Editor must always have valid arguments.');
            }
            this.grid = args.grid;
            this.gridOptions = (args.grid && args.grid.getOptions() || {});
            var options = this.gridOptions || this.args.column.params || {};
            if (options && options.i18n instanceof core$1.TranslateService) {
                this._translate = options.i18n;
            }
            this.init();
        }
        Object.defineProperty(DateEditor.prototype, "columnDef", {
            /** Get Column Definition object */
            get: function () {
                return this.args && this.args.column;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateEditor.prototype, "columnEditor", {
            /** Get Column Editor object */
            get: function () {
                return this.columnDef && this.columnDef.internalColumnEditor || {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateEditor.prototype, "editorDomElement", {
            /** Get the Editor DOM Element */
            get: function () {
                return this._$input;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateEditor.prototype, "editorOptions", {
            /** Get Flatpickr options passed to the editor by the user */
            get: function () {
                return this.columnEditor.editorOptions || {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateEditor.prototype, "hasAutoCommitEdit", {
            get: function () {
                return this.grid.getOptions().autoCommitEdit;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateEditor.prototype, "pickerOptions", {
            get: function () {
                return this._pickerMergedOptions;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateEditor.prototype, "validator", {
            /** Get the Validator function, can be passed in Editor property or Column Definition */
            get: function () {
                return this.columnEditor.validator || this.columnDef.validator;
            },
            enumerable: true,
            configurable: true
        });
        DateEditor.prototype.init = function () {
            var _this = this;
            if (this.args && this.columnDef) {
                var columnId = this.columnDef && this.columnDef.id;
                var placeholder = this.columnEditor && this.columnEditor.placeholder || '';
                var title = this.columnEditor && this.columnEditor.title || '';
                this.defaultDate = (this.args.item) ? this.args.item[this.columnDef.field] : null;
                var inputFormat = mapFlatpickrDateFormatWithFieldType(this.columnEditor.type || this.columnDef.type || exports.FieldType.dateUtc);
                var outputFormat = mapFlatpickrDateFormatWithFieldType(this.columnDef.outputType || this.columnEditor.type || this.columnDef.type || exports.FieldType.dateUtc);
                var currentLocale = this._translate && this._translate.currentLang || this.gridOptions.locale || 'en';
                if (currentLocale && currentLocale.length > 2) {
                    currentLocale = currentLocale.substring(0, 2);
                }
                var pickerOptions = {
                    defaultDate: this.defaultDate,
                    altInput: true,
                    altFormat: outputFormat,
                    dateFormat: inputFormat,
                    closeOnSelect: true,
                    wrap: true,
                    locale: (currentLocale !== 'en') ? this.loadFlatpickrLocale(currentLocale) : 'en',
                    onChange: function () { return _this.save(); },
                    errorHandler: function () {
                        // do nothing, Flatpickr is a little too sensitive and will throw an error when provided date is lower than minDate so just disregard the error completely
                    }
                };
                // merge options with optional user's custom options
                this._pickerMergedOptions = __assign({}, pickerOptions, this.editorOptions);
                var inputCssClasses = ".editor-text.editor-" + columnId + ".form-control";
                if (this._pickerMergedOptions.altInput) {
                    this._pickerMergedOptions.altInputClass = 'flatpickr-alt-input form-control';
                }
                this._$editorInputElm = $("<div class=\"flatpickr input-group\"></div>");
                var closeButtonElm = $("<span class=\"input-group-btn\" data-clear>\n          <button class=\"btn btn-default icon-close\" type=\"button\"></button>\n        </span>");
                this._$input = $("<input type=\"text\" data-input data-defaultDate=\"" + this.defaultDate + "\" class=\"" + inputCssClasses.replace(/\./g, ' ') + "\" placeholder=\"" + placeholder + "\" title=\"" + title + "\" />");
                this._$input.appendTo(this._$editorInputElm);
                // show clear date button (unless user specifically doesn't want it)
                var isCloseButtonHidden = this.columnEditor && this.columnEditor.params && this.columnEditor.params.hideClearButton || false;
                if (!isCloseButtonHidden) {
                    closeButtonElm.appendTo(this._$editorInputElm);
                }
                this._$editorInputElm.appendTo(this.args.container);
                this.flatInstance = (flatpickr && this._$editorInputElm[0] && typeof this._$editorInputElm[0].flatpickr === 'function') ? this._$editorInputElm[0].flatpickr(this._pickerMergedOptions) : flatpickr(this._$editorInputElm, this._pickerMergedOptions);
                // when we're using an alternate input to display data, we'll consider this input as the one to do the focus later on
                // else just use the top one
                this._$inputWithData = (this._pickerMergedOptions && this._pickerMergedOptions.altInput) ? $(inputCssClasses + ".flatpickr-alt-input") : this._$input;
                setTimeout(function () {
                    _this.show();
                    _this.focus();
                }, 50);
            }
        };
        DateEditor.prototype.destroy = function () {
            var _this = this;
            this.hide();
            if (this.flatInstance && typeof this.flatInstance.destroy === 'function') {
                this.flatInstance.destroy();
                if (this.flatInstance.element) {
                    setTimeout(function () { return destroyObjectDomElementProps(_this.flatInstance); });
                }
                this.flatInstance = null;
            }
            if (this._$editorInputElm) {
                this._$editorInputElm.remove();
                this._$editorInputElm = null;
            }
            if (this._$inputWithData) {
                this._$inputWithData.remove();
                this._$inputWithData = null;
            }
            this._$input.remove();
        };
        DateEditor.prototype.focus = function () {
            this._$input.focus();
            if (this._$inputWithData && typeof this._$inputWithData.focus === 'function') {
                this._$inputWithData.focus().select();
            }
        };
        DateEditor.prototype.hide = function () {
            if (this.flatInstance && typeof this.flatInstance.close === 'function') {
                this.flatInstance.close();
            }
        };
        DateEditor.prototype.show = function () {
            if (this.flatInstance && typeof this.flatInstance.open === 'function' && this.flatInstance._input) {
                this.flatInstance.open();
            }
        };
        DateEditor.prototype.getValue = function () {
            return this._$input.val();
        };
        DateEditor.prototype.setValue = function (val) {
            this.flatInstance.setDate(val);
        };
        DateEditor.prototype.applyValue = function (item, state) {
            var fieldName = this.columnDef && this.columnDef.field;
            if (fieldName !== undefined) {
                var outputTypeFormat = mapMomentDateFormatWithFieldType((this.columnDef && (this.columnDef.outputType || this.columnEditor.type || this.columnDef.type)) || exports.FieldType.dateUtc);
                var saveTypeFormat = mapMomentDateFormatWithFieldType((this.columnDef && (this.columnDef.saveOutputType || this.columnDef.outputType || this.columnEditor.type || this.columnDef.type)) || exports.FieldType.dateUtc);
                var isComplexObject = fieldName && fieldName.indexOf('.') > 0; // is the field a complex object, "address.streetNumber"
                // validate the value before applying it (if not valid we'll set an empty string)
                var validation = this.validate(state);
                var newValue = (state && validation && validation.valid) ? moment$5(state, outputTypeFormat).format(saveTypeFormat) : '';
                // set the new value to the item datacontext
                if (isComplexObject) {
                    setDeepValue(item, fieldName, newValue);
                }
                else {
                    item[fieldName] = newValue;
                }
            }
        };
        DateEditor.prototype.isValueChanged = function () {
            var elmValue = this._$input.val();
            var inputFormat = mapMomentDateFormatWithFieldType(this.columnEditor.type || (this.columnDef && this.columnDef.type) || exports.FieldType.dateIso);
            var outputTypeFormat = mapMomentDateFormatWithFieldType((this.columnDef && (this.columnDef.outputType || this.columnEditor.type || this.columnDef.type)) || exports.FieldType.dateUtc);
            var elmDateStr = elmValue ? moment$5(elmValue, inputFormat, false).format(outputTypeFormat) : '';
            var orgDateStr = this._originalDate ? moment$5(this._originalDate, inputFormat, false).format(outputTypeFormat) : '';
            if (elmDateStr === 'Invalid date' || orgDateStr === 'Invalid date') {
                return false;
            }
            var isChanged = (!(elmDateStr === '' && orgDateStr === '')) && (elmDateStr !== orgDateStr);
            return isChanged;
        };
        DateEditor.prototype.loadValue = function (item) {
            var fieldName = this.columnDef && this.columnDef.field;
            if (item && fieldName !== undefined) {
                // is the field a complex object, "address.streetNumber"
                var isComplexObject = fieldName && fieldName.indexOf('.') > 0;
                var value = (isComplexObject) ? getDescendantProperty(item, fieldName) : item[fieldName];
                this._originalDate = value;
                this.flatInstance.setDate(value);
            }
        };
        DateEditor.prototype.save = function () {
            var validation = this.validate();
            var isValid = (validation && validation.valid) || false;
            if (this.hasAutoCommitEdit && isValid) {
                // do not use args.commitChanges() as this sets the focus to the next row.
                // also the select list will stay shown when clicking off the grid
                this.grid.getEditorLock().commitCurrentEdit();
            }
            else {
                this.args.commitChanges();
            }
        };
        DateEditor.prototype.serializeValue = function () {
            var domValue = this._$input.val();
            if (!domValue) {
                return '';
            }
            var inputFormat = mapMomentDateFormatWithFieldType(this.columnEditor.type || (this.columnDef && this.columnDef.type) || exports.FieldType.dateIso);
            var outputTypeFormat = mapMomentDateFormatWithFieldType((this.columnDef && (this.columnDef.outputType || this.columnEditor.type || this.columnDef.type)) || exports.FieldType.dateIso);
            var value = moment$5(domValue, inputFormat, false).format(outputTypeFormat);
            return value;
        };
        DateEditor.prototype.validate = function (inputValue) {
            var isRequired = this.columnEditor.required;
            var elmValue = (inputValue !== undefined) ? inputValue : this._$input && this._$input.val && this._$input.val();
            var errorMsg = this.columnEditor.errorMessage;
            if (this.validator) {
                return this.validator(elmValue, this.args);
            }
            // by default the editor is almost always valid (except when it's required but not provided)
            if (isRequired && elmValue === '') {
                return {
                    valid: false,
                    msg: errorMsg || Constants.VALIDATION_REQUIRED_FIELD
                };
            }
            return {
                valid: true,
                msg: null
            };
        };
        //
        // private functions
        // ------------------
        /** Load a different set of locales for Flatpickr to be localized */
        DateEditor.prototype.loadFlatpickrLocale = function (language) {
            var locales = 'en';
            if (language !== 'en') {
                // change locale if needed, Flatpickr reference: https://chmln.github.io/flatpickr/localization/
                var localeDefault = require("flatpickr/dist/l10n/" + language + ".js").default;
                locales = (localeDefault && localeDefault[language]) ? localeDefault[language] : 'en';
            }
            return locales;
        };
        return DateEditor;
    }());

    function floatValidator(inputValue, options) {
        var floatNumber = !isNaN(inputValue) ? parseFloat(inputValue) : null;
        var decPlaces = options.decimal || 0;
        var isRequired = options.required;
        var minValue = options.minValue;
        var maxValue = options.maxValue;
        var operatorConditionalType = options.operatorConditionalType || 'inclusive';
        var errorMsg = options.errorMessage;
        var mapValidation = {
            '{{minValue}}': minValue,
            '{{maxValue}}': maxValue,
            '{{minDecimal}}': 0,
            '{{maxDecimal}}': decPlaces
        };
        var isValid = true;
        var outputMsg = '';
        if (typeof options.validator === 'function') {
            return options.validator(inputValue, options.editorArgs);
        }
        else if (isRequired && inputValue === '') {
            isValid = false;
            outputMsg = errorMsg || Constants.VALIDATION_REQUIRED_FIELD;
        }
        else if (inputValue !== '' && (isNaN(inputValue) || (decPlaces === 0 && !/^[-+]?(\d*(\.)?(\d)*)$/.test(inputValue)))) {
            // when decimal value is 0 (which is the default), we accept 0 or more decimal values
            isValid = false;
            outputMsg = errorMsg || Constants.VALIDATION_EDITOR_VALID_NUMBER;
        }
        else if (minValue !== undefined && maxValue !== undefined && floatNumber !== null && ((operatorConditionalType === 'exclusive' && (floatNumber <= minValue || floatNumber >= maxValue)) || (operatorConditionalType === 'inclusive' && (floatNumber < minValue || floatNumber > maxValue)))) {
            // MIN & MAX Values provided
            // when decimal value is bigger than 0, we only accept the decimal values as that value set
            // for example if we set decimalPlaces to 2, we will only accept numbers between 0 and 2 decimals
            isValid = false;
            outputMsg = errorMsg || Constants.VALIDATION_EDITOR_NUMBER_BETWEEN.replace(/{{minValue}}|{{maxValue}}/gi, function (matched) { return mapValidation[matched]; });
        }
        else if (minValue !== undefined && floatNumber !== null && ((operatorConditionalType === 'exclusive' && floatNumber <= minValue) || (operatorConditionalType === 'inclusive' && floatNumber < minValue))) {
            // MIN VALUE ONLY
            // when decimal value is bigger than 0, we only accept the decimal values as that value set
            // for example if we set decimalPlaces to 2, we will only accept numbers between 0 and 2 decimals
            isValid = false;
            var defaultErrorMsg = operatorConditionalType === 'inclusive' ? Constants.VALIDATION_EDITOR_NUMBER_MIN_INCLUSIVE : Constants.VALIDATION_EDITOR_NUMBER_MIN;
            outputMsg = errorMsg || defaultErrorMsg.replace(/{{minValue}}/gi, function (matched) { return mapValidation[matched]; });
        }
        else if (maxValue !== undefined && floatNumber !== null && ((operatorConditionalType === 'exclusive' && floatNumber >= maxValue) || (operatorConditionalType === 'inclusive' && floatNumber > maxValue))) {
            // MAX VALUE ONLY
            // when decimal value is bigger than 0, we only accept the decimal values as that value set
            // for example if we set decimalPlaces to 2, we will only accept numbers between 0 and 2 decimals
            isValid = false;
            var defaultErrorMsg = operatorConditionalType === 'inclusive' ? Constants.VALIDATION_EDITOR_NUMBER_MAX_INCLUSIVE : Constants.VALIDATION_EDITOR_NUMBER_MAX;
            outputMsg = errorMsg || defaultErrorMsg.replace(/{{maxValue}}/gi, function (matched) { return mapValidation[matched]; });
        }
        else if ((decPlaces > 0 && !new RegExp("^[-+]?(\\d*(\\.)?(\\d){0," + decPlaces + "})$").test(inputValue))) {
            // when decimal value is bigger than 0, we only accept the decimal values as that value set
            // for example if we set decimalPlaces to 2, we will only accept numbers between 0 and 2 decimals
            isValid = false;
            outputMsg = errorMsg || Constants.VALIDATION_EDITOR_DECIMAL_BETWEEN.replace(/{{minDecimal}}|{{maxDecimal}}/gi, function (matched) { return mapValidation[matched]; });
        }
        return { valid: isValid, msg: outputMsg };
    }

    function integerValidator(inputValue, options) {
        var intNumber = !isNaN(inputValue) ? parseInt(inputValue, 10) : null;
        if (intNumber !== null && isNaN(intNumber)) {
            intNumber = null;
        }
        var errorMsg = options.errorMessage;
        var isRequired = options.required;
        var minValue = options.minValue;
        var maxValue = options.maxValue;
        var operatorConditionalType = options.operatorConditionalType || 'inclusive';
        var mapValidation = {
            '{{minValue}}': minValue,
            '{{maxValue}}': maxValue
        };
        var isValid = true;
        var outputMsg = '';
        if (options.validator) {
            return options.validator(inputValue, options.editorArgs);
        }
        else if (isRequired && inputValue === '') {
            isValid = false;
            outputMsg = errorMsg || Constants.VALIDATION_REQUIRED_FIELD;
        }
        else if (inputValue !== '' && ((isNaN(inputValue) || !/^[+-]?\d+$/.test(inputValue)))) {
            isValid = false;
            outputMsg = errorMsg || Constants.VALIDATION_EDITOR_VALID_INTEGER;
        }
        else if (minValue !== undefined && maxValue !== undefined && intNumber !== null && ((operatorConditionalType === 'exclusive' && (intNumber <= minValue || intNumber >= maxValue)) || (operatorConditionalType === 'inclusive' && (intNumber < minValue || intNumber > maxValue)))) {
            // MIN & MAX Values provided (between)
            // when decimal value is bigger than 0, we only accept the decimal values as that value set
            // for example if we set decimalPlaces to 2, we will only accept numbers between 0 and 2 decimals
            isValid = false;
            outputMsg = errorMsg || Constants.VALIDATION_EDITOR_INTEGER_BETWEEN.replace(/{{minValue}}|{{maxValue}}/gi, function (matched) { return mapValidation[matched]; });
        }
        else if (minValue !== undefined && intNumber !== null && ((operatorConditionalType === 'exclusive' && intNumber <= minValue) || (operatorConditionalType === 'inclusive' && intNumber !== null && intNumber < minValue))) {
            // MIN VALUE ONLY
            // when decimal value has to be higher then provided minValue
            isValid = false;
            var defaultErrorMsg = operatorConditionalType === 'inclusive' ? Constants.VALIDATION_EDITOR_INTEGER_MIN_INCLUSIVE : Constants.VALIDATION_EDITOR_INTEGER_MIN;
            outputMsg = errorMsg || defaultErrorMsg.replace(/{{minValue}}/gi, function (matched) { return mapValidation[matched]; });
        }
        else if (maxValue !== undefined && intNumber !== null && ((operatorConditionalType === 'exclusive' && intNumber >= maxValue) || (operatorConditionalType === 'inclusive' && intNumber !== null && intNumber > maxValue))) {
            // MAX VALUE ONLY
            // when decimal value has to be lower then provided maxValue
            isValid = false;
            var defaultErrorMsg = operatorConditionalType === 'inclusive' ? Constants.VALIDATION_EDITOR_INTEGER_MAX_INCLUSIVE : Constants.VALIDATION_EDITOR_INTEGER_MAX;
            outputMsg = errorMsg || defaultErrorMsg.replace(/{{maxValue}}/gi, function (matched) { return mapValidation[matched]; });
        }
        return { valid: isValid, msg: outputMsg };
    }

    function sliderValidator(inputValue, options) {
        var isRequired = options.required;
        var minValue = options.minValue;
        var maxValue = options.maxValue;
        var errorMsg = options.errorMessage;
        var mapValidation = {
            '{{minValue}}': minValue,
            '{{maxValue}}': maxValue
        };
        if (options.validator) {
            return options.validator(inputValue, options.editorArgs);
        }
        else if (isRequired && inputValue === '') {
            return {
                valid: false,
                msg: errorMsg || Constants.VALIDATION_REQUIRED_FIELD
            };
        }
        else if (minValue !== undefined && maxValue !== undefined && inputValue !== null && (inputValue < minValue || inputValue > maxValue)) {
            // when decimal value is bigger than 0, we only accept the decimal values as that value set
            // for example if we set decimalPlaces to 2, we will only accept numbers between 0 and 2 decimals
            return {
                valid: false,
                msg: errorMsg || Constants.VALIDATION_EDITOR_NUMBER_BETWEEN.replace(/{{minValue}}|{{maxValue}}/gi, function (matched) {
                    return mapValidation[matched];
                })
            };
        }
        return { valid: true, msg: null };
    }

    /*
     * An example of a 'detached' editor.
     * KeyDown events are also handled to provide handling for Tab, Shift-Tab, Esc and Ctrl-Enter.
     */
    var DualInputEditor = /** @class */ (function () {
        function DualInputEditor(args) {
            var _this = this;
            this.args = args;
            this._isValueSaveCalled = false;
            if (!args) {
                throw new Error('[Angular-Slickgrid] Something is wrong with this grid, an Editor must always have valid arguments.');
            }
            this.grid = args.grid;
            this.gridOptions = (this.grid.getOptions() || {});
            this._eventHandler = new Slick.EventHandler();
            this._bindEventService = new BindingEventService();
            this.init();
            this._eventHandler.subscribe(this.grid.onValidationError, function () { return _this._isValueSaveCalled = true; });
        }
        Object.defineProperty(DualInputEditor.prototype, "columnDef", {
            /** Get Column Definition object */
            get: function () {
                return this.args && this.args.column;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DualInputEditor.prototype, "columnEditor", {
            /** Get Column Editor object */
            get: function () {
                return this.columnDef && this.columnDef.internalColumnEditor || {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DualInputEditor.prototype, "editorDomElement", {
            /** Get the Editor DOM Element */
            get: function () {
                return { leftInput: this._leftInput, rightInput: this._rightInput };
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DualInputEditor.prototype, "editorParams", {
            get: function () {
                return this.columnEditor.params || {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DualInputEditor.prototype, "eventHandler", {
            get: function () {
                return this._eventHandler;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DualInputEditor.prototype, "hasAutoCommitEdit", {
            get: function () {
                return this.grid.getOptions().autoCommitEdit;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DualInputEditor.prototype, "isValueSaveCalled", {
            get: function () {
                return this._isValueSaveCalled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DualInputEditor.prototype, "validator", {
            /** Get the Shared Validator function, can be passed in Editor property or Column Definition */
            get: function () {
                return (this.columnEditor && this.columnEditor.validator) || (this.columnDef && this.columnDef.validator);
            },
            enumerable: true,
            configurable: true
        });
        DualInputEditor.prototype.init = function () {
            var _this = this;
            if (!this.editorParams || !this.editorParams.leftInput || !this.editorParams.leftInput.field || !this.editorParams.rightInput || !this.editorParams.rightInput.field) {
                throw new Error("[Angular-Slickgrid] Please make sure that your Combo Input Editor has params defined with \"leftInput\" and \"rightInput\" (example: { editor: { model: Editors.comboInput, params: { leftInput: { field: 'firstName' }, { rightSide: { field: 'lastName' } }}}");
            }
            this._leftFieldName = this.editorParams && this.editorParams.leftInput && this.editorParams.leftInput.field;
            this._rightFieldName = this.editorParams && this.editorParams.rightInput && this.editorParams.rightInput.field;
            this._leftInput = this.createInput('leftInput');
            this._rightInput = this.createInput('rightInput');
            var containerElm = this.args.container;
            if (containerElm && typeof containerElm.appendChild === 'function') {
                containerElm.appendChild(this._leftInput);
                containerElm.appendChild(this._rightInput);
            }
            this._leftInput.onkeydown = this.handleKeyDown.bind(this);
            this._rightInput.onkeydown = this.handleKeyDown.bind(this);
            // the lib does not get the focus out event for some reason, so register it here
            if (this.hasAutoCommitEdit) {
                this._bindEventService.bind(this._leftInput, 'focusout', function (event) { return _this.handleFocusOut(event, 'leftInput'); });
                this._bindEventService.bind(this._rightInput, 'focusout', function (event) { return _this.handleFocusOut(event, 'rightInput'); });
            }
            setTimeout(function () { return _this._leftInput.select(); }, 50);
        };
        DualInputEditor.prototype.handleFocusOut = function (event, position) {
            // when clicking outside the editable cell OR when focusing out of it
            var targetClassNames = event.relatedTarget && event.relatedTarget.className || '';
            if (targetClassNames.indexOf('dual-editor') === -1 && this._lastEventType !== 'focusout-right') {
                if (position === 'rightInput' || (position === 'leftInput' && this._lastEventType !== 'focusout-left')) {
                    this.save();
                }
            }
            var side = (position === 'leftInput') ? 'left' : 'right';
            this._lastEventType = (event && event.type) + "-" + side;
        };
        DualInputEditor.prototype.handleKeyDown = function (event) {
            this._lastInputKeyEvent = event;
            if (event.keyCode === exports.KeyCode.LEFT || event.keyCode === exports.KeyCode.RIGHT || event.keyCode === exports.KeyCode.TAB) {
                event.stopImmediatePropagation();
            }
        };
        DualInputEditor.prototype.destroy = function () {
            // unsubscribe all SlickGrid events
            this._eventHandler.unsubscribeAll();
            this._bindEventService.unbindAll();
        };
        DualInputEditor.prototype.createInput = function (position) {
            var editorSideParams = this.editorParams[position];
            var columnId = this.columnDef && this.columnDef.id;
            var idPropName = this.gridOptions.datasetIdPropertyName || 'id';
            var itemId = this.args && this.args.item && this.args.item[idPropName] || 0;
            var fieldType = editorSideParams.type || 'text';
            if (fieldType === 'float' || fieldType === 'integer') {
                fieldType = 'number';
            }
            var input = document.createElement('input');
            input.id = "item-" + itemId + "-" + position;
            input.className = "dual-editor-text editor-" + columnId + " " + position.replace(/input/gi, '');
            if (fieldType === 'readonly') {
                // when the custom type is defined as readonly, we'll make a readonly text input
                input.readOnly = true;
                fieldType = 'text';
            }
            input.type = fieldType || 'text';
            input.setAttribute('role', 'presentation');
            input.autocomplete = 'off';
            input.placeholder = editorSideParams.placeholder || '';
            input.title = editorSideParams.title || '';
            if (fieldType === 'number') {
                input.step = this.getInputDecimalSteps(position);
            }
            return input;
        };
        DualInputEditor.prototype.focus = function () {
            // do nothing since we have 2 inputs and we might focus on left/right depending on which is invalid and/or new
        };
        DualInputEditor.prototype.getValues = function () {
            var obj = {};
            var leftInputValue = this._leftInput.value;
            var rightInputValue = this._rightInput.value;
            var isLeftInputTypeNumber = (this.editorParams.leftInput && (this.editorParams.leftInput.type === 'float' || this.editorParams.leftInput.type === 'integer'));
            var isRightInputTypeNumber = (this.editorParams.rightInput && (this.editorParams.rightInput.type === 'float' || this.editorParams.rightInput.type === 'integer'));
            var resultLeftValue = (leftInputValue !== '' && isLeftInputTypeNumber) ? +this._leftInput.value : (leftInputValue || '');
            var resultRightValue = (rightInputValue !== '' && isRightInputTypeNumber) ? +this._rightInput.value : (rightInputValue || '');
            setDeepValue(obj, this._leftFieldName, resultLeftValue);
            setDeepValue(obj, this._rightFieldName, resultRightValue);
            return obj;
        };
        DualInputEditor.prototype.setValues = function (values) {
            if (Array.isArray(values) && values.length === 2) {
                this._leftInput.value = "" + values[0];
                this._rightInput.value = "" + values[1];
            }
        };
        DualInputEditor.prototype.applyValue = function (item, state) {
            this.applyValueByPosition(item, state, 'leftInput');
            this.applyValueByPosition(item, state, 'rightInput');
        };
        DualInputEditor.prototype.applyValueByPosition = function (item, state, position) {
            var fieldName = position === 'leftInput' ? this._leftFieldName : this._rightFieldName;
            if (fieldName !== undefined) {
                var isComplexObject = fieldName && fieldName.indexOf('.') > 0; // is the field a complex object, "address.streetNumber"
                var fieldNameToUse = fieldName;
                if (isComplexObject) {
                    var complexFieldNames = fieldName.split(/\.(.*)/);
                    fieldNameToUse = (complexFieldNames.length > 1 ? complexFieldNames[1] : complexFieldNames);
                }
                // validate the value before applying it (if not valid we'll set an empty string)
                var stateValue = isComplexObject ? getDescendantProperty(state, fieldNameToUse) : state[fieldName];
                var validation = this.validate({ position: position, inputValue: stateValue });
                // set the new value to the item datacontext
                if (isComplexObject) {
                    var newValueFromComplex = getDescendantProperty(state, fieldNameToUse);
                    var newValue = (validation && validation.valid) ? newValueFromComplex : '';
                    setDeepValue(item, fieldName, newValue);
                }
                else if (fieldName) {
                    item[fieldName] = (validation && validation.valid) ? state[fieldName] : '';
                }
            }
        };
        DualInputEditor.prototype.isValueChanged = function () {
            var leftElmValue = this._leftInput.value;
            var rightElmValue = this._rightInput.value;
            var leftEditorParams = this.editorParams && this.editorParams.leftInput;
            var rightEditorParams = this.editorParams && this.editorParams.rightInput;
            var lastKeyEvent = this._lastInputKeyEvent && this._lastInputKeyEvent.keyCode;
            if ((leftEditorParams && leftEditorParams.alwaysSaveOnEnterKey || rightEditorParams && rightEditorParams.alwaysSaveOnEnterKey) && lastKeyEvent === exports.KeyCode.ENTER) {
                return true;
            }
            var leftResult = (!(leftElmValue === '' && (this.originalLeftValue === null || this.originalLeftValue === undefined))) && (leftElmValue !== this.originalLeftValue);
            var rightResult = (!(rightElmValue === '' && (this.originalRightValue === null || this.originalRightValue === undefined))) && (rightElmValue !== this.originalRightValue);
            return leftResult || rightResult;
        };
        DualInputEditor.prototype.loadValue = function (item) {
            this.loadValueByPosition(item, 'leftInput');
            this.loadValueByPosition(item, 'rightInput');
            this._leftInput.select();
        };
        DualInputEditor.prototype.loadValueByPosition = function (item, position) {
            // is the field a complex object, "address.streetNumber"
            var fieldName = (position === 'leftInput') ? this._leftFieldName : this._rightFieldName;
            var originalValuePosition = (position === 'leftInput') ? 'originalLeftValue' : 'originalRightValue';
            var inputVarPosition = (position === 'leftInput') ? '_leftInput' : '_rightInput';
            if (item && fieldName !== undefined) {
                var isComplexObject = fieldName && fieldName.indexOf('.') > 0;
                var itemValue = (isComplexObject) ? getDescendantProperty(item, fieldName) : (item.hasOwnProperty(fieldName) ? item[fieldName] : '');
                this[originalValuePosition] = itemValue;
                if (this.editorParams[position].type === 'float') {
                    var decimalPlaces = this.getDecimalPlaces(position);
                    if (decimalPlaces !== null && (this[originalValuePosition] || this[originalValuePosition] === 0) && (+this[originalValuePosition]).toFixed) {
                        this[originalValuePosition] = (+this[originalValuePosition]).toFixed(decimalPlaces);
                    }
                }
                if (this[inputVarPosition]) {
                    var originalValue = this[originalValuePosition];
                    this[inputVarPosition].value = "" + originalValue;
                }
            }
        };
        DualInputEditor.prototype.save = function () {
            var validation = this.validate();
            var isValid = (validation && validation.valid) || false;
            if (!this._isValueSaveCalled) {
                if (this.hasAutoCommitEdit && isValid) {
                    this.grid.getEditorLock().commitCurrentEdit();
                }
                else {
                    this.args.commitChanges();
                }
                this._isValueSaveCalled = true;
            }
        };
        DualInputEditor.prototype.serializeValue = function () {
            var obj = {};
            var leftValue = this.serializeValueByPosition('leftInput');
            var rightValue = this.serializeValueByPosition('rightInput');
            setDeepValue(obj, this._leftFieldName, leftValue);
            setDeepValue(obj, this._rightFieldName, rightValue);
            return obj;
        };
        DualInputEditor.prototype.serializeValueByPosition = function (position) {
            var elmValue = position === 'leftInput' ? this._leftInput.value : this._rightInput.value;
            if (elmValue === '' || isNaN(+elmValue)) {
                return elmValue;
            }
            var rtn = parseFloat(elmValue);
            var decPlaces = this.getDecimalPlaces(position);
            if (decPlaces !== null && (rtn || rtn === 0) && rtn.toFixed) {
                rtn = parseFloat(rtn.toFixed(decPlaces));
            }
            return rtn;
        };
        DualInputEditor.prototype.getDecimalPlaces = function (position) {
            var defaultDecimalPlaces = 0; // TODO move into a constant
            // returns the number of fixed decimal places or null
            var positionSide = position === 'leftInput' ? 'leftInput' : 'rightInput';
            var sideParams = this.editorParams[positionSide];
            var rtn = sideParams && sideParams.decimal;
            if (rtn === undefined) {
                return defaultDecimalPlaces;
            }
            return rtn;
        };
        DualInputEditor.prototype.getInputDecimalSteps = function (position) {
            var decimals = this.getDecimalPlaces(position);
            var zeroString = '';
            for (var i = 1; i < decimals; i++) {
                zeroString += '0';
            }
            if (decimals > 0) {
                return "0." + zeroString + "1";
            }
            return '1';
        };
        DualInputEditor.prototype.validate = function (inputValidation) {
            if (inputValidation) {
                var posValidation = this.validateByPosition(inputValidation.position, inputValidation.inputValue);
                if (!posValidation.valid) {
                    inputValidation.position === 'leftInput' ? this._leftInput.select() : this._rightInput.select();
                    return posValidation;
                }
            }
            else {
                var leftValidation = this.validateByPosition('leftInput');
                var rightValidation = this.validateByPosition('rightInput');
                if (!leftValidation.valid) {
                    this._leftInput.select();
                    return leftValidation;
                }
                if (!rightValidation.valid) {
                    this._rightInput.select();
                    return rightValidation;
                }
            }
            return { valid: true, msg: '' };
        };
        DualInputEditor.prototype.validateByPosition = function (position, inputValue) {
            var positionEditorParams = this.editorParams[position];
            var currentVal = '';
            if (inputValue) {
                currentVal = inputValue;
            }
            else {
                var input = position === 'leftInput' ? this._leftInput : this._rightInput;
                currentVal = input && input.value;
            }
            // there are 2 ways of passing a Validator, 1-independent validator on each side, 2-shared validator
            var commonValidator = this.validator;
            currentVal = typeof commonValidator === 'function' ? this.getValues() : currentVal;
            var baseValidatorOptions = {
                editorArgs: this.args,
                errorMessage: positionEditorParams.errorMessage,
                required: positionEditorParams.required,
                validator: typeof commonValidator === 'function' ? commonValidator : positionEditorParams.validator,
            };
            switch (positionEditorParams.type) {
                case 'float':
                    return floatValidator(currentVal, __assign({}, baseValidatorOptions, { decimal: this.getDecimalPlaces(position), minValue: positionEditorParams.minValue, maxValue: positionEditorParams.maxValue, operatorConditionalType: positionEditorParams.operatorConditionalType }));
                case 'integer':
                    return integerValidator(currentVal, __assign({}, baseValidatorOptions, { minValue: positionEditorParams.minValue, maxValue: positionEditorParams.maxValue, operatorConditionalType: positionEditorParams.operatorConditionalType }));
                case 'text':
                case 'password':
                default:
                    return textValidator(currentVal, baseValidatorOptions);
            }
        };
        return DualInputEditor;
    }());

    var defaultDecimalPlaces = 0;
    /*
     * An example of a 'detached' editor.
     * KeyDown events are also handled to provide handling for Tab, Shift-Tab, Esc and Ctrl-Enter.
     */
    var FloatEditor = /** @class */ (function () {
        function FloatEditor(args) {
            this.args = args;
            if (!args) {
                throw new Error('[Angular-SlickGrid] Something is wrong with this grid, an Editor must always have valid arguments.');
            }
            this.grid = args.grid;
            this.init();
        }
        Object.defineProperty(FloatEditor.prototype, "columnDef", {
            /** Get Column Definition object */
            get: function () {
                return this.args && this.args.column;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FloatEditor.prototype, "columnEditor", {
            /** Get Column Editor object */
            get: function () {
                return this.columnDef && this.columnDef.internalColumnEditor || {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FloatEditor.prototype, "editorDomElement", {
            /** Get the Editor DOM Element */
            get: function () {
                return this._$input;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FloatEditor.prototype, "hasAutoCommitEdit", {
            get: function () {
                return this.grid && this.grid.getOptions && this.grid.getOptions().autoCommitEdit;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FloatEditor.prototype, "validator", {
            /** Get the Validator function, can be passed in Editor property or Column Definition */
            get: function () {
                return this.columnEditor.validator || this.columnDef.validator;
            },
            enumerable: true,
            configurable: true
        });
        FloatEditor.prototype.init = function () {
            var _this = this;
            var columnId = this.columnDef && this.columnDef.id;
            var placeholder = this.columnEditor && this.columnEditor.placeholder || '';
            var title = this.columnEditor && this.columnEditor.title || '';
            this._$input = $("<input type=\"number\" role=\"presentation\" autocomplete=\"off\" class=\"editor-text editor-" + columnId + "\" placeholder=\"" + placeholder + "\" title=\"" + title + "\" step=\"" + this.getInputDecimalSteps() + "\" />")
                .appendTo(this.args.container)
                .on('keydown.nav', function (event) {
                _this._lastInputEvent = event;
                if (event.keyCode === exports.KeyCode.LEFT || event.keyCode === exports.KeyCode.RIGHT) {
                    event.stopImmediatePropagation();
                }
            });
            // the lib does not get the focus out event for some reason
            // so register it here
            if (this.hasAutoCommitEdit) {
                this._$input.on('focusout', function () { return _this.save(); });
            }
            setTimeout(function () { return _this.focus(); }, 50);
        };
        FloatEditor.prototype.destroy = function () {
            if (this._$input) {
                this._$input.off('keydown.nav').remove();
                this._$input = null;
            }
        };
        FloatEditor.prototype.focus = function () {
            if (this._$input) {
                this._$input.focus();
            }
        };
        FloatEditor.prototype.getDecimalPlaces = function () {
            // returns the number of fixed decimal places or null
            var rtn = (this.columnEditor.params && this.columnEditor.params.hasOwnProperty('decimalPlaces')) ? this.columnEditor.params.decimalPlaces : undefined;
            if (rtn === undefined) {
                rtn = defaultDecimalPlaces;
            }
            return (!rtn && rtn !== 0 ? null : rtn);
        };
        FloatEditor.prototype.getInputDecimalSteps = function () {
            var decimals = this.getDecimalPlaces();
            var zeroString = '';
            for (var i = 1; i < decimals; i++) {
                zeroString += '0';
            }
            if (decimals > 0) {
                return "0." + zeroString + "1";
            }
            return '1';
        };
        FloatEditor.prototype.getValue = function () {
            return this._$input.val() || '';
        };
        FloatEditor.prototype.setValue = function (value) {
            this._$input.val(value);
        };
        FloatEditor.prototype.applyValue = function (item, state) {
            var fieldName = this.columnDef && this.columnDef.field;
            var isComplexObject = fieldName && fieldName.indexOf('.') > 0; // is the field a complex object, "address.streetNumber"
            var validation = this.validate(state);
            var newValue = (validation && validation.valid) ? state : '';
            // set the new value to the item datacontext
            if (isComplexObject) {
                setDeepValue(item, fieldName, newValue);
            }
            else {
                item[fieldName] = newValue;
            }
        };
        FloatEditor.prototype.isValueChanged = function () {
            var elmValue = this._$input.val();
            var lastKeyEvent = this._lastInputEvent && this._lastInputEvent.keyCode;
            if (this.columnEditor && this.columnEditor.alwaysSaveOnEnterKey && lastKeyEvent === exports.KeyCode.ENTER) {
                return true;
            }
            return (!(elmValue === '' && (this.originalValue === null || this.originalValue === undefined))) && (elmValue !== this.originalValue);
        };
        FloatEditor.prototype.loadValue = function (item) {
            var fieldName = this.columnDef && this.columnDef.field;
            if (item && fieldName !== undefined) {
                // is the field a complex object, "address.streetNumber"
                var isComplexObject = fieldName && fieldName.indexOf('.') > 0;
                var value = (isComplexObject) ? getDescendantProperty(item, fieldName) : item[fieldName];
                this.originalValue = value;
                var decPlaces = this.getDecimalPlaces();
                if (decPlaces !== null && (this.originalValue || this.originalValue === 0) && (+this.originalValue).toFixed) {
                    this.originalValue = (+this.originalValue).toFixed(decPlaces);
                }
                this._$input.val(this.originalValue);
                this._$input.select();
            }
        };
        FloatEditor.prototype.save = function () {
            var validation = this.validate();
            var isValid = (validation && validation.valid) || false;
            if (this.hasAutoCommitEdit && isValid) {
                // do not use args.commitChanges() as this sets the focus to the next row.
                // also the select list will stay shown when clicking off the grid
                this.grid.getEditorLock().commitCurrentEdit();
            }
            else {
                this.args.commitChanges();
            }
        };
        FloatEditor.prototype.serializeValue = function () {
            var elmValue = this._$input.val();
            if (elmValue === '' || isNaN(elmValue)) {
                return elmValue;
            }
            var rtn = parseFloat(elmValue);
            var decPlaces = this.getDecimalPlaces();
            if (decPlaces !== null && (rtn || rtn === 0) && rtn.toFixed) {
                rtn = parseFloat(rtn.toFixed(decPlaces));
            }
            return rtn;
        };
        FloatEditor.prototype.validate = function (inputValue) {
            var elmValue = (inputValue !== undefined) ? inputValue : (this._$input && this._$input.val && this._$input.val());
            return floatValidator(elmValue, {
                editorArgs: this.args,
                errorMessage: this.columnEditor.errorMessage,
                decimal: this.getDecimalPlaces(),
                minValue: this.columnEditor.minValue,
                maxValue: this.columnEditor.maxValue,
                operatorConditionalType: this.columnEditor.operatorConditionalType,
                required: this.columnEditor.required,
                validator: this.validator,
            });
        };
        return FloatEditor;
    }());

    /*
     * An example of a 'detached' editor.
     * KeyDown events are also handled to provide handling for Tab, Shift-Tab, Esc and Ctrl-Enter.
     */
    var IntegerEditor = /** @class */ (function () {
        function IntegerEditor(args) {
            this.args = args;
            if (!args) {
                throw new Error('[Angular-SlickGrid] Something is wrong with this grid, an Editor must always have valid arguments.');
            }
            this.grid = args.grid;
            this.init();
        }
        Object.defineProperty(IntegerEditor.prototype, "columnDef", {
            /** Get Column Definition object */
            get: function () {
                return this.args && this.args.column;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IntegerEditor.prototype, "columnEditor", {
            /** Get Column Editor object */
            get: function () {
                return this.columnDef && this.columnDef.internalColumnEditor || {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IntegerEditor.prototype, "editorDomElement", {
            /** Get the Editor DOM Element */
            get: function () {
                return this._$input;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IntegerEditor.prototype, "hasAutoCommitEdit", {
            get: function () {
                return this.args && this.grid && this.grid.getOptions && this.grid.getOptions().autoCommitEdit;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IntegerEditor.prototype, "validator", {
            /** Get the Validator function, can be passed in Editor property or Column Definition */
            get: function () {
                return this.columnEditor.validator || this.columnDef.validator;
            },
            enumerable: true,
            configurable: true
        });
        IntegerEditor.prototype.init = function () {
            var _this = this;
            var columnId = this.columnDef && this.columnDef.id;
            var placeholder = this.columnEditor && this.columnEditor.placeholder || '';
            var title = this.columnEditor && this.columnEditor.title || '';
            this._$input = $("<input type=\"number\" role=\"presentation\" autocomplete=\"off\" class=\"editor-text editor-" + columnId + "\" placeholder=\"" + placeholder + "\" title=\"" + title + "\" />")
                .appendTo(this.args.container)
                .on('keydown.nav', function (event) {
                _this._lastInputEvent = event;
                if (event.keyCode === exports.KeyCode.LEFT || event.keyCode === exports.KeyCode.RIGHT) {
                    event.stopImmediatePropagation();
                }
            });
            // the lib does not get the focus out event for some reason
            // so register it here
            if (this.hasAutoCommitEdit) {
                this._$input.on('focusout', function () { return _this.save(); });
            }
            setTimeout(function () { return _this.focus(); }, 50);
        };
        IntegerEditor.prototype.destroy = function () {
            this._$input.off('keydown.nav focusout').remove();
            this._$input = null;
        };
        IntegerEditor.prototype.focus = function () {
            if (this._$input) {
                this._$input.focus();
            }
        };
        IntegerEditor.prototype.getValue = function () {
            return this._$input.val() || '';
        };
        IntegerEditor.prototype.setValue = function (value) {
            this._$input.val(value);
        };
        IntegerEditor.prototype.applyValue = function (item, state) {
            var fieldName = this.columnDef && this.columnDef.field;
            var isComplexObject = fieldName && fieldName.indexOf('.') > 0; // is the field a complex object, "address.streetNumber"
            // validate the value before applying it (if not valid we'll set an empty string)
            var validation = this.validate(state);
            var newValue = (validation && validation.valid) ? state : '';
            // set the new value to the item datacontext
            if (isComplexObject) {
                setDeepValue(item, fieldName, newValue);
            }
            else {
                item[fieldName] = newValue;
            }
        };
        IntegerEditor.prototype.isValueChanged = function () {
            var elmValue = this._$input.val();
            var lastKeyEvent = this._lastInputEvent && this._lastInputEvent.keyCode;
            if (this.columnEditor && this.columnEditor.alwaysSaveOnEnterKey && lastKeyEvent === exports.KeyCode.ENTER) {
                return true;
            }
            return (!(elmValue === '' && (this.originalValue === null || this.originalValue === undefined))) && (elmValue !== this.originalValue);
        };
        IntegerEditor.prototype.loadValue = function (item) {
            var fieldName = this.columnDef && this.columnDef.field;
            if (item && fieldName !== undefined) {
                // is the field a complex object, "address.streetNumber"
                var isComplexObject = fieldName && fieldName.indexOf('.') > 0;
                var value = (isComplexObject) ? getDescendantProperty(item, fieldName) : item[fieldName];
                this.originalValue = (isNaN(value) || value === null || value === undefined) ? value : "" + value;
                this._$input.val(this.originalValue);
                this._$input.select();
            }
        };
        IntegerEditor.prototype.save = function () {
            var validation = this.validate();
            var isValid = (validation && validation.valid) || false;
            if (this.hasAutoCommitEdit && isValid) {
                // do not use args.commitChanges() as this sets the focus to the next row.
                // also the select list will stay shown when clicking off the grid
                this.grid.getEditorLock().commitCurrentEdit();
            }
            else {
                this.args.commitChanges();
            }
        };
        IntegerEditor.prototype.serializeValue = function () {
            var elmValue = this._$input.val();
            if (elmValue === '' || isNaN(elmValue)) {
                return elmValue;
            }
            var output = isNaN(elmValue) ? elmValue : parseInt(elmValue, 10);
            return isNaN(output) ? elmValue : output;
        };
        IntegerEditor.prototype.validate = function (inputValue) {
            var elmValue = (inputValue !== undefined) ? inputValue : this.getValue();
            return integerValidator(elmValue, {
                editorArgs: this.args,
                errorMessage: this.columnEditor.errorMessage,
                minValue: this.columnEditor.minValue,
                maxValue: this.columnEditor.maxValue,
                operatorConditionalType: this.columnEditor.operatorConditionalType,
                required: this.columnEditor.required,
                validator: this.validator,
            });
        };
        return IntegerEditor;
    }());

    var DEFAULT_MAX_LENGTH = 500;
    /*
     * An example of a 'detached' editor.
     * The UI is added onto document BODY and .position(), .show() and .hide() are implemented.
     * KeyDown events are also handled to provide handling for Tab, Shift-Tab, Esc and Ctrl-Enter.
     */
    var LongTextEditor = /** @class */ (function () {
        function LongTextEditor(args) {
            this.args = args;
            if (!args) {
                throw new Error('[Angular-SlickGrid] Something is wrong with this grid, an Editor must always have valid arguments.');
            }
            this.grid = args.grid;
            this.gridOptions = args.grid && args.grid.getOptions();
            var options = this.gridOptions || this.args.column.params || {};
            if (options && options.i18n instanceof core$1.TranslateService) {
                this._translate = options.i18n;
            }
            // get locales provided by user in forRoot or else use default English locales via the Constants
            this._locales = this.gridOptions && this.gridOptions.locales || Constants.locales;
            this.init();
        }
        Object.defineProperty(LongTextEditor.prototype, "columnDef", {
            /** Get Column Definition object */
            get: function () {
                return this.args && this.args.column;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LongTextEditor.prototype, "columnEditor", {
            /** Get Column Editor object */
            get: function () {
                return this.columnDef && this.columnDef.internalColumnEditor || {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LongTextEditor.prototype, "editorDomElement", {
            /** Get the Editor DOM Element */
            get: function () {
                return this._$textarea;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LongTextEditor.prototype, "hasAutoCommitEdit", {
            get: function () {
                return this.grid.getOptions().autoCommitEdit;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LongTextEditor.prototype, "validator", {
            /** Get the Validator function, can be passed in Editor property or Column Definition */
            get: function () {
                return (this.columnEditor && this.columnEditor.validator) || (this.columnDef && this.columnDef.validator);
            },
            enumerable: true,
            configurable: true
        });
        LongTextEditor.prototype.init = function () {
            var _this = this;
            var cancelText = '';
            var saveText = '';
            if (this._translate && this._translate.instant && this._translate.currentLang) {
                var translationPrefix = getTranslationPrefix(this.gridOptions);
                cancelText = this._translate.instant(translationPrefix + "CANCEL");
                saveText = this._translate.instant(translationPrefix + "SAVE");
            }
            else {
                cancelText = this._locales && this._locales.TEXT_CANCEL;
                saveText = this._locales && this._locales.TEXT_SAVE;
            }
            var columnId = this.columnDef && this.columnDef.id;
            var placeholder = this.columnEditor && this.columnEditor.placeholder || '';
            var title = this.columnEditor && this.columnEditor.title || '';
            var maxLength = this.columnEditor && this.columnEditor.maxLength || DEFAULT_MAX_LENGTH;
            var textAreaRows = this.columnEditor && this.columnEditor.params && this.columnEditor.params.textAreaRows || 6;
            var $container = $('body');
            this._$wrapper = $("<div class=\"slick-large-editor-text editor-" + columnId + "\" />").appendTo($container);
            this._$textarea = $("<textarea hidefocus rows=\"" + textAreaRows + "\" placeholder=\"" + placeholder + "\" title=\"" + title + "\">").appendTo(this._$wrapper);
            var editorFooterElm = $("<div class=\"editor-footer\"/>");
            var countContainerElm = $("<span class=\"counter\"/>");
            this._$currentLengthElm = $("<span class=\"text-length\">0</span>");
            var textMaxLengthElm = $("<span>/</span><span class=\"max-length\">" + maxLength + "</span>");
            this._$currentLengthElm.appendTo(countContainerElm);
            textMaxLengthElm.appendTo(countContainerElm);
            var cancelBtnElm = $("<button class=\"btn btn-cancel btn-default btn-xs\">" + cancelText + "</button>");
            var saveBtnElm = $("<button class=\"btn btn-save btn-primary btn-xs\">" + saveText + "</button>");
            countContainerElm.appendTo(editorFooterElm);
            cancelBtnElm.appendTo(editorFooterElm);
            saveBtnElm.appendTo(editorFooterElm);
            editorFooterElm.appendTo(this._$wrapper);
            this._$wrapper.find('.btn-save').on('click', function () { return _this.save(); });
            this._$wrapper.find('.btn-cancel').on('click', function () { return _this.cancel(); });
            this._$textarea.on('keydown', this.handleKeyDown.bind(this));
            this._$textarea.on('input', this.handleOnInputChange.bind(this));
            this.position(this.args && this.args.position);
            this._$textarea.focus().select();
        };
        LongTextEditor.prototype.cancel = function () {
            var value = this.defaultValue || '';
            this._$textarea.val(value);
            this._$currentLengthElm.text(value.length);
            if (this.args && this.args.cancelChanges) {
                this.args.cancelChanges();
            }
        };
        LongTextEditor.prototype.hide = function () {
            this._$wrapper.hide();
        };
        LongTextEditor.prototype.show = function () {
            this._$wrapper.show();
        };
        LongTextEditor.prototype.destroy = function () {
            if (this._$textarea) {
                this._$textarea.off('keydown');
                this._$textarea.off('input');
            }
            if (this._$wrapper) {
                this._$wrapper.find('.btn-save').off('click');
                this._$wrapper.find('.btn-cancel').off('click');
                this._$wrapper.remove();
            }
            this._$wrapper = null;
        };
        LongTextEditor.prototype.focus = function () {
            this._$textarea.focus();
        };
        LongTextEditor.prototype.getValue = function () {
            return this._$textarea.val();
        };
        LongTextEditor.prototype.setValue = function (val) {
            this._$textarea.val(val);
            this._$currentLengthElm.text(val.length);
        };
        LongTextEditor.prototype.applyValue = function (item, state) {
            var fieldName = this.columnDef && this.columnDef.field;
            var isComplexObject = fieldName && fieldName.indexOf('.') > 0; // is the field a complex object, "address.streetNumber"
            // validate the value before applying it (if not valid we'll set an empty string)
            var validation = this.validate(state);
            var newValue = (validation && validation.valid) ? state : '';
            // set the new value to the item datacontext
            if (isComplexObject) {
                setDeepValue(item, fieldName, newValue);
            }
            else {
                item[fieldName] = newValue;
            }
        };
        LongTextEditor.prototype.isValueChanged = function () {
            var elmValue = this._$textarea.val();
            return (!(elmValue === '' && (this.defaultValue === null || this.defaultValue === undefined))) && (elmValue !== this.defaultValue);
        };
        LongTextEditor.prototype.loadValue = function (item) {
            var fieldName = this.columnDef && this.columnDef.field;
            if (item && fieldName !== undefined) {
                // is the field a complex object, "address.streetNumber"
                var isComplexObject = fieldName && fieldName.indexOf('.') > 0;
                var value = (isComplexObject) ? getDescendantProperty(item, fieldName) : item[fieldName];
                this.defaultValue = value || '';
                this._$textarea.val(this.defaultValue);
                this._$currentLengthElm.text(this.defaultValue.length);
                this._$textarea[0].defaultValue = this.defaultValue;
                this._$textarea.select();
            }
        };
        LongTextEditor.prototype.position = function (parentPosition) {
            var containerOffset = getHtmlElementOffset(this.args.container);
            this._$wrapper
                .css('top', (containerOffset.top || parentPosition.top || 0))
                .css('left', (containerOffset.left || parentPosition.left || 0));
        };
        LongTextEditor.prototype.save = function () {
            var validation = this.validate();
            var isValid = (validation && validation.valid) || false;
            if (this.hasAutoCommitEdit && isValid) {
                // do not use args.commitChanges() as this sets the focus to the next row.
                // also the select list will stay shown when clicking off the grid
                this.grid.getEditorLock().commitCurrentEdit();
            }
            else {
                this.args.commitChanges();
            }
        };
        LongTextEditor.prototype.serializeValue = function () {
            return this._$textarea.val();
        };
        LongTextEditor.prototype.validate = function (inputValue) {
            var elmValue = (inputValue !== undefined) ? inputValue : this._$textarea && this._$textarea.val && this._$textarea.val();
            return textValidator(elmValue, {
                editorArgs: this.args,
                errorMessage: this.columnEditor.errorMessage,
                minLength: this.columnEditor.minLength,
                maxLength: this.columnEditor.maxLength,
                operatorConditionalType: this.columnEditor.operatorConditionalType,
                required: this.columnEditor.required,
                validator: this.validator,
            });
        };
        // --
        // private functions
        // ------------------
        LongTextEditor.prototype.handleKeyDown = function (event) {
            var keyCode = event.keyCode || event.code;
            if (keyCode === exports.KeyCode.ENTER && event.ctrlKey) {
                this.save();
            }
            else if (keyCode === exports.KeyCode.ESCAPE) {
                event.preventDefault();
                this.cancel();
            }
            else if (keyCode === exports.KeyCode.TAB && event.shiftKey) {
                event.preventDefault();
                if (this.args && this.grid) {
                    this.grid.navigatePrev();
                }
            }
            else if (keyCode === exports.KeyCode.TAB) {
                event.preventDefault();
                if (this.args && this.grid) {
                    this.grid.navigateNext();
                }
            }
        };
        /** On every input change event, we'll update the current text length counter */
        LongTextEditor.prototype.handleOnInputChange = function (event) {
            var textLength = event.target.value.length;
            this._$currentLengthElm.text(textLength);
        };
        return LongTextEditor;
    }());

    var DOMPurify$4 = DOMPurify_; // patch to fix rollup to work
    /**
     * Slickgrid editor class for multiple/single select lists
     */
    var SelectEditor = /** @class */ (function () {
        function SelectEditor(args, isMultipleSelect) {
            var _this = this;
            this.args = args;
            this.isMultipleSelect = isMultipleSelect;
            /** Observable Subscriptions */
            this._subscriptions = [];
            // flag to signal that the editor is destroying itself, helps prevent
            // commit changes from being called twice and erroring
            this._destroying = false;
            if (!args) {
                throw new Error('[Angular-SlickGrid] Something is wrong with this grid, an Editor must always have valid arguments.');
            }
            this.grid = args.grid;
            this.gridOptions = (this.grid.getOptions() || {});
            var options = this.gridOptions || this.args.column.params || {};
            if (options && options.i18n instanceof core$1.TranslateService) {
                this._translate = options.i18n;
            }
            // get locales provided by user in main file or else use default English locales via the Constants
            this._locales = this.gridOptions.locales || Constants.locales;
            // provide the name attribute to the DOM element which will be needed to auto-adjust drop position (dropup / dropdown)
            var fieldId = this.columnDef && this.columnDef.id;
            this.elementName = "editor-" + fieldId;
            var libOptions = {
                autoAdjustDropHeight: true,
                autoAdjustDropPosition: true,
                autoAdjustDropWidthByTextSize: true,
                container: 'body',
                filter: false,
                maxHeight: 275,
                name: this.elementName,
                single: true,
                textTemplate: function ($elm) {
                    // render HTML code or not, by default it is sanitized and won't be rendered
                    var isRenderHtmlEnabled = _this.columnDef && _this.columnDef.internalColumnEditor && _this.columnDef.internalColumnEditor.enableRenderHtml || false;
                    return isRenderHtmlEnabled ? $elm.text() : $elm.html();
                },
                onClose: function () { return _this.save(); },
            };
            if (isMultipleSelect) {
                libOptions.single = false;
                libOptions.addTitle = true;
                libOptions.okButton = true;
                libOptions.selectAllDelimiter = ['', ''];
                if (this._translate && this._translate.instant && this._translate.currentLang) {
                    var translationPrefix = getTranslationPrefix(this.gridOptions);
                    libOptions.countSelected = this._translate.instant(translationPrefix + "X_OF_Y_SELECTED");
                    libOptions.allSelected = this._translate.instant(translationPrefix + "ALL_SELECTED");
                    libOptions.selectAllText = this._translate.instant(translationPrefix + "SELECT_ALL");
                    libOptions.okButtonText = this._translate.instant(translationPrefix + "OK");
                }
                else {
                    libOptions.countSelected = this._locales && this._locales.TEXT_X_OF_Y_SELECTED;
                    libOptions.allSelected = this._locales && this._locales.TEXT_ALL_SELECTED;
                    libOptions.selectAllText = this._locales && this._locales.TEXT_SELECT_ALL;
                    libOptions.okButtonText = this._locales && this._locales.TEXT_OK;
                }
            }
            // assign the multiple select lib options
            this.defaultOptions = libOptions;
            this.init();
        }
        Object.defineProperty(SelectEditor.prototype, "collection", {
            /** Get the Collection */
            get: function () {
                return this.columnDef && this.columnDef.internalColumnEditor.collection || [];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectEditor.prototype, "collectionOptions", {
            /** Getter for the Collection Options */
            get: function () {
                return this.columnDef && this.columnDef.internalColumnEditor && this.columnDef.internalColumnEditor.collectionOptions;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectEditor.prototype, "columnDef", {
            /** Get Column Definition object */
            get: function () {
                return this.args && this.args.column;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectEditor.prototype, "columnEditor", {
            /** Get Column Editor object */
            get: function () {
                return this.columnDef && this.columnDef.internalColumnEditor;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectEditor.prototype, "editorDomElement", {
            /** Get the Editor DOM Element */
            get: function () {
                return this.$editorElm;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectEditor.prototype, "customStructure", {
            /** Getter for the Custom Structure if exist */
            get: function () {
                return this.columnDef && this.columnDef.internalColumnEditor && this.columnDef.internalColumnEditor.customStructure;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectEditor.prototype, "hasAutoCommitEdit", {
            get: function () {
                return this.grid.getOptions().autoCommitEdit;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectEditor.prototype, "currentValues", {
            /**
             * The current selected values (multiple select) from the collection
             */
            get: function () {
                var _this = this;
                var elmValue = this.$editorElm.val();
                // collection of strings, just return the filtered string that are equals
                if (this.collection.every(function (x) { return typeof x === 'string'; })) {
                    return this.collection.filter(function (c) { return elmValue.indexOf(c.toString()) !== -1; });
                }
                // collection of label/value pair
                var separatorBetweenLabels = this.collectionOptions && this.collectionOptions.separatorBetweenTextLabels || '';
                var isIncludingPrefixSuffix = this.collectionOptions && this.collectionOptions.includePrefixSuffixToSelectedValues || false;
                return this.collection
                    .filter(function (c) { return elmValue.indexOf(c.hasOwnProperty(_this.valueName) && c[_this.valueName] !== null && c[_this.valueName].toString()) !== -1; })
                    .map(function (c) {
                    var labelText = c[_this.valueName];
                    var prefixText = c[_this.labelPrefixName] || '';
                    var suffixText = c[_this.labelSuffixName] || '';
                    // when it's a complex object, then pull the object name only, e.g.: "user.firstName" => "user"
                    var fieldName = _this.columnDef && _this.columnDef.field;
                    // is the field a complex object, "address.streetNumber"
                    var isComplexObject = fieldName && fieldName.indexOf('.') > 0;
                    if (isComplexObject && typeof c === 'object') {
                        return c;
                    }
                    // also translate prefix/suffix if enableTranslateLabel is true and text is a string
                    prefixText = (_this.enableTranslateLabel && prefixText && typeof prefixText === 'string') ? _this._translate.instant(prefixText || ' ') : prefixText;
                    suffixText = (_this.enableTranslateLabel && suffixText && typeof suffixText === 'string') ? _this._translate.instant(suffixText || ' ') : suffixText;
                    if (isIncludingPrefixSuffix) {
                        var tmpOptionArray = [prefixText, labelText, suffixText].filter(function (text) { return text; }); // add to a temp array for joining purpose and filter out empty text
                        return tmpOptionArray.join(separatorBetweenLabels);
                    }
                    return labelText;
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectEditor.prototype, "currentValue", {
            /**
             * The current selected values (single select) from the collection
             */
            get: function () {
                var _this = this;
                var elmValue = this.$editorElm.val();
                // collection of strings, just return the filtered string that are equals
                if (this.collection.every(function (x) { return typeof x === 'string'; })) {
                    return findOrDefault(this.collection, function (c) { return c.toString() === elmValue; });
                }
                // collection of label/value pair
                var separatorBetweenLabels = this.collectionOptions && this.collectionOptions.separatorBetweenTextLabels || '';
                var isIncludingPrefixSuffix = this.collectionOptions && this.collectionOptions.includePrefixSuffixToSelectedValues || false;
                var itemFound = findOrDefault(this.collection, function (c) { return c.hasOwnProperty(_this.valueName) && c[_this.valueName] !== null && c[_this.valueName].toString() === elmValue; });
                // is the field a complex object, "address.streetNumber"
                var fieldName = this.columnDef && this.columnDef.field;
                var isComplexObject = fieldName && fieldName.indexOf('.') > 0;
                if (isComplexObject && typeof itemFound === 'object') {
                    return itemFound;
                }
                else if (itemFound && itemFound.hasOwnProperty(this.valueName)) {
                    var labelText = itemFound[this.valueName];
                    if (isIncludingPrefixSuffix) {
                        var prefixText = itemFound[this.labelPrefixName] || '';
                        var suffixText = itemFound[this.labelSuffixName] || '';
                        // also translate prefix/suffix if enableTranslateLabel is true and text is a string
                        prefixText = (this.enableTranslateLabel && prefixText && typeof prefixText === 'string') ? this._translate.instant(prefixText || ' ') : prefixText;
                        suffixText = (this.enableTranslateLabel && suffixText && typeof suffixText === 'string') ? this._translate.instant(suffixText || ' ') : suffixText;
                        // add to a temp array for joining purpose and filter out empty text
                        var tmpOptionArray = [prefixText, labelText, suffixText].filter(function (text) { return text; });
                        return tmpOptionArray.join(separatorBetweenLabels);
                    }
                    return labelText;
                }
                return '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectEditor.prototype, "validator", {
            /** Get the Validator function, can be passed in Editor property or Column Definition */
            get: function () {
                return this.columnEditor.validator || this.columnDef.validator;
            },
            enumerable: true,
            configurable: true
        });
        SelectEditor.prototype.init = function () {
            if (!this.columnDef || !this.columnDef.internalColumnEditor || (!this.columnDef.internalColumnEditor.collection && !this.columnDef.internalColumnEditor.collectionAsync)) {
                throw new Error("[Angular-SlickGrid] You need to pass a \"collection\" (or \"collectionAsync\") inside Column Definition Editor for the MultipleSelect/SingleSelect Editor to work correctly.\n      Also each option should include a value/label pair (or value/labelKey when using Locale).\n      For example: { editor: { collection: [{ value: true, label: 'True' },{ value: false, label: 'False'}] } }");
            }
            this._collectionService = new CollectionService(this._translate);
            this.enableTranslateLabel = (this.columnDef.internalColumnEditor.enableTranslateLabel) ? this.columnDef.internalColumnEditor.enableTranslateLabel : false;
            this.labelName = this.customStructure && this.customStructure.label || 'label';
            this.labelPrefixName = this.customStructure && this.customStructure.labelPrefix || 'labelPrefix';
            this.labelSuffixName = this.customStructure && this.customStructure.labelSuffix || 'labelSuffix';
            this.optionLabel = this.customStructure && this.customStructure.optionLabel || 'value';
            this.valueName = this.customStructure && this.customStructure.value || 'value';
            if (this.enableTranslateLabel && (!this._translate || typeof this._translate.instant !== 'function')) {
                throw new Error('[Angular-Slickgrid] requires "ngx-translate" to be installed and configured when the grid option "enableTranslate" is enabled.');
            }
            // always render the Select (dropdown) DOM element, even if user passed a "collectionAsync",
            // if that is the case, the Select will simply be without any options but we still have to render it (else SlickGrid would throw an error)
            this.renderDomElement(this.collection);
        };
        SelectEditor.prototype.getValue = function () {
            return (this.isMultipleSelect) ? this.currentValues : this.currentValue;
        };
        SelectEditor.prototype.setValue = function (value) {
            if (this.isMultipleSelect && Array.isArray(value)) {
                this.loadMultipleValues(value);
            }
            else {
                this.loadSingleValue(value);
            }
        };
        SelectEditor.prototype.hide = function () {
            if (this.$editorElm && typeof this.$editorElm.multipleSelect === 'function') {
                this.$editorElm.multipleSelect('close');
            }
        };
        SelectEditor.prototype.show = function () {
            if (this.$editorElm && typeof this.$editorElm.multipleSelect === 'function') {
                this.$editorElm.multipleSelect('open');
            }
        };
        SelectEditor.prototype.applyValue = function (item, state) {
            var fieldName = this.columnDef && this.columnDef.field;
            var fieldType = this.columnDef && this.columnDef.type;
            var newValue = state;
            // when the provided user defined the column field type as a possible number then try parsing the state value as that
            if (fieldType === exports.FieldType.number || fieldType === exports.FieldType.integer || fieldType === exports.FieldType.boolean) {
                newValue = parseFloat(state);
            }
            // when set as a multiple selection, we can assume that the 3rd party lib multiple-select will return a CSV string
            // we need to re-split that into an array to be the same as the original column
            if (this.isMultipleSelect && typeof state === 'string' && state.indexOf(',') >= 0) {
                newValue = state.split(',');
            }
            // is the field a complex object, "user.address.streetNumber"
            var isComplexObject = fieldName && fieldName.indexOf('.') > 0;
            // validate the value before applying it (if not valid we'll set an empty string)
            var validation = this.validate(newValue);
            newValue = (validation && validation.valid) ? newValue : '';
            // set the new value to the item datacontext
            if (isComplexObject) {
                // when it's a complex object, user could override the object path (where the editable object is located)
                // else we use the path provided in the Field Column Definition
                var objectPath = this.columnEditor && this.columnEditor.complexObjectPath || fieldName;
                setDeepValue(item, objectPath, newValue);
            }
            else {
                item[fieldName] = newValue;
            }
        };
        SelectEditor.prototype.destroy = function () {
            this._destroying = true;
            if (this.$editorElm && typeof this.$editorElm.multipleSelect === 'function') {
                this.$editorElm.multipleSelect('destroy');
                this.$editorElm.remove();
                var elementClassName = this.elementName.toString().replace('.', '\\.'); // make sure to escape any dot "." from CSS class to avoid console error
                $("[name=" + elementClassName + "].ms-drop").remove();
                this.$editorElm.remove();
                this.$editorElm = null;
            }
        };
        SelectEditor.prototype.loadValue = function (item) {
            var fieldName = this.columnDef && this.columnDef.field;
            if (item && fieldName !== undefined) {
                // is the field a complex object, "address.streetNumber"
                var isComplexObject = fieldName && fieldName.indexOf('.') > 0;
                // when it's a complex object, user could override the object path (where the editable object is located)
                // else we use the path provided in the Field Column Definition
                var objectPath = this.columnEditor && this.columnEditor.complexObjectPath || fieldName;
                var currentValue = (isComplexObject) ? getDescendantProperty(item, objectPath) : item[fieldName];
                var value = (isComplexObject && currentValue.hasOwnProperty(this.valueName)) ? currentValue[this.valueName] : currentValue;
                if (this.isMultipleSelect && Array.isArray(value)) {
                    this.loadMultipleValues(value);
                }
                else {
                    this.loadSingleValue(value);
                }
                this.refresh();
            }
        };
        SelectEditor.prototype.loadMultipleValues = function (currentValues) {
            // convert to string because that is how the DOM will return these values
            if (Array.isArray(currentValues)) {
                // keep the default values in memory for references
                this.originalValue = currentValues.map(function (i) { return i; });
                // compare all the array values but as string type since multiple-select always return string
                var currentStringValues_1 = currentValues.map(function (i) { return i.toString(); });
                this.$editorElm.find('option').each(function (i, $e) {
                    $e.selected = (currentStringValues_1.indexOf($e.value) !== -1);
                });
            }
        };
        SelectEditor.prototype.loadSingleValue = function (currentValue) {
            // keep the default value in memory for references
            this.originalValue = typeof currentValue === 'number' ? "" + currentValue : currentValue;
            this.$editorElm.val(currentValue);
            // make sure the prop exists first
            this.$editorElm.find('option').each(function (i, $e) {
                // check equality after converting originalValue to string since the DOM value will always be of type string
                $e.selected = ("" + currentValue === $e.value);
            });
        };
        SelectEditor.prototype.save = function () {
            var validation = this.validate();
            var isValid = (validation && validation.valid) || false;
            if (!this._destroying && this.hasAutoCommitEdit && isValid) {
                // do not use args.commitChanges() as this sets the focus to the next row.
                // also the select list will stay shown when clicking off the grid
                this.grid.getEditorLock().commitCurrentEdit();
            }
            else {
                this.args.commitChanges();
            }
        };
        SelectEditor.prototype.serializeValue = function () {
            return (this.isMultipleSelect) ? this.currentValues : this.currentValue;
        };
        SelectEditor.prototype.focus = function () {
            if (this.$editorElm && this.$editorElm.multipleSelect) {
                this.$editorElm.multipleSelect('focus');
            }
        };
        SelectEditor.prototype.isValueChanged = function () {
            if (this.isMultipleSelect) {
                return !charArraysEqual(this.$editorElm.val(), this.originalValue);
            }
            return this.$editorElm.val() !== this.originalValue;
        };
        SelectEditor.prototype.validate = function (inputValue) {
            var isRequired = this.columnEditor.required;
            var elmValue = (inputValue !== undefined) ? inputValue : this.$editorElm && this.$editorElm.val && this.$editorElm.val();
            var errorMsg = this.columnEditor.errorMessage;
            if (this.validator) {
                var value = (inputValue !== undefined) ? inputValue : (this.isMultipleSelect ? this.currentValues : this.currentValue);
                return this.validator(value, this.args);
            }
            // by default the editor is almost always valid (except when it's required but not provided)
            if (isRequired && (elmValue === '' || (Array.isArray(elmValue) && elmValue.length === 0))) {
                return {
                    valid: false,
                    msg: errorMsg || Constants.VALIDATION_REQUIRED_FIELD
                };
            }
            return {
                valid: true,
                msg: null
            };
        };
        //
        // protected functions
        // ------------------
        /**
         * user might want to filter certain items of the collection
         * @param inputCollection
         * @return outputCollection filtered and/or sorted collection
         */
        SelectEditor.prototype.filterCollection = function (inputCollection) {
            var outputCollection = inputCollection;
            // user might want to filter certain items of the collection
            if (this.columnEditor && this.columnEditor.collectionFilterBy) {
                var filterBy = this.columnEditor.collectionFilterBy;
                var filterCollectionBy = this.columnEditor.collectionOptions && this.columnEditor.collectionOptions.filterResultAfterEachPass || null;
                outputCollection = this._collectionService.filterCollection(outputCollection, filterBy, filterCollectionBy);
            }
            return outputCollection;
        };
        /**
         * user might want to sort the collection in a certain way
         * @param inputCollection
         * @return outputCollection sorted collection
         */
        SelectEditor.prototype.sortCollection = function (inputCollection) {
            var outputCollection = inputCollection;
            // user might want to sort the collection
            if (this.columnDef.internalColumnEditor && this.columnDef.internalColumnEditor.collectionSortBy) {
                var sortBy = this.columnDef.internalColumnEditor.collectionSortBy;
                outputCollection = this._collectionService.sortCollection(this.columnDef, outputCollection, sortBy, this.enableTranslateLabel);
            }
            return outputCollection;
        };
        SelectEditor.prototype.renderDomElement = function (inputCollection) {
            if (!Array.isArray(inputCollection) && this.collectionOptions && (this.collectionOptions.collectionInsideObjectProperty || this.collectionOptions.collectionInObjectProperty)) {
                var collectionInsideObjectProperty = this.collectionOptions.collectionInsideObjectProperty || this.collectionOptions.collectionInObjectProperty;
                inputCollection = getDescendantProperty(inputCollection, collectionInsideObjectProperty);
            }
            if (!Array.isArray(inputCollection)) {
                throw new Error('The "collection" passed to the Select Editor is not a valid array.');
            }
            // make a copy of the collection so that we don't impact SelectFilter, this could happen when calling "addBlankEntry" or "addCustomFirstEntry"
            var collection = [];
            if (inputCollection.length > 0) {
                collection = __spread(inputCollection);
            }
            // user can optionally add a blank entry at the beginning of the collection
            // make sure however that it wasn't added more than once
            if (this.collectionOptions && this.collectionOptions.addBlankEntry && Array.isArray(collection) && collection.length > 0 && collection[0][this.valueName] !== '') {
                collection.unshift(this.createBlankEntry());
            }
            // user can optionally add his own custom entry at the beginning of the collection
            if (this.collectionOptions && this.collectionOptions.addCustomFirstEntry && Array.isArray(collection) && collection.length > 0 && collection[0][this.valueName] !== this.collectionOptions.addCustomFirstEntry[this.valueName]) {
                collection.unshift(this.collectionOptions && this.collectionOptions.addCustomFirstEntry);
            }
            // user can optionally add his own custom entry at the end of the collection
            if (this.collectionOptions && this.collectionOptions.addCustomLastEntry && Array.isArray(collection) && collection.length > 0) {
                var lastCollectionIndex = collection.length - 1;
                if (collection[lastCollectionIndex][this.valueName] !== this.collectionOptions.addCustomLastEntry[this.valueName]) {
                    collection.push(this.collectionOptions && this.collectionOptions.addCustomLastEntry);
                }
            }
            var newCollection = collection || [];
            // user might want to filter and/or sort certain items of the collection
            newCollection = this.filterCollection(newCollection);
            newCollection = this.sortCollection(newCollection);
            // step 1, create HTML string template
            var editorTemplate = this.buildTemplateHtmlString(newCollection);
            // step 2, create the DOM Element of the editor
            // also subscribe to the onClose event
            this.createDomElement(editorTemplate);
        };
        SelectEditor.prototype.buildTemplateHtmlString = function (collection) {
            var _this = this;
            var options = '';
            var fieldId = this.columnDef && this.columnDef.id;
            var separatorBetweenLabels = this.collectionOptions && this.collectionOptions.separatorBetweenTextLabels || '';
            var isRenderHtmlEnabled = this.columnDef.internalColumnEditor.enableRenderHtml || false;
            var sanitizedOptions = this.gridOptions && this.gridOptions.sanitizeHtmlOptions || {};
            // collection could be an Array of Strings OR Objects
            if (collection.every(function (x) { return typeof x === 'string'; })) {
                collection.forEach(function (option) {
                    options += "<option value=\"" + option + "\" label=\"" + option + "\">" + option + "</option>";
                });
            }
            else {
                // array of objects will require a label/value pair unless a customStructure is passed
                collection.forEach(function (option) {
                    if (!option || (option[_this.labelName] === undefined && option.labelKey === undefined)) {
                        throw new Error("[select-editor] A collection with value/label (or value/labelKey when using Locale) is required to populate the Select list, for example: { collection: [ { value: '1', label: 'One' } ])");
                    }
                    var labelKey = (option.labelKey || option[_this.labelName]);
                    var labelText = ((option.labelKey || _this.enableTranslateLabel) && labelKey) ? _this._translate.instant(labelKey || ' ') : labelKey;
                    var prefixText = option[_this.labelPrefixName] || '';
                    var suffixText = option[_this.labelSuffixName] || '';
                    var optionLabel = option[_this.optionLabel] || '';
                    if (optionLabel && optionLabel.toString) {
                        optionLabel = optionLabel.toString().replace(/\"/g, '\''); // replace double quotes by single quotes to avoid interfering with regular html
                    }
                    // also translate prefix/suffix if enableTranslateLabel is true and text is a string
                    prefixText = (_this.enableTranslateLabel && prefixText && typeof prefixText === 'string') ? _this._translate.instant(prefixText || ' ') : prefixText;
                    suffixText = (_this.enableTranslateLabel && suffixText && typeof suffixText === 'string') ? _this._translate.instant(suffixText || ' ') : suffixText;
                    optionLabel = (_this.enableTranslateLabel && optionLabel && typeof optionLabel === 'string') ? _this._translate.instant(optionLabel || ' ') : optionLabel;
                    // add to a temp array for joining purpose and filter out empty text
                    var tmpOptionArray = [prefixText, labelText, suffixText].filter(function (text) { return (text !== undefined && text !== ''); });
                    var optionText = tmpOptionArray.join(separatorBetweenLabels);
                    // if user specifically wants to render html text, he needs to opt-in else it will stripped out by default
                    // also, the 3rd party lib will saninitze any html code unless it's encoded, so we'll do that
                    if (isRenderHtmlEnabled) {
                        // sanitize any unauthorized html tags like script and others
                        // for the remaining allowed tags we'll permit all attributes
                        var sanitizedText = (DOMPurify$4.sanitize(optionText, sanitizedOptions) || '').toString();
                        optionText = htmlEncode(sanitizedText);
                    }
                    // html text of each select option
                    var optionValue = option[_this.valueName];
                    if (optionValue === undefined || optionValue === null) {
                        optionValue = '';
                    }
                    options += "<option value=\"" + optionValue + "\" label=\"" + optionLabel + "\">" + optionText + "</option>";
                });
            }
            return "<select id=\"" + this.elementName + "\" class=\"ms-filter search-filter editor-" + fieldId + "\" " + (this.isMultipleSelect ? 'multiple="multiple"' : '') + ">" + options + "</select>";
        };
        /** Create a blank entry that can be added to the collection. It will also reuse the same customStructure if need be */
        SelectEditor.prototype.createBlankEntry = function () {
            var _a;
            var blankEntry = (_a = {},
                _a[this.labelName] = '',
                _a[this.valueName] = '',
                _a);
            if (this.labelPrefixName) {
                blankEntry[this.labelPrefixName] = '';
            }
            if (this.labelSuffixName) {
                blankEntry[this.labelSuffixName] = '';
            }
            return blankEntry;
        };
        /** Build the template HTML string */
        SelectEditor.prototype.createDomElement = function (editorTemplate) {
            var _this = this;
            this.$editorElm = $(editorTemplate);
            if (this.$editorElm && typeof this.$editorElm.appendTo === 'function') {
                this.$editorElm.appendTo(this.args.container);
            }
            // add placeholder when found
            var placeholder = this.columnEditor && this.columnEditor.placeholder || '';
            this.defaultOptions.placeholder = placeholder || '';
            if (typeof this.$editorElm.multipleSelect === 'function') {
                var elementOptions = (this.columnDef.internalColumnEditor) ? this.columnDef.internalColumnEditor.elementOptions : {};
                var editorOptions = (this.columnDef && this.columnDef.internalColumnEditor) ? this.columnDef.internalColumnEditor.editorOptions : {};
                this.editorElmOptions = __assign({}, this.defaultOptions, elementOptions, editorOptions);
                this.$editorElm = this.$editorElm.multipleSelect(this.editorElmOptions);
                setTimeout(function () { return _this.show(); });
            }
        };
        // refresh the jquery object because the selected checkboxes were already set
        // prior to this method being called
        SelectEditor.prototype.refresh = function () {
            if (typeof this.$editorElm.multipleSelect === 'function') {
                this.$editorElm.multipleSelect('refresh');
            }
        };
        return SelectEditor;
    }());

    var MultipleSelectEditor = /** @class */ (function (_super) {
        __extends(MultipleSelectEditor, _super);
        /**
         * Initialize the Editor
         */
        function MultipleSelectEditor(args) {
            var _this = _super.call(this, args, true) || this;
            _this.args = args;
            return _this;
        }
        return MultipleSelectEditor;
    }(SelectEditor));

    var SingleSelectEditor = /** @class */ (function (_super) {
        __extends(SingleSelectEditor, _super);
        /**
         * Initialize the Editor
         */
        function SingleSelectEditor(args) {
            var _this = _super.call(this, args, false) || this;
            _this.args = args;
            return _this;
        }
        return SingleSelectEditor;
    }(SelectEditor));

    var DEFAULT_MIN_VALUE$3 = 0;
    var DEFAULT_MAX_VALUE$3 = 100;
    var DEFAULT_STEP$3 = 1;
    var SliderEditor = /** @class */ (function () {
        function SliderEditor(args) {
            this.args = args;
            if (!args) {
                throw new Error('[Angular-SlickGrid] Something is wrong with this grid, an Editor must always have valid arguments.');
            }
            this.grid = args.grid;
            this.init();
        }
        Object.defineProperty(SliderEditor.prototype, "columnDef", {
            /** Get Column Definition object */
            get: function () {
                return this.args && this.args.column;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SliderEditor.prototype, "columnEditor", {
            /** Get Column Editor object */
            get: function () {
                return this.columnDef && this.columnDef.internalColumnEditor || {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SliderEditor.prototype, "editorDomElement", {
            /** Get the Editor DOM Element */
            get: function () {
                return this._$input;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SliderEditor.prototype, "hasAutoCommitEdit", {
            get: function () {
                return this.grid && this.grid.getOptions && this.grid.getOptions().autoCommitEdit;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SliderEditor.prototype, "editorParams", {
            /** Getter for the Editor Generic Params */
            get: function () {
                return this.columnEditor.params || {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SliderEditor.prototype, "validator", {
            /** Get the Validator function, can be passed in Editor property or Column Definition */
            get: function () {
                return this.columnEditor.validator || this.columnDef.validator;
            },
            enumerable: true,
            configurable: true
        });
        SliderEditor.prototype.init = function () {
            var _this = this;
            var container = this.args && this.args.container;
            // define the input & slider number IDs
            var itemId = this.args && this.args.item && this.args.item.id;
            this._elementRangeInputId = "rangeInput_" + this.columnDef.field + "_" + itemId;
            this._elementRangeOutputId = "rangeOutput_" + this.columnDef.field + "_" + itemId;
            // create HTML string template
            var editorTemplate = this.buildTemplateHtmlString();
            this._$editorElm = $(editorTemplate);
            this._$input = this._$editorElm.children('input');
            this.$sliderNumber = this._$editorElm.children('div.input-group-addon.input-group-append').children();
            this.focus();
            // watch on change event
            this._$editorElm
                .appendTo(container)
                .on('mouseup', function () { return _this.save(); });
            // if user chose to display the slider number on the right side, then update it every time it changes
            // we need to use both "input" and "change" event to be all cross-browser
            if (!this.editorParams.hideSliderNumber) {
                this._$editorElm.on('input change', function (event) {
                    var value = event && event.target && event.target.value || '';
                    if (value) {
                        var elements = document.getElementsByClassName(_this._elementRangeOutputId);
                        if (elements.length) {
                            elements[0].innerHTML = event.target.value;
                        }
                    }
                });
            }
        };
        SliderEditor.prototype.cancel = function () {
            this._$input.val(this.originalValue);
            this.args.cancelChanges();
        };
        SliderEditor.prototype.destroy = function () {
            if (this._$editorElm) {
                this._$editorElm.off('input change mouseup touchend').remove();
                this._$editorElm = null;
            }
        };
        SliderEditor.prototype.focus = function () {
            this._$editorElm.focus();
        };
        SliderEditor.prototype.getValue = function () {
            return this._$input.val() || '';
        };
        SliderEditor.prototype.setValue = function (value) {
            this._$input.val(value);
        };
        SliderEditor.prototype.applyValue = function (item, state) {
            var fieldName = this.columnDef && this.columnDef.field;
            var isComplexObject = fieldName && fieldName.indexOf('.') > 0; // is the field a complex object, "address.streetNumber"
            var validation = this.validate(state);
            var newValue = (validation && validation.valid) ? state : '';
            // set the new value to the item datacontext
            if (isComplexObject) {
                setDeepValue(item, fieldName, newValue);
            }
            else {
                item[fieldName] = newValue;
            }
        };
        SliderEditor.prototype.isValueChanged = function () {
            var elmValue = this._$input.val();
            return (!(elmValue === '' && this.originalValue === undefined)) && (+elmValue !== this.originalValue);
        };
        SliderEditor.prototype.loadValue = function (item) {
            var fieldName = this.columnDef && this.columnDef.field;
            if (item && fieldName !== undefined) {
                // is the field a complex object, "address.streetNumber"
                var isComplexObject = fieldName && fieldName.indexOf('.') > 0;
                var value = (isComplexObject) ? getDescendantProperty(item, fieldName) : item[fieldName];
                if (value === '' || value === null || value === undefined) {
                    value = this.defaultValue; // load default value when item doesn't have any value
                }
                this.originalValue = +value;
                this._$input.val(value);
                this.$sliderNumber.html(value);
            }
        };
        SliderEditor.prototype.save = function () {
            var validation = this.validate();
            var isValid = (validation && validation.valid) || false;
            if (this.hasAutoCommitEdit && isValid) {
                // do not use args.commitChanges() as this sets the focus to the next row.
                // also the select list will stay shown when clicking off the grid
                this.grid.getEditorLock().commitCurrentEdit();
            }
            else {
                this.args.commitChanges();
            }
        };
        SliderEditor.prototype.serializeValue = function () {
            var elmValue = this._$input.val();
            return elmValue !== '' ? parseInt(elmValue, 10) : this.originalValue;
        };
        SliderEditor.prototype.validate = function (inputValue) {
            var elmValue = (inputValue !== undefined) ? inputValue : this._$input && this._$input.val();
            return sliderValidator(elmValue, {
                editorArgs: this.args,
                errorMessage: this.columnEditor.errorMessage,
                minValue: this.columnEditor.minValue,
                maxValue: this.columnEditor.maxValue,
                required: this.columnEditor.required,
                validator: this.validator,
            });
        };
        //
        // private functions
        // ------------------
        /**
         * Create the HTML template as a string
         */
        SliderEditor.prototype.buildTemplateHtmlString = function () {
            var fieldId = this.columnDef && this.columnDef.id;
            var title = this.columnEditor && this.columnEditor.title || '';
            var minValue = this.columnEditor.hasOwnProperty('minValue') ? this.columnEditor.minValue : DEFAULT_MIN_VALUE$3;
            var maxValue = this.columnEditor.hasOwnProperty('maxValue') ? this.columnEditor.maxValue : DEFAULT_MAX_VALUE$3;
            var defaultValue = this.editorParams.hasOwnProperty('sliderStartValue') ? this.editorParams.sliderStartValue : minValue;
            var step = this.columnEditor.hasOwnProperty('valueStep') ? this.columnEditor.valueStep : DEFAULT_STEP$3;
            this.defaultValue = defaultValue;
            if (this.editorParams.hideSliderNumber) {
                return "\n      <div class=\"slider-container slider-editor\">\n        <input type=\"range\" name=\"" + this._elementRangeInputId + "\" title=\"" + title + "\"\n          defaultValue=\"" + defaultValue + "\" value=\"" + defaultValue + "\"\n          min=\"" + minValue + "\" max=\"" + maxValue + "\" step=\"" + step + "\"\n          class=\"form-control slider-editor-input editor-" + fieldId + " range " + this._elementRangeInputId + "\" />\n      </div>";
            }
            return "\n      <div class=\"input-group slider-container slider-editor\">\n        <input type=\"range\" name=\"" + this._elementRangeInputId + "\" title=\"" + title + "\"\n          defaultValue=\"" + defaultValue + "\" value=\"" + defaultValue + "\"\n          min=\"" + minValue + "\" max=\"" + maxValue + "\" step=\"" + step + "\"\n          class=\"form-control slider-editor-input editor-" + fieldId + " range " + this._elementRangeInputId + "\" />\n        <div class=\"input-group-addon input-group-append slider-value\"><span class=\"input-group-text " + this._elementRangeOutputId + "\">" + defaultValue + "</span></div>\n      </div>";
        };
        return SliderEditor;
    }());

    /*
     * An example of a 'detached' editor.
     * KeyDown events are also handled to provide handling for Tab, Shift-Tab, Esc and Ctrl-Enter.
     */
    var TextEditor = /** @class */ (function () {
        function TextEditor(args) {
            this.args = args;
            if (!args) {
                throw new Error('[Angular-SlickGrid] Something is wrong with this grid, an Editor must always have valid arguments.');
            }
            this.grid = args.grid;
            this.init();
        }
        Object.defineProperty(TextEditor.prototype, "columnDef", {
            /** Get Column Definition object */
            get: function () {
                return this.args && this.args.column;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextEditor.prototype, "columnEditor", {
            /** Get Column Editor object */
            get: function () {
                return this.columnDef && this.columnDef.internalColumnEditor || {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextEditor.prototype, "editorDomElement", {
            /** Get the Editor DOM Element */
            get: function () {
                return this._$input;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextEditor.prototype, "hasAutoCommitEdit", {
            get: function () {
                return this.grid.getOptions().autoCommitEdit;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextEditor.prototype, "validator", {
            /** Get the Validator function, can be passed in Editor property or Column Definition */
            get: function () {
                return this.columnEditor.validator || this.columnDef.validator;
            },
            enumerable: true,
            configurable: true
        });
        TextEditor.prototype.init = function () {
            var _this = this;
            var columnId = this.columnDef && this.columnDef.id;
            var placeholder = this.columnEditor && this.columnEditor.placeholder || '';
            var title = this.columnEditor && this.columnEditor.title || '';
            this._$input = $("<input type=\"text\" role=\"presentation\"  autocomplete=\"off\" class=\"editor-text editor-" + columnId + "\" placeholder=\"" + placeholder + "\" title=\"" + title + "\" />")
                .appendTo(this.args.container)
                .on('keydown.nav', function (event) {
                _this._lastInputEvent = event;
                if (event.keyCode === exports.KeyCode.LEFT || event.keyCode === exports.KeyCode.RIGHT) {
                    event.stopImmediatePropagation();
                }
            });
            // the lib does not get the focus out event for some reason
            // so register it here
            if (this.hasAutoCommitEdit) {
                this._$input.on('focusout', function () { return _this.save(); });
            }
            setTimeout(function () { return _this.focus(); }, 50);
        };
        TextEditor.prototype.destroy = function () {
            this._$input.off('keydown.nav focusout').remove();
            this._$input = null;
        };
        TextEditor.prototype.focus = function () {
            if (this._$input) {
                this._$input.focus();
            }
        };
        TextEditor.prototype.getValue = function () {
            return this._$input.val();
        };
        TextEditor.prototype.setValue = function (val) {
            this._$input.val(val);
        };
        TextEditor.prototype.applyValue = function (item, state) {
            var fieldName = this.columnDef && this.columnDef.field;
            var isComplexObject = fieldName && fieldName.indexOf('.') > 0; // is the field a complex object, "address.streetNumber"
            // validate the value before applying it (if not valid we'll set an empty string)
            var validation = this.validate(state);
            var newValue = (validation && validation.valid) ? state : '';
            // set the new value to the item datacontext
            if (isComplexObject) {
                setDeepValue(item, fieldName, newValue);
            }
            else {
                item[fieldName] = newValue;
            }
        };
        TextEditor.prototype.isValueChanged = function () {
            var elmValue = this._$input.val();
            var lastKeyEvent = this._lastInputEvent && this._lastInputEvent.keyCode;
            if (this.columnEditor && this.columnEditor.alwaysSaveOnEnterKey && lastKeyEvent === exports.KeyCode.ENTER) {
                return true;
            }
            return (!(elmValue === '' && (this.originalValue === null || this.originalValue === undefined))) && (elmValue !== this.originalValue);
        };
        TextEditor.prototype.loadValue = function (item) {
            var fieldName = this.columnDef && this.columnDef.field;
            if (item && fieldName !== undefined) {
                // is the field a complex object, "address.streetNumber"
                var isComplexObject = fieldName && fieldName.indexOf('.') > 0;
                var value = (isComplexObject) ? getDescendantProperty(item, fieldName) : item[fieldName];
                this.originalValue = value;
                this._$input.val(this.originalValue);
                this._$input.select();
            }
        };
        TextEditor.prototype.save = function () {
            var validation = this.validate();
            var isValid = (validation && validation.valid) || false;
            if (this.hasAutoCommitEdit && isValid) {
                // do not use args.commitChanges() as this sets the focus to the next row.
                // also the select list will stay shown when clicking off the grid
                this.grid.getEditorLock().commitCurrentEdit();
            }
            else {
                this.args.commitChanges();
            }
        };
        TextEditor.prototype.serializeValue = function () {
            return this._$input.val();
        };
        TextEditor.prototype.validate = function (inputValue) {
            var elmValue = (inputValue !== undefined) ? inputValue : this._$input && this._$input.val();
            return textValidator(elmValue, {
                editorArgs: this.args,
                errorMessage: this.columnEditor.errorMessage,
                minLength: this.columnEditor.minLength,
                maxLength: this.columnEditor.maxLength,
                operatorConditionalType: this.columnEditor.operatorConditionalType,
                required: this.columnEditor.required,
                validator: this.validator,
            });
        };
        return TextEditor;
    }());

    var Editors = {
        /** AutoComplete Editor (using jQuery UI autocomplete feature) */
        autoComplete: AutoCompleteEditor,
        /** Checkbox Editor (uses native checkbox DOM element) */
        checkbox: CheckboxEditor,
        /** Date Picker Editor (which uses 3rd party lib "flatpickr") */
        date: DateEditor,
        /** Dual Input Editor, default input type is text but it could be (integer/float/number/password/text) */
        dualInput: DualInputEditor,
        /** Float Number Editor */
        float: FloatEditor,
        /** Integer Editor */
        integer: IntegerEditor,
        /** Long Text Editor (uses a textarea) */
        longText: LongTextEditor,
        /** Multiple Select editor (which uses 3rd party lib "multiple-select.js") */
        multipleSelect: MultipleSelectEditor,
        /** Single Select editor (which uses 3rd party lib "multiple-select.js") */
        singleSelect: SingleSelectEditor,
        /** Slider Editor */
        slider: SliderEditor,
        /** Text Editor */
        text: TextEditor
    };

    var moment$6 = moment_; // patch to fix rollup "moment has no default export" issue, document here https://github.com/rollup/rollup/issues/670
    /**
     * Find the option value from the following (in order of execution)
     * 1- Column Definition "params"
     * 2- Grid Options "formatterOptions"
     * 3- nothing found, return default value provided
     */
    function getValueFromParamsOrFormatterOptions(optionName, columnDef, grid, defaultValue) {
        var gridOptions = ((grid && typeof grid.getOptions === 'function') ? grid.getOptions() : {});
        var params = columnDef && columnDef.params;
        if (params && params.hasOwnProperty(optionName)) {
            return params[optionName];
        }
        else if (gridOptions.formatterOptions && gridOptions.formatterOptions.hasOwnProperty(optionName)) {
            return gridOptions.formatterOptions[optionName];
        }
        return defaultValue;
    }
    /** From a FieldType, return the associated date Formatter */
    function getAssociatedDateFormatter(fieldType, defaultSeparator) {
        var defaultDateFormat = mapMomentDateFormatWithFieldType(fieldType);
        return function (_row, _cell, value, columnDef, _dataContext, grid) {
            var gridOptions = ((grid && typeof grid.getOptions === 'function') ? grid.getOptions() : {});
            var customSeparator = gridOptions && gridOptions.formatterOptions && gridOptions.formatterOptions.dateSeparator || defaultSeparator;
            var inputType = columnDef && columnDef.type || exports.FieldType.date;
            var inputDateFormat = mapMomentDateFormatWithFieldType(inputType);
            var isParsingAsUtc = columnDef && columnDef.params && columnDef.params.parseDateAsUtc || false;
            var isDateValid = moment$6(value, inputDateFormat, false).isValid();
            var outputDate = value;
            if (value && isDateValid) {
                outputDate = isParsingAsUtc ? moment$6.utc(value).format(defaultDateFormat) : moment$6(value).format(defaultDateFormat);
            }
            // user can customize the separator through the "formatterOptions"
            // if that is the case we need to replace the default "/" to the new separator
            if (outputDate && customSeparator !== defaultSeparator) {
                var regex = new RegExp(defaultSeparator, 'ig'); // find separator globally
                outputDate = outputDate.replace(regex, customSeparator);
            }
            return outputDate;
        };
    }

    var alignRightFormatter = function (_row, _cell, value) {
        var outputValue = value;
        if (value === null || value === undefined) {
            outputValue = '';
        }
        return "<div style=\"float: right\">" + outputValue + "</div>";
    };

    var arrayObjectToCsvFormatter = function (row, cell, value, columnDef, dataContext) {
        var columnParams = columnDef && columnDef.params || {};
        var propertyNames = columnParams.propertyNames;
        var parentObjectKeyName = columnParams.dataContextProperty;
        if (!parentObjectKeyName) {
            parentObjectKeyName = columnDef && columnDef.field && columnDef.field.split('.')[0]; // e.g. "users.roles" would be "users"
        }
        if (!propertyNames || !Array.isArray(propertyNames) || !parentObjectKeyName) {
            throw new Error("Formatters.arrayObjectToCsv requires you to pass an array of \"propertyNames\" (declared in \"params\") that you want to pull the data from.\n      For example, if we have an array of user objects that have the property of firstName & lastName then we need to pass in your column definition:: { params: { propertyNames: ['firtName'] }}.\n      Optionally, you can also pass the \"dataContextProperty\" if you wish to run this on another completely different field of the dataContext object.");
        }
        // the dataContext holds all the data, so we can find the values we want even when "value" argument might be null
        // e.g. if we want to use the propertyNames of ['firstName', 'lastName'] from the "users" array of objects
        if (dataContext[parentObjectKeyName] && Array.isArray(dataContext[parentObjectKeyName])) {
            // we will 1st get the object from the dataContext, then
            if (Array.isArray(dataContext[parentObjectKeyName]) && dataContext[parentObjectKeyName].length > 0) {
                var outputStrings_1 = [];
                dataContext[parentObjectKeyName].forEach(function (data) {
                    var strings = [];
                    // 2nd from that data loop through all propertyNames we want to use (e.g.: ['firstName', 'lastName'])
                    propertyNames.forEach(function (prop) {
                        strings.push(data[prop]);
                    });
                    // we will join these strings with spaces (e.g. 'John Doe' where 'John' was firstName and 'Doe' was lastName)
                    outputStrings_1.push(strings.join(' '));
                });
                // finally join all the output strings by CSV (e.g.: 'John Doe, Jane Doe')
                var output = outputStrings_1.join(', ');
                return "<span title=\"" + output + "\">" + output + "</span>";
            }
        }
        return value;
    };

    var arrayToCsvFormatter = function (row, cell, value, columnDef, dataContext) {
        if (value && Array.isArray(value) && value.length > 0) {
            var values = value.join(', ');
            return "<span title=\"" + values + "\">" + values + "</span>";
        }
        return value;
    };

    var boldFormatter = function (row, cell, value) {
        return value ? "<b>" + value + "</b>" : '';
    };

    var centerFormatter = function (_row, _cell, value) {
        var outputValue = value;
        if (value === null || value === undefined) {
            outputValue = '';
        }
        return "<center>" + outputValue + "</center>";
    };

    var checkboxFormatter = function (row, cell, value, columnDef, dataContext) {
        return value ? '&#x2611;' : '';
    };

    var checkmarkFormatter = function (row, cell, value, columnDef, dataContext) {
        var isChecked = false;
        var isNumber = (value === null || value === undefined || value === '') ? false : !isNaN(+value);
        if (isNumber) {
            value = +value; // convert to number before doing next condition
        }
        if (value === true || (isNumber && +value > 0) || (typeof value === 'string' && value.length > 0 && value.toLowerCase() !== 'false' && value !== '0')) {
            isChecked = true;
        }
        return isChecked ? "<i class=\"fa fa-check checkmark-icon\" aria-hidden=\"true\"></i>" : '';
    };

    /**
     * A formatter to show the label property value of a params collection
     */
    var collectionFormatter = function (row, cell, value, columnDef, dataContext, grid) {
        if (!value || !columnDef || !columnDef.params || !columnDef.params.collection
            || !columnDef.params.collection.length) {
            return value;
        }
        var params = columnDef.params, collection = columnDef.params.collection;
        var labelName = (params.customStructure) ? params.customStructure.label : 'label';
        var valueName = (params.customStructure) ? params.customStructure.value : 'value';
        if (Array.isArray(value)) {
            return arrayToCsvFormatter(row, cell, value.map(function (v) { return findOrDefault(collection, function (c) { return c[valueName] === v; })[labelName]; }), columnDef, dataContext, grid);
        }
        return findOrDefault(collection, function (c) { return c[valueName] === value; })[labelName] || '';
    };

    /**
     * A formatter to show the label property value of an editor collection
     */
    var collectionEditorFormatter = function (row, cell, value, columnDef, dataContext, grid) {
        if (!value || !columnDef || !columnDef.internalColumnEditor || !columnDef.internalColumnEditor.collection
            || !columnDef.internalColumnEditor.collection.length) {
            return value;
        }
        var internalColumnEditor = columnDef.internalColumnEditor, collection = columnDef.internalColumnEditor.collection;
        var labelName = (internalColumnEditor.customStructure) ? internalColumnEditor.customStructure.label : 'label';
        var valueName = (internalColumnEditor.customStructure) ? internalColumnEditor.customStructure.value : 'value';
        if (Array.isArray(value)) {
            if (collection.every(function (x) { return typeof x === 'string'; })) {
                return arrayToCsvFormatter(row, cell, value.map(function (v) { return findOrDefault(collection, function (c) { return c === v; }); }), columnDef, dataContext, grid);
            }
            else {
                return arrayToCsvFormatter(row, cell, value.map(function (v) { return findOrDefault(collection, function (c) { return c[valueName] === v; })[labelName]; }), columnDef, dataContext, grid);
            }
        }
        return findOrDefault(collection, function (c) { return c[valueName] === value; })[labelName] || '';
    };

    var complexObjectFormatter = function (row, cell, cellValue, columnDef, dataContext) {
        if (!columnDef) {
            return '';
        }
        var columnParams = columnDef.params || {};
        var complexFieldLabel = columnParams && columnParams.complexFieldLabel || columnDef.field;
        if (!complexFieldLabel) {
            throw new Error("For the Formatters.complexObject to work properly, you need to tell it which property of the complex object to use.\n      There are 3 ways to provide it:\n      1- via the generic \"params\" with a \"complexFieldLabel\" property on your Column Definition, example: this.columnDefs = [{ id: 'user', field: 'user', params: { complexFieldLabel: 'user.firstName' } }]\n      2- via the generic \"params\" with a \"complexFieldLabel\" and a \"labelKey\" property on your Column Definition, example: this.columnDefs = [{ id: 'user', field: 'user', labelKey: 'firstName' params: { complexFieldLabel: 'user' } }]\n      3- via the field name that includes a dot notation, example: this.columnDefs = [{ id: 'user', field: 'user.firstName'}] ");
        }
        if (columnDef.labelKey && dataContext.hasOwnProperty(complexFieldLabel)) {
            return dataContext[complexFieldLabel] && dataContext[complexFieldLabel][columnDef.labelKey];
        }
        // when complexFieldLabel includes the dot ".", we will do the split and get the value from the complex object
        // however we also need to make sure that the complex objet exist, else we'll return the cell value (original value)
        if (typeof complexFieldLabel === 'string' && complexFieldLabel.indexOf('.') > 0) {
            return complexFieldLabel.split('.').reduce(function (obj, i) { return (obj && obj.hasOwnProperty(i) ? obj[i] : cellValue); }, dataContext);
        }
        return cellValue;
    };

    var decimalFormatter = function (row, cell, value, columnDef, dataContext, grid) {
        var isNumber = (value === null || value === undefined || value === '') ? false : !isNaN(+value);
        var params = columnDef.params || {};
        var minDecimal = getValueFromParamsOrFormatterOptions('minDecimal', columnDef, grid, 2);
        var maxDecimal = getValueFromParamsOrFormatterOptions('maxDecimal', columnDef, grid, 2);
        var decimalSeparator = getValueFromParamsOrFormatterOptions('decimalSeparator', columnDef, grid, '.');
        var thousandSeparator = getValueFromParamsOrFormatterOptions('thousandSeparator', columnDef, grid, '');
        var displayNegativeNumberWithParentheses = getValueFromParamsOrFormatterOptions('displayNegativeNumberWithParentheses', columnDef, grid, false);
        // @deprecated: decimalPlaces, minDecimalPlaces, maxDecimalPlaces
        // add these extra checks to support previous way of passing the decimal count
        if ((params.minDecimalPlaces !== null && params.minDecimalPlaces) || (params.decimalPlaces !== null && params.decimalPlaces)) {
            console.warn('[Angular-Slickgrid] please consider using "minDecimal" (instead of "minDecimalPlaces" or "decimalPlaces").');
            minDecimal = (params.minDecimalPlaces !== null && params.minDecimalPlaces) || (params.decimalPlaces !== null && params.decimalPlaces);
        }
        if (params.maxDecimalPlaces !== null && params.maxDecimalPlaces) {
            console.warn('[Angular-Slickgrid] please consider using "maxDecimal" (instead of "maxDecimalPlaces").');
            maxDecimal = (params.maxDecimalPlaces !== null && params.maxDecimalPlaces);
        }
        if (isNumber) {
            return formatNumber(value, minDecimal, maxDecimal, displayNegativeNumberWithParentheses, '', '', decimalSeparator, thousandSeparator);
        }
        return value;
    };

    var deleteIconFormatter = function (row, cell, value, columnDef, dataContext) {
        return "<i class=\"fa fa-trash pointer delete-icon\" aria-hidden=\"true\"></i>";
    };

    var dollarColoredBoldFormatter = function (row, cell, value, columnDef, dataContext, grid) {
        var isNumber = (value === null || value === undefined || value === '') ? false : !isNaN(+value);
        var minDecimal = getValueFromParamsOrFormatterOptions('minDecimal', columnDef, grid, 2);
        var maxDecimal = getValueFromParamsOrFormatterOptions('maxDecimal', columnDef, grid, 4);
        var decimalSeparator = getValueFromParamsOrFormatterOptions('decimalSeparator', columnDef, grid, '.');
        var thousandSeparator = getValueFromParamsOrFormatterOptions('thousandSeparator', columnDef, grid, '');
        var displayNegativeNumberWithParentheses = getValueFromParamsOrFormatterOptions('displayNegativeNumberWithParentheses', columnDef, grid, false);
        if (isNumber) {
            var colorStyle = (value >= 0) ? 'green' : 'red';
            var formattedNumber = formatNumber(value, minDecimal, maxDecimal, displayNegativeNumberWithParentheses, '$', '', decimalSeparator, thousandSeparator);
            return "<span style=\"color:" + colorStyle + "; font-weight:bold;\">" + formattedNumber + "</span>";
        }
        return value;
    };

    var dollarColoredFormatter = function (row, cell, value, columnDef, dataContext, grid) {
        var isNumber = (value === null || value === undefined || value === '') ? false : !isNaN(+value);
        var minDecimal = getValueFromParamsOrFormatterOptions('minDecimal', columnDef, grid, 2);
        var maxDecimal = getValueFromParamsOrFormatterOptions('maxDecimal', columnDef, grid, 4);
        var decimalSeparator = getValueFromParamsOrFormatterOptions('decimalSeparator', columnDef, grid, '.');
        var thousandSeparator = getValueFromParamsOrFormatterOptions('thousandSeparator', columnDef, grid, '');
        var displayNegativeNumberWithParentheses = getValueFromParamsOrFormatterOptions('displayNegativeNumberWithParentheses', columnDef, grid, false);
        if (isNumber) {
            var colorStyle = (value >= 0) ? 'green' : 'red';
            var formattedNumber = formatNumber(value, minDecimal, maxDecimal, displayNegativeNumberWithParentheses, '$', '', decimalSeparator, thousandSeparator);
            return "<span style=\"color:" + colorStyle + "\">" + formattedNumber + "</span>";
        }
        return value;
    };

    var dollarFormatter = function (row, cell, value, columnDef, dataContext, grid) {
        var isNumber = (value === null || value === undefined || value === '') ? false : !isNaN(+value);
        var minDecimal = getValueFromParamsOrFormatterOptions('minDecimal', columnDef, grid, 2);
        var maxDecimal = getValueFromParamsOrFormatterOptions('maxDecimal', columnDef, grid, 4);
        var decimalSeparator = getValueFromParamsOrFormatterOptions('decimalSeparator', columnDef, grid, '.');
        var thousandSeparator = getValueFromParamsOrFormatterOptions('thousandSeparator', columnDef, grid, '');
        var displayNegativeNumberWithParentheses = getValueFromParamsOrFormatterOptions('displayNegativeNumberWithParentheses', columnDef, grid, false);
        if (isNumber) {
            return formatNumber(value, minDecimal, maxDecimal, displayNegativeNumberWithParentheses, '$', '', decimalSeparator, thousandSeparator);
        }
        return value;
    };

    var editIconFormatter = function (row, cell, value, columnDef, dataContext) {
        return "<i class=\"fa fa-pencil pointer edit-icon\" aria-hidden=\"true\"></i>";
    };

    var fakeHyperlinkFormatter = function (_row, _cell, value) {
        return value ? "<span class=\"fake-hyperlink\">" + value + "</span>" : '';
    };

    var DOMPurify$5 = DOMPurify_; // patch to fix rollup to work
    /**
     * Takes an hyperlink cell value and transforms it into a real hyperlink, given that the value starts with 1 of these (http|ftp|https).
     * The structure will be "<a href="hyperlink">hyperlink</a>"
     *
     * You can optionally change the hyperlink text displayed by using the generic params "hyperlinkText" in the column definition
     * For example: { id: 'link', field: 'link', params: { hyperlinkText: 'Company Website' } } will display "<a href="link">Company Website</a>"
     *
     * You can also optionally provide the hyperlink URL by using the generic params "hyperlinkUrl" in the column definition
     * For example: { id: 'link', field: 'link', params: {  hyperlinkText: 'Company Website', hyperlinkUrl: 'http://www.somewhere.com' } } will display "<a href="http://www.somewhere.com">Company Website</a>"
     */
    var hyperlinkFormatter = function (row, cell, value, columnDef, dataContext) {
        var columnParams = columnDef && columnDef.params || {};
        var displayedText = columnParams.hyperlinkText ? columnParams.hyperlinkText : value;
        displayedText = DOMPurify$5.sanitize(displayedText || '');
        var outputLink = columnParams.hyperlinkUrl ? columnParams.hyperlinkUrl : value;
        outputLink = DOMPurify$5.sanitize(outputLink || '');
        var matchUrl = outputLink.match(/^(http|ftp|https):\/\/[\w\-_]+(\.[\w\-_]+)+([\w\-\.,@?^=%&amp;:\/~\+#]*[\w\-\@?^=%&amp;\/~\+#])?/i);
        if (matchUrl && Array.isArray(matchUrl) && matchUrl.length > 0) {
            var finalUrl = matchUrl[0];
            return "<a href=\"" + finalUrl + "\">" + displayedText + "</a>";
        }
        return value;
    };

    var iconFormatter = function (row, cell, value, columnDef, dataContext) {
        var columnParams = columnDef && columnDef.params || {};
        var icon = columnParams.icon || columnParams.formatterIcon;
        if (!icon) {
            throw new Error("You must provide the \"icon\" or \"formatterIcon\" via the generic \"params\" options (e.g.: { formatter: Formatters.icon, params: { formatterIcon: 'fa fa-search' }}");
        }
        return "<i class=\"" + icon + "\" aria-hidden=\"true\"></i>";
    };

    var infoIconFormatter = function (row, cell, value, columnDef, dataContext) {
        return "<i class=\"fa fa-info-circle pointer info-icon\" aria-hidden=\"true\"></i>";
    };

    var italicFormatter = function (row, cell, value, columnDef, dataContext) {
        return value ? "<i>" + value + "</i>" : '';
    };

    var lowercaseFormatter = function (row, cell, value, columnDef, dataContext) {
        // make sure the value is a string
        if (value !== undefined && typeof value !== 'string') {
            value = value + '';
        }
        return value ? value.toLowerCase() : '';
    };

    /**
     * Takes a value display it according to a mask provided
     * e.: 1234567890 with mask "(000) 000-0000" will display "(123) 456-7890"
     */
    var maskFormatter = function (row, cell, value, columnDef, dataContext) {
        var params = columnDef.params || {};
        var mask = params.mask;
        if (!mask) {
            throw new Error("You must provide a \"mask\" via the generic \"params\" options (e.g.: { formatter: Formatters.mask, params: { mask: '000-000' }}");
        }
        if (value) {
            var i_1 = 0;
            var v_1 = value.toString();
            return mask.replace(/[09A]/gi, function () { return v_1[i_1++] || ''; });
        }
        return value;
    };

    var multipleFormatter = function (row, cell, value, columnDef, dataContext, grid) {
        var e_1, _a;
        var params = columnDef.params || {};
        if (!params.formatters || !Array.isArray(params.formatters)) {
            throw new Error("The multiple formatter requires the \"formatters\" to be provided as a column params.\n    For example: this.columnDefinitions = [{ id: title, field: title, formatter: Formatters.multiple, params: { formatters: [Formatters.lowercase, Formatters.uppercase] }");
        }
        var formatters = params.formatters;
        // loop through all Formatters, the value of 1st formatter will be used by 2nd formatter and so on.
        // they are piped and executed in sequences
        var currentValue = value;
        try {
            for (var formatters_1 = __values(formatters), formatters_1_1 = formatters_1.next(); !formatters_1_1.done; formatters_1_1 = formatters_1.next()) {
                var formatter = formatters_1_1.value;
                currentValue = formatter(row, cell, currentValue, columnDef, dataContext, grid);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (formatters_1_1 && !formatters_1_1.done && (_a = formatters_1.return)) _a.call(formatters_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return currentValue;
    };

    var percentFormatter = function (row, cell, value, columnDef, dataContext, grid) {
        var isNumber = (value === null || value === undefined || value === '') ? false : !isNaN(+value);
        var minDecimal = getValueFromParamsOrFormatterOptions('minDecimal', columnDef, grid);
        var maxDecimal = getValueFromParamsOrFormatterOptions('maxDecimal', columnDef, grid);
        var decimalSeparator = getValueFromParamsOrFormatterOptions('decimalSeparator', columnDef, grid, '.');
        var thousandSeparator = getValueFromParamsOrFormatterOptions('thousandSeparator', columnDef, grid, '');
        var displayNegativeNumberWithParentheses = getValueFromParamsOrFormatterOptions('displayNegativeNumberWithParentheses', columnDef, grid, false);
        if (isNumber) {
            var percentValue = value * 100;
            return formatNumber(percentValue, minDecimal, maxDecimal, displayNegativeNumberWithParentheses, '', '%', decimalSeparator, thousandSeparator);
        }
        return value;
    };

    var percentCompleteBarFormatter = function (row, cell, value, columnDef, dataContext) {
        var isNumber = (value === null || value === undefined || value === '') ? false : !isNaN(+value);
        if (!isNumber) {
            return '';
        }
        var color = '';
        var inputNumber = parseFloat(value);
        if (inputNumber > 100) {
            inputNumber = 100;
        }
        if (inputNumber < 30) {
            color = 'red';
        }
        else if (inputNumber < 70) {
            color = 'silver';
        }
        else {
            color = 'green';
        }
        return "<span class=\"percent-complete-bar\" style=\"background:" + color + "; width:" + inputNumber + "%\"></span>";
    };

    var percentCompleteFormatter = function (row, cell, value, columnDef, dataContext, grid) {
        var isNumber = (value === null || value === undefined || value === '') ? false : !isNaN(+value);
        var minDecimal = getValueFromParamsOrFormatterOptions('minDecimal', columnDef, grid);
        var maxDecimal = getValueFromParamsOrFormatterOptions('maxDecimal', columnDef, grid);
        var decimalSeparator = getValueFromParamsOrFormatterOptions('decimalSeparator', columnDef, grid, '.');
        var thousandSeparator = getValueFromParamsOrFormatterOptions('thousandSeparator', columnDef, grid, '');
        var displayNegativeNumberWithParentheses = getValueFromParamsOrFormatterOptions('displayNegativeNumberWithParentheses', columnDef, grid, false);
        if (isNumber) {
            var colorStyle = (value < 50) ? 'red' : 'green';
            var formattedNumber = formatNumber(value, minDecimal, maxDecimal, displayNegativeNumberWithParentheses, '', '%', decimalSeparator, thousandSeparator);
            var outputFormattedValue = value > 100 ? '100%' : formattedNumber;
            return "<span style='color:" + colorStyle + "'>" + outputFormattedValue + "</span>";
        }
        return value;
    };

    var percentSymbolFormatter = function (row, cell, value, columnDef, dataContext, grid) {
        var isNumber = (value === null || value === undefined || value === '') ? false : !isNaN(+value);
        var minDecimal = getValueFromParamsOrFormatterOptions('minDecimal', columnDef, grid);
        var maxDecimal = getValueFromParamsOrFormatterOptions('maxDecimal', columnDef, grid);
        var decimalSeparator = getValueFromParamsOrFormatterOptions('decimalSeparator', columnDef, grid, '.');
        var thousandSeparator = getValueFromParamsOrFormatterOptions('thousandSeparator', columnDef, grid, '');
        var displayNegativeNumberWithParentheses = getValueFromParamsOrFormatterOptions('displayNegativeNumberWithParentheses', columnDef, grid, false);
        if (isNumber) {
            return formatNumber(value, minDecimal, maxDecimal, displayNegativeNumberWithParentheses, '', '%', decimalSeparator, thousandSeparator);
        }
        return value;
    };

    var progressBarFormatter = function (row, cell, value, columnDef, dataContext) {
        var isNumber = (value === null || value === undefined || value === '') ? false : !isNaN(+value);
        if (!isNumber) {
            return '';
        }
        var color = '';
        var inputNumber = parseFloat(value);
        if (inputNumber > 100) {
            inputNumber = 100;
        }
        if (inputNumber < 30) {
            color = 'danger';
        }
        else if (inputNumber < 70) {
            color = 'warning';
        }
        else {
            color = 'success';
        }
        var output = "<div class=\"progress\">\n    <div class=\"progress-bar progress-bar-" + color + " bg-" + color + "\" role=\"progressbar\" aria-valuenow=\"" + inputNumber + "\" aria-valuemin=\"0\" aria-valuemax=\"100\" style=\"min-width: 2em; width: " + inputNumber + "%;\">\n    " + inputNumber + "%\n    </div>\n  </div>";
        return output.replace(/\s{2,}/g, ' ').trim();
    };

    /** Takes a cell value and translates it with the "ngx-translate" service */
    var translateFormatter = function (row, cell, value, columnDef, dataContext, grid) {
        var gridOptions = (grid && typeof grid.getOptions === 'function') ? grid.getOptions() : {};
        var translate = gridOptions.i18n || (columnDef && columnDef.params && columnDef.params.i18n);
        if (!translate || typeof translate.instant !== 'function') {
            throw new Error("The translate formatter requires the \"ngx-translate\" Service to be provided as a Grid Options or Column Definition \"i18n\".\n    For example: this.gridOptions = { enableTranslate: true, i18n: this.translate }");
        }
        // make sure the value is a string (for example a boolean value would throw an error)
        if (value !== undefined && value !== null && typeof value !== 'string') {
            value = value + '';
        }
        return value ? translate.instant(value) : '';
    };

    /** Takes a boolean value, cast it to upperCase string and finally translates it with the "ngx-translate" service */
    var translateBooleanFormatter = function (row, cell, value, columnDef, dataContext, grid) {
        var gridOptions = (grid && typeof grid.getOptions === 'function') ? grid.getOptions() : {};
        var translate = gridOptions.i18n || (columnDef && columnDef.params && columnDef.params.i18n);
        if (!translate || typeof translate.instant !== 'function') {
            throw new Error("The translate formatter requires the \"ngx-translate\" Service to be provided as a Grid Options or Column Definition \"i18n\".\n    For example: this.gridOptions = { enableTranslate: true, i18n: this.translate }");
        }
        // make sure the value is a string (for example a boolean value would throw an error)
        if (value !== undefined && value !== null && typeof value !== 'string') {
            value = value + '';
        }
        return value ? translate.instant(value.toUpperCase()) : '';
    };

    var treeFormatter = function (row, cell, value, columnDef, dataContext, grid) {
        var dataView = grid && grid.getData();
        var gridOptions = grid && grid.getOptions();
        var treeDataOptions = gridOptions && gridOptions.treeDataOptions;
        var treeLevelPropName = treeDataOptions && treeDataOptions.levelPropName || '__treeLevel';
        var indentMarginLeft = treeDataOptions && treeDataOptions.indentMarginLeft || 15;
        var outputValue = value;
        if (typeof columnDef.queryFieldNameGetterFn === 'function') {
            var fieldName = columnDef.queryFieldNameGetterFn(dataContext);
            if (fieldName && fieldName.indexOf('.') >= 0) {
                outputValue = getDescendantProperty(dataContext, fieldName);
            }
            else {
                outputValue = dataContext.hasOwnProperty(fieldName) ? dataContext[fieldName] : value;
            }
        }
        if (outputValue === null || outputValue === undefined || dataContext === undefined) {
            return '';
        }
        if (!dataContext.hasOwnProperty(treeLevelPropName)) {
            throw new Error('You must provide valid "treeDataOptions" in your Grid Options and it seems that there are no tree level found in this row');
        }
        if (dataView && dataView.getIdxById && dataView.getItemByIdx) {
            if (typeof outputValue === 'string') {
                outputValue = htmlEncode(outputValue);
            }
            var identifierPropName = dataView.getIdPropertyName() || 'id';
            var spacer = "<span style=\"display:inline-block; width:" + indentMarginLeft * dataContext[treeLevelPropName] + "px;\"></span>";
            var idx = dataView.getIdxById(dataContext[identifierPropName]);
            var nextItemRow = dataView.getItemByIdx(idx + 1);
            if (nextItemRow && nextItemRow[treeLevelPropName] > dataContext[treeLevelPropName]) {
                if (dataContext.__collapsed) {
                    return spacer + "<span class=\"slick-group-toggle collapsed\"></span>&nbsp;" + outputValue;
                }
                else {
                    return spacer + "<span class=\"slick-group-toggle expanded\"></span>&nbsp;" + outputValue;
                }
            }
            return spacer + "<span class=\"slick-group-toggle\"></span>&nbsp;" + outputValue;
        }
        return '';
    };

    var uppercaseFormatter = function (row, cell, value, columnDef, dataContext) {
        // make sure the value is a string
        if (value !== undefined && typeof value !== 'string') {
            value = value + '';
        }
        return value ? value.toUpperCase() : '';
    };

    var yesNoFormatter = function (row, cell, value, columnDef, dataContext) {
        return value ? 'Yes' : 'No';
    };

    var bsDropdownFormatter = function (row, cell, value, columnDef, dataContext) {
        var columnParams = columnDef && columnDef.params || {};
        var label = columnParams.label || columnParams.formatterLabel;
        if (!label) {
            throw new Error("You must provide the \"label\" or \"formatterLabel\" via the generic \"params\" options (e.g.: { formatter: Formatters.bsDropdown, params: { formatterLabel: 'Label' }}");
        }
        return "<div id=\"myDrop-r" + row + "-c" + cell + "\" class=\"dropdown pointer\">\n    <a class=\"dropdown-toggle\">\n      " + label + "\n      <span class=\"caret\"></span>\n    </a>\n  </div>";
    };

    /** Provides a list of different Formatters that will change the cell value displayed in the UI */
    var Formatters = {
        /** Align cell value to the center (alias to Formatters.center)  */
        alignCenter: centerFormatter,
        /** Align cell value to the right */
        alignRight: alignRightFormatter,
        /**
         * Takes an array of complex objects converts it to a comma delimited string.
         * Requires to pass an array of "propertyNames" in the column definition the generic "params" property
         * For example, if we have an array of user objects that have the property of firstName & lastName then we need to pass in your column definition::
         * params: { propertyNames: ['firtName', 'lastName'] } => 'John Doe, Jane Doe'
         */
        arrayObjectToCsv: arrayObjectToCsvFormatter,
        /** Takes an array of string and converts it to a comma delimited string */
        arrayToCsv: arrayToCsvFormatter,
        /** show value in bold font weight */
        bold: boldFormatter,
        /** boostrap dropdown formatter */
        bsDropdown: bsDropdownFormatter,
        /** Center a text value horizontally */
        center: centerFormatter,
        /** When value is filled (true), it will display a checkbox Unicode icon */
        checkbox: checkboxFormatter,
        /**
         * When value is filled, or if the value is a number and is bigger than 0, it will display a Font-Awesome icon (fa-check).
         * The icon will NOT be displayed when the value is any of the following ("false", false, "0", 0, -0.5, null, undefined)
         * Anything else than the condition specified will display the icon, so a text with "00123" will display the icon but "0" will not.
         * Also note that a string ("null", "undefined") will display the icon but (null, undefined) will not, so the typeof is also important
         */
        checkmark: checkmarkFormatter,
        /**
         * Takes a complex data object and return the data under that property (for example: "user.firstName" will return the first name "John")
         * You can pass the complex structure in the "field" or the "params: { complexField: string }" properties.
         * For example::
         * this.columnDefs = [{ id: 'username', field: 'user.firstName', ... }]
         * OR this.columnDefs = [{ id: 'username', field: 'user', params: { complexField: 'user.firstName' }, ... }]
         */
        complex: complexObjectFormatter,
        complexObject: complexObjectFormatter,
        /**
         * Looks up values from the columnDefinition.params.collection property and displays the label in CSV or string format
         * @example
         * // the grid will display 'foo' and 'bar' and not 1 and 2 from your dataset
         * { params: { collection: [{ value: 1, label: 'foo'}, {value: 2, label: 'bar' }] }}
         * const dataset = [1, 2];
         */
        collection: collectionFormatter,
        /**
         * Roughly the same as the "collectionFormatter" except that it
         * looks up values from the columnDefinition.editor.collection (instead of params) property and displays the label in CSV or string format
         * @example
         * // the grid will display 'foo' and 'bar' and not 1 and 2 from your dataset
         * { editor: { collection: [{ value: 1, label: 'foo'}, {value: 2, label: 'bar' }] }}
         * const dataset = [1, 2];
         */
        collectionEditor: collectionEditorFormatter,
        /** Takes a Date object and displays it as an ISO Date format (YYYY-MM-DD) */
        dateIso: getAssociatedDateFormatter(exports.FieldType.dateIso, '-'),
        /** Takes a Date object and displays it as an ISO Date+Time format (YYYY-MM-DD HH:mm:ss) */
        dateTimeIso: getAssociatedDateFormatter(exports.FieldType.dateTimeIso, '-'),
        /** Takes a Date object and displays it as an ISO Date+Time (without seconds) format (YYYY-MM-DD HH:mm) */
        dateTimeShortIso: getAssociatedDateFormatter(exports.FieldType.dateTimeShortIso, '-'),
        /** Takes a Date object and displays it as an ISO Date+Time+(am/pm) format (YYYY-MM-DD h:mm:ss a) */
        dateTimeIsoAmPm: getAssociatedDateFormatter(exports.FieldType.dateTimeIsoAmPm, '-'),
        /** Takes a Date object and displays it as an Euro Date format (DD/MM/YYYY) */
        dateEuro: getAssociatedDateFormatter(exports.FieldType.dateEuro, '/'),
        /** Takes a Date object and displays it as an Euro Date+Time format (DD/MM/YYYY HH:mm:ss) */
        dateTimeEuro: getAssociatedDateFormatter(exports.FieldType.dateTimeEuro, '/'),
        /** Takes a Date object and displays it as an Euro Date+Time (without seconds) format (DD/MM/YYYY HH:mm) */
        dateTimeShortEuro: getAssociatedDateFormatter(exports.FieldType.dateTimeShortEuro, '/'),
        /** Takes a Date object and displays it as an Euro Date+Time+(am/pm) format (DD/MM/YYYY hh:mm:ss a) */
        dateTimeEuroAmPm: getAssociatedDateFormatter(exports.FieldType.dateTimeEuroAmPm, '/'),
        /** Takes a Date object and displays it as an US Date format (MM/DD/YYYY) */
        dateUs: getAssociatedDateFormatter(exports.FieldType.dateUs, '/'),
        /** Takes a Date object and displays it as an US Date+Time format (MM/DD/YYYY HH:mm:ss) */
        dateTimeUs: getAssociatedDateFormatter(exports.FieldType.dateTimeUs, '/'),
        /** Takes a Date object and displays it as an US Date+Time (without seconds) format (MM/DD/YYYY HH:mm:ss) */
        dateTimeShortUs: getAssociatedDateFormatter(exports.FieldType.dateTimeShortUs, '/'),
        /** Takes a Date object and displays it as an US Date+Time+(am/pm) format (MM/DD/YYYY hh:mm:ss a) */
        dateTimeUsAmPm: getAssociatedDateFormatter(exports.FieldType.dateTimeUsAmPm, '/'),
        /** Displays a Font-Awesome delete icon (fa-trash) */
        deleteIcon: deleteIconFormatter,
        /**
         * Display the value as x decimals formatted, defaults to 2 decimals.
         * You can pass "decimalPlaces" or "minDecimalPlaces" and/or "maxDecimalPlaces" to the "params" property.
         * For example:: `{ formatter: Formatters.decimal, params: { decimalPlaces: 3 }}`
         * The property "decimalPlaces" is an alias of "minDecimalPlaces"
         */
        decimal: decimalFormatter,
        /** Display the value as 2 decimals formatted with dollar sign '$' at the end of of the value */
        dollar: dollarFormatter,
        /** Display the value as 2 decimals formatted with dollar sign '$' at the end of of the value, change color of text to red/green on negative/positive value */
        dollarColored: dollarColoredFormatter,
        /** Display the value as 2 decimals formatted with dollar sign '$' at the end of of the value, change color of text to red/green on negative/positive value, show it in bold font weight as well */
        dollarColoredBold: dollarColoredBoldFormatter,
        /** Displays a Font-Awesome edit icon (fa-pencil) */
        editIcon: editIconFormatter,
        /** Takes any text value and display it as a fake a hyperlink (only styled as an hyperlink), this can be used in combo with "onCellClick" event */
        fakeHyperlink: fakeHyperlinkFormatter,
        /**
         * Takes an hyperlink cell value and transforms it into a real hyperlink, given that the value starts with 1 of these (http|ftp|https).
         * The structure will be "<a href="hyperlink">hyperlink</a>"
         *
         * You can optionally change the hyperlink text displayed by using the generic params "hyperlinkText" in the column definition
         * For example: { id: 'link', field: 'link', params: { hyperlinkText: 'Company Website' } } will display "<a href="link">Company Website</a>"
         *
         * You can also optionally provide the hyperlink URL by using the generic params "hyperlinkUrl" in the column definition
         * For example: { id: 'link', field: 'link', params: {  hyperlinkText: 'Company Website', hyperlinkUrl: 'http://www.somewhere.com' } } will display "<a href="http://www.somewhere.com">Company Website</a>"
         */
        hyperlink: hyperlinkFormatter,
        /** Display whichever icon you want (library agnostic, it could be Font-Awesome or any other) */
        icon: iconFormatter,
        /** Displays a Font-Awesome edit icon (fa-info-circle) */
        infoIcon: infoIconFormatter,
        /** show input text value as italic text */
        italic: italicFormatter,
        /** Takes a value and displays it all lowercase */
        lowercase: lowercaseFormatter,
        /**
         * Takes a value display it according to a mask provided
         * e.: 1234567890 with mask "(000) 000-0000" will display "(123) 456-7890"
         */
        mask: maskFormatter,
        /**
         * You can pipe multiple formatters (executed in sequence), use params to pass the list of formatters.
         * Requires to pass an array of "formatters" in the column definition the generic "params" property
         * For example::
         * { field: 'title', formatter: Formatters.multiple, params: { formatters: [ Formatters.lowercase, Formatters.uppercase ] }
         */
        multiple: multipleFormatter,
        /** Takes a cell value number (between 0.0-1.0) and displays a red (<50) or green (>=50) bar */
        percent: percentFormatter,
        /** Takes a cell value number (between 0.0-100) and displays a red (<50) or green (>=50) bar */
        percentComplete: percentCompleteFormatter,
        /** Takes a cell value number (between 0-100) and displays Bootstrap "percent-complete-bar" a red (<30), silver (>30 & <70) or green (>=70) bar */
        percentCompleteBar: percentCompleteBarFormatter,
        /** Takes a cell value number (between 0-100) and add the "%" after the number */
        percentSymbol: percentSymbolFormatter,
        /** Takes a cell value number (between 0-100) and displays Bootstrap "progress-bar" a red (<30), silver (>30 & <70) or green (>=70) bar */
        progressBar: progressBarFormatter,
        /** Takes a cell value and translates it (i18n). Requires an instance of the Translate Service:: `i18n: this.translate */
        translate: translateFormatter,
        /** Takes a boolean value, cast it to upperCase string and finally translates it (i18n). */
        translateBoolean: translateBooleanFormatter,
        /** Formatter that must be use with a Tree Data column */
        tree: treeFormatter,
        /** Takes a value and displays it all uppercase */
        uppercase: uppercaseFormatter,
        /** Takes a boolean value and display a string 'Yes' or 'No' */
        yesNo: yesNoFormatter
    };

    var avgTotalsPercentageFormatter = function (totals, columnDef, grid) {
        var field = columnDef.field || '';
        var val = totals.avg && totals.avg[field];
        var params = columnDef && columnDef.params;
        var prefix = params && params.groupFormatterPrefix || '';
        var suffix = params && params.groupFormatterSuffix || '';
        var minDecimal = getValueFromParamsOrFormatterOptions('minDecimal', columnDef, grid);
        var maxDecimal = getValueFromParamsOrFormatterOptions('maxDecimal', columnDef, grid);
        var decimalSeparator = getValueFromParamsOrFormatterOptions('decimalSeparator', columnDef, grid, '.');
        var thousandSeparator = getValueFromParamsOrFormatterOptions('thousandSeparator', columnDef, grid, '');
        var displayNegativeNumberWithParentheses = getValueFromParamsOrFormatterOptions('displayNegativeNumberWithParentheses', columnDef, grid, false);
        if (val !== null && val !== undefined && !isNaN(+val)) {
            if (val < 0) {
                val = Math.abs(val);
                if (!displayNegativeNumberWithParentheses) {
                    prefix += '-';
                }
                else {
                    if (isNaN(minDecimal) && isNaN(maxDecimal)) {
                        var outputVal = thousandSeparatorFormatted(Math.round(val), thousandSeparator);
                        return prefix + "(" + outputVal + "%)" + suffix;
                    }
                    return prefix + "(" + decimalFormatted(val, minDecimal, maxDecimal, decimalSeparator, thousandSeparator) + "%)" + suffix;
                }
            }
            if (isNaN(minDecimal) && isNaN(maxDecimal)) {
                var outputVal = thousandSeparatorFormatted(Math.round(val), thousandSeparator);
                return "" + prefix + outputVal + "%" + suffix;
            }
            return "" + prefix + decimalFormatted(val, minDecimal, maxDecimal, decimalSeparator, thousandSeparator) + "%" + suffix;
        }
        return '';
    };

    var avgTotalsDollarFormatter = function (totals, columnDef, grid) {
        var field = columnDef.field || '';
        var val = totals.avg && totals.avg[field];
        var params = columnDef && columnDef.params;
        var prefix = params && params.groupFormatterPrefix || '';
        var suffix = params && params.groupFormatterSuffix || '';
        var minDecimal = getValueFromParamsOrFormatterOptions('minDecimal', columnDef, grid, 2);
        var maxDecimal = getValueFromParamsOrFormatterOptions('maxDecimal', columnDef, grid, 4);
        var decimalSeparator = getValueFromParamsOrFormatterOptions('decimalSeparator', columnDef, grid, '.');
        var thousandSeparator = getValueFromParamsOrFormatterOptions('thousandSeparator', columnDef, grid, '');
        var displayNegativeNumberWithParentheses = getValueFromParamsOrFormatterOptions('displayNegativeNumberWithParentheses', columnDef, grid, false);
        if (val !== null && val !== undefined && !isNaN(+val)) {
            var formattedNumber = formatNumber(val, minDecimal, maxDecimal, displayNegativeNumberWithParentheses, '$', '', decimalSeparator, thousandSeparator);
            return "" + prefix + formattedNumber + suffix;
        }
        return '';
    };

    var avgTotalsFormatter = function (totals, columnDef, grid) {
        var field = columnDef.field || '';
        var val = totals.avg && totals.avg[field];
        var params = columnDef && columnDef.params;
        var prefix = params && params.groupFormatterPrefix || '';
        var suffix = params && params.groupFormatterSuffix || '';
        var minDecimal = getValueFromParamsOrFormatterOptions('minDecimal', columnDef, grid);
        var maxDecimal = getValueFromParamsOrFormatterOptions('maxDecimal', columnDef, grid);
        var decimalSeparator = getValueFromParamsOrFormatterOptions('decimalSeparator', columnDef, grid, '.');
        var thousandSeparator = getValueFromParamsOrFormatterOptions('thousandSeparator', columnDef, grid, '');
        var displayNegativeNumberWithParentheses = getValueFromParamsOrFormatterOptions('displayNegativeNumberWithParentheses', columnDef, grid, false);
        if (val !== null && val !== undefined && !isNaN(+val)) {
            if (val < 0) {
                val = Math.abs(val);
                if (!displayNegativeNumberWithParentheses) {
                    prefix += '-';
                }
                else {
                    if (isNaN(minDecimal) && isNaN(maxDecimal)) {
                        var outputVal = thousandSeparatorFormatted(Math.round(val), thousandSeparator);
                        return prefix + "(" + outputVal + ")" + suffix;
                    }
                    return prefix + "(" + decimalFormatted(val, minDecimal, maxDecimal, decimalSeparator, thousandSeparator) + ")" + suffix;
                }
            }
            if (isNaN(minDecimal) && isNaN(maxDecimal)) {
                var outputVal = thousandSeparatorFormatted(Math.round(val), thousandSeparator);
                return "" + prefix + outputVal + suffix;
            }
            return "" + prefix + decimalFormatted(val, minDecimal, maxDecimal, decimalSeparator, thousandSeparator) + suffix;
        }
        return '';
    };

    var minTotalsFormatter = function (totals, columnDef, grid) {
        var field = columnDef.field || '';
        var val = totals.min && totals.min[field];
        var params = columnDef && columnDef.params;
        var prefix = params && params.groupFormatterPrefix || '';
        var suffix = params && params.groupFormatterSuffix || '';
        var minDecimal = getValueFromParamsOrFormatterOptions('minDecimal', columnDef, grid);
        var maxDecimal = getValueFromParamsOrFormatterOptions('maxDecimal', columnDef, grid);
        var decimalSeparator = getValueFromParamsOrFormatterOptions('decimalSeparator', columnDef, grid, '.');
        var thousandSeparator = getValueFromParamsOrFormatterOptions('thousandSeparator', columnDef, grid, '');
        var displayNegativeNumberWithParentheses = getValueFromParamsOrFormatterOptions('displayNegativeNumberWithParentheses', columnDef, grid, false);
        if (val !== null && val !== undefined && !isNaN(+val)) {
            var formattedNumber = formatNumber(val, minDecimal, maxDecimal, displayNegativeNumberWithParentheses, '', '', decimalSeparator, thousandSeparator);
            return "" + prefix + formattedNumber + suffix;
        }
        return '';
    };

    var maxTotalsFormatter = function (totals, columnDef, grid) {
        var field = columnDef.field || '';
        var val = totals.max && totals.max[field];
        var params = columnDef && columnDef.params;
        var prefix = params && params.groupFormatterPrefix || '';
        var suffix = params && params.groupFormatterSuffix || '';
        var minDecimal = getValueFromParamsOrFormatterOptions('minDecimal', columnDef, grid);
        var maxDecimal = getValueFromParamsOrFormatterOptions('maxDecimal', columnDef, grid);
        var decimalSeparator = getValueFromParamsOrFormatterOptions('decimalSeparator', columnDef, grid, '.');
        var thousandSeparator = getValueFromParamsOrFormatterOptions('thousandSeparator', columnDef, grid, '');
        var displayNegativeNumberWithParentheses = getValueFromParamsOrFormatterOptions('displayNegativeNumberWithParentheses', columnDef, grid, false);
        if (val !== null && val !== undefined && !isNaN(+val)) {
            var formattedNumber = formatNumber(val, minDecimal, maxDecimal, displayNegativeNumberWithParentheses, '', '', decimalSeparator, thousandSeparator);
            return "" + prefix + formattedNumber + suffix;
        }
        return '';
    };

    var sumTotalsColoredFormatter = function (totals, columnDef, grid) {
        var field = columnDef.field || '';
        var val = totals.sum && totals.sum[field];
        var params = columnDef && columnDef.params;
        var prefix = params && params.groupFormatterPrefix || '';
        var suffix = params && params.groupFormatterSuffix || '';
        var minDecimal = getValueFromParamsOrFormatterOptions('minDecimal', columnDef, grid);
        var maxDecimal = getValueFromParamsOrFormatterOptions('maxDecimal', columnDef, grid);
        var decimalSeparator = getValueFromParamsOrFormatterOptions('decimalSeparator', columnDef, grid, '.');
        var thousandSeparator = getValueFromParamsOrFormatterOptions('thousandSeparator', columnDef, grid, '');
        var displayNegativeNumberWithParentheses = getValueFromParamsOrFormatterOptions('displayNegativeNumberWithParentheses', columnDef, grid, false);
        if (val !== null && val !== undefined && !isNaN(+val)) {
            var colorStyle = (val >= 0) ? 'green' : 'red';
            var formattedNumber = formatNumber(val, minDecimal, maxDecimal, displayNegativeNumberWithParentheses, '', '', decimalSeparator, thousandSeparator);
            return "<span style=\"color:" + colorStyle + "\">" + prefix + formattedNumber + suffix + "</span>";
        }
        return '';
    };

    var sumTotalsDollarColoredBoldFormatter = function (totals, columnDef, grid) {
        var field = columnDef.field || '';
        var val = totals.sum && totals.sum[field];
        var params = columnDef && columnDef.params;
        var prefix = params && params.groupFormatterPrefix || '';
        var suffix = params && params.groupFormatterSuffix || '';
        var minDecimal = getValueFromParamsOrFormatterOptions('minDecimal', columnDef, grid, 2);
        var maxDecimal = getValueFromParamsOrFormatterOptions('maxDecimal', columnDef, grid, 4);
        var decimalSeparator = getValueFromParamsOrFormatterOptions('decimalSeparator', columnDef, grid, '.');
        var thousandSeparator = getValueFromParamsOrFormatterOptions('thousandSeparator', columnDef, grid, '');
        var displayNegativeNumberWithParentheses = getValueFromParamsOrFormatterOptions('displayNegativeNumberWithParentheses', columnDef, grid, false);
        if (val !== null && val !== undefined && !isNaN(+val)) {
            var colorStyle = (val >= 0) ? 'green' : 'red';
            var formattedNumber = formatNumber(val, minDecimal, maxDecimal, displayNegativeNumberWithParentheses, '$', '', decimalSeparator, thousandSeparator);
            return "<span style=\"color:" + colorStyle + "; font-weight: bold;\">" + prefix + formattedNumber + suffix + "</span>";
        }
        return '';
    };

    var sumTotalsDollarColoredFormatter = function (totals, columnDef, grid) {
        var field = columnDef.field || '';
        var val = totals.sum && totals.sum[field];
        var params = columnDef && columnDef.params;
        var prefix = params && params.groupFormatterPrefix || '';
        var suffix = params && params.groupFormatterSuffix || '';
        var minDecimal = getValueFromParamsOrFormatterOptions('minDecimal', columnDef, grid, 2);
        var maxDecimal = getValueFromParamsOrFormatterOptions('maxDecimal', columnDef, grid, 4);
        var decimalSeparator = getValueFromParamsOrFormatterOptions('decimalSeparator', columnDef, grid, '.');
        var thousandSeparator = getValueFromParamsOrFormatterOptions('thousandSeparator', columnDef, grid, '');
        var displayNegativeNumberWithParentheses = getValueFromParamsOrFormatterOptions('displayNegativeNumberWithParentheses', columnDef, grid, false);
        if (val !== null && val !== undefined && !isNaN(+val)) {
            var colorStyle = (val >= 0) ? 'green' : 'red';
            var formattedNumber = formatNumber(val, minDecimal, maxDecimal, displayNegativeNumberWithParentheses, '$', '', decimalSeparator, thousandSeparator);
            return "<span style=\"color:" + colorStyle + "\">" + prefix + formattedNumber + suffix + "</span>";
        }
        return '';
    };

    var sumTotalsDollarBoldFormatter = function (totals, columnDef, grid) {
        var field = columnDef.field || '';
        var val = totals.sum && totals.sum[field];
        var params = columnDef && columnDef.params;
        var prefix = params && params.groupFormatterPrefix || '';
        var suffix = params && params.groupFormatterSuffix || '';
        var minDecimal = getValueFromParamsOrFormatterOptions('minDecimal', columnDef, grid, 2);
        var maxDecimal = getValueFromParamsOrFormatterOptions('maxDecimal', columnDef, grid, 4);
        var decimalSeparator = getValueFromParamsOrFormatterOptions('decimalSeparator', columnDef, grid, '.');
        var thousandSeparator = getValueFromParamsOrFormatterOptions('thousandSeparator', columnDef, grid, '');
        var displayNegativeNumberWithParentheses = getValueFromParamsOrFormatterOptions('displayNegativeNumberWithParentheses', columnDef, grid, false);
        if (val !== null && val !== undefined && !isNaN(+val)) {
            var formattedNumber = formatNumber(val, minDecimal, maxDecimal, displayNegativeNumberWithParentheses, '$', '', decimalSeparator, thousandSeparator);
            return "<b>" + prefix + formattedNumber + suffix + "</b>";
        }
        return '';
    };

    var sumTotalsDollarFormatter = function (totals, columnDef, grid) {
        var field = columnDef.field || '';
        var val = totals.sum && totals.sum[field];
        var params = columnDef && columnDef.params;
        var prefix = params && params.groupFormatterPrefix || '';
        var suffix = params && params.groupFormatterSuffix || '';
        var minDecimal = getValueFromParamsOrFormatterOptions('minDecimal', columnDef, grid, 2);
        var maxDecimal = getValueFromParamsOrFormatterOptions('maxDecimal', columnDef, grid, 4);
        var decimalSeparator = getValueFromParamsOrFormatterOptions('decimalSeparator', columnDef, grid, '.');
        var thousandSeparator = getValueFromParamsOrFormatterOptions('thousandSeparator', columnDef, grid, '');
        var displayNegativeNumberWithParentheses = getValueFromParamsOrFormatterOptions('displayNegativeNumberWithParentheses', columnDef, grid, false);
        if (val !== null && val !== undefined && !isNaN(+val)) {
            var formattedNumber = formatNumber(val, minDecimal, maxDecimal, displayNegativeNumberWithParentheses, '$', '', decimalSeparator, thousandSeparator);
            return "" + prefix + formattedNumber + suffix;
        }
        return '';
    };

    var sumTotalsFormatter = function (totals, columnDef, grid) {
        var field = columnDef.field || '';
        var val = totals.sum && totals.sum[field];
        var params = columnDef && columnDef.params;
        var prefix = params && params.groupFormatterPrefix || '';
        var suffix = params && params.groupFormatterSuffix || '';
        var minDecimal = getValueFromParamsOrFormatterOptions('minDecimal', columnDef, grid);
        var maxDecimal = getValueFromParamsOrFormatterOptions('maxDecimal', columnDef, grid);
        var decimalSeparator = getValueFromParamsOrFormatterOptions('decimalSeparator', columnDef, grid, '.');
        var thousandSeparator = getValueFromParamsOrFormatterOptions('thousandSeparator', columnDef, grid, '');
        var displayNegativeNumberWithParentheses = getValueFromParamsOrFormatterOptions('displayNegativeNumberWithParentheses', columnDef, grid, false);
        if (val !== null && val !== undefined && !isNaN(+val)) {
            var formattedNumber = formatNumber(val, minDecimal, maxDecimal, displayNegativeNumberWithParentheses, '', '', decimalSeparator, thousandSeparator);
            return "" + prefix + formattedNumber + suffix;
        }
        return '';
    };

    var sumTotalsBoldFormatter = function (totals, columnDef, grid) {
        var field = columnDef.field || '';
        var val = totals.sum && totals.sum[field];
        var params = columnDef && columnDef.params;
        var prefix = params && params.groupFormatterPrefix || '';
        var suffix = params && params.groupFormatterSuffix || '';
        var minDecimal = getValueFromParamsOrFormatterOptions('minDecimal', columnDef, grid);
        var maxDecimal = getValueFromParamsOrFormatterOptions('maxDecimal', columnDef, grid);
        var decimalSeparator = getValueFromParamsOrFormatterOptions('decimalSeparator', columnDef, grid, '.');
        var thousandSeparator = getValueFromParamsOrFormatterOptions('thousandSeparator', columnDef, grid, '');
        var displayNegativeNumberWithParentheses = getValueFromParamsOrFormatterOptions('displayNegativeNumberWithParentheses', columnDef, grid, false);
        if (val !== null && val !== undefined && !isNaN(+val)) {
            var formattedNumber = formatNumber(val, minDecimal, maxDecimal, displayNegativeNumberWithParentheses, '', '', decimalSeparator, thousandSeparator);
            return "<b>" + prefix + formattedNumber + suffix + "</b>";
        }
        return '';
    };

    /** Provides a list of different Formatters that will change the cell value displayed in the UI */
    var GroupTotalFormatters = {
        /**
         * Average all the column totals
         * Extra options available in "params":: "groupFormatterPrefix" and "groupFormatterSuffix", e.g.: params: { groupFormatterPrefix: '<i>Total</i>: ', groupFormatterSuffix: '$' }
         */
        avgTotals: avgTotalsFormatter,
        /**
         * Average all the column totals and display '$' at the end of the value
         * Extra options available in "params":: "groupFormatterPrefix" and "groupFormatterSuffix", e.g.: params: { groupFormatterPrefix: '<i>Total</i>: ', groupFormatterSuffix: '$' }
         */
        avgTotalsDollar: avgTotalsDollarFormatter,
        /**
         * Average all the column totals and display '%' at the end of the value
         * Extra options available in "params":: "groupFormatterPrefix" and "groupFormatterSuffix", e.g.: params: { groupFormatterPrefix: '<i>Total</i>: ', groupFormatterSuffix: '$' }
         */
        avgTotalsPercentage: avgTotalsPercentageFormatter,
        /**
         * Show max value of all the column totals
         * Extra options available in "params":: "groupFormatterPrefix" and "groupFormatterSuffix", e.g.: params: { groupFormatterPrefix: '<i>Total</i>: ', groupFormatterSuffix: '$' }
         */
        maxTotals: maxTotalsFormatter,
        /**
         * Show min value of all the column totals
         * Extra options available in "params":: "groupFormatterPrefix" and "groupFormatterSuffix", e.g.: params: { groupFormatterPrefix: '<i>Total</i>: ', groupFormatterSuffix: '$' }
         */
        minTotals: minTotalsFormatter,
        /**
         * Sums up all the column totals
         * Extra options available in "params":: "groupFormatterPrefix" and "groupFormatterSuffix", e.g.: params: { groupFormatterPrefix: '<i>Total</i>: ', groupFormatterSuffix: '$' }
         */
        sumTotals: sumTotalsFormatter,
        /**
         * Sums up all the column totals and display it in bold font weight
         * Extra options available in "params":: "groupFormatterPrefix" and "groupFormatterSuffix", e.g: params: { groupFormatterPrefix: '<i>Total</i>: ', groupFormatterSuffix: '$' }
         */
        sumTotalsBold: sumTotalsBoldFormatter,
        /**
         * Sums up all the column totals, change color of text to red/green on negative/positive value
         * Extra options available in "params":: "groupFormatterPrefix" and "groupFormatterSuffix", e.g: params: { groupFormatterPrefix: '<i>Total</i>: ', groupFormatterSuffix: '$' }
         */
        sumTotalsColored: sumTotalsColoredFormatter,
        /**
         * Sums up all the column totals and display dollar sign
         * Extra options available in "params":: "groupFormatterPrefix" and "groupFormatterSuffix", e.g: params: { groupFormatterPrefix: '<i>Total</i>: ', groupFormatterSuffix: '$' }
         */
        sumTotalsDollar: sumTotalsDollarFormatter,
        /**
         * Sums up all the column totals and display dollar sign and show it in bold font weight
         * Extra options available in "params":: "groupFormatterPrefix" and "groupFormatterSuffix", e.g: params: { groupFormatterPrefix: '<i>Total</i>: ', groupFormatterSuffix: '$' }
         */
        sumTotalsDollarBold: sumTotalsDollarBoldFormatter,
        /**
         * Sums up all the column totals, change color of text to red/green on negative/positive value
         * Extra options available in "params":: "groupFormatterPrefix" and "groupFormatterSuffix", e.g: params: { groupFormatterPrefix: '<i>Total</i>: ', groupFormatterSuffix: '$' }
         */
        sumTotalsDollarColored: sumTotalsDollarColoredFormatter,
        /**
         * Sums up all the column totals, change color of text to red/green on negative/positive value, show it in bold font weight as well
         * Extra options available in "params":: "groupFormatterPrefix" and "groupFormatterSuffix", e.g: params: { groupFormatterPrefix: '<i>Total</i>: ', groupFormatterSuffix: '$' }
         */
        sumTotalsDollarColoredBold: sumTotalsDollarColoredBoldFormatter,
    };

    var SlickPaginationComponent = /** @class */ (function () {
        /** Constructor */
        function SlickPaginationComponent(paginationService, translate) {
            this.paginationService = paginationService;
            this.translate = translate;
            this.subscriptions = [];
            this._enableTranslate = false;
            // text translations (handled by ngx-translate or by custom locale)
            this.textItemsPerPage = 'items per page';
            this.textItems = 'items';
            this.textOf = 'of';
            this.textPage = 'Page';
        }
        Object.defineProperty(SlickPaginationComponent.prototype, "availablePageSizes", {
            get: function () {
                return this.paginationService.availablePageSizes;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SlickPaginationComponent.prototype, "dataFrom", {
            get: function () {
                return this.paginationService.dataFrom;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SlickPaginationComponent.prototype, "dataTo", {
            get: function () {
                return this.paginationService.dataTo;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SlickPaginationComponent.prototype, "isLeftPaginationDisabled", {
            /** is the left side pagination disabled? */
            get: function () {
                return this.pageNumber === 1 || this.totalItems === 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SlickPaginationComponent.prototype, "isRightPaginationDisabled", {
            /** is the right side pagination disabled? */
            get: function () {
                return this.pageNumber === this.pageCount || this.totalItems === 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SlickPaginationComponent.prototype, "itemsPerPage", {
            get: function () {
                return this.paginationService.itemsPerPage;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SlickPaginationComponent.prototype, "pageCount", {
            get: function () {
                return this.paginationService.pageCount;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SlickPaginationComponent.prototype, "pageNumber", {
            get: function () {
                return this.paginationService.pageNumber;
            },
            set: function (page) {
                // the setter has to be declared but we won't use it, instead we will use the "changeToCurrentPage()" to only update the value after ENTER keydown event
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SlickPaginationComponent.prototype, "totalItems", {
            get: function () {
                return this.paginationService.totalItems;
            },
            enumerable: true,
            configurable: true
        });
        SlickPaginationComponent.prototype.ngOnDestroy = function () {
            this.dispose();
        };
        SlickPaginationComponent.prototype.ngOnInit = function () {
            var _this = this;
            this._gridOptions = this.gridOptions || {};
            this._enableTranslate = this._gridOptions && this._gridOptions.enableTranslate || false;
            this._locales = this._gridOptions && this._gridOptions.locales || Constants.locales;
            if (this._enableTranslate && !this.translate) {
                throw new Error('[Angular-Slickgrid] requires "ngx-translate" to be installed and configured when the grid option "enableTranslate" is enabled.');
            }
            this.translateAllUiTexts(this._locales);
            // translate all the text using ngx-translate or custom locales
            if (this._enableTranslate && this.translate && this.translate.onLangChange) {
                this.subscriptions.push(this.translate.onLangChange.subscribe(function () { return _this.translateAllUiTexts(_this._locales); }));
            }
        };
        SlickPaginationComponent.prototype.changeToFirstPage = function (event) {
            if (!this.isLeftPaginationDisabled) {
                this.paginationService.goToFirstPage(event);
            }
        };
        SlickPaginationComponent.prototype.changeToLastPage = function (event) {
            if (!this.isRightPaginationDisabled) {
                this.paginationService.goToLastPage(event);
            }
        };
        SlickPaginationComponent.prototype.changeToNextPage = function (event) {
            if (!this.isRightPaginationDisabled) {
                this.paginationService.goToNextPage(event);
            }
        };
        SlickPaginationComponent.prototype.changeToPreviousPage = function (event) {
            if (!this.isLeftPaginationDisabled) {
                this.paginationService.goToPreviousPage(event);
            }
        };
        SlickPaginationComponent.prototype.changeToCurrentPage = function (event) {
            var pageNumber = 1;
            if (event && event.currentTarget && event.currentTarget.value) {
                pageNumber = +(event.currentTarget.value);
            }
            this.paginationService.goToPageNumber(pageNumber, event);
        };
        SlickPaginationComponent.prototype.changeItemPerPage = function (event) {
            var itemsPerPage = 1;
            if (event && event.currentTarget && event.currentTarget.value) {
                itemsPerPage = +(event.currentTarget.value);
            }
            this.paginationService.changeItemPerPage(itemsPerPage, event);
        };
        SlickPaginationComponent.prototype.dispose = function () {
            this.paginationService.dispose();
            // also unsubscribe all Angular Subscriptions
            this.subscriptions = unsubscribeAllObservables(this.subscriptions);
        };
        // --
        // private functions
        // --------------------
        /** Translate all the texts shown in the UI, use ngx-translate service when available or custom locales when service is null */
        SlickPaginationComponent.prototype.translateAllUiTexts = function (locales) {
            if (this._enableTranslate && this.translate && this.translate.instant && this.translate.currentLang) {
                var translationPrefix = getTranslationPrefix(this._gridOptions);
                this.textItemsPerPage = this.translate.instant(translationPrefix + "ITEMS_PER_PAGE");
                this.textItems = this.translate.instant(translationPrefix + "ITEMS");
                this.textOf = this.translate.instant(translationPrefix + "OF");
                this.textPage = this.translate.instant(translationPrefix + "PAGE");
            }
            else if (locales) {
                this.textItemsPerPage = locales.TEXT_ITEMS_PER_PAGE || 'TEXT_ITEMS_PER_PAGE';
                this.textItems = locales.TEXT_ITEMS || 'TEXT_ITEMS';
                this.textOf = locales.TEXT_OF || 'TEXT_OF';
                this.textPage = locales.TEXT_PAGE || 'TEXT_PAGE';
            }
        };
        SlickPaginationComponent.ctorParameters = function () { return [
            { type: PaginationService },
            { type: core$1.TranslateService, decorators: [{ type: core.Optional }] }
        ]; };
        __decorate([
            core.Input()
        ], SlickPaginationComponent.prototype, "gridOptions", void 0);
        SlickPaginationComponent = __decorate([
            core.Component({
                selector: 'slick-pagination',
                template: "<div class=\"slick-pagination\">\r\n  <div class=\"slick-pagination-nav\">\r\n    <nav aria-label=\"Page navigation\">\r\n      <ul class=\"pagination\">\r\n        <li class=\"page-item\" [ngClass]=\"isLeftPaginationDisabled ? 'disabled' : ''\">\r\n          <a class=\"page-link icon-seek-first fa fa-angle-double-left\" aria-label=\"First\"\r\n             (click)=\"changeToFirstPage($event)\">\r\n          </a>\r\n        </li>\r\n        <li class=\"page-item\" [ngClass]=\"isLeftPaginationDisabled ? 'disabled' : ''\">\r\n          <a class=\"page-link icon-seek-prev fa fa-angle-left\" aria-label=\"Previous\"\r\n             (click)=\"changeToPreviousPage($event)\">\r\n          </a>\r\n        </li>\r\n      </ul>\r\n    </nav>\r\n\r\n    <div class=\"slick-page-number\">\r\n      <span>{{textPage}}</span>\r\n      <input type=\"text\" class=\"form-control\" data-test=\"page-number-input\" [value]=\"pageNumber\" size=\"1\"\r\n             [readOnly]=\"totalItems === 0\" (change)=\"changeToCurrentPage($event)\">\r\n      <span>{{textOf}}</span><span data-test=\"page-count\"> {{pageCount}}</span>\r\n    </div>\r\n\r\n    <nav aria-label=\"Page navigation\">\r\n      <ul class=\"pagination\">\r\n        <li class=\"page-item\" [ngClass]=\"isRightPaginationDisabled ? 'disabled' : ''\">\r\n          <a class=\"page-link icon-seek-next text-center fa fa-lg fa-angle-right\" aria-label=\"Next\"\r\n             (click)=\"changeToNextPage($event)\">\r\n          </a>\r\n        </li>\r\n        <li class=\"page-item\" [ngClass]=\"isRightPaginationDisabled ? 'disabled' : ''\">\r\n          <a class=\"page-link icon-seek-end fa fa-lg fa-angle-double-right\" aria-label=\"Last\"\r\n             (click)=\"changeToLastPage($event)\">\r\n          </a>\r\n        </li>\r\n      </ul>\r\n    </nav>\r\n  </div>\r\n  <span class=\"slick-pagination-settings\">\r\n    <select id=\"items-per-page-label\" (change)=\"changeItemPerPage($event)\">\r\n      <option value=\"{{pageSize}}\" [selected]=\"pageSize === itemsPerPage\" *ngFor=\"let pageSize of availablePageSizes\">{{pageSize}}</option>\r\n    </select>\r\n    <span>{{textItemsPerPage}}</span>,\r\n    <span class=\"slick-pagination-count\">\r\n      <span *ngIf=\"totalItems\">\r\n        <span class=\"page-info-from-to\">\r\n          <span data-test=\"item-from\">{{dataFrom}}</span>-<span data-test=\"item-to\">{{dataTo}}</span>\r\n          {{textOf}}\r\n        </span>\r\n      </span>\r\n      <span class=\"page-info-total-items\">\r\n        <span data-test=\"total-items\">{{totalItems}}</span> {{textItems}}\r\n      </span>\r\n    </span>\r\n  </span>\r\n</div>\r\n"
            }),
            __param(1, core.Optional())
        ], SlickPaginationComponent);
        return SlickPaginationComponent;
    }());

    var SlickEmptyWarningComponent = /** @class */ (function () {
        function SlickEmptyWarningComponent(translate) {
            this.translate = translate;
        }
        Object.defineProperty(SlickEmptyWarningComponent.prototype, "gridOptions", {
            /** Getter for the Grid Options pulled through the Grid Object */
            get: function () {
                return (this._grid && this._grid.getOptions) ? this._grid.getOptions() : {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SlickEmptyWarningComponent.prototype, "grid", {
            set: function (slickGrid) {
                this._grid = slickGrid;
            },
            enumerable: true,
            configurable: true
        });
        SlickEmptyWarningComponent.prototype.dispose = function () {
            if (this._warningLeftElement && this._warningLeftElement.remove) {
                this._warningLeftElement.remove();
            }
            if (this._warningRightElement && this._warningRightElement.remove) {
                this._warningRightElement.remove();
            }
            this._warningLeftElement = null;
            this._warningRightElement = null;
        };
        /**
         * Display a warning of empty data when the filtered dataset is empty
         * NOTE: to make this code reusable, you could (should) move this code into a utility service
         * @param isShowing - are we showing the message?
         * @param options - any styling options you'd like to pass like the text color
         */
        SlickEmptyWarningComponent.prototype.showEmptyDataMessage = function (isShowing, options) {
            if (isShowing === void 0) { isShowing = true; }
            if (!this._grid || !this.gridOptions) {
                return false;
            }
            var gridUid = this._grid && this._grid.getUID();
            var defaultMessage = 'No data to display.';
            var mergedOptions = __assign({ message: defaultMessage }, this.gridOptions.emptyDataWarning, options);
            var emptyDataClassName = mergedOptions && mergedOptions.className || 'slick-empty-data-warning';
            this._warningLeftElement = document.querySelector("." + gridUid + " ." + emptyDataClassName);
            var gridCanvasLeftElm = document.querySelector("." + gridUid + " .grid-canvas.grid-canvas-left");
            var gridCanvasRightElm = document.querySelector("." + gridUid + " .grid-canvas.grid-canvas-right");
            var leftElementMarginLeft = mergedOptions.leftViewportMarginLeft || 0;
            var rightElementMarginLeft = mergedOptions.rightViewportMarginLeft || 0;
            var leftElementFrozenMarginLeft = mergedOptions.frozenLeftViewportMarginLeft || 0;
            var rightElementFrozenMarginLeft = mergedOptions.frozenRightViewportMarginLeft || 0;
            var isFrozenGrid = (this.gridOptions.frozenColumn !== undefined && this.gridOptions.frozenColumn >= 0);
            var leftViewportMarginLeft = typeof leftElementMarginLeft === 'string' ? leftElementMarginLeft : leftElementMarginLeft + "px";
            var rightViewportMarginLeft = typeof rightElementMarginLeft === 'string' ? rightElementMarginLeft : rightElementMarginLeft + "px";
            if (!this._warningLeftElement && !isShowing) {
                return false;
            }
            // warning message could come from a translation key or by the warning options
            var warningMessage = mergedOptions.message;
            if (this.gridOptions.enableTranslate && this.translate && this.translate.instant && mergedOptions && mergedOptions.messageKey) {
                warningMessage = this.translate.instant(mergedOptions.messageKey);
            }
            if (!this._warningLeftElement && gridCanvasLeftElm && gridCanvasRightElm) {
                var sanitizedOptions = this.gridOptions && this.gridOptions.sanitizeHtmlOptions || {};
                // sanitize any unauthorized html tags like script and others
                // for the remaining allowed tags we'll permit all attributes
                var sanitizedText = (DOMPurify_.sanitize(warningMessage, sanitizedOptions) || '').toString();
                this._warningLeftElement = document.createElement('div');
                this._warningLeftElement.classList.add(emptyDataClassName);
                this._warningLeftElement.classList.add('left');
                this._warningLeftElement.innerHTML = sanitizedText;
                // clone the warning element and add the "right" class to it so we can distinguish
                this._warningRightElement = this._warningLeftElement.cloneNode(true);
                this._warningRightElement.classList.add('right');
                // append both warning elements to both left/right canvas
                gridCanvasRightElm.appendChild(this._warningRightElement);
                gridCanvasLeftElm.appendChild(this._warningLeftElement);
            }
            // if we did find the Slick-Empty-Warning element then we'll display/hide at the grid position with some margin offsets (we need to position under the headerRow and filterRow)
            // when using a frozen/pinned grid, we also have extra options to hide left/right message
            if (this._warningLeftElement) {
                // display/hide right/left messages
                var leftDisplay = isShowing ? 'block' : 'none';
                if (isFrozenGrid && isShowing) {
                    leftDisplay = (mergedOptions.hideFrozenLeftWarning) ? 'none' : 'block';
                }
                this._warningLeftElement.style.display = leftDisplay;
                // use correct left margin (defaults to 40% on regular grid or 10px on frozen grid)
                var leftFrozenMarginLeft = typeof leftElementFrozenMarginLeft === 'string' ? leftElementFrozenMarginLeft : leftElementFrozenMarginLeft + "px";
                this._warningLeftElement.style.marginLeft = isFrozenGrid ? leftFrozenMarginLeft : leftViewportMarginLeft;
            }
            if (this._warningRightElement) {
                // use correct left margin (defaults to 40% on regular grid or 10px on frozen grid)
                var rightDisplay = isShowing ? 'block' : 'none';
                if (isFrozenGrid && isShowing) {
                    rightDisplay = (mergedOptions.hideFrozenRightWarning) ? 'none' : 'block';
                }
                this._warningRightElement.style.display = rightDisplay;
                // use correct left margin (defaults to 40% on regular grid or 10px on frozen grid)
                var rightFrozenMarginLeft = typeof rightElementFrozenMarginLeft === 'string' ? rightElementFrozenMarginLeft : rightElementFrozenMarginLeft + "px";
                this._warningRightElement.style.marginLeft = isFrozenGrid ? rightFrozenMarginLeft : rightViewportMarginLeft;
            }
            return isShowing;
        };
        SlickEmptyWarningComponent = __decorate([
            __param(0, core.Optional())
        ], SlickEmptyWarningComponent);
        return SlickEmptyWarningComponent;
    }());

    var slickgridEventPrefix = 'sg';
    var AngularSlickgridComponent = /** @class */ (function () {
        function AngularSlickgridComponent(cd, elm, excelExportService, exportService, extensionService, extensionUtility, filterService, gridEventService, gridService, gridStateService, groupingAndColspanService, paginationService, resizer, sharedService, sortService, treeDataService, translate, forRootConfig) {
            this.cd = cd;
            this.elm = elm;
            this.excelExportService = excelExportService;
            this.exportService = exportService;
            this.extensionService = extensionService;
            this.extensionUtility = extensionUtility;
            this.filterService = filterService;
            this.gridEventService = gridEventService;
            this.gridService = gridService;
            this.gridStateService = gridStateService;
            this.groupingAndColspanService = groupingAndColspanService;
            this.paginationService = paginationService;
            this.resizer = resizer;
            this.sharedService = sharedService;
            this.sortService = sortService;
            this.treeDataService = treeDataService;
            this.translate = translate;
            this.forRootConfig = forRootConfig;
            this._eventHandler = new Slick.EventHandler();
            this._hideHeaderRowAfterPageLoad = false;
            this._isGridInitialized = false;
            this._isDatasetInitialized = false;
            this._isPaginationInitialized = false;
            this._isLocalGrid = true;
            this.groupingDefinition = {};
            this.showCustomFooter = false;
            this.showPagination = false;
            this.totalItems = 0;
            this.subscriptions = [];
            this.onAngularGridCreated = new core.EventEmitter();
            this.onDataviewCreated = new core.EventEmitter();
            this.onGridCreated = new core.EventEmitter();
            this.onGridInitialized = new core.EventEmitter();
            this.onBeforeGridCreate = new core.EventEmitter();
            this.onBeforeGridDestroy = new core.EventEmitter();
            this.onAfterGridDestroyed = new core.EventEmitter();
            this.onGridStateChanged = new core.EventEmitter();
            this.onGridBeforeExportToFile = this.exportService.onGridBeforeExportToFile;
            this.onGridAfterExportToFile = this.exportService.onGridAfterExportToFile;
            this.onGridBeforeExportToExcel = this.excelExportService.onGridBeforeExportToExcel;
            this.onGridAfterExportToExcel = this.excelExportService.onGridAfterExportToExcel;
            this.slickEmptyWarning = new SlickEmptyWarningComponent(this.translate);
        }
        Object.defineProperty(AngularSlickgridComponent.prototype, "paginationOptions", {
            get: function () {
                return this._paginationOptions;
            },
            set: function (options) {
                if (options && this._paginationOptions) {
                    this._paginationOptions = __assign({}, this._paginationOptions, options);
                }
                else {
                    this._paginationOptions = options;
                }
                this.gridOptions.pagination = this._paginationOptions;
                this.paginationService.updateTotalItems(options && options.totalItems || 0, true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AngularSlickgridComponent.prototype, "gridHeight", {
            set: function (height) {
                this._fixedHeight = height;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AngularSlickgridComponent.prototype, "gridWidth", {
            set: function (width) {
                this._fixedWidth = width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AngularSlickgridComponent.prototype, "columnDefinitions", {
            get: function () {
                return this._columnDefinitions;
            },
            set: function (columnDefinitions) {
                this._columnDefinitions = columnDefinitions;
                if (this._isGridInitialized) {
                    this.updateColumnDefinitionsList(columnDefinitions);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AngularSlickgridComponent.prototype, "dataset", {
            get: function () {
                return this.dataView.getItems();
            },
            set: function (dataset) {
                this._dataset = dataset;
                this.refreshGridData(dataset);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AngularSlickgridComponent.prototype, "datasetHierarchical", {
            get: function () {
                return this.sharedService.hierarchicalDataset;
            },
            set: function (newHierarchicalDataset) {
                var _this = this;
                this.sharedService.hierarchicalDataset = newHierarchicalDataset;
                if (newHierarchicalDataset && this.columnDefinitions && this.filterService && this.filterService.clearFilters) {
                    this.filterService.clearFilters();
                }
                // when a hierarchical dataset is set afterward, we can reset the flat dataset and call a tree data sort that will overwrite the flat dataset
                setTimeout(function () {
                    if (newHierarchicalDataset && _this.dataView && _this.sortService && _this.sortService.processTreeDataInitialSort && _this.gridOptions && _this.gridOptions.enableTreeData) {
                        _this.dataView.setItems([], _this.gridOptions.datasetIdPropertyName);
                        _this.sortService.processTreeDataInitialSort();
                    }
                }, 1);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AngularSlickgridComponent.prototype, "elementRef", {
            get: function () {
                return this.elm;
            },
            enumerable: true,
            configurable: true
        });
        AngularSlickgridComponent.prototype.ngAfterViewInit = function () {
            this.initialization();
            this._isGridInitialized = true;
            // user must provide a "gridHeight" or use "autoResize: true" in the grid options
            if (!this._fixedHeight && !this.gridOptions.enableAutoResize) {
                throw new Error("[Angular-Slickgrid] requires a \"grid-height\" or the \"enableAutoResize\" grid option to be enabled.\n        Without that the grid will seem empty while in fact it just does not have any height define.");
            }
        };
        AngularSlickgridComponent.prototype.ngOnInit = function () {
            this.onBeforeGridCreate.emit(true);
            if (this.gridOptions && !this.gridOptions.enableAutoResize && (this._fixedHeight || this._fixedWidth)) {
                this.gridHeightString = this._fixedHeight + "px";
                this.gridWidthString = this._fixedWidth + "px";
            }
        };
        AngularSlickgridComponent.prototype.ngOnDestroy = function () {
            this.onBeforeGridDestroy.emit(this.grid);
            this.destroy();
            this.onAfterGridDestroyed.emit(true);
        };
        AngularSlickgridComponent.prototype.destroy = function (shouldEmptyDomElementContainer) {
            var e_1, _a, e_2, _b, e_3, _c;
            if (shouldEmptyDomElementContainer === void 0) { shouldEmptyDomElementContainer = false; }
            this.extensionService.dispose();
            this.filterService.dispose();
            this.gridEventService.dispose();
            this.gridStateService.dispose();
            this.gridService.dispose();
            this.groupingAndColspanService.dispose();
            this.paginationService.dispose();
            this.resizer.dispose();
            this.sortService.dispose();
            this.treeDataService.dispose();
            // dispose the Components
            this.slickEmptyWarning.dispose();
            if (this._eventHandler && this._eventHandler.unsubscribeAll) {
                this._eventHandler.unsubscribeAll();
            }
            if (this.dataView) {
                if (this.dataView && this.dataView.setItems) {
                    this.dataView.setItems([]);
                }
                if (this.dataView.destroy) {
                    this.dataView.destroy();
                }
            }
            if (this.grid && this.grid.destroy) {
                this.grid.destroy(shouldEmptyDomElementContainer);
            }
            if (this.backendServiceApi) {
                try {
                    for (var _d = __values(Object.keys(this.backendServiceApi)), _e = _d.next(); !_e.done; _e = _d.next()) {
                        var prop = _e.value;
                        this.backendServiceApi[prop] = null;
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                this.backendServiceApi = null;
            }
            try {
                for (var _f = __values(Object.keys(this.columnDefinitions)), _g = _f.next(); !_g.done; _g = _f.next()) {
                    var prop = _g.value;
                    this.columnDefinitions[prop] = null;
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
                }
                finally { if (e_2) throw e_2.error; }
            }
            try {
                for (var _h = __values(Object.keys(this.sharedService)), _j = _h.next(); !_j.done; _j = _h.next()) {
                    var prop = _j.value;
                    this.sharedService[prop] = null;
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_j && !_j.done && (_c = _h.return)) _c.call(_h);
                }
                finally { if (e_3) throw e_3.error; }
            }
            // we could optionally also empty the content of the grid container DOM element
            if (shouldEmptyDomElementContainer) {
                this.emptyGridContainerElm();
            }
            // also unsubscribe all RxJS subscriptions
            this.subscriptions = unsubscribeAllObservables(this.subscriptions);
            this._dataset = null;
            this.datasetHierarchical = null;
            this._columnDefinitions = [];
            this._angularGridInstances = null;
            this.grid = null;
            this.gridOptions = null;
            this.dataView = null;
        };
        AngularSlickgridComponent.prototype.emptyGridContainerElm = function () {
            var gridContainerId = this.gridOptions && this.gridOptions.gridContainerId || 'grid1';
            $(gridContainerId).empty();
        };
        /** Dispatch of Custom Event, which by default will bubble & is cancelable */
        AngularSlickgridComponent.prototype.dispatchCustomEvent = function (eventName, data, isBubbling, isCancelable) {
            if (isBubbling === void 0) { isBubbling = true; }
            if (isCancelable === void 0) { isCancelable = true; }
            var eventInit = { bubbles: isBubbling, cancelable: isCancelable };
            if (data) {
                eventInit.detail = data;
            }
            return this.elm.nativeElement.dispatchEvent(new CustomEvent(eventName, eventInit));
        };
        /**
         * Define our internal Post Process callback, it will execute internally after we get back result from the Process backend call
         * For now, this is GraphQL Service ONLY feature and it will basically refresh the Dataset & Pagination without having the user to create his own PostProcess every time
         */
        AngularSlickgridComponent.prototype.createBackendApiInternalPostProcessCallback = function (gridOptions) {
            var _this = this;
            var backendApi = gridOptions && gridOptions.backendServiceApi;
            if (backendApi && backendApi.service) {
                // internalPostProcess only works (for now) with a GraphQL Service, so make sure it is of that type
                if (backendApi.service instanceof GraphqlService || typeof backendApi.service.getDatasetName === 'function') {
                    backendApi.internalPostProcess = function (processResult) {
                        var datasetName = (backendApi && backendApi.service && typeof backendApi.service.getDatasetName === 'function') ? backendApi.service.getDatasetName() : '';
                        if (processResult && processResult.data && processResult.data[datasetName]) {
                            var data = processResult.data[datasetName].hasOwnProperty('nodes') ? processResult.data[datasetName].nodes : processResult.data[datasetName];
                            var totalCount = processResult.data[datasetName].hasOwnProperty('totalCount') ? processResult.data[datasetName].totalCount : processResult.data[datasetName].length;
                            _this.refreshGridData(data, totalCount || 0);
                        }
                    };
                }
            }
        };
        /**
         * On a Pagination changed, we will trigger a Grid State changed with the new pagination info
         * Also if we use Row Selection or the Checkbox Selector, we need to reset any selection
         */
        AngularSlickgridComponent.prototype.paginationChanged = function (pagination) {
            var isSyncGridSelectionEnabled = this.gridStateService && this.gridStateService.needToPreserveRowSelection() || false;
            if (!isSyncGridSelectionEnabled && (this.gridOptions.enableRowSelection || this.gridOptions.enableCheckboxSelector)) {
                this.gridService.setSelectedRows([]);
            }
            var pageNumber = pagination.pageNumber, pageSize = pagination.pageSize;
            if (this.sharedService) {
                if (pageSize) {
                    this.sharedService.currentPagination = { pageNumber: pageNumber, pageSize: pageSize };
                }
            }
            this.gridStateService.onGridStateChanged.next({
                change: { newValues: { pageNumber: pageNumber, pageSize: pageSize }, type: exports.GridStateType.pagination },
                gridState: this.gridStateService.getCurrentGridState()
            });
        };
        /**
         * When dataset changes, we need to refresh the entire grid UI & possibly resize it as well
         * @param dataset
         */
        AngularSlickgridComponent.prototype.refreshGridData = function (dataset, totalCount) {
            if (this.gridOptions && this.gridOptions.enableEmptyDataWarningMessage && Array.isArray(dataset)) {
                var finalTotalCount = totalCount || dataset.length;
                this.displayEmptyDataWarning(finalTotalCount < 1);
            }
            if (Array.isArray(dataset) && this.grid && this.dataView && typeof this.dataView.setItems === 'function') {
                this.dataView.setItems(dataset, this.gridOptions.datasetIdPropertyName);
                if (!this.gridOptions.backendServiceApi) {
                    this.dataView.reSort();
                }
                if (dataset.length > 0) {
                    if (!this._isDatasetInitialized) {
                        this.loadPresetsWhenDatasetInitialized();
                        if (this.gridOptions.enableCheckboxSelector) {
                            this.loadRowSelectionPresetWhenExists();
                        }
                    }
                    this._isDatasetInitialized = true;
                    // also update the hierarchical dataset
                    if (dataset.length > 0 && this.gridOptions.treeDataOptions) {
                        this.sharedService.hierarchicalDataset = this.treeDataSortComparer(dataset);
                    }
                }
                if (dataset) {
                    this.grid.invalidate();
                }
                // display the Pagination component only after calling this refresh data first, we call it here so that if we preset pagination page number it will be shown correctly
                this.showPagination = (this.gridOptions && (this.gridOptions.enablePagination || (this.gridOptions.backendServiceApi && this.gridOptions.enablePagination === undefined))) ? true : false;
                if (this.gridOptions && this.gridOptions.backendServiceApi && this.gridOptions.pagination) {
                    var paginationOptions = this.setPaginationOptionsWhenPresetDefined(this.gridOptions, this._paginationOptions);
                    // when we have a totalCount use it, else we'll take it from the pagination object
                    // only update the total items if it's different to avoid refreshing the UI
                    var totalRecords = totalCount !== undefined ? totalCount : (this.gridOptions && this.gridOptions.pagination && this.gridOptions.pagination.totalItems);
                    if (totalRecords !== this.totalItems) {
                        this.totalItems = totalRecords;
                    }
                    // initialize the Pagination Service with new pagination options (which might have presets)
                    if (!this._isPaginationInitialized) {
                        this.initializePaginationService(paginationOptions);
                    }
                    else {
                        // update the pagination service with the new total
                        this.paginationService.totalItems = this.totalItems;
                    }
                }
                // resize the grid inside a slight timeout, in case other DOM element changed prior to the resize (like a filter/pagination changed)
                if (this.grid && this.gridOptions.enableAutoResize) {
                    var delay = this.gridOptions.autoResize && this.gridOptions.autoResize.delay;
                    this.resizer.resizeGrid(delay || 10);
                }
            }
        };
        /**
         * Check if there's any Pagination Presets defined in the Grid Options,
         * if there are then load them in the paginationOptions object
         */
        AngularSlickgridComponent.prototype.setPaginationOptionsWhenPresetDefined = function (gridOptions, paginationOptions) {
            if (gridOptions.presets && gridOptions.presets.pagination && gridOptions.pagination) {
                paginationOptions.pageSize = gridOptions.presets.pagination.pageSize;
                paginationOptions.pageNumber = gridOptions.presets.pagination.pageNumber;
            }
            return paginationOptions;
        };
        /**
         * Dynamically change or update the column definitions list.
         * We will re-render the grid so that the new header and data shows up correctly.
         * If using i18n, we also need to trigger a re-translate of the column headers
         */
        AngularSlickgridComponent.prototype.updateColumnDefinitionsList = function (newColumnDefinitions) {
            // map/swap the internal library Editor to the SlickGrid Editor factory
            newColumnDefinitions = this.swapInternalEditorToSlickGridFactoryEditor(newColumnDefinitions);
            if (this.gridOptions.enableTranslate) {
                this.extensionService.translateColumnHeaders(false, newColumnDefinitions);
            }
            else {
                this.extensionService.renderColumnHeaders(newColumnDefinitions, true);
            }
            if (this.gridOptions && this.gridOptions.enableAutoSizeColumns) {
                this.grid.autosizeColumns();
            }
        };
        /**
         * Show the filter row displayed on first row, we can optionally pass false to hide it.
         * @param showing
         */
        AngularSlickgridComponent.prototype.showHeaderRow = function (showing) {
            if (showing === void 0) { showing = true; }
            this.grid.setHeaderRowVisibility(showing, false);
            if (showing === true && this._isGridInitialized) {
                this.grid.setColumns(this.columnDefinitions);
            }
            return showing;
        };
        //
        // private functions
        // ------------------
        AngularSlickgridComponent.prototype.displayEmptyDataWarning = function (showWarning) {
            if (showWarning === void 0) { showWarning = true; }
            this.slickEmptyWarning.grid = this.grid;
            this.slickEmptyWarning && this.slickEmptyWarning.showEmptyDataMessage(showWarning);
        };
        AngularSlickgridComponent.prototype.bindDifferentHooks = function (grid, gridOptions, dataView) {
            var _this = this;
            // on locale change, we have to manually translate the Headers, GridMenu
            if (this.translate && this.translate.onLangChange) {
                // translate some of them on first load, then on each language change
                if (gridOptions.enableTranslate) {
                    this.translateColumnHeaderTitleKeys();
                    this.translateColumnGroupKeys();
                    this.translateCustomFooterTexts();
                }
                this.subscriptions.push(this.translate.onLangChange.subscribe(function () {
                    if (gridOptions.enableTranslate) {
                        _this.extensionService.translateCellMenu();
                        _this.extensionService.translateColumnHeaders();
                        _this.extensionService.translateColumnPicker();
                        _this.extensionService.translateContextMenu();
                        _this.extensionService.translateGridMenu();
                        _this.extensionService.translateHeaderMenu();
                        _this.translateCustomFooterTexts();
                        _this.translateColumnHeaderTitleKeys();
                        _this.translateColumnGroupKeys();
                        if (gridOptions.createPreHeaderPanel && !gridOptions.enableDraggableGrouping) {
                            _this.groupingAndColspanService.translateGroupingAndColSpan();
                        }
                    }
                }));
            }
            if (!this.customDataView) {
                // bind external sorting (backend) when available or default onSort (dataView)
                if (gridOptions.enableSorting) {
                    // bind external sorting (backend) unless specified to use the local one
                    if (gridOptions.backendServiceApi && !gridOptions.backendServiceApi.useLocalSorting) {
                        this.sortService.bindBackendOnSort(grid);
                    }
                    else {
                        this.sortService.bindLocalOnSort(grid);
                    }
                }
                // bind external filter (backend) when available or default onFilter (dataView)
                if (gridOptions.enableFiltering) {
                    this.filterService.init(grid);
                    // bind external filter (backend) unless specified to use the local one
                    if (gridOptions.backendServiceApi && !gridOptions.backendServiceApi.useLocalFiltering) {
                        this.filterService.bindBackendOnFilter(grid);
                    }
                    else {
                        this.filterService.bindLocalOnFilter(grid);
                    }
                }
                // load any presets if any (after dataset is initialized)
                this.loadPresetsWhenDatasetInitialized();
            }
            // if user set an onInit Backend, we'll run it right away (and if so, we also need to run preProcess, internalPostProcess & postProcess)
            if (gridOptions.backendServiceApi) {
                var backendApi = gridOptions.backendServiceApi;
                if (backendApi && backendApi.service && backendApi.service.init) {
                    backendApi.service.init(backendApi.options, gridOptions.pagination, this.grid);
                }
            }
            var _loop_1 = function (prop) {
                if (grid.hasOwnProperty(prop) && prop.startsWith('on')) {
                    this_1._eventHandler.subscribe(grid[prop], function (event, args) {
                        return _this.dispatchCustomEvent("" + slickgridEventPrefix + titleCase(prop), { eventData: event, args: args });
                    });
                }
            };
            var this_1 = this;
            // expose all Slick Grid Events through dispatch
            for (var prop in grid) {
                _loop_1(prop);
            }
            var _loop_2 = function (prop) {
                if (dataView.hasOwnProperty(prop) && prop.startsWith('on')) {
                    this_2._eventHandler.subscribe(dataView[prop], function (event, args) {
                        return _this.dispatchCustomEvent("" + slickgridEventPrefix + titleCase(prop), { eventData: event, args: args });
                    });
                }
            };
            var this_2 = this;
            // expose all Slick DataView Events through dispatch
            for (var prop in dataView) {
                _loop_2(prop);
            }
            // expose GridState Service changes event through dispatch
            this.subscriptions.push(this.gridStateService.onGridStateChanged.subscribe(function (gridStateChange) {
                _this.onGridStateChanged.emit(gridStateChange);
            }));
            // on cell click, mainly used with the columnDef.action callback
            this.gridEventService.bindOnCellChange(grid, dataView);
            this.gridEventService.bindOnClick(grid, dataView);
            if (dataView && grid) {
                this._eventHandler.subscribe(dataView.onRowCountChanged, function (e, args) {
                    grid.invalidate();
                    _this.metrics = {
                        startTime: new Date(),
                        endTime: new Date(),
                        itemCount: args && args.current || 0,
                        totalItemCount: Array.isArray(_this.dataset) ? _this.dataset.length : 0
                    };
                    // when using local (in-memory) dataset, we'll display a warning message when filtered data is empty
                    if (_this._isLocalGrid && _this.gridOptions && _this.gridOptions.enableEmptyDataWarningMessage) {
                        _this.displayEmptyDataWarning(args.current === 0);
                    }
                });
                // when dealing with Tree Data View, make sure we have necessary tree data options
                if (this.gridOptions && this.gridOptions.enableTreeData && (!this.gridOptions.treeDataOptions || !this.gridOptions.treeDataOptions.columnId)) {
                    throw new Error('[Angular-Slickgrid] When enabling tree data, you must also provide the "treeDataOption" property in your Grid Options with "childrenPropName" or "parentPropName" (depending if your array is hierarchical or flat) for the Tree Data to work properly');
                }
                this._eventHandler.subscribe(dataView.onRowsChanged, function (e, args) {
                    // when dealing with Tree Data, anytime the flat dataset changes, we need to update our hierarchical dataset
                    // this could be triggered by a DataView setItems or updateItem
                    if (_this.gridOptions && _this.gridOptions.enableTreeData) {
                        var items = _this.dataView.getItems();
                        if (Array.isArray(items) && items.length > 0 && !_this._isDatasetInitialized) {
                            _this.sharedService.hierarchicalDataset = _this.treeDataSortComparer(items);
                        }
                    }
                    // filtering data with local dataset will not always show correctly unless we call this updateRow/render
                    // also don't use "invalidateRows" since it destroys the entire row and as bad user experience when updating a row
                    // see commit: https://github.com/ghiscoding/Angular-Slickgrid/commit/bb62c0aa2314a5d61188ff005ccb564577f08805
                    if (gridOptions && gridOptions.enableFiltering && !gridOptions.enableRowDetailView) {
                        if (args && args.rows && Array.isArray(args.rows)) {
                            args.rows.forEach(function (row) { return grid.updateRow(row); });
                            grid.render();
                        }
                    }
                });
            }
            // does the user have a colspan callback?
            if (gridOptions && gridOptions.colspanCallback && dataView && dataView.getItem && dataView.getItemMetadata) {
                dataView.getItemMetadata = function (rowNumber) {
                    var callbackResult = null;
                    if (gridOptions.colspanCallback && gridOptions.colspanCallback) {
                        callbackResult = gridOptions.colspanCallback(dataView.getItem(rowNumber));
                    }
                    return callbackResult;
                };
            }
        };
        AngularSlickgridComponent.prototype.bindBackendCallbackFunctions = function (gridOptions) {
            var _this = this;
            var backendApi = gridOptions.backendServiceApi;
            var backendApiService = backendApi && backendApi.service;
            var serviceOptions = backendApiService && backendApiService.options || {};
            var isExecuteCommandOnInit = (!serviceOptions) ? false : ((serviceOptions && serviceOptions.hasOwnProperty('executeProcessCommandOnInit')) ? serviceOptions['executeProcessCommandOnInit'] : true);
            if (backendApiService) {
                // update backend filters (if need be) BEFORE the query runs (via the onInit command a few lines below)
                // if user entered some any "presets", we need to reflect them all in the grid
                if (gridOptions && gridOptions.presets) {
                    // Filters "presets"
                    if (backendApiService.updateFilters && Array.isArray(gridOptions.presets.filters) && gridOptions.presets.filters.length > 0) {
                        backendApiService.updateFilters(gridOptions.presets.filters, true);
                    }
                    // Sorters "presets"
                    if (backendApiService.updateSorters && Array.isArray(gridOptions.presets.sorters) && gridOptions.presets.sorters.length > 0) {
                        backendApiService.updateSorters(undefined, gridOptions.presets.sorters);
                    }
                    // Pagination "presets"
                    if (backendApiService.updatePagination && gridOptions.presets.pagination) {
                        var _a = gridOptions.presets.pagination, pageNumber = _a.pageNumber, pageSize = _a.pageSize;
                        backendApiService.updatePagination(pageNumber, pageSize);
                    }
                }
                else {
                    var columnFilters = this.filterService.getColumnFilters();
                    if (columnFilters && backendApiService.updateFilters) {
                        backendApiService.updateFilters(columnFilters, false);
                    }
                }
                // execute onInit command when necessary
                if (backendApi && backendApiService && (backendApi.onInit || isExecuteCommandOnInit)) {
                    var query = (typeof backendApiService.buildQuery === 'function') ? backendApiService.buildQuery() : '';
                    var process_1 = (isExecuteCommandOnInit) ? (backendApi.process && backendApi.process(query) || null) : (backendApi.onInit && backendApi.onInit(query) || null);
                    // wrap this inside a setTimeout to avoid timing issue since the gridOptions needs to be ready before running this onInit
                    setTimeout(function () {
                        // keep start time & end timestamps then return these metrics after the process execution
                        var startTime = new Date();
                        // run any pre-process, if defined, for example a spinner
                        if (backendApi.preProcess) {
                            backendApi.preProcess();
                        }
                        // the processes can be Promises or Observables (like Angular HttpClient)
                        var totalItems = _this.gridOptions && _this.gridOptions.pagination && _this.gridOptions.pagination.totalItems;
                        if (process_1 instanceof Promise && process_1.then) {
                            process_1.then(function (processResult) { return executeBackendProcessesCallback(startTime, processResult, backendApi, totalItems); })
                                .catch(function (error) { return onBackendError(error, backendApi); });
                        }
                        else if (rxjs.isObservable(process_1)) {
                            _this.subscriptions.push(process_1.subscribe(function (processResult) { return executeBackendProcessesCallback(startTime, processResult, backendApi, totalItems); }, function (error) { return onBackendError(error, backendApi); }));
                        }
                    });
                }
            }
        };
        AngularSlickgridComponent.prototype.bindResizeHook = function (grid, options) {
            // expand/autofit columns on first page load
            if (grid && options.autoFitColumnsOnFirstLoad && options.enableAutoSizeColumns) {
                grid.autosizeColumns();
            }
            // auto-resize grid on browser resize
            if (this._fixedHeight || this._fixedWidth) {
                this.resizer.init(grid, { height: this._fixedHeight, width: this._fixedWidth });
            }
            else {
                this.resizer.init(grid);
            }
            if (options.enableAutoResize) {
                this.resizer.bindAutoResizeDataGrid();
                if (grid && options.autoFitColumnsOnFirstLoad && options.enableAutoSizeColumns) {
                    grid.autosizeColumns();
                }
            }
        };
        AngularSlickgridComponent.prototype.executeAfterDataviewCreated = function (grid, gridOptions, dataView) {
            // if user entered some Sort "presets", we need to reflect them all in the DOM
            if (gridOptions.enableSorting) {
                if (gridOptions.presets && Array.isArray(gridOptions.presets.sorters) && gridOptions.presets.sorters.length > 0) {
                    this.sortService.loadGridSorters(gridOptions.presets.sorters);
                }
            }
        };
        AngularSlickgridComponent.prototype.initializePaginationService = function (paginationOptions) {
            var _this = this;
            if (this.gridOptions) {
                this.paginationData = {
                    gridOptions: this.gridOptions,
                };
                this.paginationService.totalItems = this.totalItems;
                this.paginationService.init(this.grid, this.dataView, paginationOptions, this.backendServiceApi);
                this.subscriptions.push(this.paginationService.onPaginationChanged.subscribe(function (changes) { return _this.paginationChanged(changes); }), this.paginationService.onPaginationVisibilityChanged.subscribe(function (visibility) {
                    _this.showPagination = visibility && visibility.visible || false;
                    if (_this.gridOptions && _this.gridOptions.backendServiceApi) {
                        refreshBackendDataset();
                    }
                }));
                this._isPaginationInitialized = true;
            }
            this.cd.detectChanges();
        };
        AngularSlickgridComponent.prototype.initialization = function () {
            // when detecting a frozen grid, we'll automatically enable the mousewheel scroll handler so that we can scroll from both left/right frozen containers
            if (this.gridOptions && ((this.gridOptions.frozenRow !== undefined && this.gridOptions.frozenRow >= 0) || this.gridOptions.frozenColumn !== undefined && this.gridOptions.frozenColumn >= 0) && this.gridOptions.enableMouseWheelScrollHandler === undefined) {
                this.gridOptions.enableMouseWheelScrollHandler = true;
            }
            // make sure the dataset is initialized (if not it will throw an error that it cannot getLength of null)
            this._dataset = this._dataset || [];
            this.gridOptions = this.mergeGridOptions(this.gridOptions);
            this._paginationOptions = this.gridOptions.pagination;
            this.locales = this.gridOptions && this.gridOptions.locales || Constants.locales;
            this.backendServiceApi = this.gridOptions && this.gridOptions.backendServiceApi;
            this.createBackendApiInternalPostProcessCallback(this.gridOptions);
            this._isLocalGrid = !this.backendServiceApi; // considered a local grid if it doesn't have a backend service set
            if (!this.customDataView) {
                var dataviewInlineFilters = this.gridOptions.dataView && this.gridOptions.dataView.inlineFilters || false;
                var dataViewOptions = { inlineFilters: dataviewInlineFilters };
                if (this.gridOptions.draggableGrouping || this.gridOptions.enableGrouping) {
                    this.extensionUtility.loadExtensionDynamically(exports.ExtensionName.groupItemMetaProvider);
                    this.groupItemMetadataProvider = new Slick.Data.GroupItemMetadataProvider();
                    this.sharedService.groupItemMetadataProvider = this.groupItemMetadataProvider;
                    dataViewOptions = __assign({}, dataViewOptions, { groupItemMetadataProvider: this.groupItemMetadataProvider });
                }
                this.dataView = new Slick.Data.DataView(dataViewOptions);
            }
            // for convenience to the user, we provide the property "editor" as an Angular-Slickgrid editor complex object
            // however "editor" is used internally by SlickGrid for it's own Editor Factory
            // so in our lib we will swap "editor" and copy it into a new property called "internalColumnEditor"
            // then take back "editor.model" and make it the new "editor" so that SlickGrid Editor Factory still works
            this._columnDefinitions = this.swapInternalEditorToSlickGridFactoryEditor(this._columnDefinitions);
            // save reference for all columns before they optionally become hidden/visible
            this.sharedService.allColumns = this._columnDefinitions;
            this.sharedService.visibleColumns = this._columnDefinitions;
            this.extensionService.createExtensionsBeforeGridCreation(this._columnDefinitions, this.gridOptions);
            // build SlickGrid Grid, also user might optionally pass a custom dataview (e.g. remote model)
            this.grid = new Slick.Grid("#" + this.gridId, this.customDataView || this.dataView, this._columnDefinitions, this.gridOptions);
            this.sharedService.dataView = this.dataView;
            this.sharedService.grid = this.grid;
            this.extensionService.bindDifferentExtensions();
            this.bindDifferentHooks(this.grid, this.gridOptions, this.dataView);
            // emit the Grid & DataView object to make them available in parent component
            this.onGridCreated.emit(this.grid);
            // when it's a frozen grid, we need to keep the frozen column id for reference if we ever show/hide column from ColumnPicker/GridMenu afterward
            var frozenColumnIndex = this.gridOptions.frozenColumn !== undefined ? this.gridOptions.frozenColumn : -1;
            if (frozenColumnIndex >= 0 && frozenColumnIndex <= this._columnDefinitions.length) {
                this.sharedService.frozenVisibleColumnId = this._columnDefinitions[frozenColumnIndex].id || '';
            }
            // initialize the SlickGrid grid
            this.grid.init();
            if (!this.customDataView && (this.dataView && this.dataView.beginUpdate && this.dataView.setItems && this.dataView.endUpdate)) {
                this.onDataviewCreated.emit(this.dataView);
                this.dataView.beginUpdate();
                this.dataView.setItems(this._dataset || [], this.gridOptions.datasetIdPropertyName);
                this.dataView.endUpdate();
                // if you don't want the items that are not visible (due to being filtered out or being on a different page)
                // to stay selected, pass 'false' to the second arg
                var selectionModel = this.grid && this.grid.getSelectionModel();
                if (selectionModel && this.gridOptions && this.gridOptions.dataView && this.gridOptions.dataView.hasOwnProperty('syncGridSelection')) {
                    // if we are using a Backend Service, we will do an extra flag check, the reason is because it might have some unintended behaviors
                    // with the BackendServiceApi because technically the data in the page changes the DataView on every page change.
                    var preservedRowSelectionWithBackend = false;
                    if (this.gridOptions.backendServiceApi && this.gridOptions.dataView.hasOwnProperty('syncGridSelectionWithBackendService')) {
                        preservedRowSelectionWithBackend = this.gridOptions.dataView.syncGridSelectionWithBackendService;
                    }
                    var syncGridSelection = this.gridOptions.dataView.syncGridSelection;
                    if (typeof syncGridSelection === 'boolean') {
                        var preservedRowSelection = syncGridSelection;
                        if (!this._isLocalGrid) {
                            // when using BackendServiceApi, we'll be using the "syncGridSelectionWithBackendService" flag BUT "syncGridSelection" must also be set to True
                            preservedRowSelection = syncGridSelection && preservedRowSelectionWithBackend;
                        }
                        this.dataView.syncGridSelection(this.grid, preservedRowSelection);
                    }
                    else if (typeof syncGridSelection === 'object') {
                        this.dataView.syncGridSelection(this.grid, syncGridSelection.preserveHidden, syncGridSelection.preserveHiddenOnSelectionChange);
                    }
                }
                var datasetLn = this.dataView.getLength() || this._dataset && this._dataset.length || 0;
                if (datasetLn > 0) {
                    if (!this._isDatasetInitialized && (this.gridOptions.enableCheckboxSelector || this.gridOptions.enableRowSelection)) {
                        this.loadRowSelectionPresetWhenExists();
                    }
                    this.loadPresetsWhenDatasetInitialized();
                    this._isDatasetInitialized = true;
                }
            }
            // user might want to hide the header row on page load but still have `enableFiltering: true`
            // if that is the case, we need to hide the headerRow ONLY AFTER all filters got created & dataView exist
            if (this._hideHeaderRowAfterPageLoad) {
                this.showHeaderRow(false);
                this.sharedService.hideHeaderRowAfterPageLoad = this._hideHeaderRowAfterPageLoad;
            }
            // after the DataView is created & updated execute some processes
            this.executeAfterDataviewCreated(this.grid, this.gridOptions, this.dataView);
            // bind resize ONLY after the dataView is ready
            this.bindResizeHook(this.grid, this.gridOptions);
            // bind & initialize grouping and header grouping colspan service
            if (this.gridOptions.createPreHeaderPanel && !this.gridOptions.enableDraggableGrouping) {
                this.groupingAndColspanService.init(this.grid, this.dataView);
            }
            // bind & initialize the grid service
            this.gridService.init(this.grid, this.dataView);
            // when user enables translation, we need to translate Headers on first pass & subsequently in the bindDifferentHooks
            if (this.gridOptions.enableTranslate) {
                this.extensionService.translateColumnHeaders();
            }
            // if Export is enabled, initialize the service with the necessary grid and other objects
            if (this.gridOptions.enableExport) {
                this.exportService.init(this.grid, this.dataView);
            }
            // if Excel Export is enabled, initialize the service with the necessary grid and other objects
            if (this.gridOptions.enableExcelExport && this.sharedService) {
                this.excelExportService.init(this.grid, this.dataView);
            }
            // when using Tree Data View
            if (this.gridOptions.enableTreeData) {
                this.treeDataService.init(this.grid);
            }
            // once all hooks are in placed and the grid is initialized, we can emit an event
            this.onGridInitialized.emit(this.grid);
            // bind the Backend Service API callback functions only after the grid is initialized
            // because the preProcess() and onInit() might get triggered
            if (this.gridOptions && this.gridOptions.backendServiceApi) {
                this.bindBackendCallbackFunctions(this.gridOptions);
            }
            this.gridStateService.init(this.grid, this.dataView);
            // local grid, check if we need to show the Pagination
            // if so then also check if there's any presets and finally initialize the PaginationService
            // a local grid with Pagination presets will potentially have a different total of items, we'll need to get it from the DataView and update our total
            if (this.gridOptions && this.gridOptions.enablePagination && this._isLocalGrid) {
                this.showPagination = true;
                this.loadLocalGridPagination();
            }
            this._angularGridInstances = {
                // Slick Grid & DataView objects
                dataView: this.dataView,
                slickGrid: this.grid,
                extensions: this.extensionService && this.extensionService.extensionList,
                // public methods
                destroy: this.destroy.bind(this),
                // return all available Services (non-singleton)
                backendService: this.gridOptions && this.gridOptions.backendServiceApi && this.gridOptions.backendServiceApi.service,
                excelExportService: this.excelExportService,
                exportService: this.exportService,
                extensionService: this.extensionService,
                filterService: this.filterService,
                gridEventService: this.gridEventService,
                gridStateService: this.gridStateService,
                gridService: this.gridService,
                groupingService: this.groupingAndColspanService,
                paginationService: this.paginationService,
                resizerService: this.resizer,
                sortService: this.sortService,
                treeDataService: this.treeDataService,
                /** @deprecated please use "extensionService" instead */
                pluginService: this.extensionService,
            };
            // all instances (SlickGrid, DataView & all Services)
            this.onAngularGridCreated.emit(this._angularGridInstances);
            // user could show a custom footer with the data metrics (dataset length and last updated timestamp)
            this.optionallyShowCustomFooterWithMetrics();
        };
        /** Load the Editor Collection asynchronously and replace the "collection" property when Observable resolves */
        AngularSlickgridComponent.prototype.loadEditorCollectionAsync = function (column) {
            var _this = this;
            var collectionAsync = column && column.editor && column.editor.collectionAsync;
            if (collectionAsync instanceof rxjs.Observable) {
                this.subscriptions.push(collectionAsync.subscribe(function (resolvedCollection) { return _this.updateEditorCollection(column, resolvedCollection); }));
            }
        };
        AngularSlickgridComponent.prototype.loadPresetsWhenDatasetInitialized = function () {
            if (this.gridOptions && !this.customDataView) {
                // if user entered some Filter "presets", we need to reflect them all in the DOM
                if (this.gridOptions.presets && Array.isArray(this.gridOptions.presets.filters) && this.gridOptions.presets.filters.length > 0) {
                    this.filterService.populateColumnFilterSearchTermPresets(this.gridOptions.presets.filters);
                }
                // if user entered some Columns "presets", we need to reflect them all in the grid
                if (this.gridOptions.presets && Array.isArray(this.gridOptions.presets.columns) && this.gridOptions.presets.columns.length > 0) {
                    var gridColumns = this.gridStateService.getAssociatedGridColumns(this.grid, this.gridOptions.presets.columns);
                    if (gridColumns && Array.isArray(gridColumns) && gridColumns.length > 0) {
                        // make sure that the checkbox selector is also visible if it is enabled
                        if (this.gridOptions.enableCheckboxSelector) {
                            var checkboxColumn = (Array.isArray(this._columnDefinitions) && this._columnDefinitions.length > 0) ? this._columnDefinitions[0] : null;
                            if (checkboxColumn && checkboxColumn.id === '_checkbox_selector' && gridColumns[0].id !== '_checkbox_selector') {
                                gridColumns.unshift(checkboxColumn);
                            }
                        }
                        // finally set the new presets columns (including checkbox selector if need be)
                        this.grid.setColumns(gridColumns);
                    }
                }
            }
        };
        /**
         * local grid, check if we need to show the Pagination
         * if so then also check if there's any presets and finally initialize the PaginationService
         * a local grid with Pagination presets will potentially have a different total of items, we'll need to get it from the DataView and update our total
         */
        AngularSlickgridComponent.prototype.loadLocalGridPagination = function () {
            if (this.gridOptions) {
                this.totalItems = Array.isArray(this.dataset) ? this.dataset.length : 0;
                if (this._paginationOptions && this.dataView && this.dataView.getPagingInfo) {
                    var slickPagingInfo = this.dataView.getPagingInfo() || {};
                    if (slickPagingInfo.hasOwnProperty('totalRows') && this._paginationOptions.totalItems !== slickPagingInfo.totalRows) {
                        this.totalItems = slickPagingInfo.totalRows;
                    }
                }
                this._paginationOptions.totalItems = this.totalItems;
                var paginationOptions = this.setPaginationOptionsWhenPresetDefined(this.gridOptions, this._paginationOptions);
                this.initializePaginationService(paginationOptions);
            }
        };
        /** Load any Row Selections into the DataView that were presets by the user */
        AngularSlickgridComponent.prototype.loadRowSelectionPresetWhenExists = function () {
            var _this = this;
            // if user entered some Row Selections "presets"
            var presets = this.gridOptions && this.gridOptions.presets;
            var selectionModel = this.grid && this.grid.getSelectionModel();
            var enableRowSelection = this.gridOptions && (this.gridOptions.enableCheckboxSelector || this.gridOptions.enableRowSelection);
            if (enableRowSelection && selectionModel && presets && presets.rowSelection && (Array.isArray(presets.rowSelection.gridRowIndexes) || Array.isArray(presets.rowSelection.dataContextIds))) {
                var dataContextIds = presets.rowSelection.dataContextIds;
                var gridRowIndexes_1 = presets.rowSelection.gridRowIndexes;
                // maps the IDs to the Grid Rows and vice versa, the "dataContextIds" has precedence over the other
                if (Array.isArray(dataContextIds) && dataContextIds.length > 0) {
                    gridRowIndexes_1 = this.dataView.mapIdsToRows(dataContextIds) || [];
                }
                else if (Array.isArray(gridRowIndexes_1) && gridRowIndexes_1.length > 0) {
                    dataContextIds = this.dataView.mapRowsToIds(gridRowIndexes_1) || [];
                }
                this.gridStateService.selectedRowDataContextIds = dataContextIds;
                // change the selected rows except UNLESS it's a Local Grid with Pagination
                // local Pagination uses the DataView and that also trigger a change/refresh
                // and we don't want to trigger 2 Grid State changes just 1
                if ((this._isLocalGrid && !this.gridOptions.enablePagination) || !this._isLocalGrid) {
                    setTimeout(function () { return _this.grid.setSelectedRows(gridRowIndexes_1); });
                }
            }
        };
        AngularSlickgridComponent.prototype.mergeGridOptions = function (gridOptions) {
            gridOptions.gridId = this.gridId;
            gridOptions.gridContainerId = "slickGridContainer-" + this.gridId;
            // if we have a backendServiceApi and the enablePagination is undefined, we'll assume that we do want to see it, else get that defined value
            // @deprecated TODO remove this check in the future, user should explicitely enable the Pagination since this feature is now optional (you can now call OData/GraphQL without Pagination which is a new feature)
            gridOptions.enablePagination = ((gridOptions.backendServiceApi && gridOptions.enablePagination === undefined) ? true : gridOptions.enablePagination) || false;
            // use jquery extend to deep merge & copy to avoid immutable properties being changed in GlobalGridOptions after a route change
            var options = $.extend(true, {}, GlobalGridOptions, this.forRootConfig, gridOptions);
            // using jQuery extend to do a deep clone has an unwanted side on objects and pageSizes but ES6 spread has other worst side effects
            // so we will just overwrite the pageSizes when needed, this is the only one causing issues so far.
            // jQuery wrote this on their docs:: On a deep extend, Object and Array are extended, but object wrappers on primitive types such as String, Boolean, and Number are not.
            if (options && options.pagination && (gridOptions.enablePagination || gridOptions.backendServiceApi) && gridOptions.pagination && Array.isArray(gridOptions.pagination.pageSizes)) {
                options.pagination.pageSizes = gridOptions.pagination.pageSizes;
            }
            // also make sure to show the header row if user have enabled filtering
            this._hideHeaderRowAfterPageLoad = (options.showHeaderRow === false);
            if (options.enableFiltering && !options.showHeaderRow) {
                options.showHeaderRow = options.enableFiltering;
            }
            // when we use Pagination on Local Grid, it doesn't seem to work without enableFiltering
            // so we'll enable the filtering but we'll keep the header row hidden
            if (!options.enableFiltering && options.enablePagination && this._isLocalGrid) {
                options.enableFiltering = true;
                options.showHeaderRow = false;
                this._hideHeaderRowAfterPageLoad = true;
                this.sharedService.hideHeaderRowAfterPageLoad = true;
            }
            return options;
        };
        /**
         * We could optionally display a custom footer below the grid to show some metrics (last update, item count with/without filters)
         * It's an opt-in, user has to enable "showCustomFooter" and it cannot be used when there's already a Pagination since they display the same kind of info
         */
        AngularSlickgridComponent.prototype.optionallyShowCustomFooterWithMetrics = function () {
            if (this.gridOptions) {
                if (this.gridOptions.enableTranslate) {
                    this.translateCustomFooterTexts();
                }
                else if (this.gridOptions.customFooterOptions) {
                    var customFooterOptions = this.gridOptions.customFooterOptions;
                    customFooterOptions.metricTexts = customFooterOptions.metricTexts || {};
                    customFooterOptions.metricTexts.lastUpdate = customFooterOptions.metricTexts.lastUpdate || this.locales && this.locales.TEXT_LAST_UPDATE || 'TEXT_LAST_UPDATE';
                    customFooterOptions.metricTexts.items = customFooterOptions.metricTexts.items || this.locales && this.locales.TEXT_ITEMS || 'TEXT_ITEMS';
                    customFooterOptions.metricTexts.of = customFooterOptions.metricTexts.of || this.locales && this.locales.TEXT_OF || 'TEXT_OF';
                }
                // we will display the custom footer only when there's no Pagination
                if (!this.gridOptions.enablePagination && !this._isPaginationInitialized) {
                    this.showCustomFooter = this.gridOptions.hasOwnProperty('showCustomFooter') ? this.gridOptions.showCustomFooter : false;
                    this.customFooterOptions = this.gridOptions.customFooterOptions || {};
                }
                this.cd.detectChanges();
            }
        };
        AngularSlickgridComponent.prototype.treeDataSortComparer = function (flatDataset) {
            var dataViewIdIdentifier = this.gridOptions && this.gridOptions.datasetIdPropertyName || 'id';
            var treeDataOpt = this.gridOptions && this.gridOptions.treeDataOptions || { columnId: '' };
            var treeDataOptions = __assign({}, treeDataOpt, { identifierPropName: treeDataOpt.identifierPropName || dataViewIdIdentifier });
            return convertParentChildArrayToHierarchicalView(flatDataset, treeDataOptions);
        };
        /**
         * For convenience to the user, we provide the property "editor" as an Angular-Slickgrid editor complex object
         * however "editor" is used internally by SlickGrid for it's own Editor Factory
         * so in our lib we will swap "editor" and copy it into a new property called "internalColumnEditor"
         * then take back "editor.model" and make it the new "editor" so that SlickGrid Editor Factory still works
         */
        AngularSlickgridComponent.prototype.swapInternalEditorToSlickGridFactoryEditor = function (columnDefinitions) {
            var _this = this;
            return columnDefinitions.map(function (column) {
                // on every Editor that have a "collectionAsync", resolve the data and assign it to the "collection" property
                if (column && column.editor && column.editor.collectionAsync) {
                    _this.loadEditorCollectionAsync(column);
                }
                return __assign({}, column, { editor: column.editor && column.editor.model, internalColumnEditor: __assign({}, column.editor) });
            });
        };
        /** Translate all Custom Footer Texts (footer with metrics) */
        AngularSlickgridComponent.prototype.translateCustomFooterTexts = function () {
            var e_4, _a;
            if (this.translate && this.translate.instant && this.translate.currentLang) {
                var customFooterOptions = this.gridOptions && this.gridOptions.customFooterOptions || {};
                customFooterOptions.metricTexts = customFooterOptions.metricTexts || {};
                try {
                    for (var _b = __values(Object.keys(customFooterOptions.metricTexts)), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var propName = _c.value;
                        if (propName.lastIndexOf('Key') > 0) {
                            var propNameWithoutKey = propName.substring(0, propName.lastIndexOf('Key'));
                            customFooterOptions.metricTexts[propNameWithoutKey] = this.translate.instant(customFooterOptions.metricTexts[propName] || ' ');
                        }
                    }
                }
                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_4) throw e_4.error; }
                }
            }
        };
        AngularSlickgridComponent.prototype.translateColumnHeaderTitleKeys = function () {
            // translate all columns (including hidden columns)
            // eventually deprecate the "headerKey" and use only the "nameKey"
            this.extensionUtility.translateItems(this.sharedService.allColumns, 'headerKey', 'name');
            this.extensionUtility.translateItems(this.sharedService.allColumns, 'nameKey', 'name');
        };
        AngularSlickgridComponent.prototype.translateColumnGroupKeys = function () {
            // translate all column groups (including hidden columns)
            this.extensionUtility.translateItems(this.sharedService.allColumns, 'columnGroupKey', 'columnGroup');
        };
        /**
         * Update the Editor "collection" property from an async call resolved
         * Since this is called after the async call resolves, the pointer will not be the same as the "column" argument passed.
         * Once we found the new pointer, we will reassign the "editor" and "collection" to the "internalColumnEditor" so it has newest collection
         */
        AngularSlickgridComponent.prototype.updateEditorCollection = function (column, newCollection) {
            column.editor.collection = newCollection;
            // find the new column reference pointer
            var columns = this.grid.getColumns();
            if (Array.isArray(columns)) {
                var columnRef = columns.find(function (col) { return col.id === column.id; });
                columnRef.internalColumnEditor = column.editor;
            }
        };
        AngularSlickgridComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef },
            { type: ExcelExportService },
            { type: ExportService },
            { type: ExtensionService },
            { type: ExtensionUtility },
            { type: FilterService },
            { type: GridEventService },
            { type: GridService },
            { type: GridStateService },
            { type: GroupingAndColspanService },
            { type: PaginationService },
            { type: ResizerService },
            { type: SharedService },
            { type: SortService },
            { type: TreeDataService },
            { type: core$1.TranslateService, decorators: [{ type: core.Optional }] },
            { type: undefined, decorators: [{ type: core.Inject, args: ['config',] }] }
        ]; };
        __decorate([
            core.Output()
        ], AngularSlickgridComponent.prototype, "onAngularGridCreated", void 0);
        __decorate([
            core.Output()
        ], AngularSlickgridComponent.prototype, "onDataviewCreated", void 0);
        __decorate([
            core.Output()
        ], AngularSlickgridComponent.prototype, "onGridCreated", void 0);
        __decorate([
            core.Output()
        ], AngularSlickgridComponent.prototype, "onGridInitialized", void 0);
        __decorate([
            core.Output()
        ], AngularSlickgridComponent.prototype, "onBeforeGridCreate", void 0);
        __decorate([
            core.Output()
        ], AngularSlickgridComponent.prototype, "onBeforeGridDestroy", void 0);
        __decorate([
            core.Output()
        ], AngularSlickgridComponent.prototype, "onAfterGridDestroyed", void 0);
        __decorate([
            core.Output()
        ], AngularSlickgridComponent.prototype, "onGridStateChanged", void 0);
        __decorate([
            core.Output()
        ], AngularSlickgridComponent.prototype, "onGridBeforeExportToFile", void 0);
        __decorate([
            core.Output()
        ], AngularSlickgridComponent.prototype, "onGridAfterExportToFile", void 0);
        __decorate([
            core.Output()
        ], AngularSlickgridComponent.prototype, "onGridBeforeExportToExcel", void 0);
        __decorate([
            core.Output()
        ], AngularSlickgridComponent.prototype, "onGridAfterExportToExcel", void 0);
        __decorate([
            core.Input()
        ], AngularSlickgridComponent.prototype, "customDataView", void 0);
        __decorate([
            core.Input()
        ], AngularSlickgridComponent.prototype, "gridId", void 0);
        __decorate([
            core.Input()
        ], AngularSlickgridComponent.prototype, "gridOptions", void 0);
        __decorate([
            core.Input()
        ], AngularSlickgridComponent.prototype, "paginationOptions", null);
        __decorate([
            core.Input()
        ], AngularSlickgridComponent.prototype, "gridHeight", null);
        __decorate([
            core.Input()
        ], AngularSlickgridComponent.prototype, "gridWidth", null);
        __decorate([
            core.Input()
        ], AngularSlickgridComponent.prototype, "columnDefinitions", null);
        __decorate([
            core.Input()
        ], AngularSlickgridComponent.prototype, "dataset", null);
        __decorate([
            core.Input()
        ], AngularSlickgridComponent.prototype, "datasetHierarchical", null);
        AngularSlickgridComponent = __decorate([
            core.Component({
                selector: 'angular-slickgrid',
                template: "<div id=\"slickGridContainer-{{gridId}}\" class=\"gridPane\" [style.width]=\"gridWidthString\">\r\n  <div attr.id='{{gridId}}' class=\"slickgrid-container\" style=\"width: 100%\" [style.height]=\"gridHeightString\">\r\n  </div>\r\n\r\n  <!-- Pagination section under the grid -->\r\n  <slick-pagination id=\"slickPagingContainer-{{gridId}}\" *ngIf=\"showPagination\" [gridOptions]=\"gridOptions\">\r\n  </slick-pagination>\r\n\r\n  <!-- Custom Footer section under the grid -->\r\n  <div *ngIf=\"showCustomFooter && customFooterOptions\" class=\"slick-custom-footer\" style=\"width: 100%;\"\r\n       [style.height]=\"customFooterOptions?.footerHeight || 20\">\r\n    <div class=\"left-footer\" [ngClass]=\"customFooterOptions.leftContainerClass\">\r\n      {{customFooterOptions.leftFooterText}}\r\n    </div>\r\n\r\n    <div class=\"right-footer metrics\" [ngClass]=\"customFooterOptions.rightContainerClass\"\r\n         *ngIf=\"metrics && !customFooterOptions.hideMetrics\">\r\n      <span *ngIf=\"!customFooterOptions.hideLastUpdateTimestamp\">\r\n        <span>{{customFooterOptions.metricTexts?.lastUpdate}}</span>\r\n\r\n        {{metrics.endTime | date: customFooterOptions.dateFormat}}\r\n        <span class=\"separator\">{{customFooterOptions.metricSeparator}}</span>\r\n      </span>\r\n\r\n      {{metrics.itemCount}}\r\n      <span *ngIf=\"!customFooterOptions.hideTotalItemCount\">{{customFooterOptions.metricTexts?.of}}\r\n        {{metrics.totalItemCount}}\r\n      </span>\r\n      {{customFooterOptions.metricTexts?.items}}\r\n    </div>\r\n  </div>\r\n</div>\r\n",
                providers: [
                    // make everything transient (non-singleton)
                    AngularUtilService,
                    AutoTooltipExtension,
                    CellExternalCopyManagerExtension,
                    CellMenuExtension,
                    CheckboxSelectorExtension,
                    ColumnPickerExtension,
                    ContextMenuExtension,
                    DraggableGroupingExtension,
                    ExcelExportService,
                    ExtensionService,
                    ExportService,
                    ExtensionUtility,
                    FilterFactory,
                    FilterService,
                    GraphqlService,
                    GridEventService,
                    GridMenuExtension,
                    GridService,
                    GridStateService,
                    GroupingAndColspanService,
                    GroupItemMetaProviderExtension,
                    HeaderButtonExtension,
                    HeaderMenuExtension,
                    PaginationService,
                    ResizerService,
                    RowDetailViewExtension,
                    RowMoveManagerExtension,
                    RowSelectionExtension,
                    SharedService,
                    SortService,
                    SlickgridConfig,
                    TreeDataService,
                ]
            }),
            __param(16, core.Optional()),
            __param(17, core.Inject('config'))
        ], AngularSlickgridComponent);
        return AngularSlickgridComponent;
    }());

    var AngularSlickgridModule = /** @class */ (function () {
        function AngularSlickgridModule() {
        }
        AngularSlickgridModule_1 = AngularSlickgridModule;
        AngularSlickgridModule.forRoot = function (config) {
            if (config === void 0) { config = {}; }
            return {
                ngModule: AngularSlickgridModule_1,
                providers: [
                    { provide: 'config', useValue: config },
                    AngularUtilService,
                    BsDropDownService,
                    CollectionService,
                    FilterFactory,
                    GraphqlService,
                    GridOdataService,
                ]
            };
        };
        var AngularSlickgridModule_1;
        AngularSlickgridModule = AngularSlickgridModule_1 = __decorate([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    core$1.TranslateModule
                ],
                declarations: [
                    AngularSlickgridComponent,
                    SlickPaginationComponent
                ],
                exports: [
                    AngularSlickgridComponent,
                    SlickPaginationComponent
                ],
                entryComponents: [AngularSlickgridComponent]
            })
        ], AngularSlickgridModule);
        return AngularSlickgridModule;
    }());

    exports.Aggregators = Aggregators;
    exports.AngularSlickgridComponent = AngularSlickgridComponent;
    exports.AngularSlickgridModule = AngularSlickgridModule;
    exports.AngularUtilService = AngularUtilService;
    exports.AutoTooltipExtension = AutoTooltipExtension;
    exports.BindingEventService = BindingEventService;
    exports.BsDropDownService = BsDropDownService;
    exports.CellExternalCopyManagerExtension = CellExternalCopyManagerExtension;
    exports.CellMenuExtension = CellMenuExtension;
    exports.CheckboxSelectorExtension = CheckboxSelectorExtension;
    exports.CollectionService = CollectionService;
    exports.ColumnPickerExtension = ColumnPickerExtension;
    exports.ContextMenuExtension = ContextMenuExtension;
    exports.DraggableGroupingExtension = DraggableGroupingExtension;
    exports.Editors = Editors;
    exports.ExcelExportService = ExcelExportService;
    exports.ExportService = ExportService;
    exports.ExtensionService = ExtensionService;
    exports.ExtensionUtility = ExtensionUtility;
    exports.FilterConditions = FilterConditions;
    exports.FilterFactory = FilterFactory;
    exports.FilterService = FilterService;
    exports.Filters = Filters;
    exports.Formatters = Formatters;
    exports.GraphqlService = GraphqlService;
    exports.GridEventService = GridEventService;
    exports.GridMenuExtension = GridMenuExtension;
    exports.GridOdataService = GridOdataService;
    exports.GridService = GridService;
    exports.GridStateService = GridStateService;
    exports.GroupItemMetaProviderExtension = GroupItemMetaProviderExtension;
    exports.GroupTotalFormatters = GroupTotalFormatters;
    exports.GroupingAndColspanService = GroupingAndColspanService;
    exports.HeaderButtonExtension = HeaderButtonExtension;
    exports.HeaderMenuExtension = HeaderMenuExtension;
    exports.OdataQueryBuilderService = OdataQueryBuilderService;
    exports.PaginationService = PaginationService;
    exports.ResizerService = ResizerService;
    exports.RowDetailViewExtension = RowDetailViewExtension;
    exports.RowMoveManagerExtension = RowMoveManagerExtension;
    exports.RowSelectionExtension = RowSelectionExtension;
    exports.SharedService = SharedService;
    exports.SlickPaginationComponent = SlickPaginationComponent;
    exports.SlickgridConfig = SlickgridConfig;
    exports.SortService = SortService;
    exports.Sorters = Sorters;
    exports.TreeDataService = TreeDataService;
    exports.addToArrayWhenNotExists = addToArrayWhenNotExists;
    exports.addWhiteSpaces = addWhiteSpaces;
    exports.arrayRemoveItemByIndex = arrayRemoveItemByIndex;
    exports.castToPromise = castToPromise;
    exports.charArraysEqual = charArraysEqual;
    exports.convertHierarchicalViewToParentChildArray = convertHierarchicalViewToParentChildArray;
    exports.convertHierarchicalViewToParentChildArrayByReference = convertHierarchicalViewToParentChildArrayByReference;
    exports.convertParentChildArrayToHierarchicalView = convertParentChildArrayToHierarchicalView;
    exports.decimalFormatted = decimalFormatted;
    exports.deepCopy = deepCopy;
    exports.destroyObjectDomElementProps = destroyObjectDomElementProps;
    exports.executeBackendCallback = executeBackendCallback;
    exports.executeBackendProcessesCallback = executeBackendProcessesCallback;
    exports.exportWithFormatterWhenDefined = exportWithFormatterWhenDefined;
    exports.findItemInHierarchicalStructure = findItemInHierarchicalStructure;
    exports.findOrDefault = findOrDefault;
    exports.formatNumber = formatNumber;
    exports.getDescendantProperty = getDescendantProperty;
    exports.getHtmlElementOffset = getHtmlElementOffset;
    exports.getTranslationPrefix = getTranslationPrefix;
    exports.htmlDecode = htmlDecode;
    exports.htmlEncode = htmlEncode;
    exports.htmlEncodedStringWithPadding = htmlEncodedStringWithPadding;
    exports.htmlEntityDecode = htmlEntityDecode;
    exports.htmlEntityEncode = htmlEntityEncode;
    exports.mapFlatpickrDateFormatWithFieldType = mapFlatpickrDateFormatWithFieldType;
    exports.mapMomentDateFormatWithFieldType = mapMomentDateFormatWithFieldType;
    exports.mapOperatorByFieldType = mapOperatorByFieldType;
    exports.mapOperatorToShorthandDesignation = mapOperatorToShorthandDesignation;
    exports.mapOperatorType = mapOperatorType;
    exports.onBackendError = onBackendError;
    exports.parseBoolean = parseBoolean;
    exports.parseUtcDate = parseUtcDate;
    exports.refreshBackendDataset = refreshBackendDataset;
    exports.sanitizeHtmlToText = sanitizeHtmlToText;
    exports.setDeepValue = setDeepValue;
    exports.thousandSeparatorFormatted = thousandSeparatorFormatted;
    exports.titleCase = titleCase;
    exports.toCamelCase = toCamelCase;
    exports.toKebabCase = toKebabCase;
    exports.toSnakeCase = toSnakeCase;
    exports.uniqueArray = uniqueArray;
    exports.uniqueObjectArray = uniqueObjectArray;
    exports.unsubscribeAllObservables = unsubscribeAllObservables;
    exports.ɵa = AvgAggregator;
    exports.ɵb = MinAggregator;
    exports.ɵba = CompoundInputPasswordFilter;
    exports.ɵbb = CompoundSliderFilter;
    exports.ɵbc = DateRangeFilter;
    exports.ɵbd = InputFilter;
    exports.ɵbe = InputMaskFilter;
    exports.ɵbf = InputNumberFilter;
    exports.ɵbg = InputPasswordFilter;
    exports.ɵbh = MultipleSelectFilter;
    exports.ɵbi = SelectFilter;
    exports.ɵbj = NativeSelectFilter;
    exports.ɵbk = SingleSelectFilter;
    exports.ɵbl = SliderFilter;
    exports.ɵbm = SliderRangeFilter;
    exports.ɵbn = centerFormatter;
    exports.ɵbo = alignRightFormatter;
    exports.ɵbp = arrayObjectToCsvFormatter;
    exports.ɵbq = arrayToCsvFormatter;
    exports.ɵbr = boldFormatter;
    exports.ɵbs = bsDropdownFormatter;
    exports.ɵbt = checkboxFormatter;
    exports.ɵbu = checkmarkFormatter;
    exports.ɵbv = complexObjectFormatter;
    exports.ɵbw = collectionFormatter;
    exports.ɵbx = collectionEditorFormatter;
    exports.ɵby = getAssociatedDateFormatter;
    exports.ɵbz = deleteIconFormatter;
    exports.ɵc = MaxAggregator;
    exports.ɵca = decimalFormatter;
    exports.ɵcb = dollarFormatter;
    exports.ɵcc = dollarColoredFormatter;
    exports.ɵcd = dollarColoredBoldFormatter;
    exports.ɵce = editIconFormatter;
    exports.ɵcf = fakeHyperlinkFormatter;
    exports.ɵcg = hyperlinkFormatter;
    exports.ɵch = iconFormatter;
    exports.ɵci = infoIconFormatter;
    exports.ɵcj = italicFormatter;
    exports.ɵck = lowercaseFormatter;
    exports.ɵcl = maskFormatter;
    exports.ɵcm = multipleFormatter;
    exports.ɵcn = percentFormatter;
    exports.ɵco = percentCompleteFormatter;
    exports.ɵcp = percentCompleteBarFormatter;
    exports.ɵcq = percentSymbolFormatter;
    exports.ɵcr = progressBarFormatter;
    exports.ɵcs = translateFormatter;
    exports.ɵct = translateBooleanFormatter;
    exports.ɵcu = treeFormatter;
    exports.ɵcv = uppercaseFormatter;
    exports.ɵcw = yesNoFormatter;
    exports.ɵcx = avgTotalsFormatter;
    exports.ɵcy = avgTotalsDollarFormatter;
    exports.ɵcz = avgTotalsPercentageFormatter;
    exports.ɵd = SumAggregator;
    exports.ɵda = maxTotalsFormatter;
    exports.ɵdb = minTotalsFormatter;
    exports.ɵdc = sumTotalsFormatter;
    exports.ɵdd = sumTotalsBoldFormatter;
    exports.ɵde = sumTotalsColoredFormatter;
    exports.ɵdf = sumTotalsDollarFormatter;
    exports.ɵdg = sumTotalsDollarBoldFormatter;
    exports.ɵdh = sumTotalsDollarColoredFormatter;
    exports.ɵdi = sumTotalsDollarColoredBoldFormatter;
    exports.ɵdj = getAssociatedDateSorter;
    exports.ɵdk = numericSorter;
    exports.ɵdl = objectStringSorter;
    exports.ɵdm = stringSorter;
    exports.ɵe = AutoCompleteEditor;
    exports.ɵf = CheckboxEditor;
    exports.ɵg = DateEditor;
    exports.ɵh = DualInputEditor;
    exports.ɵi = FloatEditor;
    exports.ɵj = IntegerEditor;
    exports.ɵk = LongTextEditor;
    exports.ɵl = MultipleSelectEditor;
    exports.ɵm = SelectEditor;
    exports.ɵn = SingleSelectEditor;
    exports.ɵo = SliderEditor;
    exports.ɵp = TextEditor;
    exports.ɵq = executeMappedCondition;
    exports.ɵr = booleanFilterCondition;
    exports.ɵs = collectionSearchFilterCondition;
    exports.ɵt = numberFilterCondition;
    exports.ɵu = stringFilterCondition;
    exports.ɵv = testFilterCondition;
    exports.ɵw = AutoCompleteFilter;
    exports.ɵx = CompoundDateFilter;
    exports.ɵy = CompoundInputFilter;
    exports.ɵz = CompoundInputNumberFilter;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=angular-slickgrid.umd.js.map
